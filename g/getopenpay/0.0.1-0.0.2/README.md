# Comparing `tmp/getopenpay-0.0.1.tar.gz` & `tmp/getopenpay-0.0.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "getopenpay-0.0.1.tar", last modified: Tue May 21 17:39:31 2024, max compression
+gzip compressed data, was "getopenpay-0.0.2.tar", last modified: Wed May 22 15:41:54 2024, max compression
```

## Comparing `getopenpay-0.0.1.tar` & `getopenpay-0.0.2.tar`

### file list

```diff
@@ -1,213 +1,214 @@
-drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-21 17:39:31.714932 getopenpay-0.0.1/
--rw-r--r--   0 iman       (501) staff       (20)      398 2024-05-21 17:39:31.714851 getopenpay-0.0.1/PKG-INFO
--rw-r--r--   0 iman       (501) staff       (20)    25997 2024-05-21 15:53:26.000000 getopenpay-0.0.1/README.md
-drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-21 17:39:31.655911 getopenpay-0.0.1/getopenpay/
--rw-r--r--   0 iman       (501) staff       (20)    14971 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/__init__.py
-drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-21 17:39:31.665714 getopenpay-0.0.1/getopenpay/api/
--rw-r--r--   0 iman       (501) staff       (20)     1139 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/api/__init__.py
--rw-r--r--   0 iman       (501) staff       (20)    11846 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/api/billing_portal_api.py
--rw-r--r--   0 iman       (501) staff       (20)    22059 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/charges_api.py
--rw-r--r--   0 iman       (501) staff       (20)    33126 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/checkout_api.py
--rw-r--r--   0 iman       (501) staff       (20)    52986 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/coupons_api.py
--rw-r--r--   0 iman       (501) staff       (20)    34157 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/api/credit_notes_api.py
--rw-r--r--   0 iman       (501) staff       (20)   121909 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/customers_api.py
--rw-r--r--   0 iman       (501) staff       (20)    31633 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/api/events_api.py
--rw-r--r--   0 iman       (501) staff       (20)    32483 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/invoice_items_api.py
--rw-r--r--   0 iman       (501) staff       (20)   107561 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/invoices_api.py
--rw-r--r--   0 iman       (501) staff       (20)    32726 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/payment_intents_api.py
--rw-r--r--   0 iman       (501) staff       (20)    42549 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/payment_links_api.py
--rw-r--r--   0 iman       (501) staff       (20)    46671 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/payment_methods_api.py
--rw-r--r--   0 iman       (501) staff       (20)    64076 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/prices_api.py
--rw-r--r--   0 iman       (501) staff       (20)    52832 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/product_family_api.py
--rw-r--r--   0 iman       (501) staff       (20)    64166 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/products_api.py
--rw-r--r--   0 iman       (501) staff       (20)    44208 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/promotion_codes_api.py
--rw-r--r--   0 iman       (501) staff       (20)    22044 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/api/refunds_api.py
--rw-r--r--   0 iman       (501) staff       (20)    59221 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/subscription_items_api.py
--rw-r--r--   0 iman       (501) staff       (20)   111122 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api/subscriptions_api.py
--rw-r--r--   0 iman       (501) staff       (20)    24826 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/api_client.py
--rw-r--r--   0 iman       (501) staff       (20)      669 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/api_response.py
--rw-r--r--   0 iman       (501) staff       (20)     3034 2024-05-21 15:36:57.000000 getopenpay-0.0.1/getopenpay/client.py
--rw-r--r--   0 iman       (501) staff       (20)    14279 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/configuration.py
--rw-r--r--   0 iman       (501) staff       (20)     5381 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/exceptions.py
-drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-21 17:39:31.714123 getopenpay-0.0.1/getopenpay/models/
--rw-r--r--   0 iman       (501) staff       (20)    13372 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/__init__.py
--rw-r--r--   0 iman       (501) staff       (20)     3948 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/account_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3010 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/active_sub_response.py
--rw-r--r--   0 iman       (501) staff       (20)     4111 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/api_token_external.py
--rw-r--r--   0 iman       (501) staff       (20)     2460 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/attach_payment_method_request.py
--rw-r--r--   0 iman       (501) staff       (20)      988 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/billing_reason_enum.py
--rw-r--r--   0 iman       (501) staff       (20)      792 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/billing_scheme_enum.py
--rw-r--r--   0 iman       (501) staff       (20)      857 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/business_type.py
--rw-r--r--   0 iman       (501) staff       (20)      825 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/calendar_interval_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     5657 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/charge_external.py
--rw-r--r--   0 iman       (501) staff       (20)     6097 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/charge_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)      815 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/charge_status_enum.py
--rw-r--r--   0 iman       (501) staff       (20)      807 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/checkout_mode.py
--rw-r--r--   0 iman       (501) staff       (20)     8173 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/checkout_session_external.py
--rw-r--r--   0 iman       (501) staff       (20)     4843 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/checkout_session_line_item_external.py
--rw-r--r--   0 iman       (501) staff       (20)     4382 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/checkout_session_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)      824 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/checkout_session_status.py
--rw-r--r--   0 iman       (501) staff       (20)      837 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/collection_method_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     4297 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/complete_address.py
--rw-r--r--   0 iman       (501) staff       (20)      805 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/coupon_duration.py
--rw-r--r--   0 iman       (501) staff       (20)     5965 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/coupon_external.py
--rw-r--r--   0 iman       (501) staff       (20)     4299 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/coupon_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     2608 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_checkout_line_item.py
--rw-r--r--   0 iman       (501) staff       (20)     4905 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_checkout_session_request.py
--rw-r--r--   0 iman       (501) staff       (20)     5117 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_coupon_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3609 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_credit_note_line.py
--rw-r--r--   0 iman       (501) staff       (20)     4371 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_credit_note_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3117 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_customer_balance_transaction_request.py
--rw-r--r--   0 iman       (501) staff       (20)     4943 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_customer_request.py
--rw-r--r--   0 iman       (501) staff       (20)     4120 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_invoice_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3251 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_payment_link_request.py
--rw-r--r--   0 iman       (501) staff       (20)     2668 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_portal_session_request.py
--rw-r--r--   0 iman       (501) staff       (20)     8447 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_price_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3095 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_product_family_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3554 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_product_request.py
--rw-r--r--   0 iman       (501) staff       (20)     4429 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_promo_code_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3783 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_refund_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3419 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_subscription_item_request.py
--rw-r--r--   0 iman       (501) staff       (20)     6203 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_subscription_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3392 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/create_subscription_response.py
--rw-r--r--   0 iman       (501) staff       (20)     1083 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/credit_card_type.py
--rw-r--r--   0 iman       (501) staff       (20)     5231 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/credit_note_external.py
--rw-r--r--   0 iman       (501) staff       (20)     4637 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/credit_note_item_external.py
--rw-r--r--   0 iman       (501) staff       (20)      833 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/credit_note_line_type.py
--rw-r--r--   0 iman       (501) staff       (20)     4659 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/credit_note_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)      887 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/credit_note_reason.py
--rw-r--r--   0 iman       (501) staff       (20)     4701 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/customer_balance_transaction_external.py
--rw-r--r--   0 iman       (501) staff       (20)     1185 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/customer_balance_transaction_type.py
--rw-r--r--   0 iman       (501) staff       (20)     6291 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/customer_external.py
--rw-r--r--   0 iman       (501) staff       (20)     4378 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/customer_payment_method_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     4595 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/customer_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     3592 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/date_time_filter.py
--rw-r--r--   0 iman       (501) staff       (20)     2751 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/delete_invoice_item_response.py
--rw-r--r--   0 iman       (501) staff       (20)     2678 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/delete_price_response.py
--rw-r--r--   0 iman       (501) staff       (20)     2700 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/delete_product_response.py
--rw-r--r--   0 iman       (501) staff       (20)     2795 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/delete_subscription_item_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3436 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/delete_subscription_item_response.py
--rw-r--r--   0 iman       (501) staff       (20)     3558 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/delete_subscription_request.py
--rw-r--r--   0 iman       (501) staff       (20)     5705 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/discount_external.py
--rw-r--r--   0 iman       (501) staff       (20)     5105 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/discounts.py
--rw-r--r--   0 iman       (501) staff       (20)     4599 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/event_external.py
--rw-r--r--   0 iman       (501) staff       (20)     4459 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/event_search_params.py
--rw-r--r--   0 iman       (501) staff       (20)     5870 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/event_type.py
--rw-r--r--   0 iman       (501) staff       (20)     4498 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/events_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     2804 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/http_validation_error.py
--rw-r--r--   0 iman       (501) staff       (20)     4624 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/inline_subscription_item_update.py
--rw-r--r--   0 iman       (501) staff       (20)     3579 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/int_range_filter.py
--rw-r--r--   0 iman       (501) staff       (20)     3828 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invite_external.py
--rw-r--r--   0 iman       (501) staff       (20)      843 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/invite_status_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     2848 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_discount_amounts_external.py
--rw-r--r--   0 iman       (501) staff       (20)     2683 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_discount_options.py
--rw-r--r--   0 iman       (501) staff       (20)    13092 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_external.py
--rw-r--r--   0 iman       (501) staff       (20)     2831 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_item_discount_amounts_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3064 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_item_discount_amounts_public.py
--rw-r--r--   0 iman       (501) staff       (20)     7705 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_item_external.py
--rw-r--r--   0 iman       (501) staff       (20)     5002 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_item_public.py
--rw-r--r--   0 iman       (501) staff       (20)     4988 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_items_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     4886 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_public.py
--rw-r--r--   0 iman       (501) staff       (20)     7749 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     2595 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_settings.py
--rw-r--r--   0 iman       (501) staff       (20)      880 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/invoice_status_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     2900 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_active_sub_params.py
--rw-r--r--   0 iman       (501) staff       (20)     3073 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_charge_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3146 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_checkout_session_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3073 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_coupon_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3106 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_credit_note_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3089 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_customer_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3065 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_event_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3081 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_invoice_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3114 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_invoice_item_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3130 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_payment_intent_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3114 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_payment_link_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3130 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_payment_method_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3065 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_price_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3081 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_product_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3130 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_product_family_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3130 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_promotion_code_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3073 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_refund_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3121 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_subscription_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3154 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/list_response_subscription_item_external.py
--rw-r--r--   0 iman       (501) staff       (20)     2155 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/object_name.py
--rw-r--r--   0 iman       (501) staff       (20)     3019 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/pay_invoice_request.py
--rw-r--r--   0 iman       (501) staff       (20)     5267 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/payment_intent_external.py
--rw-r--r--   0 iman       (501) staff       (20)     5709 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/payment_intent_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     1052 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/payment_intent_status.py
--rw-r--r--   0 iman       (501) staff       (20)     4494 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/payment_link_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3678 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/payment_link_line_item_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3997 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/payment_link_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     4590 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/payment_method_external.py
--rw-r--r--   0 iman       (501) staff       (20)     4231 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/payment_processor_external.py
--rw-r--r--   0 iman       (501) staff       (20)      881 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/payment_processor_name.py
--rw-r--r--   0 iman       (501) staff       (20)     4041 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/portal_session_external.py
--rw-r--r--   0 iman       (501) staff       (20)    10165 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/price_external.py
--rw-r--r--   0 iman       (501) staff       (20)     5115 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/price_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     3731 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/price_tier_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3359 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/price_tier_params.py
--rw-r--r--   0 iman       (501) staff       (20)     2940 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/price_tier_public.py
--rw-r--r--   0 iman       (501) staff       (20)      786 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/price_type_enum.py
--rw-r--r--   0 iman       (501) staff       (20)      829 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/pricing_model.py
--rw-r--r--   0 iman       (501) staff       (20)      791 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/pricing_tiers_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     5386 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/product_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3959 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/product_family_external.py
--rw-r--r--   0 iman       (501) staff       (20)     4335 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/product_family_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     4985 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/product_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     5250 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/promo_code_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     3258 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/promo_restrictions.py
--rw-r--r--   0 iman       (501) staff       (20)     5414 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/promotion_code_external.py
--rw-r--r--   0 iman       (501) staff       (20)      832 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/proration_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     3030 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/recurring_details.py
--rw-r--r--   0 iman       (501) staff       (20)     4086 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/refund_external.py
--rw-r--r--   0 iman       (501) staff       (20)     6419 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/refund_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)      933 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/refund_reason_enum.py
--rw-r--r--   0 iman       (501) staff       (20)      881 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/refund_status_enum.py
--rw-r--r--   0 iman       (501) staff       (20)      839 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/role_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     3566 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/search_charge_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3574 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/search_customer_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3570 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/search_invoice_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3594 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/search_payment_intent_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3562 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/search_price_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3570 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/search_product_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3590 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/search_subscription_request.py
--rw-r--r--   0 iman       (501) staff       (20)     2589 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/selected_price_quantity.py
--rw-r--r--   0 iman       (501) staff       (20)     1051 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/subscription_cancel_feedback_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     3337 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/subscription_cancellation_details.py
--rw-r--r--   0 iman       (501) staff       (20)    11763 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/subscription_external.py
--rw-r--r--   0 iman       (501) staff       (20)     4948 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/subscription_item_external.py
--rw-r--r--   0 iman       (501) staff       (20)     2497 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/subscription_item_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     2554 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/subscription_pause_request.py
--rw-r--r--   0 iman       (501) staff       (20)     7091 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/subscription_query_params.py
--rw-r--r--   0 iman       (501) staff       (20)     2472 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/subscription_resume_request.py
--rw-r--r--   0 iman       (501) staff       (20)      881 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/subscription_status_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     4843 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/tokenized_credit_card_input.py
--rw-r--r--   0 iman       (501) staff       (20)     4667 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/transition_eligibility_external.py
--rw-r--r--   0 iman       (501) staff       (20)     2969 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_coupon_request.py
--rw-r--r--   0 iman       (501) staff       (20)     5677 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_customer_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3559 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_invoice_request.py
--rw-r--r--   0 iman       (501) staff       (20)     8777 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_price_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3305 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_product_family_request.py
--rw-r--r--   0 iman       (501) staff       (20)     4372 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_product_request.py
--rw-r--r--   0 iman       (501) staff       (20)     2565 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_promo_code_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3486 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_subscription_item_request.py
--rw-r--r--   0 iman       (501) staff       (20)     5624 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_subscription_request.py
--rw-r--r--   0 iman       (501) staff       (20)     3446 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/update_subscription_response.py
--rw-r--r--   0 iman       (501) staff       (20)      853 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/usage_agg_method_enum.py
--rw-r--r--   0 iman       (501) staff       (20)      788 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/usage_record_action.py
--rw-r--r--   0 iman       (501) staff       (20)      782 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/usage_type_enum.py
--rw-r--r--   0 iman       (501) staff       (20)     3650 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/user_external.py
--rw-r--r--   0 iman       (501) staff       (20)     2905 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/validation_error.py
--rw-r--r--   0 iman       (501) staff       (20)     4817 2024-05-21 15:53:27.000000 getopenpay-0.0.1/getopenpay/models/validation_error_loc_inner.py
--rw-r--r--   0 iman       (501) staff       (20)     4061 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/webhook_endpoint_external.py
--rw-r--r--   0 iman       (501) staff       (20)     3803 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/models/webhook_endpoint_external_no_secret.py
--rw-r--r--   0 iman       (501) staff       (20)        0 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/py.typed
--rw-r--r--   0 iman       (501) staff       (20)     8225 2024-05-21 15:53:26.000000 getopenpay-0.0.1/getopenpay/rest.py
-drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-21 17:39:31.714359 getopenpay-0.0.1/getopenpay.egg-info/
--rw-r--r--   0 iman       (501) staff       (20)      398 2024-05-21 17:39:31.000000 getopenpay-0.0.1/getopenpay.egg-info/PKG-INFO
--rw-r--r--   0 iman       (501) staff       (20)     8833 2024-05-21 17:39:31.000000 getopenpay-0.0.1/getopenpay.egg-info/SOURCES.txt
--rw-r--r--   0 iman       (501) staff       (20)        1 2024-05-21 17:39:31.000000 getopenpay-0.0.1/getopenpay.egg-info/dependency_links.txt
--rw-r--r--   0 iman       (501) staff       (20)       76 2024-05-21 17:39:31.000000 getopenpay-0.0.1/getopenpay.egg-info/requires.txt
--rw-r--r--   0 iman       (501) staff       (20)       11 2024-05-21 17:39:31.000000 getopenpay-0.0.1/getopenpay.egg-info/top_level.txt
--rw-r--r--   0 iman       (501) staff       (20)       69 2024-05-21 17:39:31.715277 getopenpay-0.0.1/setup.cfg
--rw-r--r--   0 iman       (501) staff       (20)     1120 2024-05-21 17:37:21.000000 getopenpay-0.0.1/setup.py
+drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-22 15:41:54.348172 getopenpay-0.0.2/
+-rw-r--r--   0 iman       (501) staff       (20)      398 2024-05-22 15:41:54.348033 getopenpay-0.0.2/PKG-INFO
+-rw-r--r--   0 iman       (501) staff       (20)    26067 2024-05-22 15:11:33.000000 getopenpay-0.0.2/README.md
+drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-22 15:41:54.298618 getopenpay-0.0.2/getopenpay/
+-rw-r--r--   0 iman       (501) staff       (20)    14952 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/__init__.py
+drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-22 15:41:54.304099 getopenpay-0.0.2/getopenpay/api/
+-rw-r--r--   0 iman       (501) staff       (20)     1138 2024-05-22 15:11:39.000000 getopenpay-0.0.2/getopenpay/api/__init__.py
+-rw-r--r--   0 iman       (501) staff       (20)    10798 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/billing_portal_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    19987 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/charges_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    30244 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/checkout_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    48325 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/coupons_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    31281 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/credit_notes_api.py
+-rw-r--r--   0 iman       (501) staff       (20)   111095 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/customers_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    28687 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/events_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    29854 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/invoice_items_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    98673 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/invoices_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    29786 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/payment_intents_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    38900 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/payment_links_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    43306 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/payment_methods_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    58145 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/prices_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    47972 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/product_family_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    58469 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/products_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    40354 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/promotion_codes_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    19972 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/refunds_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    54188 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/subscription_items_api.py
+-rw-r--r--   0 iman       (501) staff       (20)   101765 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api/subscriptions_api.py
+-rw-r--r--   0 iman       (501) staff       (20)    21634 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api_client.py
+-rw-r--r--   0 iman       (501) staff       (20)      646 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/api_response.py
+-rw-r--r--   0 iman       (501) staff       (20)     4204 2024-05-22 15:01:39.000000 getopenpay-0.0.2/getopenpay/client.py
+-rw-r--r--   0 iman       (501) staff       (20)    13140 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/configuration.py
+-rw-r--r--   0 iman       (501) staff       (20)     5077 2024-05-22 15:11:38.000000 getopenpay-0.0.2/getopenpay/exceptions.py
+drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-22 15:41:54.347178 getopenpay-0.0.2/getopenpay/models/
+-rw-r--r--   0 iman       (501) staff       (20)    13514 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/__init__.py
+-rw-r--r--   0 iman       (501) staff       (20)     3779 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/account_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2834 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/active_sub_response.py
+-rw-r--r--   0 iman       (501) staff       (20)     3916 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/api_token_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2264 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/attach_payment_method_request.py
+-rw-r--r--   0 iman       (501) staff       (20)      951 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/billing_reason_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)      763 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/billing_scheme_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)      824 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/business_type.py
+-rw-r--r--   0 iman       (501) staff       (20)      792 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/calendar_interval_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     5404 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/charge_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     5789 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/charge_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)      784 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/charge_status_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     2615 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/chart_mogul_integration_public.py
+-rw-r--r--   0 iman       (501) staff       (20)      776 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/checkout_mode.py
+-rw-r--r--   0 iman       (501) staff       (20)     7789 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/checkout_session_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4590 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/checkout_session_line_item_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4194 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/checkout_session_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)      793 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/checkout_session_status.py
+-rw-r--r--   0 iman       (501) staff       (20)      808 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/collection_method_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     4013 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/complete_address.py
+-rw-r--r--   0 iman       (501) staff       (20)      774 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/coupon_duration.py
+-rw-r--r--   0 iman       (501) staff       (20)     5632 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/coupon_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4107 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/coupon_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     2398 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_checkout_line_item.py
+-rw-r--r--   0 iman       (501) staff       (20)     4615 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_checkout_session_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     4828 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_coupon_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3391 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_credit_note_line.py
+-rw-r--r--   0 iman       (501) staff       (20)     4201 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_credit_note_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     2932 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_customer_balance_transaction_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     4613 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_customer_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3937 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_invoice_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3057 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_payment_link_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     2507 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_portal_session_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     8060 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_price_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     2899 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_product_family_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3336 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_product_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     4187 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_promo_code_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3573 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_refund_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3274 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_subscription_item_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     5951 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_subscription_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3194 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/create_subscription_response.py
+-rw-r--r--   0 iman       (501) staff       (20)     1032 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/credit_card_type.py
+-rw-r--r--   0 iman       (501) staff       (20)     5033 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/credit_note_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4431 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/credit_note_item_external.py
+-rw-r--r--   0 iman       (501) staff       (20)      804 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/credit_note_line_type.py
+-rw-r--r--   0 iman       (501) staff       (20)     4447 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/credit_note_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)      854 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/credit_note_reason.py
+-rw-r--r--   0 iman       (501) staff       (20)     4450 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/customer_balance_transaction_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     1142 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/customer_balance_transaction_type.py
+-rw-r--r--   0 iman       (501) staff       (20)     5978 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/customer_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4225 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/customer_payment_method_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     4383 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/customer_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     3331 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/date_time_filter.py
+-rw-r--r--   0 iman       (501) staff       (20)     2609 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/delete_invoice_item_response.py
+-rw-r--r--   0 iman       (501) staff       (20)     2522 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/delete_price_response.py
+-rw-r--r--   0 iman       (501) staff       (20)     2544 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/delete_product_response.py
+-rw-r--r--   0 iman       (501) staff       (20)     2633 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/delete_subscription_item_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3303 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/delete_subscription_item_response.py
+-rw-r--r--   0 iman       (501) staff       (20)     3389 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/delete_subscription_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     5384 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/discount_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4689 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/discounts.py
+-rw-r--r--   0 iman       (501) staff       (20)     4348 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/event_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4285 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/event_search_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     5653 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/event_type.py
+-rw-r--r--   0 iman       (501) staff       (20)     4304 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/events_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     2634 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/http_validation_error.py
+-rw-r--r--   0 iman       (501) staff       (20)     4338 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/inline_subscription_item_update.py
+-rw-r--r--   0 iman       (501) staff       (20)     3317 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/int_range_filter.py
+-rw-r--r--   0 iman       (501) staff       (20)     3643 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invite_external.py
+-rw-r--r--   0 iman       (501) staff       (20)      810 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invite_status_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     2684 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_discount_amounts_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2475 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_discount_options.py
+-rw-r--r--   0 iman       (501) staff       (20)    12644 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2659 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_item_discount_amounts_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2874 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_item_discount_amounts_public.py
+-rw-r--r--   0 iman       (501) staff       (20)     8225 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_item_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4788 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_item_public.py
+-rw-r--r--   0 iman       (501) staff       (20)     4752 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_items_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     4597 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_public.py
+-rw-r--r--   0 iman       (501) staff       (20)     7415 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     2401 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_settings.py
+-rw-r--r--   0 iman       (501) staff       (20)      843 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/invoice_status_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     2710 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_active_sub_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     2885 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_charge_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2958 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_checkout_session_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2885 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_coupon_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2918 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_credit_note_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2901 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_customer_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2877 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_event_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2893 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_invoice_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2926 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_invoice_item_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2942 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_payment_intent_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2926 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_payment_link_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2942 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_payment_method_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2877 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_price_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2893 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_product_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2942 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_product_family_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2942 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_promotion_code_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2885 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_refund_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2933 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_subscription_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2966 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/list_response_subscription_item_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2102 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/object_name.py
+-rw-r--r--   0 iman       (501) staff       (20)     2854 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/pay_invoice_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     4984 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/payment_intent_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     5455 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/payment_intent_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     1011 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/payment_intent_status.py
+-rw-r--r--   0 iman       (501) staff       (20)     4263 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/payment_link_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     3513 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/payment_link_line_item_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     3829 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/payment_link_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     4369 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/payment_method_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4044 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/payment_processor_external.py
+-rw-r--r--   0 iman       (501) staff       (20)      850 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/payment_processor_name.py
+-rw-r--r--   0 iman       (501) staff       (20)     3895 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/portal_session_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     9913 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/price_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4873 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/price_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     3540 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/price_tier_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     3176 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/price_tier_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     2742 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/price_tier_public.py
+-rw-r--r--   0 iman       (501) staff       (20)      757 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/price_type_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)      796 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/pricing_model.py
+-rw-r--r--   0 iman       (501) staff       (20)      762 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/pricing_tiers_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     5097 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/product_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     3770 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/product_family_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4143 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/product_family_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     4749 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/product_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     4990 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/promo_code_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     3070 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/promo_restrictions.py
+-rw-r--r--   0 iman       (501) staff       (20)     5127 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/promotion_code_external.py
+-rw-r--r--   0 iman       (501) staff       (20)      801 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/proration_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     2862 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/recurring_details.py
+-rw-r--r--   0 iman       (501) staff       (20)     3895 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/refund_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     6117 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/refund_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)      898 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/refund_reason_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)      846 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/refund_status_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)      806 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/role_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     3415 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/search_charge_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3423 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/search_customer_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3419 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/search_invoice_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3443 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/search_payment_intent_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3411 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/search_price_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3419 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/search_product_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3439 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/search_subscription_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     2379 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/selected_price_quantity.py
+-rw-r--r--   0 iman       (501) staff       (20)     1010 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/subscription_cancel_feedback_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     3123 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/subscription_cancellation_details.py
+-rw-r--r--   0 iman       (501) staff       (20)    11579 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/subscription_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     4716 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/subscription_item_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2309 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/subscription_item_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     2378 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/subscription_pause_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     6775 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/subscription_query_params.py
+-rw-r--r--   0 iman       (501) staff       (20)     2296 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/subscription_resume_request.py
+-rw-r--r--   0 iman       (501) staff       (20)      846 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/subscription_status_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     4507 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/tokenized_credit_card_input.py
+-rw-r--r--   0 iman       (501) staff       (20)     4416 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/transition_eligibility_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2740 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_coupon_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     5283 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_customer_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3367 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_invoice_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     8285 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_price_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3085 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_product_family_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     4088 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_product_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     2382 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_promo_code_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3266 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_subscription_item_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     5293 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_subscription_request.py
+-rw-r--r--   0 iman       (501) staff       (20)     3248 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/update_subscription_response.py
+-rw-r--r--   0 iman       (501) staff       (20)      820 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/usage_agg_method_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)      759 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/usage_record_action.py
+-rw-r--r--   0 iman       (501) staff       (20)      753 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/usage_type_enum.py
+-rw-r--r--   0 iman       (501) staff       (20)     3471 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/user_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     2723 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/validation_error.py
+-rw-r--r--   0 iman       (501) staff       (20)     4398 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/validation_error_loc_inner.py
+-rw-r--r--   0 iman       (501) staff       (20)     3840 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/webhook_endpoint_external.py
+-rw-r--r--   0 iman       (501) staff       (20)     3606 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/models/webhook_endpoint_external_no_secret.py
+-rw-r--r--   0 iman       (501) staff       (20)        0 2024-05-22 15:11:33.000000 getopenpay-0.0.2/getopenpay/py.typed
+-rw-r--r--   0 iman       (501) staff       (20)     6615 2024-05-22 15:11:50.000000 getopenpay-0.0.2/getopenpay/rest.py
+drwxr-xr-x   0 iman       (501) staff       (20)        0 2024-05-22 15:41:54.347474 getopenpay-0.0.2/getopenpay.egg-info/
+-rw-r--r--   0 iman       (501) staff       (20)      398 2024-05-22 15:41:54.000000 getopenpay-0.0.2/getopenpay.egg-info/PKG-INFO
+-rw-r--r--   0 iman       (501) staff       (20)     8885 2024-05-22 15:41:54.000000 getopenpay-0.0.2/getopenpay.egg-info/SOURCES.txt
+-rw-r--r--   0 iman       (501) staff       (20)        1 2024-05-22 15:41:54.000000 getopenpay-0.0.2/getopenpay.egg-info/dependency_links.txt
+-rw-r--r--   0 iman       (501) staff       (20)       76 2024-05-22 15:41:54.000000 getopenpay-0.0.2/getopenpay.egg-info/requires.txt
+-rw-r--r--   0 iman       (501) staff       (20)       11 2024-05-22 15:41:54.000000 getopenpay-0.0.2/getopenpay.egg-info/top_level.txt
+-rw-r--r--   0 iman       (501) staff       (20)       69 2024-05-22 15:41:54.348510 getopenpay-0.0.2/setup.cfg
+-rw-r--r--   0 iman       (501) staff       (20)     1120 2024-05-22 15:40:30.000000 getopenpay-0.0.2/setup.py
```

### Comparing `getopenpay-0.0.1/README.md` & `getopenpay-0.0.2/README.md`

 * *Files 0% similar despite different names*

```diff
@@ -195,14 +195,15 @@
  - [BillingReasonEnum](docs/BillingReasonEnum.md)
  - [BillingSchemeEnum](docs/BillingSchemeEnum.md)
  - [BusinessType](docs/BusinessType.md)
  - [CalendarIntervalEnum](docs/CalendarIntervalEnum.md)
  - [ChargeExternal](docs/ChargeExternal.md)
  - [ChargeQueryParams](docs/ChargeQueryParams.md)
  - [ChargeStatusEnum](docs/ChargeStatusEnum.md)
+ - [ChartMogulIntegrationPublic](docs/ChartMogulIntegrationPublic.md)
  - [CheckoutMode](docs/CheckoutMode.md)
  - [CheckoutSessionExternal](docs/CheckoutSessionExternal.md)
  - [CheckoutSessionLineItemExternal](docs/CheckoutSessionLineItemExternal.md)
  - [CheckoutSessionQueryParams](docs/CheckoutSessionQueryParams.md)
  - [CheckoutSessionStatus](docs/CheckoutSessionStatus.md)
  - [CollectionMethodEnum](docs/CollectionMethodEnum.md)
  - [CompleteAddress](docs/CompleteAddress.md)
```

### Comparing `getopenpay-0.0.1/getopenpay/__init__.py` & `getopenpay-0.0.2/getopenpay/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,16 +9,15 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
-__version__ = "1.0.0"
+__version__ = '1.0.0'
 
 # import apis into sdk package
 from getopenpay.api.billing_portal_api import BillingPortalApi
 from getopenpay.api.charges_api import ChargesApi
 from getopenpay.api.checkout_api import CheckoutApi
 from getopenpay.api.coupons_api import CouponsApi
 from getopenpay.api.credit_notes_api import CreditNotesApi
@@ -32,38 +31,34 @@
 from getopenpay.api.prices_api import PricesApi
 from getopenpay.api.product_family_api import ProductFamilyApi
 from getopenpay.api.products_api import ProductsApi
 from getopenpay.api.promotion_codes_api import PromotionCodesApi
 from getopenpay.api.refunds_api import RefundsApi
 from getopenpay.api.subscription_items_api import SubscriptionItemsApi
 from getopenpay.api.subscriptions_api import SubscriptionsApi
-
+from getopenpay.api_client import ApiClient
 # import ApiClient
 from getopenpay.api_response import ApiResponse
-from getopenpay.api_client import ApiClient
 from getopenpay.configuration import Configuration
-from getopenpay.exceptions import OpenApiException
-from getopenpay.exceptions import ApiTypeError
-from getopenpay.exceptions import ApiValueError
-from getopenpay.exceptions import ApiKeyError
-from getopenpay.exceptions import ApiAttributeError
-from getopenpay.exceptions import ApiException
-
+from getopenpay.exceptions import (
+  ApiAttributeError, ApiException, ApiKeyError, ApiTypeError, ApiValueError, OpenApiException
+)
 # import models into sdk package
 from getopenpay.models.account_external import AccountExternal
 from getopenpay.models.active_sub_response import ActiveSubResponse
 from getopenpay.models.api_token_external import ApiTokenExternal
 from getopenpay.models.attach_payment_method_request import AttachPaymentMethodRequest
 from getopenpay.models.billing_reason_enum import BillingReasonEnum
 from getopenpay.models.billing_scheme_enum import BillingSchemeEnum
 from getopenpay.models.business_type import BusinessType
 from getopenpay.models.calendar_interval_enum import CalendarIntervalEnum
 from getopenpay.models.charge_external import ChargeExternal
 from getopenpay.models.charge_query_params import ChargeQueryParams
 from getopenpay.models.charge_status_enum import ChargeStatusEnum
+from getopenpay.models.chart_mogul_integration_public import ChartMogulIntegrationPublic
 from getopenpay.models.checkout_mode import CheckoutMode
 from getopenpay.models.checkout_session_external import CheckoutSessionExternal
 from getopenpay.models.checkout_session_line_item_external import CheckoutSessionLineItemExternal
 from getopenpay.models.checkout_session_query_params import CheckoutSessionQueryParams
 from getopenpay.models.checkout_session_status import CheckoutSessionStatus
 from getopenpay.models.collection_method_enum import CollectionMethodEnum
 from getopenpay.models.complete_address import CompleteAddress
@@ -71,15 +66,17 @@
 from getopenpay.models.coupon_external import CouponExternal
 from getopenpay.models.coupon_query_params import CouponQueryParams
 from getopenpay.models.create_checkout_line_item import CreateCheckoutLineItem
 from getopenpay.models.create_checkout_session_request import CreateCheckoutSessionRequest
 from getopenpay.models.create_coupon_request import CreateCouponRequest
 from getopenpay.models.create_credit_note_line import CreateCreditNoteLine
 from getopenpay.models.create_credit_note_request import CreateCreditNoteRequest
-from getopenpay.models.create_customer_balance_transaction_request import CreateCustomerBalanceTransactionRequest
+from getopenpay.models.create_customer_balance_transaction_request import (
+  CreateCustomerBalanceTransactionRequest
+)
 from getopenpay.models.create_customer_request import CreateCustomerRequest
 from getopenpay.models.create_invoice_request import CreateInvoiceRequest
 from getopenpay.models.create_payment_link_request import CreatePaymentLinkRequest
 from getopenpay.models.create_portal_session_request import CreatePortalSessionRequest
 from getopenpay.models.create_price_request import CreatePriceRequest
 from getopenpay.models.create_product_family_request import CreateProductFamilyRequest
 from getopenpay.models.create_product_request import CreateProductRequest
@@ -90,15 +87,17 @@
 from getopenpay.models.create_subscription_response import CreateSubscriptionResponse
 from getopenpay.models.credit_card_type import CreditCardType
 from getopenpay.models.credit_note_external import CreditNoteExternal
 from getopenpay.models.credit_note_item_external import CreditNoteItemExternal
 from getopenpay.models.credit_note_line_type import CreditNoteLineType
 from getopenpay.models.credit_note_query_params import CreditNoteQueryParams
 from getopenpay.models.credit_note_reason import CreditNoteReason
-from getopenpay.models.customer_balance_transaction_external import CustomerBalanceTransactionExternal
+from getopenpay.models.customer_balance_transaction_external import (
+  CustomerBalanceTransactionExternal
+)
 from getopenpay.models.customer_balance_transaction_type import CustomerBalanceTransactionType
 from getopenpay.models.customer_external import CustomerExternal
 from getopenpay.models.customer_payment_method_query_params import CustomerPaymentMethodQueryParams
 from getopenpay.models.customer_query_params import CustomerQueryParams
 from getopenpay.models.date_time_filter import DateTimeFilter
 from getopenpay.models.delete_invoice_item_response import DeleteInvoiceItemResponse
 from getopenpay.models.delete_price_response import DeletePriceResponse
@@ -116,42 +115,56 @@
 from getopenpay.models.inline_subscription_item_update import InlineSubscriptionItemUpdate
 from getopenpay.models.int_range_filter import IntRangeFilter
 from getopenpay.models.invite_external import InviteExternal
 from getopenpay.models.invite_status_enum import InviteStatusEnum
 from getopenpay.models.invoice_discount_amounts_external import InvoiceDiscountAmountsExternal
 from getopenpay.models.invoice_discount_options import InvoiceDiscountOptions
 from getopenpay.models.invoice_external import InvoiceExternal
-from getopenpay.models.invoice_item_discount_amounts_external import InvoiceItemDiscountAmountsExternal
+from getopenpay.models.invoice_item_discount_amounts_external import (
+  InvoiceItemDiscountAmountsExternal
+)
 from getopenpay.models.invoice_item_discount_amounts_public import InvoiceItemDiscountAmountsPublic
 from getopenpay.models.invoice_item_external import InvoiceItemExternal
 from getopenpay.models.invoice_item_public import InvoiceItemPublic
 from getopenpay.models.invoice_items_query_params import InvoiceItemsQueryParams
 from getopenpay.models.invoice_public import InvoicePublic
 from getopenpay.models.invoice_query_params import InvoiceQueryParams
 from getopenpay.models.invoice_settings import InvoiceSettings
 from getopenpay.models.invoice_status_enum import InvoiceStatusEnum
 from getopenpay.models.list_active_sub_params import ListActiveSubParams
 from getopenpay.models.list_response_charge_external import ListResponseChargeExternal
-from getopenpay.models.list_response_checkout_session_external import ListResponseCheckoutSessionExternal
+from getopenpay.models.list_response_checkout_session_external import (
+  ListResponseCheckoutSessionExternal
+)
 from getopenpay.models.list_response_coupon_external import ListResponseCouponExternal
 from getopenpay.models.list_response_credit_note_external import ListResponseCreditNoteExternal
 from getopenpay.models.list_response_customer_external import ListResponseCustomerExternal
 from getopenpay.models.list_response_event_external import ListResponseEventExternal
 from getopenpay.models.list_response_invoice_external import ListResponseInvoiceExternal
 from getopenpay.models.list_response_invoice_item_external import ListResponseInvoiceItemExternal
-from getopenpay.models.list_response_payment_intent_external import ListResponsePaymentIntentExternal
+from getopenpay.models.list_response_payment_intent_external import (
+  ListResponsePaymentIntentExternal
+)
 from getopenpay.models.list_response_payment_link_external import ListResponsePaymentLinkExternal
-from getopenpay.models.list_response_payment_method_external import ListResponsePaymentMethodExternal
+from getopenpay.models.list_response_payment_method_external import (
+  ListResponsePaymentMethodExternal
+)
 from getopenpay.models.list_response_price_external import ListResponsePriceExternal
 from getopenpay.models.list_response_product_external import ListResponseProductExternal
-from getopenpay.models.list_response_product_family_external import ListResponseProductFamilyExternal
-from getopenpay.models.list_response_promotion_code_external import ListResponsePromotionCodeExternal
+from getopenpay.models.list_response_product_family_external import (
+  ListResponseProductFamilyExternal
+)
+from getopenpay.models.list_response_promotion_code_external import (
+  ListResponsePromotionCodeExternal
+)
 from getopenpay.models.list_response_refund_external import ListResponseRefundExternal
 from getopenpay.models.list_response_subscription_external import ListResponseSubscriptionExternal
-from getopenpay.models.list_response_subscription_item_external import ListResponseSubscriptionItemExternal
+from getopenpay.models.list_response_subscription_item_external import (
+  ListResponseSubscriptionItemExternal
+)
 from getopenpay.models.object_name import ObjectName
 from getopenpay.models.pay_invoice_request import PayInvoiceRequest
 from getopenpay.models.payment_intent_external import PaymentIntentExternal
 from getopenpay.models.payment_intent_query_params import PaymentIntentQueryParams
 from getopenpay.models.payment_intent_status import PaymentIntentStatus
 from getopenpay.models.payment_link_external import PaymentLinkExternal
 from getopenpay.models.payment_link_line_item_external import PaymentLinkLineItemExternal
```

### Comparing `getopenpay-0.0.1/getopenpay/api/__init__.py` & `getopenpay-0.0.2/getopenpay/api/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -16,8 +16,7 @@
 from getopenpay.api.prices_api import PricesApi
 from getopenpay.api.product_family_api import ProductFamilyApi
 from getopenpay.api.products_api import ProductsApi
 from getopenpay.api.promotion_codes_api import PromotionCodesApi
 from getopenpay.api.refunds_api import RefundsApi
 from getopenpay.api.subscription_items_api import SubscriptionItemsApi
 from getopenpay.api.subscriptions_api import SubscriptionsApi
-
```

### Comparing `getopenpay-0.0.1/getopenpay/api/billing_portal_api.py` & `getopenpay-0.0.2/getopenpay/api/billing_portal_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,63 +7,55 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from getopenpay.models.create_portal_session_request import CreatePortalSessionRequest
-from getopenpay.models.portal_session_external import PortalSessionExternal
+  from typing_extensions import Annotated
 
 from getopenpay.api_client import ApiClient
 from getopenpay.api_response import ApiResponse
+from getopenpay.models.create_portal_session_request import CreatePortalSessionRequest
+from getopenpay.models.portal_session_external import PortalSessionExternal
 from getopenpay.rest import RESTResponseType
 
 
 class BillingPortalApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_portal_session(
-        self,
-        create_portal_session_request: CreatePortalSessionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PortalSessionExternal:
-        """Create Portal Session
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_portal_session(
+    self,
+    create_portal_session_request: CreatePortalSessionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PortalSessionExternal:
+    """Create Portal Session
 
 
         :param create_portal_session_request: (required)
         :type create_portal_session_request: CreatePortalSessionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -82,56 +74,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_portal_session_serialize(
-            create_portal_session_request=create_portal_session_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PortalSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_portal_session_with_http_info(
-        self,
-        create_portal_session_request: CreatePortalSessionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PortalSessionExternal]:
-        """Create Portal Session
+    _param = self._create_portal_session_serialize(
+      create_portal_session_request=create_portal_session_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PortalSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_portal_session_with_http_info(
+    self,
+    create_portal_session_request: CreatePortalSessionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PortalSessionExternal]:
+    """Create Portal Session
 
 
         :param create_portal_session_request: (required)
         :type create_portal_session_request: CreatePortalSessionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -150,56 +132,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_portal_session_serialize(
-            create_portal_session_request=create_portal_session_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PortalSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_portal_session_without_preload_content(
-        self,
-        create_portal_session_request: CreatePortalSessionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Portal Session
+    _param = self._create_portal_session_serialize(
+      create_portal_session_request=create_portal_session_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PortalSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_portal_session_without_preload_content(
+    self,
+    create_portal_session_request: CreatePortalSessionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Portal Session
 
 
         :param create_portal_session_request: (required)
         :type create_portal_session_request: CreatePortalSessionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -218,100 +190,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_portal_session_serialize(
-            create_portal_session_request=create_portal_session_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PortalSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_portal_session_serialize(
-        self,
-        create_portal_session_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_portal_session_request is not None:
-            _body_params = create_portal_session_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/billing_portal/sessions',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._create_portal_session_serialize(
+      create_portal_session_request=create_portal_session_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PortalSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_portal_session_serialize(
+    self,
+    create_portal_session_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_portal_session_request is not None:
+      _body_params = create_portal_session_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/billing_portal/sessions',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/charges_api.py` & `getopenpay-0.0.2/getopenpay/api/charges_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,64 +7,56 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.charge_query_params import ChargeQueryParams
 from getopenpay.models.list_response_charge_external import ListResponseChargeExternal
 from getopenpay.models.search_charge_request import SearchChargeRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
 
 
 class ChargesApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def list_charges(
-        self,
-        charge_query_params: ChargeQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseChargeExternal:
-        """List Charges
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def list_charges(
+    self,
+    charge_query_params: ChargeQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseChargeExternal:
+    """List Charges
 
 
         :param charge_query_params: (required)
         :type charge_query_params: ChargeQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -83,56 +75,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_charges_serialize(
-            charge_query_params=charge_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseChargeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_charges_with_http_info(
-        self,
-        charge_query_params: ChargeQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseChargeExternal]:
-        """List Charges
+    _param = self._list_charges_serialize(
+      charge_query_params=charge_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseChargeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_charges_with_http_info(
+    self,
+    charge_query_params: ChargeQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseChargeExternal]:
+    """List Charges
 
 
         :param charge_query_params: (required)
         :type charge_query_params: ChargeQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -151,56 +133,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_charges_serialize(
-            charge_query_params=charge_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseChargeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_charges_without_preload_content(
-        self,
-        charge_query_params: ChargeQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Charges
+    _param = self._list_charges_serialize(
+      charge_query_params=charge_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseChargeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_charges_without_preload_content(
+    self,
+    charge_query_params: ChargeQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Charges
 
 
         :param charge_query_params: (required)
         :type charge_query_params: ChargeQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -219,127 +191,99 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_charges_serialize(
-            charge_query_params=charge_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseChargeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_charges_serialize(
-        self,
-        charge_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if charge_query_params is not None:
-            _body_params = charge_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/charges/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def search_charges(
-        self,
-        search_charge_request: SearchChargeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseChargeExternal:
-        """Search Charges
+    _param = self._list_charges_serialize(
+      charge_query_params=charge_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseChargeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_charges_serialize(
+    self,
+    charge_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if charge_query_params is not None:
+      _body_params = charge_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/charges/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def search_charges(
+    self,
+    search_charge_request: SearchChargeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseChargeExternal:
+    """Search Charges
 
 
         :param search_charge_request: (required)
         :type search_charge_request: SearchChargeRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -358,56 +302,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_charges_serialize(
-            search_charge_request=search_charge_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseChargeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def search_charges_with_http_info(
-        self,
-        search_charge_request: SearchChargeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseChargeExternal]:
-        """Search Charges
+    _param = self._search_charges_serialize(
+      search_charge_request=search_charge_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseChargeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def search_charges_with_http_info(
+    self,
+    search_charge_request: SearchChargeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseChargeExternal]:
+    """Search Charges
 
 
         :param search_charge_request: (required)
         :type search_charge_request: SearchChargeRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -426,56 +360,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_charges_serialize(
-            search_charge_request=search_charge_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseChargeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def search_charges_without_preload_content(
-        self,
-        search_charge_request: SearchChargeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Search Charges
+    _param = self._search_charges_serialize(
+      search_charge_request=search_charge_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseChargeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def search_charges_without_preload_content(
+    self,
+    search_charge_request: SearchChargeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Search Charges
 
 
         :param search_charge_request: (required)
         :type search_charge_request: SearchChargeRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -494,100 +418,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_charges_serialize(
-            search_charge_request=search_charge_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseChargeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _search_charges_serialize(
-        self,
-        search_charge_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if search_charge_request is not None:
-            _body_params = search_charge_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/charges/search',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._search_charges_serialize(
+      search_charge_request=search_charge_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseChargeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _search_charges_serialize(
+    self,
+    search_charge_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if search_charge_request is not None:
+      _body_params = search_charge_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/charges/search',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/checkout_api.py` & `getopenpay-0.0.2/getopenpay/api/checkout_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,69 +7,61 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.checkout_session_external import CheckoutSessionExternal
 from getopenpay.models.checkout_session_query_params import CheckoutSessionQueryParams
 from getopenpay.models.create_checkout_session_request import CreateCheckoutSessionRequest
-from getopenpay.models.list_response_checkout_session_external import ListResponseCheckoutSessionExternal
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
+from getopenpay.models.list_response_checkout_session_external import (
+  ListResponseCheckoutSessionExternal
+)
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class CheckoutApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_checkout_session(
-        self,
-        create_checkout_session_request: CreateCheckoutSessionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CheckoutSessionExternal:
-        """Create Checkout Session
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_checkout_session(
+    self,
+    create_checkout_session_request: CreateCheckoutSessionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CheckoutSessionExternal:
+    """Create Checkout Session
 
 
         :param create_checkout_session_request: (required)
         :type create_checkout_session_request: CreateCheckoutSessionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -88,56 +80,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_checkout_session_serialize(
-            create_checkout_session_request=create_checkout_session_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CheckoutSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_checkout_session_with_http_info(
-        self,
-        create_checkout_session_request: CreateCheckoutSessionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CheckoutSessionExternal]:
-        """Create Checkout Session
+    _param = self._create_checkout_session_serialize(
+      create_checkout_session_request=create_checkout_session_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CheckoutSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_checkout_session_with_http_info(
+    self,
+    create_checkout_session_request: CreateCheckoutSessionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CheckoutSessionExternal]:
+    """Create Checkout Session
 
 
         :param create_checkout_session_request: (required)
         :type create_checkout_session_request: CreateCheckoutSessionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -156,56 +138,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_checkout_session_serialize(
-            create_checkout_session_request=create_checkout_session_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CheckoutSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_checkout_session_without_preload_content(
-        self,
-        create_checkout_session_request: CreateCheckoutSessionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Checkout Session
+    _param = self._create_checkout_session_serialize(
+      create_checkout_session_request=create_checkout_session_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CheckoutSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_checkout_session_without_preload_content(
+    self,
+    create_checkout_session_request: CreateCheckoutSessionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Checkout Session
 
 
         :param create_checkout_session_request: (required)
         :type create_checkout_session_request: CreateCheckoutSessionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -224,127 +196,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_checkout_session_serialize(
-            create_checkout_session_request=create_checkout_session_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CheckoutSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_checkout_session_serialize(
-        self,
-        create_checkout_session_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_checkout_session_request is not None:
-            _body_params = create_checkout_session_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/checkout/sessions',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_checkout_session(
-        self,
-        session_id: Annotated[StrictStr, Field(description="Unique identifier of the checkout session.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CheckoutSessionExternal:
-        """Get Checkout Session
+    _param = self._create_checkout_session_serialize(
+      create_checkout_session_request=create_checkout_session_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CheckoutSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_checkout_session_serialize(
+    self,
+    create_checkout_session_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_checkout_session_request is not None:
+      _body_params = create_checkout_session_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/checkout/sessions',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_checkout_session(
+    self,
+    session_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the checkout session.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CheckoutSessionExternal:
+    """Get Checkout Session
 
 
         :param session_id: Unique identifier of the checkout session. (required)
         :type session_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -363,56 +308,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_checkout_session_serialize(
-            session_id=session_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CheckoutSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_checkout_session_with_http_info(
-        self,
-        session_id: Annotated[StrictStr, Field(description="Unique identifier of the checkout session.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CheckoutSessionExternal]:
-        """Get Checkout Session
+    _param = self._get_checkout_session_serialize(
+      session_id=session_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CheckoutSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_checkout_session_with_http_info(
+    self,
+    session_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the checkout session.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CheckoutSessionExternal]:
+    """Get Checkout Session
 
 
         :param session_id: Unique identifier of the checkout session. (required)
         :type session_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -431,56 +367,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_checkout_session_serialize(
-            session_id=session_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CheckoutSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_checkout_session_without_preload_content(
-        self,
-        session_id: Annotated[StrictStr, Field(description="Unique identifier of the checkout session.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Checkout Session
+    _param = self._get_checkout_session_serialize(
+      session_id=session_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CheckoutSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_checkout_session_without_preload_content(
+    self,
+    session_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the checkout session.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Checkout Session
 
 
         :param session_id: Unique identifier of the checkout session. (required)
         :type session_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -499,114 +426,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_checkout_session_serialize(
-            session_id=session_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CheckoutSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_checkout_session_serialize(
-        self,
-        session_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if session_id is not None:
-            _path_params['session_id'] = session_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/checkout/sessions/{session_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_checkout_sessions(
-        self,
-        checkout_session_query_params: CheckoutSessionQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseCheckoutSessionExternal:
-        """List Checkout Sessions
+    _param = self._get_checkout_session_serialize(
+      session_id=session_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CheckoutSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_checkout_session_serialize(
+    self,
+    session_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if session_id is not None:
+      _path_params['session_id'] = session_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/checkout/sessions/{session_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_checkout_sessions(
+    self,
+    checkout_session_query_params: CheckoutSessionQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseCheckoutSessionExternal:
+    """List Checkout Sessions
 
 
         :param checkout_session_query_params: (required)
         :type checkout_session_query_params: CheckoutSessionQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -625,56 +529,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_checkout_sessions_serialize(
-            checkout_session_query_params=checkout_session_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCheckoutSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_checkout_sessions_with_http_info(
-        self,
-        checkout_session_query_params: CheckoutSessionQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseCheckoutSessionExternal]:
-        """List Checkout Sessions
+    _param = self._list_checkout_sessions_serialize(
+      checkout_session_query_params=checkout_session_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCheckoutSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_checkout_sessions_with_http_info(
+    self,
+    checkout_session_query_params: CheckoutSessionQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseCheckoutSessionExternal]:
+    """List Checkout Sessions
 
 
         :param checkout_session_query_params: (required)
         :type checkout_session_query_params: CheckoutSessionQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -693,56 +587,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_checkout_sessions_serialize(
-            checkout_session_query_params=checkout_session_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCheckoutSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_checkout_sessions_without_preload_content(
-        self,
-        checkout_session_query_params: CheckoutSessionQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Checkout Sessions
+    _param = self._list_checkout_sessions_serialize(
+      checkout_session_query_params=checkout_session_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCheckoutSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_checkout_sessions_without_preload_content(
+    self,
+    checkout_session_query_params: CheckoutSessionQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Checkout Sessions
 
 
         :param checkout_session_query_params: (required)
         :type checkout_session_query_params: CheckoutSessionQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -761,100 +645,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_checkout_sessions_serialize(
-            checkout_session_query_params=checkout_session_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCheckoutSessionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_checkout_sessions_serialize(
-        self,
-        checkout_session_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if checkout_session_query_params is not None:
-            _body_params = checkout_session_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/checkout/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._list_checkout_sessions_serialize(
+      checkout_session_query_params=checkout_session_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCheckoutSessionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_checkout_sessions_serialize(
+    self,
+    checkout_session_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if checkout_session_query_params is not None:
+      _body_params = checkout_session_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/checkout/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/coupons_api.py` & `getopenpay-0.0.2/getopenpay/api/coupons_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,70 +7,60 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.coupon_external import CouponExternal
 from getopenpay.models.coupon_query_params import CouponQueryParams
 from getopenpay.models.create_coupon_request import CreateCouponRequest
 from getopenpay.models.list_response_coupon_external import ListResponseCouponExternal
 from getopenpay.models.update_coupon_request import UpdateCouponRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class CouponsApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_coupon(
-        self,
-        create_coupon_request: CreateCouponRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CouponExternal:
-        """Create Coupon
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_coupon(
+    self,
+    create_coupon_request: CreateCouponRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CouponExternal:
+    """Create Coupon
 
 
         :param create_coupon_request: (required)
         :type create_coupon_request: CreateCouponRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -89,56 +79,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_coupon_serialize(
-            create_coupon_request=create_coupon_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_coupon_with_http_info(
-        self,
-        create_coupon_request: CreateCouponRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CouponExternal]:
-        """Create Coupon
+    _param = self._create_coupon_serialize(
+      create_coupon_request=create_coupon_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_coupon_with_http_info(
+    self,
+    create_coupon_request: CreateCouponRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CouponExternal]:
+    """Create Coupon
 
 
         :param create_coupon_request: (required)
         :type create_coupon_request: CreateCouponRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -157,56 +137,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_coupon_serialize(
-            create_coupon_request=create_coupon_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_coupon_without_preload_content(
-        self,
-        create_coupon_request: CreateCouponRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Coupon
+    _param = self._create_coupon_serialize(
+      create_coupon_request=create_coupon_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_coupon_without_preload_content(
+    self,
+    create_coupon_request: CreateCouponRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Coupon
 
 
         :param create_coupon_request: (required)
         :type create_coupon_request: CreateCouponRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -225,127 +195,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_coupon_serialize(
-            create_coupon_request=create_coupon_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_coupon_serialize(
-        self,
-        create_coupon_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_coupon_request is not None:
-            _body_params = create_coupon_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/coupons/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def delete_coupon(
-        self,
-        coupon_id: Annotated[StrictStr, Field(description="Unique identifier of the Coupon.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> None:
-        """Delete Coupon
+    _param = self._create_coupon_serialize(
+      create_coupon_request=create_coupon_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_coupon_serialize(
+    self,
+    create_coupon_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_coupon_request is not None:
+      _body_params = create_coupon_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/coupons/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def delete_coupon(
+    self,
+    coupon_id: Annotated[StrictStr,
+                         Field(description='Unique identifier of the Coupon.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> None:
+    """Delete Coupon
 
 
         :param coupon_id: Unique identifier of the Coupon. (required)
         :type coupon_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -364,54 +307,44 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_coupon_serialize(
-            coupon_id=coupon_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def delete_coupon_with_http_info(
-        self,
-        coupon_id: Annotated[StrictStr, Field(description="Unique identifier of the Coupon.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[None]:
-        """Delete Coupon
+    _param = self._delete_coupon_serialize(
+      coupon_id=coupon_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {}
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def delete_coupon_with_http_info(
+    self,
+    coupon_id: Annotated[StrictStr,
+                         Field(description='Unique identifier of the Coupon.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[None]:
+    """Delete Coupon
 
 
         :param coupon_id: Unique identifier of the Coupon. (required)
         :type coupon_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -430,54 +363,44 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_coupon_serialize(
-            coupon_id=coupon_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def delete_coupon_without_preload_content(
-        self,
-        coupon_id: Annotated[StrictStr, Field(description="Unique identifier of the Coupon.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Delete Coupon
+    _param = self._delete_coupon_serialize(
+      coupon_id=coupon_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {}
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def delete_coupon_without_preload_content(
+    self,
+    coupon_id: Annotated[StrictStr,
+                         Field(description='Unique identifier of the Coupon.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Delete Coupon
 
 
         :param coupon_id: Unique identifier of the Coupon. (required)
         :type coupon_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -496,112 +419,89 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_coupon_serialize(
-            coupon_id=coupon_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _delete_coupon_serialize(
-        self,
-        coupon_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if coupon_id is not None:
-            _path_params['coupon_id'] = coupon_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/coupons/{coupon_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_coupon(
-        self,
-        coupon_id: Annotated[StrictStr, Field(description="Unique identifier of the Coupon.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CouponExternal:
-        """Get Coupon
+    _param = self._delete_coupon_serialize(
+      coupon_id=coupon_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {}
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _delete_coupon_serialize(
+    self,
+    coupon_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if coupon_id is not None:
+      _path_params['coupon_id'] = coupon_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='DELETE',
+      resource_path='/coupons/{coupon_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_coupon(
+    self,
+    coupon_id: Annotated[StrictStr,
+                         Field(description='Unique identifier of the Coupon.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CouponExternal:
+    """Get Coupon
 
 
         :param coupon_id: Unique identifier of the Coupon. (required)
         :type coupon_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -620,56 +520,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_coupon_serialize(
-            coupon_id=coupon_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_coupon_with_http_info(
-        self,
-        coupon_id: Annotated[StrictStr, Field(description="Unique identifier of the Coupon.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CouponExternal]:
-        """Get Coupon
+    _param = self._get_coupon_serialize(
+      coupon_id=coupon_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_coupon_with_http_info(
+    self,
+    coupon_id: Annotated[StrictStr,
+                         Field(description='Unique identifier of the Coupon.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CouponExternal]:
+    """Get Coupon
 
 
         :param coupon_id: Unique identifier of the Coupon. (required)
         :type coupon_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -688,56 +579,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_coupon_serialize(
-            coupon_id=coupon_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_coupon_without_preload_content(
-        self,
-        coupon_id: Annotated[StrictStr, Field(description="Unique identifier of the Coupon.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Coupon
+    _param = self._get_coupon_serialize(
+      coupon_id=coupon_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_coupon_without_preload_content(
+    self,
+    coupon_id: Annotated[StrictStr,
+                         Field(description='Unique identifier of the Coupon.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Coupon
 
 
         :param coupon_id: Unique identifier of the Coupon. (required)
         :type coupon_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -756,114 +638,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_coupon_serialize(
-            coupon_id=coupon_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_coupon_serialize(
-        self,
-        coupon_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if coupon_id is not None:
-            _path_params['coupon_id'] = coupon_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/coupons/{coupon_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_coupons(
-        self,
-        coupon_query_params: CouponQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseCouponExternal:
-        """List Coupons
+    _param = self._get_coupon_serialize(
+      coupon_id=coupon_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_coupon_serialize(
+    self,
+    coupon_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if coupon_id is not None:
+      _path_params['coupon_id'] = coupon_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/coupons/{coupon_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_coupons(
+    self,
+    coupon_query_params: CouponQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseCouponExternal:
+    """List Coupons
 
 
         :param coupon_query_params: (required)
         :type coupon_query_params: CouponQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -882,56 +741,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_coupons_serialize(
-            coupon_query_params=coupon_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_coupons_with_http_info(
-        self,
-        coupon_query_params: CouponQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseCouponExternal]:
-        """List Coupons
+    _param = self._list_coupons_serialize(
+      coupon_query_params=coupon_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_coupons_with_http_info(
+    self,
+    coupon_query_params: CouponQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseCouponExternal]:
+    """List Coupons
 
 
         :param coupon_query_params: (required)
         :type coupon_query_params: CouponQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -950,56 +799,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_coupons_serialize(
-            coupon_query_params=coupon_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_coupons_without_preload_content(
-        self,
-        coupon_query_params: CouponQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Coupons
+    _param = self._list_coupons_serialize(
+      coupon_query_params=coupon_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_coupons_without_preload_content(
+    self,
+    coupon_query_params: CouponQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Coupons
 
 
         :param coupon_query_params: (required)
         :type coupon_query_params: CouponQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1018,128 +857,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_coupons_serialize(
-            coupon_query_params=coupon_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_coupons_serialize(
-        self,
-        coupon_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if coupon_query_params is not None:
-            _body_params = coupon_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/coupons/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def update_coupon(
-        self,
-        coupon_id: Annotated[StrictStr, Field(description="Unique identifier of the Coupon.")],
-        update_coupon_request: UpdateCouponRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CouponExternal:
-        """Update Coupon
+    _param = self._list_coupons_serialize(
+      coupon_query_params=coupon_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_coupons_serialize(
+    self,
+    coupon_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if coupon_query_params is not None:
+      _body_params = coupon_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/coupons/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def update_coupon(
+    self,
+    coupon_id: Annotated[StrictStr,
+                         Field(description='Unique identifier of the Coupon.')],
+    update_coupon_request: UpdateCouponRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CouponExternal:
+    """Update Coupon
 
 
         :param coupon_id: Unique identifier of the Coupon. (required)
         :type coupon_id: str
         :param update_coupon_request: (required)
         :type update_coupon_request: UpdateCouponRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1160,58 +972,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_coupon_serialize(
-            coupon_id=coupon_id,
-            update_coupon_request=update_coupon_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def update_coupon_with_http_info(
-        self,
-        coupon_id: Annotated[StrictStr, Field(description="Unique identifier of the Coupon.")],
-        update_coupon_request: UpdateCouponRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CouponExternal]:
-        """Update Coupon
+    _param = self._update_coupon_serialize(
+      coupon_id=coupon_id,
+      update_coupon_request=update_coupon_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def update_coupon_with_http_info(
+    self,
+    coupon_id: Annotated[StrictStr,
+                         Field(description='Unique identifier of the Coupon.')],
+    update_coupon_request: UpdateCouponRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CouponExternal]:
+    """Update Coupon
 
 
         :param coupon_id: Unique identifier of the Coupon. (required)
         :type coupon_id: str
         :param update_coupon_request: (required)
         :type update_coupon_request: UpdateCouponRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1232,58 +1035,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_coupon_serialize(
-            coupon_id=coupon_id,
-            update_coupon_request=update_coupon_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def update_coupon_without_preload_content(
-        self,
-        coupon_id: Annotated[StrictStr, Field(description="Unique identifier of the Coupon.")],
-        update_coupon_request: UpdateCouponRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Update Coupon
+    _param = self._update_coupon_serialize(
+      coupon_id=coupon_id,
+      update_coupon_request=update_coupon_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def update_coupon_without_preload_content(
+    self,
+    coupon_id: Annotated[StrictStr,
+                         Field(description='Unique identifier of the Coupon.')],
+    update_coupon_request: UpdateCouponRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Update Coupon
 
 
         :param coupon_id: Unique identifier of the Coupon. (required)
         :type coupon_id: str
         :param update_coupon_request: (required)
         :type update_coupon_request: UpdateCouponRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1304,104 +1098,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_coupon_serialize(
-            coupon_id=coupon_id,
-            update_coupon_request=update_coupon_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CouponExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _update_coupon_serialize(
-        self,
-        coupon_id,
-        update_coupon_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if coupon_id is not None:
-            _path_params['coupon_id'] = coupon_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if update_coupon_request is not None:
-            _body_params = update_coupon_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/coupons/{coupon_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._update_coupon_serialize(
+      coupon_id=coupon_id,
+      update_coupon_request=update_coupon_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CouponExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _update_coupon_serialize(
+    self,
+    coupon_id,
+    update_coupon_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if coupon_id is not None:
+      _path_params['coupon_id'] = coupon_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if update_coupon_request is not None:
+      _body_params = update_coupon_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/coupons/{coupon_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/credit_notes_api.py` & `getopenpay-0.0.2/getopenpay/api/credit_notes_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,69 +7,59 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_credit_note_request import CreateCreditNoteRequest
 from getopenpay.models.credit_note_external import CreditNoteExternal
 from getopenpay.models.credit_note_query_params import CreditNoteQueryParams
 from getopenpay.models.list_response_credit_note_external import ListResponseCreditNoteExternal
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class CreditNotesApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_credit_note(
-        self,
-        create_credit_note_request: CreateCreditNoteRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CreditNoteExternal:
-        """Create Credit Note
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_credit_note(
+    self,
+    create_credit_note_request: CreateCreditNoteRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CreditNoteExternal:
+    """Create Credit Note
 
         Issue a credit note to adjust the amount of a finalized invoice. You may issue multiple credit notes for an invoice. The sum of all credit notes issued for an invoice cant exceed the  total amount of the invoice. For a paid invoice, the sum of the refund and credit must equal the invoice total. Each credit note will increment the invoices pre_payment_credit_notes_amount_atom  or post_payment_credit_notes_amount_atom depending on its status at the time  of credit note creation.
 
         :param create_credit_note_request: (required)
         :type create_credit_note_request: CreateCreditNoteRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -89,56 +79,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_credit_note_serialize(
-            create_credit_note_request=create_credit_note_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CreditNoteExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_credit_note_with_http_info(
-        self,
-        create_credit_note_request: CreateCreditNoteRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CreditNoteExternal]:
-        """Create Credit Note
+    _param = self._create_credit_note_serialize(
+      create_credit_note_request=create_credit_note_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CreditNoteExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_credit_note_with_http_info(
+    self,
+    create_credit_note_request: CreateCreditNoteRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CreditNoteExternal]:
+    """Create Credit Note
 
         Issue a credit note to adjust the amount of a finalized invoice. You may issue multiple credit notes for an invoice. The sum of all credit notes issued for an invoice cant exceed the  total amount of the invoice. For a paid invoice, the sum of the refund and credit must equal the invoice total. Each credit note will increment the invoices pre_payment_credit_notes_amount_atom  or post_payment_credit_notes_amount_atom depending on its status at the time  of credit note creation.
 
         :param create_credit_note_request: (required)
         :type create_credit_note_request: CreateCreditNoteRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -158,56 +138,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_credit_note_serialize(
-            create_credit_note_request=create_credit_note_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CreditNoteExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_credit_note_without_preload_content(
-        self,
-        create_credit_note_request: CreateCreditNoteRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Credit Note
+    _param = self._create_credit_note_serialize(
+      create_credit_note_request=create_credit_note_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CreditNoteExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_credit_note_without_preload_content(
+    self,
+    create_credit_note_request: CreateCreditNoteRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Credit Note
 
         Issue a credit note to adjust the amount of a finalized invoice. You may issue multiple credit notes for an invoice. The sum of all credit notes issued for an invoice cant exceed the  total amount of the invoice. For a paid invoice, the sum of the refund and credit must equal the invoice total. Each credit note will increment the invoices pre_payment_credit_notes_amount_atom  or post_payment_credit_notes_amount_atom depending on its status at the time  of credit note creation.
 
         :param create_credit_note_request: (required)
         :type create_credit_note_request: CreateCreditNoteRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -227,127 +197,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_credit_note_serialize(
-            create_credit_note_request=create_credit_note_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CreditNoteExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_credit_note_serialize(
-        self,
-        create_credit_note_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_credit_note_request is not None:
-            _body_params = create_credit_note_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/credit-notes/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_credit_note(
-        self,
-        credit_note_id: Annotated[StrictStr, Field(description="Unique Identifier of the credit_note.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CreditNoteExternal:
-        """Get Credit Note
+    _param = self._create_credit_note_serialize(
+      create_credit_note_request=create_credit_note_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CreditNoteExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_credit_note_serialize(
+    self,
+    create_credit_note_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_credit_note_request is not None:
+      _body_params = create_credit_note_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/credit-notes/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_credit_note(
+    self,
+    credit_note_id: Annotated[StrictStr,
+                              Field(description='Unique Identifier of the credit_note.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CreditNoteExternal:
+    """Get Credit Note
 
 
         :param credit_note_id: Unique Identifier of the credit_note. (required)
         :type credit_note_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -366,56 +309,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_credit_note_serialize(
-            credit_note_id=credit_note_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CreditNoteExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_credit_note_with_http_info(
-        self,
-        credit_note_id: Annotated[StrictStr, Field(description="Unique Identifier of the credit_note.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CreditNoteExternal]:
-        """Get Credit Note
+    _param = self._get_credit_note_serialize(
+      credit_note_id=credit_note_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CreditNoteExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_credit_note_with_http_info(
+    self,
+    credit_note_id: Annotated[StrictStr,
+                              Field(description='Unique Identifier of the credit_note.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CreditNoteExternal]:
+    """Get Credit Note
 
 
         :param credit_note_id: Unique Identifier of the credit_note. (required)
         :type credit_note_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -434,56 +368,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_credit_note_serialize(
-            credit_note_id=credit_note_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CreditNoteExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_credit_note_without_preload_content(
-        self,
-        credit_note_id: Annotated[StrictStr, Field(description="Unique Identifier of the credit_note.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Credit Note
+    _param = self._get_credit_note_serialize(
+      credit_note_id=credit_note_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CreditNoteExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_credit_note_without_preload_content(
+    self,
+    credit_note_id: Annotated[StrictStr,
+                              Field(description='Unique Identifier of the credit_note.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Credit Note
 
 
         :param credit_note_id: Unique Identifier of the credit_note. (required)
         :type credit_note_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -502,114 +427,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_credit_note_serialize(
-            credit_note_id=credit_note_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CreditNoteExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_credit_note_serialize(
-        self,
-        credit_note_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if credit_note_id is not None:
-            _path_params['credit_note_id'] = credit_note_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/credit-notes/{credit_note_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_credit_notes(
-        self,
-        credit_note_query_params: CreditNoteQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseCreditNoteExternal:
-        """List Credit Notes
+    _param = self._get_credit_note_serialize(
+      credit_note_id=credit_note_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CreditNoteExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_credit_note_serialize(
+    self,
+    credit_note_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if credit_note_id is not None:
+      _path_params['credit_note_id'] = credit_note_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/credit-notes/{credit_note_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_credit_notes(
+    self,
+    credit_note_query_params: CreditNoteQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseCreditNoteExternal:
+    """List Credit Notes
 
 
         :param credit_note_query_params: (required)
         :type credit_note_query_params: CreditNoteQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -628,56 +530,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_credit_notes_serialize(
-            credit_note_query_params=credit_note_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCreditNoteExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_credit_notes_with_http_info(
-        self,
-        credit_note_query_params: CreditNoteQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseCreditNoteExternal]:
-        """List Credit Notes
+    _param = self._list_credit_notes_serialize(
+      credit_note_query_params=credit_note_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCreditNoteExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_credit_notes_with_http_info(
+    self,
+    credit_note_query_params: CreditNoteQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseCreditNoteExternal]:
+    """List Credit Notes
 
 
         :param credit_note_query_params: (required)
         :type credit_note_query_params: CreditNoteQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -696,56 +588,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_credit_notes_serialize(
-            credit_note_query_params=credit_note_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCreditNoteExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_credit_notes_without_preload_content(
-        self,
-        credit_note_query_params: CreditNoteQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Credit Notes
+    _param = self._list_credit_notes_serialize(
+      credit_note_query_params=credit_note_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCreditNoteExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_credit_notes_without_preload_content(
+    self,
+    credit_note_query_params: CreditNoteQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Credit Notes
 
 
         :param credit_note_query_params: (required)
         :type credit_note_query_params: CreditNoteQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -764,100 +646,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_credit_notes_serialize(
-            credit_note_query_params=credit_note_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCreditNoteExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_credit_notes_serialize(
-        self,
-        credit_note_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if credit_note_query_params is not None:
-            _body_params = credit_note_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/credit-notes/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._list_credit_notes_serialize(
+      credit_note_query_params=credit_note_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCreditNoteExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_credit_notes_serialize(
+    self,
+    credit_note_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if credit_note_query_params is not None:
+      _body_params = credit_note_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/credit-notes/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/customers_api.py` & `getopenpay-0.0.2/getopenpay/api/customers_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,79 +7,75 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
 from typing import List, Optional
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.active_sub_response import ActiveSubResponse
-from getopenpay.models.create_customer_balance_transaction_request import CreateCustomerBalanceTransactionRequest
+from getopenpay.models.create_customer_balance_transaction_request import (
+  CreateCustomerBalanceTransactionRequest
+)
 from getopenpay.models.create_customer_request import CreateCustomerRequest
-from getopenpay.models.customer_balance_transaction_external import CustomerBalanceTransactionExternal
+from getopenpay.models.customer_balance_transaction_external import (
+  CustomerBalanceTransactionExternal
+)
 from getopenpay.models.customer_external import CustomerExternal
 from getopenpay.models.customer_payment_method_query_params import CustomerPaymentMethodQueryParams
 from getopenpay.models.customer_query_params import CustomerQueryParams
 from getopenpay.models.list_active_sub_params import ListActiveSubParams
 from getopenpay.models.list_response_customer_external import ListResponseCustomerExternal
-from getopenpay.models.list_response_payment_method_external import ListResponsePaymentMethodExternal
+from getopenpay.models.list_response_payment_method_external import (
+  ListResponsePaymentMethodExternal
+)
 from getopenpay.models.search_customer_request import SearchCustomerRequest
 from getopenpay.models.update_customer_request import UpdateCustomerRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class CustomersApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_customer(
-        self,
-        create_customer_request: CreateCustomerRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CustomerExternal:
-        """Create Customer
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_customer(
+    self,
+    create_customer_request: CreateCustomerRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CustomerExternal:
+    """Create Customer
 
 
         :param create_customer_request: (required)
         :type create_customer_request: CreateCustomerRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -98,56 +94,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_customer_serialize(
-            create_customer_request=create_customer_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_customer_with_http_info(
-        self,
-        create_customer_request: CreateCustomerRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CustomerExternal]:
-        """Create Customer
+    _param = self._create_customer_serialize(
+      create_customer_request=create_customer_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_customer_with_http_info(
+    self,
+    create_customer_request: CreateCustomerRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CustomerExternal]:
+    """Create Customer
 
 
         :param create_customer_request: (required)
         :type create_customer_request: CreateCustomerRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -166,56 +152,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_customer_serialize(
-            create_customer_request=create_customer_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_customer_without_preload_content(
-        self,
-        create_customer_request: CreateCustomerRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Customer
+    _param = self._create_customer_serialize(
+      create_customer_request=create_customer_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_customer_without_preload_content(
+    self,
+    create_customer_request: CreateCustomerRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Customer
 
 
         :param create_customer_request: (required)
         :type create_customer_request: CreateCustomerRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -234,128 +210,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_customer_serialize(
-            create_customer_request=create_customer_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_customer_serialize(
-        self,
-        create_customer_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_customer_request is not None:
-            _body_params = create_customer_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/customers/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def create_customer_balance_transaction(
-        self,
-        customer_id: StrictStr,
-        create_customer_balance_transaction_request: CreateCustomerBalanceTransactionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CustomerBalanceTransactionExternal:
-        """Create Customer Balance Transaction
+    _param = self._create_customer_serialize(
+      create_customer_request=create_customer_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_customer_serialize(
+    self,
+    create_customer_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_customer_request is not None:
+      _body_params = create_customer_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/customers/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def create_customer_balance_transaction(
+    self,
+    customer_id: StrictStr,
+    create_customer_balance_transaction_request: CreateCustomerBalanceTransactionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CustomerBalanceTransactionExternal:
+    """Create Customer Balance Transaction
 
         Each customer has a Balance value, which denotes a debit or credit that's automatically applied to their next invoice upon finalization. Creates an immutable transaction that updates the customer's credit balance.
 
         :param customer_id: (required)
         :type customer_id: str
         :param create_customer_balance_transaction_request: (required)
         :type create_customer_balance_transaction_request: CreateCustomerBalanceTransactionRequest
@@ -377,58 +325,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_customer_balance_transaction_serialize(
-            customer_id=customer_id,
-            create_customer_balance_transaction_request=create_customer_balance_transaction_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CustomerBalanceTransactionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_customer_balance_transaction_with_http_info(
-        self,
-        customer_id: StrictStr,
-        create_customer_balance_transaction_request: CreateCustomerBalanceTransactionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CustomerBalanceTransactionExternal]:
-        """Create Customer Balance Transaction
+    _param = self._create_customer_balance_transaction_serialize(
+      customer_id=customer_id,
+      create_customer_balance_transaction_request=create_customer_balance_transaction_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CustomerBalanceTransactionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_customer_balance_transaction_with_http_info(
+    self,
+    customer_id: StrictStr,
+    create_customer_balance_transaction_request: CreateCustomerBalanceTransactionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CustomerBalanceTransactionExternal]:
+    """Create Customer Balance Transaction
 
         Each customer has a Balance value, which denotes a debit or credit that's automatically applied to their next invoice upon finalization. Creates an immutable transaction that updates the customer's credit balance.
 
         :param customer_id: (required)
         :type customer_id: str
         :param create_customer_balance_transaction_request: (required)
         :type create_customer_balance_transaction_request: CreateCustomerBalanceTransactionRequest
@@ -450,58 +388,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_customer_balance_transaction_serialize(
-            customer_id=customer_id,
-            create_customer_balance_transaction_request=create_customer_balance_transaction_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CustomerBalanceTransactionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_customer_balance_transaction_without_preload_content(
-        self,
-        customer_id: StrictStr,
-        create_customer_balance_transaction_request: CreateCustomerBalanceTransactionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Customer Balance Transaction
+    _param = self._create_customer_balance_transaction_serialize(
+      customer_id=customer_id,
+      create_customer_balance_transaction_request=create_customer_balance_transaction_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CustomerBalanceTransactionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_customer_balance_transaction_without_preload_content(
+    self,
+    customer_id: StrictStr,
+    create_customer_balance_transaction_request: CreateCustomerBalanceTransactionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Customer Balance Transaction
 
         Each customer has a Balance value, which denotes a debit or credit that's automatically applied to their next invoice upon finalization. Creates an immutable transaction that updates the customer's credit balance.
 
         :param customer_id: (required)
         :type customer_id: str
         :param create_customer_balance_transaction_request: (required)
         :type create_customer_balance_transaction_request: CreateCustomerBalanceTransactionRequest
@@ -523,131 +451,103 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_customer_balance_transaction_serialize(
-            customer_id=customer_id,
-            create_customer_balance_transaction_request=create_customer_balance_transaction_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CustomerBalanceTransactionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_customer_balance_transaction_serialize(
-        self,
-        customer_id,
-        create_customer_balance_transaction_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if customer_id is not None:
-            _path_params['customer_id'] = customer_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_customer_balance_transaction_request is not None:
-            _body_params = create_customer_balance_transaction_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/customers/{customer_id}/balance-transactions',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def delete_customer_discount(
-        self,
-        customer_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CustomerExternal:
-        """Delete Customer Discount
+    _param = self._create_customer_balance_transaction_serialize(
+      customer_id=customer_id,
+      create_customer_balance_transaction_request=create_customer_balance_transaction_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CustomerBalanceTransactionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_customer_balance_transaction_serialize(
+    self,
+    customer_id,
+    create_customer_balance_transaction_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if customer_id is not None:
+      _path_params['customer_id'] = customer_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_customer_balance_transaction_request is not None:
+      _body_params = create_customer_balance_transaction_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/customers/{customer_id}/balance-transactions',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def delete_customer_discount(
+    self,
+    customer_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CustomerExternal:
+    """Delete Customer Discount
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -666,56 +566,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_customer_discount_serialize(
-            customer_id=customer_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def delete_customer_discount_with_http_info(
-        self,
-        customer_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CustomerExternal]:
-        """Delete Customer Discount
+    _param = self._delete_customer_discount_serialize(
+      customer_id=customer_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def delete_customer_discount_with_http_info(
+    self,
+    customer_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CustomerExternal]:
+    """Delete Customer Discount
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -734,56 +624,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_customer_discount_serialize(
-            customer_id=customer_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def delete_customer_discount_without_preload_content(
-        self,
-        customer_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Delete Customer Discount
+    _param = self._delete_customer_discount_serialize(
+      customer_id=customer_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def delete_customer_discount_without_preload_content(
+    self,
+    customer_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Delete Customer Discount
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -802,115 +682,92 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_customer_discount_serialize(
-            customer_id=customer_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _delete_customer_discount_serialize(
-        self,
-        customer_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if customer_id is not None:
-            _path_params['customer_id'] = customer_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/customers/{customer_id}/discount',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_customer(
-        self,
-        customer_id: StrictStr,
-        expand: Optional[List[StrictStr]] = None,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CustomerExternal:
-        """Get Customer
+    _param = self._delete_customer_discount_serialize(
+      customer_id=customer_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _delete_customer_discount_serialize(
+    self,
+    customer_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if customer_id is not None:
+      _path_params['customer_id'] = customer_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='DELETE',
+      resource_path='/customers/{customer_id}/discount',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_customer(
+    self,
+    customer_id: StrictStr,
+    expand: Optional[List[StrictStr]] = None,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CustomerExternal:
+    """Get Customer
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param expand:
         :type expand: List[str]
         :param _request_timeout: timeout setting for this request. If one
@@ -931,58 +788,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_customer_serialize(
-            customer_id=customer_id,
-            expand=expand,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_customer_with_http_info(
-        self,
-        customer_id: StrictStr,
-        expand: Optional[List[StrictStr]] = None,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CustomerExternal]:
-        """Get Customer
+    _param = self._get_customer_serialize(
+      customer_id=customer_id,
+      expand=expand,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_customer_with_http_info(
+    self,
+    customer_id: StrictStr,
+    expand: Optional[List[StrictStr]] = None,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CustomerExternal]:
+    """Get Customer
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param expand:
         :type expand: List[str]
         :param _request_timeout: timeout setting for this request. If one
@@ -1003,58 +850,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_customer_serialize(
-            customer_id=customer_id,
-            expand=expand,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_customer_without_preload_content(
-        self,
-        customer_id: StrictStr,
-        expand: Optional[List[StrictStr]] = None,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Customer
+    _param = self._get_customer_serialize(
+      customer_id=customer_id,
+      expand=expand,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_customer_without_preload_content(
+    self,
+    customer_id: StrictStr,
+    expand: Optional[List[StrictStr]] = None,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Customer
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param expand:
         :type expand: List[str]
         :param _request_timeout: timeout setting for this request. If one
@@ -1075,122 +912,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_customer_serialize(
-            customer_id=customer_id,
-            expand=expand,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_customer_serialize(
-        self,
-        customer_id,
-        expand,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-            'expand': 'multi',
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if customer_id is not None:
-            _path_params['customer_id'] = customer_id
-        # process the query parameters
-        if expand is not None:
-            
-            _query_params.append(('expand', expand))
-            
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/customers/{customer_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_customer_balance_transaction(
-        self,
-        customer_id: StrictStr,
-        transaction_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CustomerBalanceTransactionExternal:
-        """Get Customer Balance Transaction
+    _param = self._get_customer_serialize(
+      customer_id=customer_id,
+      expand=expand,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_customer_serialize(
+    self,
+    customer_id,
+    expand,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {
+      'expand': 'multi',
+    }
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if customer_id is not None:
+      _path_params['customer_id'] = customer_id
+    # process the query parameters
+    if expand is not None:
+
+      _query_params.append(('expand', expand))
+
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/customers/{customer_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_customer_balance_transaction(
+    self,
+    customer_id: StrictStr,
+    transaction_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CustomerBalanceTransactionExternal:
+    """Get Customer Balance Transaction
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param transaction_id: (required)
         :type transaction_id: str
         :param _request_timeout: timeout setting for this request. If one
@@ -1211,58 +1026,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_customer_balance_transaction_serialize(
-            customer_id=customer_id,
-            transaction_id=transaction_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CustomerBalanceTransactionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_customer_balance_transaction_with_http_info(
-        self,
-        customer_id: StrictStr,
-        transaction_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CustomerBalanceTransactionExternal]:
-        """Get Customer Balance Transaction
+    _param = self._get_customer_balance_transaction_serialize(
+      customer_id=customer_id,
+      transaction_id=transaction_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CustomerBalanceTransactionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_customer_balance_transaction_with_http_info(
+    self,
+    customer_id: StrictStr,
+    transaction_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CustomerBalanceTransactionExternal]:
+    """Get Customer Balance Transaction
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param transaction_id: (required)
         :type transaction_id: str
         :param _request_timeout: timeout setting for this request. If one
@@ -1283,58 +1088,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_customer_balance_transaction_serialize(
-            customer_id=customer_id,
-            transaction_id=transaction_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CustomerBalanceTransactionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_customer_balance_transaction_without_preload_content(
-        self,
-        customer_id: StrictStr,
-        transaction_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Customer Balance Transaction
+    _param = self._get_customer_balance_transaction_serialize(
+      customer_id=customer_id,
+      transaction_id=transaction_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CustomerBalanceTransactionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_customer_balance_transaction_without_preload_content(
+    self,
+    customer_id: StrictStr,
+    transaction_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Customer Balance Transaction
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param transaction_id: (required)
         :type transaction_id: str
         :param _request_timeout: timeout setting for this request. If one
@@ -1355,118 +1150,95 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_customer_balance_transaction_serialize(
-            customer_id=customer_id,
-            transaction_id=transaction_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CustomerBalanceTransactionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_customer_balance_transaction_serialize(
-        self,
-        customer_id,
-        transaction_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if customer_id is not None:
-            _path_params['customer_id'] = customer_id
-        if transaction_id is not None:
-            _path_params['transaction_id'] = transaction_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/customers/{customer_id}/balance-transactions/{transaction_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_customer_balance_transactions(
-        self,
-        customer_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> List[CustomerBalanceTransactionExternal]:
-        """Get Customer Balance Transactions
+    _param = self._get_customer_balance_transaction_serialize(
+      customer_id=customer_id,
+      transaction_id=transaction_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CustomerBalanceTransactionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_customer_balance_transaction_serialize(
+    self,
+    customer_id,
+    transaction_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if customer_id is not None:
+      _path_params['customer_id'] = customer_id
+    if transaction_id is not None:
+      _path_params['transaction_id'] = transaction_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/customers/{customer_id}/balance-transactions/{transaction_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_customer_balance_transactions(
+    self,
+    customer_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> List[CustomerBalanceTransactionExternal]:
+    """Get Customer Balance Transactions
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1485,56 +1257,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_customer_balance_transactions_serialize(
-            customer_id=customer_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CustomerBalanceTransactionExternal]",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_customer_balance_transactions_with_http_info(
-        self,
-        customer_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[List[CustomerBalanceTransactionExternal]]:
-        """Get Customer Balance Transactions
+    _param = self._get_customer_balance_transactions_serialize(
+      customer_id=customer_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'List[CustomerBalanceTransactionExternal]',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_customer_balance_transactions_with_http_info(
+    self,
+    customer_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[List[CustomerBalanceTransactionExternal]]:
+    """Get Customer Balance Transactions
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1553,56 +1315,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_customer_balance_transactions_serialize(
-            customer_id=customer_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CustomerBalanceTransactionExternal]",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_customer_balance_transactions_without_preload_content(
-        self,
-        customer_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Customer Balance Transactions
+    _param = self._get_customer_balance_transactions_serialize(
+      customer_id=customer_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'List[CustomerBalanceTransactionExternal]',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_customer_balance_transactions_without_preload_content(
+    self,
+    customer_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Customer Balance Transactions
 
 
         :param customer_id: (required)
         :type customer_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1621,115 +1373,93 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_customer_balance_transactions_serialize(
-            customer_id=customer_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "List[CustomerBalanceTransactionExternal]",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_customer_balance_transactions_serialize(
-        self,
-        customer_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if customer_id is not None:
-            _path_params['customer_id'] = customer_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/customers/{customer_id}/balance-transactions',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_customer_payment_methods(
-        self,
-        customer_id: Annotated[StrictStr, Field(description="Unique Identifier of the customer.")],
-        customer_payment_method_query_params: CustomerPaymentMethodQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponsePaymentMethodExternal:
-        """List Customer Payment Methods
+    _param = self._get_customer_balance_transactions_serialize(
+      customer_id=customer_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'List[CustomerBalanceTransactionExternal]',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_customer_balance_transactions_serialize(
+    self,
+    customer_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if customer_id is not None:
+      _path_params['customer_id'] = customer_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/customers/{customer_id}/balance-transactions',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_customer_payment_methods(
+    self,
+    customer_id: Annotated[StrictStr,
+                           Field(description='Unique Identifier of the customer.')],
+    customer_payment_method_query_params: CustomerPaymentMethodQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponsePaymentMethodExternal:
+    """List Customer Payment Methods
 
         Retrieves payment methods for a given customer. Can optionally filter by payment provider type.
 
         :param customer_id: Unique Identifier of the customer. (required)
         :type customer_id: str
         :param customer_payment_method_query_params: (required)
         :type customer_payment_method_query_params: CustomerPaymentMethodQueryParams
@@ -1751,58 +1481,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_customer_payment_methods_serialize(
-            customer_id=customer_id,
-            customer_payment_method_query_params=customer_payment_method_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_customer_payment_methods_with_http_info(
-        self,
-        customer_id: Annotated[StrictStr, Field(description="Unique Identifier of the customer.")],
-        customer_payment_method_query_params: CustomerPaymentMethodQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponsePaymentMethodExternal]:
-        """List Customer Payment Methods
+    _param = self._list_customer_payment_methods_serialize(
+      customer_id=customer_id,
+      customer_payment_method_query_params=customer_payment_method_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_customer_payment_methods_with_http_info(
+    self,
+    customer_id: Annotated[StrictStr,
+                           Field(description='Unique Identifier of the customer.')],
+    customer_payment_method_query_params: CustomerPaymentMethodQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponsePaymentMethodExternal]:
+    """List Customer Payment Methods
 
         Retrieves payment methods for a given customer. Can optionally filter by payment provider type.
 
         :param customer_id: Unique Identifier of the customer. (required)
         :type customer_id: str
         :param customer_payment_method_query_params: (required)
         :type customer_payment_method_query_params: CustomerPaymentMethodQueryParams
@@ -1824,58 +1545,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_customer_payment_methods_serialize(
-            customer_id=customer_id,
-            customer_payment_method_query_params=customer_payment_method_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_customer_payment_methods_without_preload_content(
-        self,
-        customer_id: Annotated[StrictStr, Field(description="Unique Identifier of the customer.")],
-        customer_payment_method_query_params: CustomerPaymentMethodQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Customer Payment Methods
+    _param = self._list_customer_payment_methods_serialize(
+      customer_id=customer_id,
+      customer_payment_method_query_params=customer_payment_method_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_customer_payment_methods_without_preload_content(
+    self,
+    customer_id: Annotated[StrictStr,
+                           Field(description='Unique Identifier of the customer.')],
+    customer_payment_method_query_params: CustomerPaymentMethodQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Customer Payment Methods
 
         Retrieves payment methods for a given customer. Can optionally filter by payment provider type.
 
         :param customer_id: Unique Identifier of the customer. (required)
         :type customer_id: str
         :param customer_payment_method_query_params: (required)
         :type customer_payment_method_query_params: CustomerPaymentMethodQueryParams
@@ -1897,131 +1609,103 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_customer_payment_methods_serialize(
-            customer_id=customer_id,
-            customer_payment_method_query_params=customer_payment_method_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_customer_payment_methods_serialize(
-        self,
-        customer_id,
-        customer_payment_method_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if customer_id is not None:
-            _path_params['customer_id'] = customer_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if customer_payment_method_query_params is not None:
-            _body_params = customer_payment_method_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/customers/{customer_id}/payment-methods',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_customers(
-        self,
-        customer_query_params: CustomerQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseCustomerExternal:
-        """List Customers
+    _param = self._list_customer_payment_methods_serialize(
+      customer_id=customer_id,
+      customer_payment_method_query_params=customer_payment_method_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_customer_payment_methods_serialize(
+    self,
+    customer_id,
+    customer_payment_method_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if customer_id is not None:
+      _path_params['customer_id'] = customer_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if customer_payment_method_query_params is not None:
+      _body_params = customer_payment_method_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/customers/{customer_id}/payment-methods',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_customers(
+    self,
+    customer_query_params: CustomerQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseCustomerExternal:
+    """List Customers
 
 
         :param customer_query_params: (required)
         :type customer_query_params: CustomerQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2040,56 +1724,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_customers_serialize(
-            customer_query_params=customer_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_customers_with_http_info(
-        self,
-        customer_query_params: CustomerQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseCustomerExternal]:
-        """List Customers
+    _param = self._list_customers_serialize(
+      customer_query_params=customer_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_customers_with_http_info(
+    self,
+    customer_query_params: CustomerQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseCustomerExternal]:
+    """List Customers
 
 
         :param customer_query_params: (required)
         :type customer_query_params: CustomerQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2108,56 +1782,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_customers_serialize(
-            customer_query_params=customer_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_customers_without_preload_content(
-        self,
-        customer_query_params: CustomerQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Customers
+    _param = self._list_customers_serialize(
+      customer_query_params=customer_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_customers_without_preload_content(
+    self,
+    customer_query_params: CustomerQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Customers
 
 
         :param customer_query_params: (required)
         :type customer_query_params: CustomerQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2176,128 +1840,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_customers_serialize(
-            customer_query_params=customer_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_customers_serialize(
-        self,
-        customer_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if customer_query_params is not None:
-            _body_params = customer_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/customers/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_valid_subscriptions(
-        self,
-        customer_id: Annotated[StrictStr, Field(description="Unique Identifier of the customer.")],
-        list_active_sub_params: ListActiveSubParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ActiveSubResponse:
-        """List Valid Subscriptions
+    _param = self._list_customers_serialize(
+      customer_query_params=customer_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_customers_serialize(
+    self,
+    customer_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if customer_query_params is not None:
+      _body_params = customer_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/customers/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_valid_subscriptions(
+    self,
+    customer_id: Annotated[StrictStr,
+                           Field(description='Unique Identifier of the customer.')],
+    list_active_sub_params: ListActiveSubParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ActiveSubResponse:
+    """List Valid Subscriptions
 
         Lists valid subscriptions for given product_id or price_id. All 'active' or 'trialing' subscriptions are considered to be valid.
 
         :param customer_id: Unique Identifier of the customer. (required)
         :type customer_id: str
         :param list_active_sub_params: (required)
         :type list_active_sub_params: ListActiveSubParams
@@ -2319,58 +1956,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_valid_subscriptions_serialize(
-            customer_id=customer_id,
-            list_active_sub_params=list_active_sub_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ActiveSubResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_valid_subscriptions_with_http_info(
-        self,
-        customer_id: Annotated[StrictStr, Field(description="Unique Identifier of the customer.")],
-        list_active_sub_params: ListActiveSubParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ActiveSubResponse]:
-        """List Valid Subscriptions
+    _param = self._list_valid_subscriptions_serialize(
+      customer_id=customer_id,
+      list_active_sub_params=list_active_sub_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ActiveSubResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_valid_subscriptions_with_http_info(
+    self,
+    customer_id: Annotated[StrictStr,
+                           Field(description='Unique Identifier of the customer.')],
+    list_active_sub_params: ListActiveSubParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ActiveSubResponse]:
+    """List Valid Subscriptions
 
         Lists valid subscriptions for given product_id or price_id. All 'active' or 'trialing' subscriptions are considered to be valid.
 
         :param customer_id: Unique Identifier of the customer. (required)
         :type customer_id: str
         :param list_active_sub_params: (required)
         :type list_active_sub_params: ListActiveSubParams
@@ -2392,58 +2020,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_valid_subscriptions_serialize(
-            customer_id=customer_id,
-            list_active_sub_params=list_active_sub_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ActiveSubResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_valid_subscriptions_without_preload_content(
-        self,
-        customer_id: Annotated[StrictStr, Field(description="Unique Identifier of the customer.")],
-        list_active_sub_params: ListActiveSubParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Valid Subscriptions
+    _param = self._list_valid_subscriptions_serialize(
+      customer_id=customer_id,
+      list_active_sub_params=list_active_sub_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ActiveSubResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_valid_subscriptions_without_preload_content(
+    self,
+    customer_id: Annotated[StrictStr,
+                           Field(description='Unique Identifier of the customer.')],
+    list_active_sub_params: ListActiveSubParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Valid Subscriptions
 
         Lists valid subscriptions for given product_id or price_id. All 'active' or 'trialing' subscriptions are considered to be valid.
 
         :param customer_id: Unique Identifier of the customer. (required)
         :type customer_id: str
         :param list_active_sub_params: (required)
         :type list_active_sub_params: ListActiveSubParams
@@ -2465,131 +2084,103 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_valid_subscriptions_serialize(
-            customer_id=customer_id,
-            list_active_sub_params=list_active_sub_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ActiveSubResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_valid_subscriptions_serialize(
-        self,
-        customer_id,
-        list_active_sub_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if customer_id is not None:
-            _path_params['customer_id'] = customer_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if list_active_sub_params is not None:
-            _body_params = list_active_sub_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/customers{customer_id}/list_valid_subscriptions',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def search_customers(
-        self,
-        search_customer_request: SearchCustomerRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseCustomerExternal:
-        """Search Customers
+    _param = self._list_valid_subscriptions_serialize(
+      customer_id=customer_id,
+      list_active_sub_params=list_active_sub_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ActiveSubResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_valid_subscriptions_serialize(
+    self,
+    customer_id,
+    list_active_sub_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if customer_id is not None:
+      _path_params['customer_id'] = customer_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if list_active_sub_params is not None:
+      _body_params = list_active_sub_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/customers{customer_id}/list_valid_subscriptions',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def search_customers(
+    self,
+    search_customer_request: SearchCustomerRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseCustomerExternal:
+    """Search Customers
 
 
         :param search_customer_request: (required)
         :type search_customer_request: SearchCustomerRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2608,56 +2199,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_customers_serialize(
-            search_customer_request=search_customer_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def search_customers_with_http_info(
-        self,
-        search_customer_request: SearchCustomerRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseCustomerExternal]:
-        """Search Customers
+    _param = self._search_customers_serialize(
+      search_customer_request=search_customer_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def search_customers_with_http_info(
+    self,
+    search_customer_request: SearchCustomerRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseCustomerExternal]:
+    """Search Customers
 
 
         :param search_customer_request: (required)
         :type search_customer_request: SearchCustomerRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2676,56 +2257,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_customers_serialize(
-            search_customer_request=search_customer_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def search_customers_without_preload_content(
-        self,
-        search_customer_request: SearchCustomerRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Search Customers
+    _param = self._search_customers_serialize(
+      search_customer_request=search_customer_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def search_customers_without_preload_content(
+    self,
+    search_customer_request: SearchCustomerRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Search Customers
 
 
         :param search_customer_request: (required)
         :type search_customer_request: SearchCustomerRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2744,128 +2315,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_customers_serialize(
-            search_customer_request=search_customer_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseCustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _search_customers_serialize(
-        self,
-        search_customer_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if search_customer_request is not None:
-            _body_params = search_customer_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/customers/search',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def update_customer(
-        self,
-        customer_external_id: StrictStr,
-        update_customer_request: UpdateCustomerRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CustomerExternal:
-        """Update Customer
+    _param = self._search_customers_serialize(
+      search_customer_request=search_customer_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseCustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _search_customers_serialize(
+    self,
+    search_customer_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if search_customer_request is not None:
+      _body_params = search_customer_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/customers/search',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def update_customer(
+    self,
+    customer_external_id: StrictStr,
+    update_customer_request: UpdateCustomerRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CustomerExternal:
+    """Update Customer
 
 
         :param customer_external_id: (required)
         :type customer_external_id: str
         :param update_customer_request: (required)
         :type update_customer_request: UpdateCustomerRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2886,58 +2429,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_customer_serialize(
-            customer_external_id=customer_external_id,
-            update_customer_request=update_customer_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def update_customer_with_http_info(
-        self,
-        customer_external_id: StrictStr,
-        update_customer_request: UpdateCustomerRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CustomerExternal]:
-        """Update Customer
+    _param = self._update_customer_serialize(
+      customer_external_id=customer_external_id,
+      update_customer_request=update_customer_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def update_customer_with_http_info(
+    self,
+    customer_external_id: StrictStr,
+    update_customer_request: UpdateCustomerRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CustomerExternal]:
+    """Update Customer
 
 
         :param customer_external_id: (required)
         :type customer_external_id: str
         :param update_customer_request: (required)
         :type update_customer_request: UpdateCustomerRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2958,58 +2491,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_customer_serialize(
-            customer_external_id=customer_external_id,
-            update_customer_request=update_customer_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def update_customer_without_preload_content(
-        self,
-        customer_external_id: StrictStr,
-        update_customer_request: UpdateCustomerRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Update Customer
+    _param = self._update_customer_serialize(
+      customer_external_id=customer_external_id,
+      update_customer_request=update_customer_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def update_customer_without_preload_content(
+    self,
+    customer_external_id: StrictStr,
+    update_customer_request: UpdateCustomerRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Update Customer
 
 
         :param customer_external_id: (required)
         :type customer_external_id: str
         :param update_customer_request: (required)
         :type update_customer_request: UpdateCustomerRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -3030,104 +2553,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_customer_serialize(
-            customer_external_id=customer_external_id,
-            update_customer_request=update_customer_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "CustomerExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _update_customer_serialize(
-        self,
-        customer_external_id,
-        update_customer_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if customer_external_id is not None:
-            _path_params['customer_external_id'] = customer_external_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if update_customer_request is not None:
-            _body_params = update_customer_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/customers/{customer_external_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._update_customer_serialize(
+      customer_external_id=customer_external_id,
+      update_customer_request=update_customer_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'CustomerExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _update_customer_serialize(
+    self,
+    customer_external_id,
+    update_customer_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if customer_external_id is not None:
+      _path_params['customer_external_id'] = customer_external_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if update_customer_request is not None:
+      _body_params = update_customer_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/customers/{customer_external_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/events_api.py` & `getopenpay-0.0.2/getopenpay/api/events_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,67 +7,58 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.event_external import EventExternal
 from getopenpay.models.event_search_params import EventSearchParams
 from getopenpay.models.events_query_params import EventsQueryParams
 from getopenpay.models.list_response_event_external import ListResponseEventExternal
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import StrictStr
 
 
 class EventsApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def get_event(
-        self,
-        event_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> EventExternal:
-        """Get Event
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def get_event(
+    self,
+    event_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> EventExternal:
+    """Get Event
 
 
         :param event_id: (required)
         :type event_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -86,56 +77,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_event_serialize(
-            event_id=event_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "EventExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_event_with_http_info(
-        self,
-        event_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[EventExternal]:
-        """Get Event
+    _param = self._get_event_serialize(
+      event_id=event_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'EventExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_event_with_http_info(
+    self,
+    event_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[EventExternal]:
+    """Get Event
 
 
         :param event_id: (required)
         :type event_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -154,56 +135,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_event_serialize(
-            event_id=event_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "EventExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_event_without_preload_content(
-        self,
-        event_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Event
+    _param = self._get_event_serialize(
+      event_id=event_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'EventExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_event_without_preload_content(
+    self,
+    event_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Event
 
 
         :param event_id: (required)
         :type event_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -222,114 +193,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_event_serialize(
-            event_id=event_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "EventExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_event_serialize(
-        self,
-        event_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if event_id is not None:
-            _path_params['event_id'] = event_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/events/{event_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_events(
-        self,
-        events_query_params: EventsQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseEventExternal:
-        """List Events
+    _param = self._get_event_serialize(
+      event_id=event_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'EventExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_event_serialize(
+    self,
+    event_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if event_id is not None:
+      _path_params['event_id'] = event_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/events/{event_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_events(
+    self,
+    events_query_params: EventsQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseEventExternal:
+    """List Events
 
 
         :param events_query_params: (required)
         :type events_query_params: EventsQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -348,56 +296,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_events_serialize(
-            events_query_params=events_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseEventExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_events_with_http_info(
-        self,
-        events_query_params: EventsQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseEventExternal]:
-        """List Events
+    _param = self._list_events_serialize(
+      events_query_params=events_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseEventExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_events_with_http_info(
+    self,
+    events_query_params: EventsQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseEventExternal]:
+    """List Events
 
 
         :param events_query_params: (required)
         :type events_query_params: EventsQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -416,56 +354,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_events_serialize(
-            events_query_params=events_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseEventExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_events_without_preload_content(
-        self,
-        events_query_params: EventsQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Events
+    _param = self._list_events_serialize(
+      events_query_params=events_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseEventExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_events_without_preload_content(
+    self,
+    events_query_params: EventsQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Events
 
 
         :param events_query_params: (required)
         :type events_query_params: EventsQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -484,127 +412,99 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_events_serialize(
-            events_query_params=events_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseEventExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_events_serialize(
-        self,
-        events_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if events_query_params is not None:
-            _body_params = events_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/events/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def search_events(
-        self,
-        event_search_params: EventSearchParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseEventExternal:
-        """Search Events
+    _param = self._list_events_serialize(
+      events_query_params=events_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseEventExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_events_serialize(
+    self,
+    events_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if events_query_params is not None:
+      _body_params = events_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/events/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def search_events(
+    self,
+    event_search_params: EventSearchParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseEventExternal:
+    """Search Events
 
 
         :param event_search_params: (required)
         :type event_search_params: EventSearchParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -623,56 +523,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_events_serialize(
-            event_search_params=event_search_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseEventExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def search_events_with_http_info(
-        self,
-        event_search_params: EventSearchParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseEventExternal]:
-        """Search Events
+    _param = self._search_events_serialize(
+      event_search_params=event_search_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseEventExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def search_events_with_http_info(
+    self,
+    event_search_params: EventSearchParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseEventExternal]:
+    """Search Events
 
 
         :param event_search_params: (required)
         :type event_search_params: EventSearchParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -691,56 +581,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_events_serialize(
-            event_search_params=event_search_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseEventExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def search_events_without_preload_content(
-        self,
-        event_search_params: EventSearchParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Search Events
+    _param = self._search_events_serialize(
+      event_search_params=event_search_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseEventExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def search_events_without_preload_content(
+    self,
+    event_search_params: EventSearchParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Search Events
 
 
         :param event_search_params: (required)
         :type event_search_params: EventSearchParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -759,100 +639,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_events_serialize(
-            event_search_params=event_search_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseEventExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _search_events_serialize(
-        self,
-        event_search_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if event_search_params is not None:
-            _body_params = event_search_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/events/search',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._search_events_serialize(
+      event_search_params=event_search_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseEventExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _search_events_serialize(
+    self,
+    event_search_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if event_search_params is not None:
+      _body_params = event_search_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/events/search',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/invoice_items_api.py` & `getopenpay-0.0.2/getopenpay/api/invoice_items_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,69 +7,60 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.delete_invoice_item_response import DeleteInvoiceItemResponse
 from getopenpay.models.invoice_item_external import InvoiceItemExternal
 from getopenpay.models.invoice_items_query_params import InvoiceItemsQueryParams
 from getopenpay.models.list_response_invoice_item_external import ListResponseInvoiceItemExternal
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class InvoiceItemsApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def delete_invoice_item_by_id(
-        self,
-        invoice_item_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice_item.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> DeleteInvoiceItemResponse:
-        """Delete Invoice Item By Id
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def delete_invoice_item_by_id(
+    self,
+    invoice_item_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the invoice_item.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> DeleteInvoiceItemResponse:
+    """Delete Invoice Item By Id
 
 
         :param invoice_item_id: Unique identifier of the invoice_item. (required)
         :type invoice_item_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -88,56 +79,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_invoice_item_by_id_serialize(
-            invoice_item_id=invoice_item_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeleteInvoiceItemResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def delete_invoice_item_by_id_with_http_info(
-        self,
-        invoice_item_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice_item.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[DeleteInvoiceItemResponse]:
-        """Delete Invoice Item By Id
+    _param = self._delete_invoice_item_by_id_serialize(
+      invoice_item_id=invoice_item_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeleteInvoiceItemResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def delete_invoice_item_by_id_with_http_info(
+    self,
+    invoice_item_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the invoice_item.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[DeleteInvoiceItemResponse]:
+    """Delete Invoice Item By Id
 
 
         :param invoice_item_id: Unique identifier of the invoice_item. (required)
         :type invoice_item_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -156,56 +138,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_invoice_item_by_id_serialize(
-            invoice_item_id=invoice_item_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeleteInvoiceItemResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def delete_invoice_item_by_id_without_preload_content(
-        self,
-        invoice_item_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice_item.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Delete Invoice Item By Id
+    _param = self._delete_invoice_item_by_id_serialize(
+      invoice_item_id=invoice_item_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeleteInvoiceItemResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def delete_invoice_item_by_id_without_preload_content(
+    self,
+    invoice_item_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the invoice_item.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Delete Invoice Item By Id
 
 
         :param invoice_item_id: Unique identifier of the invoice_item. (required)
         :type invoice_item_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -224,114 +197,92 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_invoice_item_by_id_serialize(
-            invoice_item_id=invoice_item_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeleteInvoiceItemResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _delete_invoice_item_by_id_serialize(
-        self,
-        invoice_item_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if invoice_item_id is not None:
-            _path_params['invoice_item_id'] = invoice_item_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/invoice-items/{invoice_item_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_invoice_item(
-        self,
-        invoice_item_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice_item.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> InvoiceItemExternal:
-        """Get Invoice Item
+    _param = self._delete_invoice_item_by_id_serialize(
+      invoice_item_id=invoice_item_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeleteInvoiceItemResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _delete_invoice_item_by_id_serialize(
+    self,
+    invoice_item_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if invoice_item_id is not None:
+      _path_params['invoice_item_id'] = invoice_item_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='DELETE',
+      resource_path='/invoice-items/{invoice_item_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_invoice_item(
+    self,
+    invoice_item_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the invoice_item.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> InvoiceItemExternal:
+    """Get Invoice Item
 
 
         :param invoice_item_id: Unique identifier of the invoice_item. (required)
         :type invoice_item_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -350,56 +301,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_invoice_item_serialize(
-            invoice_item_id=invoice_item_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_invoice_item_with_http_info(
-        self,
-        invoice_item_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice_item.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[InvoiceItemExternal]:
-        """Get Invoice Item
+    _param = self._get_invoice_item_serialize(
+      invoice_item_id=invoice_item_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_invoice_item_with_http_info(
+    self,
+    invoice_item_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the invoice_item.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[InvoiceItemExternal]:
+    """Get Invoice Item
 
 
         :param invoice_item_id: Unique identifier of the invoice_item. (required)
         :type invoice_item_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -418,56 +360,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_invoice_item_serialize(
-            invoice_item_id=invoice_item_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_invoice_item_without_preload_content(
-        self,
-        invoice_item_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice_item.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Invoice Item
+    _param = self._get_invoice_item_serialize(
+      invoice_item_id=invoice_item_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_invoice_item_without_preload_content(
+    self,
+    invoice_item_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the invoice_item.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Invoice Item
 
 
         :param invoice_item_id: Unique identifier of the invoice_item. (required)
         :type invoice_item_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -486,114 +419,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_invoice_item_serialize(
-            invoice_item_id=invoice_item_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_invoice_item_serialize(
-        self,
-        invoice_item_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if invoice_item_id is not None:
-            _path_params['invoice_item_id'] = invoice_item_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/invoice-items/{invoice_item_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_invoice_items(
-        self,
-        invoice_items_query_params: InvoiceItemsQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseInvoiceItemExternal:
-        """List Invoice Items
+    _param = self._get_invoice_item_serialize(
+      invoice_item_id=invoice_item_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_invoice_item_serialize(
+    self,
+    invoice_item_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if invoice_item_id is not None:
+      _path_params['invoice_item_id'] = invoice_item_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/invoice-items/{invoice_item_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_invoice_items(
+    self,
+    invoice_items_query_params: InvoiceItemsQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseInvoiceItemExternal:
+    """List Invoice Items
 
 
         :param invoice_items_query_params: (required)
         :type invoice_items_query_params: InvoiceItemsQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -612,56 +522,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_invoice_items_serialize(
-            invoice_items_query_params=invoice_items_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseInvoiceItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_invoice_items_with_http_info(
-        self,
-        invoice_items_query_params: InvoiceItemsQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseInvoiceItemExternal]:
-        """List Invoice Items
+    _param = self._list_invoice_items_serialize(
+      invoice_items_query_params=invoice_items_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseInvoiceItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_invoice_items_with_http_info(
+    self,
+    invoice_items_query_params: InvoiceItemsQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseInvoiceItemExternal]:
+    """List Invoice Items
 
 
         :param invoice_items_query_params: (required)
         :type invoice_items_query_params: InvoiceItemsQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -680,56 +580,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_invoice_items_serialize(
-            invoice_items_query_params=invoice_items_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseInvoiceItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_invoice_items_without_preload_content(
-        self,
-        invoice_items_query_params: InvoiceItemsQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Invoice Items
+    _param = self._list_invoice_items_serialize(
+      invoice_items_query_params=invoice_items_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseInvoiceItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_invoice_items_without_preload_content(
+    self,
+    invoice_items_query_params: InvoiceItemsQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Invoice Items
 
 
         :param invoice_items_query_params: (required)
         :type invoice_items_query_params: InvoiceItemsQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -748,100 +638,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_invoice_items_serialize(
-            invoice_items_query_params=invoice_items_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseInvoiceItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_invoice_items_serialize(
-        self,
-        invoice_items_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if invoice_items_query_params is not None:
-            _body_params = invoice_items_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/invoice-items/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._list_invoice_items_serialize(
+      invoice_items_query_params=invoice_items_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseInvoiceItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_invoice_items_serialize(
+    self,
+    invoice_items_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if invoice_items_query_params is not None:
+      _body_params = invoice_items_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/invoice-items/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/invoices_api.py` & `getopenpay-0.0.2/getopenpay/api/invoices_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,73 +7,63 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_invoice_request import CreateInvoiceRequest
 from getopenpay.models.invoice_external import InvoiceExternal
 from getopenpay.models.invoice_public import InvoicePublic
 from getopenpay.models.invoice_query_params import InvoiceQueryParams
 from getopenpay.models.list_response_invoice_external import ListResponseInvoiceExternal
 from getopenpay.models.pay_invoice_request import PayInvoiceRequest
 from getopenpay.models.search_invoice_request import SearchInvoiceRequest
 from getopenpay.models.update_invoice_request import UpdateInvoiceRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class InvoicesApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_invoice(
-        self,
-        create_invoice_request: CreateInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> InvoiceExternal:
-        """Create Invoice
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_invoice(
+    self,
+    create_invoice_request: CreateInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> InvoiceExternal:
+    """Create Invoice
 
         This endpoint creates a draft invoice for a given subscription. The invoice remains a draft until you finalize the invoice. The created invoice will only include floating invoice items for a subscription. The subscriptions billing cycle and regular subscription events wont be affected.
 
         :param create_invoice_request: (required)
         :type create_invoice_request: CreateInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -93,56 +83,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_invoice_serialize(
-            create_invoice_request=create_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_invoice_with_http_info(
-        self,
-        create_invoice_request: CreateInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[InvoiceExternal]:
-        """Create Invoice
+    _param = self._create_invoice_serialize(
+      create_invoice_request=create_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_invoice_with_http_info(
+    self,
+    create_invoice_request: CreateInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[InvoiceExternal]:
+    """Create Invoice
 
         This endpoint creates a draft invoice for a given subscription. The invoice remains a draft until you finalize the invoice. The created invoice will only include floating invoice items for a subscription. The subscriptions billing cycle and regular subscription events wont be affected.
 
         :param create_invoice_request: (required)
         :type create_invoice_request: CreateInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -162,56 +142,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_invoice_serialize(
-            create_invoice_request=create_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_invoice_without_preload_content(
-        self,
-        create_invoice_request: CreateInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Invoice
+    _param = self._create_invoice_serialize(
+      create_invoice_request=create_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_invoice_without_preload_content(
+    self,
+    create_invoice_request: CreateInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Invoice
 
         This endpoint creates a draft invoice for a given subscription. The invoice remains a draft until you finalize the invoice. The created invoice will only include floating invoice items for a subscription. The subscriptions billing cycle and regular subscription events wont be affected.
 
         :param create_invoice_request: (required)
         :type create_invoice_request: CreateInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -231,127 +201,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_invoice_serialize(
-            create_invoice_request=create_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_invoice_serialize(
-        self,
-        create_invoice_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_invoice_request is not None:
-            _body_params = create_invoice_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/invoices/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def finalize_invoice(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> InvoiceExternal:
-        """Finalize Invoice
+    _param = self._create_invoice_serialize(
+      create_invoice_request=create_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_invoice_serialize(
+    self,
+    create_invoice_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_invoice_request is not None:
+      _body_params = create_invoice_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/invoices/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def finalize_invoice(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> InvoiceExternal:
+    """Finalize Invoice
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -370,56 +313,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._finalize_invoice_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def finalize_invoice_with_http_info(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[InvoiceExternal]:
-        """Finalize Invoice
+    _param = self._finalize_invoice_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def finalize_invoice_with_http_info(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[InvoiceExternal]:
+    """Finalize Invoice
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -438,56 +372,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._finalize_invoice_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def finalize_invoice_without_preload_content(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Finalize Invoice
+    _param = self._finalize_invoice_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def finalize_invoice_without_preload_content(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Finalize Invoice
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -506,114 +431,92 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._finalize_invoice_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _finalize_invoice_serialize(
-        self,
-        invoice_external_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if invoice_external_id is not None:
-            _path_params['invoice_external_id'] = invoice_external_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/invoices/{invoice_external_id}/finalize',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_invoice(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> InvoiceExternal:
-        """Get Invoice
+    _param = self._finalize_invoice_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _finalize_invoice_serialize(
+    self,
+    invoice_external_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if invoice_external_id is not None:
+      _path_params['invoice_external_id'] = invoice_external_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/invoices/{invoice_external_id}/finalize',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_invoice(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> InvoiceExternal:
+    """Get Invoice
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -632,56 +535,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_invoice_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_invoice_with_http_info(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[InvoiceExternal]:
-        """Get Invoice
+    _param = self._get_invoice_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_invoice_with_http_info(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[InvoiceExternal]:
+    """Get Invoice
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -700,56 +594,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_invoice_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_invoice_without_preload_content(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Invoice
+    _param = self._get_invoice_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_invoice_without_preload_content(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Invoice
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -768,114 +653,92 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_invoice_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_invoice_serialize(
-        self,
-        invoice_external_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if invoice_external_id is not None:
-            _path_params['invoice_external_id'] = invoice_external_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/invoices/{invoice_external_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_invoice_public(
-        self,
-        public_permanent_token: Annotated[StrictStr, Field(description="Public token for the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> InvoicePublic:
-        """Get Invoice Public
+    _param = self._get_invoice_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_invoice_serialize(
+    self,
+    invoice_external_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if invoice_external_id is not None:
+      _path_params['invoice_external_id'] = invoice_external_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/invoices/{invoice_external_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_invoice_public(
+    self,
+    public_permanent_token: Annotated[StrictStr,
+                                      Field(description='Public token for the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> InvoicePublic:
+    """Get Invoice Public
 
 
         :param public_permanent_token: Public token for the invoice. (required)
         :type public_permanent_token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -894,56 +757,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_invoice_public_serialize(
-            public_permanent_token=public_permanent_token,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoicePublic",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_invoice_public_with_http_info(
-        self,
-        public_permanent_token: Annotated[StrictStr, Field(description="Public token for the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[InvoicePublic]:
-        """Get Invoice Public
+    _param = self._get_invoice_public_serialize(
+      public_permanent_token=public_permanent_token,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoicePublic',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_invoice_public_with_http_info(
+    self,
+    public_permanent_token: Annotated[StrictStr,
+                                      Field(description='Public token for the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[InvoicePublic]:
+    """Get Invoice Public
 
 
         :param public_permanent_token: Public token for the invoice. (required)
         :type public_permanent_token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -962,56 +816,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_invoice_public_serialize(
-            public_permanent_token=public_permanent_token,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoicePublic",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_invoice_public_without_preload_content(
-        self,
-        public_permanent_token: Annotated[StrictStr, Field(description="Public token for the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Invoice Public
+    _param = self._get_invoice_public_serialize(
+      public_permanent_token=public_permanent_token,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoicePublic',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_invoice_public_without_preload_content(
+    self,
+    public_permanent_token: Annotated[StrictStr,
+                                      Field(description='Public token for the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Invoice Public
 
 
         :param public_permanent_token: Public token for the invoice. (required)
         :type public_permanent_token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1030,113 +875,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_invoice_public_serialize(
-            public_permanent_token=public_permanent_token,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoicePublic",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_invoice_public_serialize(
-        self,
-        public_permanent_token,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if public_permanent_token is not None:
-            _path_params['public_permanent_token'] = public_permanent_token
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/invoices/public/{public_permanent_token}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_invoices(
-        self,
-        invoice_query_params: InvoiceQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseInvoiceExternal:
-        """List Invoices
+    _param = self._get_invoice_public_serialize(
+      public_permanent_token=public_permanent_token,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoicePublic',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_invoice_public_serialize(
+    self,
+    public_permanent_token,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if public_permanent_token is not None:
+      _path_params['public_permanent_token'] = public_permanent_token
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = []
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/invoices/public/{public_permanent_token}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_invoices(
+    self,
+    invoice_query_params: InvoiceQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseInvoiceExternal:
+    """List Invoices
 
 
         :param invoice_query_params: (required)
         :type invoice_query_params: InvoiceQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1155,56 +978,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_invoices_serialize(
-            invoice_query_params=invoice_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseInvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_invoices_with_http_info(
-        self,
-        invoice_query_params: InvoiceQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseInvoiceExternal]:
-        """List Invoices
+    _param = self._list_invoices_serialize(
+      invoice_query_params=invoice_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseInvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_invoices_with_http_info(
+    self,
+    invoice_query_params: InvoiceQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseInvoiceExternal]:
+    """List Invoices
 
 
         :param invoice_query_params: (required)
         :type invoice_query_params: InvoiceQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1223,56 +1036,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_invoices_serialize(
-            invoice_query_params=invoice_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseInvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_invoices_without_preload_content(
-        self,
-        invoice_query_params: InvoiceQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Invoices
+    _param = self._list_invoices_serialize(
+      invoice_query_params=invoice_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseInvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_invoices_without_preload_content(
+    self,
+    invoice_query_params: InvoiceQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Invoices
 
 
         :param invoice_query_params: (required)
         :type invoice_query_params: InvoiceQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1291,127 +1094,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_invoices_serialize(
-            invoice_query_params=invoice_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseInvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_invoices_serialize(
-        self,
-        invoice_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if invoice_query_params is not None:
-            _body_params = invoice_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/invoices/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def mark_invoice_as_uncollectible(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> InvoiceExternal:
-        """Mark Invoice As Uncollectible
+    _param = self._list_invoices_serialize(
+      invoice_query_params=invoice_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseInvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_invoices_serialize(
+    self,
+    invoice_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if invoice_query_params is not None:
+      _body_params = invoice_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/invoices/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def mark_invoice_as_uncollectible(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> InvoiceExternal:
+    """Mark Invoice As Uncollectible
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1430,56 +1206,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._mark_invoice_as_uncollectible_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def mark_invoice_as_uncollectible_with_http_info(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[InvoiceExternal]:
-        """Mark Invoice As Uncollectible
+    _param = self._mark_invoice_as_uncollectible_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def mark_invoice_as_uncollectible_with_http_info(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[InvoiceExternal]:
+    """Mark Invoice As Uncollectible
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1498,56 +1265,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._mark_invoice_as_uncollectible_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def mark_invoice_as_uncollectible_without_preload_content(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Mark Invoice As Uncollectible
+    _param = self._mark_invoice_as_uncollectible_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def mark_invoice_as_uncollectible_without_preload_content(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Mark Invoice As Uncollectible
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1566,114 +1324,92 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._mark_invoice_as_uncollectible_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _mark_invoice_as_uncollectible_serialize(
-        self,
-        invoice_external_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if invoice_external_id is not None:
-            _path_params['invoice_external_id'] = invoice_external_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/invoices/{invoice_external_id}/mark_uncollectible',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def mark_invoice_as_void(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> InvoiceExternal:
-        """Mark Invoice As Void
+    _param = self._mark_invoice_as_uncollectible_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _mark_invoice_as_uncollectible_serialize(
+    self,
+    invoice_external_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if invoice_external_id is not None:
+      _path_params['invoice_external_id'] = invoice_external_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/invoices/{invoice_external_id}/mark_uncollectible',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def mark_invoice_as_void(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> InvoiceExternal:
+    """Mark Invoice As Void
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1692,56 +1428,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._mark_invoice_as_void_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def mark_invoice_as_void_with_http_info(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[InvoiceExternal]:
-        """Mark Invoice As Void
+    _param = self._mark_invoice_as_void_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def mark_invoice_as_void_with_http_info(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[InvoiceExternal]:
+    """Mark Invoice As Void
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1760,56 +1487,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._mark_invoice_as_void_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def mark_invoice_as_void_without_preload_content(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Mark Invoice As Void
+    _param = self._mark_invoice_as_void_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def mark_invoice_as_void_without_preload_content(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Mark Invoice As Void
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1828,115 +1546,93 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._mark_invoice_as_void_serialize(
-            invoice_external_id=invoice_external_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _mark_invoice_as_void_serialize(
-        self,
-        invoice_external_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if invoice_external_id is not None:
-            _path_params['invoice_external_id'] = invoice_external_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/invoices/{invoice_external_id}/void',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def pay_invoice(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        pay_invoice_request: PayInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> InvoiceExternal:
-        """Pay Invoice
+    _param = self._mark_invoice_as_void_serialize(
+      invoice_external_id=invoice_external_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _mark_invoice_as_void_serialize(
+    self,
+    invoice_external_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if invoice_external_id is not None:
+      _path_params['invoice_external_id'] = invoice_external_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/invoices/{invoice_external_id}/void',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def pay_invoice(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    pay_invoice_request: PayInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> InvoiceExternal:
+    """Pay Invoice
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param pay_invoice_request: (required)
         :type pay_invoice_request: PayInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1957,58 +1653,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._pay_invoice_serialize(
-            invoice_external_id=invoice_external_id,
-            pay_invoice_request=pay_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def pay_invoice_with_http_info(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        pay_invoice_request: PayInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[InvoiceExternal]:
-        """Pay Invoice
+    _param = self._pay_invoice_serialize(
+      invoice_external_id=invoice_external_id,
+      pay_invoice_request=pay_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def pay_invoice_with_http_info(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    pay_invoice_request: PayInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[InvoiceExternal]:
+    """Pay Invoice
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param pay_invoice_request: (required)
         :type pay_invoice_request: PayInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2029,58 +1716,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._pay_invoice_serialize(
-            invoice_external_id=invoice_external_id,
-            pay_invoice_request=pay_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def pay_invoice_without_preload_content(
-        self,
-        invoice_external_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        pay_invoice_request: PayInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Pay Invoice
+    _param = self._pay_invoice_serialize(
+      invoice_external_id=invoice_external_id,
+      pay_invoice_request=pay_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def pay_invoice_without_preload_content(
+    self,
+    invoice_external_id: Annotated[StrictStr,
+                                   Field(description='Unique identifier of the invoice.')],
+    pay_invoice_request: PayInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Pay Invoice
 
 
         :param invoice_external_id: Unique identifier of the invoice. (required)
         :type invoice_external_id: str
         :param pay_invoice_request: (required)
         :type pay_invoice_request: PayInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2101,131 +1779,103 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._pay_invoice_serialize(
-            invoice_external_id=invoice_external_id,
-            pay_invoice_request=pay_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _pay_invoice_serialize(
-        self,
-        invoice_external_id,
-        pay_invoice_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if invoice_external_id is not None:
-            _path_params['invoice_external_id'] = invoice_external_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if pay_invoice_request is not None:
-            _body_params = pay_invoice_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/invoices/{invoice_external_id}/pay',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def search_invoices(
-        self,
-        search_invoice_request: SearchInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseInvoiceExternal:
-        """Search Invoices
+    _param = self._pay_invoice_serialize(
+      invoice_external_id=invoice_external_id,
+      pay_invoice_request=pay_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _pay_invoice_serialize(
+    self,
+    invoice_external_id,
+    pay_invoice_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if invoice_external_id is not None:
+      _path_params['invoice_external_id'] = invoice_external_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if pay_invoice_request is not None:
+      _body_params = pay_invoice_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/invoices/{invoice_external_id}/pay',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def search_invoices(
+    self,
+    search_invoice_request: SearchInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseInvoiceExternal:
+    """Search Invoices
 
 
         :param search_invoice_request: (required)
         :type search_invoice_request: SearchInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2244,56 +1894,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_invoices_serialize(
-            search_invoice_request=search_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseInvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def search_invoices_with_http_info(
-        self,
-        search_invoice_request: SearchInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseInvoiceExternal]:
-        """Search Invoices
+    _param = self._search_invoices_serialize(
+      search_invoice_request=search_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseInvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def search_invoices_with_http_info(
+    self,
+    search_invoice_request: SearchInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseInvoiceExternal]:
+    """Search Invoices
 
 
         :param search_invoice_request: (required)
         :type search_invoice_request: SearchInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2312,56 +1952,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_invoices_serialize(
-            search_invoice_request=search_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseInvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def search_invoices_without_preload_content(
-        self,
-        search_invoice_request: SearchInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Search Invoices
+    _param = self._search_invoices_serialize(
+      search_invoice_request=search_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseInvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def search_invoices_without_preload_content(
+    self,
+    search_invoice_request: SearchInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Search Invoices
 
 
         :param search_invoice_request: (required)
         :type search_invoice_request: SearchInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2380,128 +2010,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_invoices_serialize(
-            search_invoice_request=search_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseInvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _search_invoices_serialize(
-        self,
-        search_invoice_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if search_invoice_request is not None:
-            _body_params = search_invoice_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/invoices/search',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def update_invoice(
-        self,
-        invoice_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        update_invoice_request: UpdateInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> InvoiceExternal:
-        """Update Invoice
+    _param = self._search_invoices_serialize(
+      search_invoice_request=search_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseInvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _search_invoices_serialize(
+    self,
+    search_invoice_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if search_invoice_request is not None:
+      _body_params = search_invoice_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/invoices/search',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def update_invoice(
+    self,
+    invoice_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the invoice.')],
+    update_invoice_request: UpdateInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> InvoiceExternal:
+    """Update Invoice
 
 
         :param invoice_id: Unique identifier of the invoice. (required)
         :type invoice_id: str
         :param update_invoice_request: (required)
         :type update_invoice_request: UpdateInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2522,58 +2125,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_invoice_serialize(
-            invoice_id=invoice_id,
-            update_invoice_request=update_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def update_invoice_with_http_info(
-        self,
-        invoice_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        update_invoice_request: UpdateInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[InvoiceExternal]:
-        """Update Invoice
+    _param = self._update_invoice_serialize(
+      invoice_id=invoice_id,
+      update_invoice_request=update_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def update_invoice_with_http_info(
+    self,
+    invoice_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the invoice.')],
+    update_invoice_request: UpdateInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[InvoiceExternal]:
+    """Update Invoice
 
 
         :param invoice_id: Unique identifier of the invoice. (required)
         :type invoice_id: str
         :param update_invoice_request: (required)
         :type update_invoice_request: UpdateInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2594,58 +2188,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_invoice_serialize(
-            invoice_id=invoice_id,
-            update_invoice_request=update_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def update_invoice_without_preload_content(
-        self,
-        invoice_id: Annotated[StrictStr, Field(description="Unique identifier of the invoice.")],
-        update_invoice_request: UpdateInvoiceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Update Invoice
+    _param = self._update_invoice_serialize(
+      invoice_id=invoice_id,
+      update_invoice_request=update_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def update_invoice_without_preload_content(
+    self,
+    invoice_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the invoice.')],
+    update_invoice_request: UpdateInvoiceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Update Invoice
 
 
         :param invoice_id: Unique identifier of the invoice. (required)
         :type invoice_id: str
         :param update_invoice_request: (required)
         :type update_invoice_request: UpdateInvoiceRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2666,104 +2251,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_invoice_serialize(
-            invoice_id=invoice_id,
-            update_invoice_request=update_invoice_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "InvoiceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _update_invoice_serialize(
-        self,
-        invoice_id,
-        update_invoice_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if invoice_id is not None:
-            _path_params['invoice_id'] = invoice_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if update_invoice_request is not None:
-            _body_params = update_invoice_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/invoices/{invoice_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._update_invoice_serialize(
+      invoice_id=invoice_id,
+      update_invoice_request=update_invoice_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'InvoiceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _update_invoice_serialize(
+    self,
+    invoice_id,
+    update_invoice_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if invoice_id is not None:
+      _path_params['invoice_id'] = invoice_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if update_invoice_request is not None:
+      _body_params = update_invoice_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/invoices/{invoice_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/payment_intents_api.py` & `getopenpay-0.0.2/getopenpay/api/payment_intents_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,67 +7,60 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
-from getopenpay.models.list_response_payment_intent_external import ListResponsePaymentIntentExternal
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
+from getopenpay.models.list_response_payment_intent_external import (
+  ListResponsePaymentIntentExternal
+)
 from getopenpay.models.payment_intent_external import PaymentIntentExternal
 from getopenpay.models.payment_intent_query_params import PaymentIntentQueryParams
 from getopenpay.models.search_payment_intent_request import SearchPaymentIntentRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import StrictStr
 
 
 class PaymentIntentsApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def get_payment_intent(
-        self,
-        payment_intent_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PaymentIntentExternal:
-        """Get Payment Intent
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def get_payment_intent(
+    self,
+    payment_intent_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PaymentIntentExternal:
+    """Get Payment Intent
 
 
         :param payment_intent_id: (required)
         :type payment_intent_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -86,56 +79,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_payment_intent_serialize(
-            payment_intent_id=payment_intent_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentIntentExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_payment_intent_with_http_info(
-        self,
-        payment_intent_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PaymentIntentExternal]:
-        """Get Payment Intent
+    _param = self._get_payment_intent_serialize(
+      payment_intent_id=payment_intent_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentIntentExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_payment_intent_with_http_info(
+    self,
+    payment_intent_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PaymentIntentExternal]:
+    """Get Payment Intent
 
 
         :param payment_intent_id: (required)
         :type payment_intent_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -154,56 +137,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_payment_intent_serialize(
-            payment_intent_id=payment_intent_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentIntentExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_payment_intent_without_preload_content(
-        self,
-        payment_intent_id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Payment Intent
+    _param = self._get_payment_intent_serialize(
+      payment_intent_id=payment_intent_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentIntentExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_payment_intent_without_preload_content(
+    self,
+    payment_intent_id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Payment Intent
 
 
         :param payment_intent_id: (required)
         :type payment_intent_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -222,114 +195,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_payment_intent_serialize(
-            payment_intent_id=payment_intent_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentIntentExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_payment_intent_serialize(
-        self,
-        payment_intent_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if payment_intent_id is not None:
-            _path_params['payment_intent_id'] = payment_intent_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/payment-intents/{payment_intent_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_payment_intents(
-        self,
-        payment_intent_query_params: PaymentIntentQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponsePaymentIntentExternal:
-        """List Payment Intents
+    _param = self._get_payment_intent_serialize(
+      payment_intent_id=payment_intent_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentIntentExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_payment_intent_serialize(
+    self,
+    payment_intent_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if payment_intent_id is not None:
+      _path_params['payment_intent_id'] = payment_intent_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/payment-intents/{payment_intent_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_payment_intents(
+    self,
+    payment_intent_query_params: PaymentIntentQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponsePaymentIntentExternal:
+    """List Payment Intents
 
 
         :param payment_intent_query_params: (required)
         :type payment_intent_query_params: PaymentIntentQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -348,56 +298,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_payment_intents_serialize(
-            payment_intent_query_params=payment_intent_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentIntentExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_payment_intents_with_http_info(
-        self,
-        payment_intent_query_params: PaymentIntentQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponsePaymentIntentExternal]:
-        """List Payment Intents
+    _param = self._list_payment_intents_serialize(
+      payment_intent_query_params=payment_intent_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentIntentExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_payment_intents_with_http_info(
+    self,
+    payment_intent_query_params: PaymentIntentQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponsePaymentIntentExternal]:
+    """List Payment Intents
 
 
         :param payment_intent_query_params: (required)
         :type payment_intent_query_params: PaymentIntentQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -416,56 +356,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_payment_intents_serialize(
-            payment_intent_query_params=payment_intent_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentIntentExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_payment_intents_without_preload_content(
-        self,
-        payment_intent_query_params: PaymentIntentQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Payment Intents
+    _param = self._list_payment_intents_serialize(
+      payment_intent_query_params=payment_intent_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentIntentExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_payment_intents_without_preload_content(
+    self,
+    payment_intent_query_params: PaymentIntentQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Payment Intents
 
 
         :param payment_intent_query_params: (required)
         :type payment_intent_query_params: PaymentIntentQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -484,127 +414,99 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_payment_intents_serialize(
-            payment_intent_query_params=payment_intent_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentIntentExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_payment_intents_serialize(
-        self,
-        payment_intent_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if payment_intent_query_params is not None:
-            _body_params = payment_intent_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/payment-intents/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def search_payment_intents(
-        self,
-        search_payment_intent_request: SearchPaymentIntentRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponsePaymentIntentExternal:
-        """Search Payment Intents
+    _param = self._list_payment_intents_serialize(
+      payment_intent_query_params=payment_intent_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentIntentExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_payment_intents_serialize(
+    self,
+    payment_intent_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if payment_intent_query_params is not None:
+      _body_params = payment_intent_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/payment-intents/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def search_payment_intents(
+    self,
+    search_payment_intent_request: SearchPaymentIntentRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponsePaymentIntentExternal:
+    """Search Payment Intents
 
 
         :param search_payment_intent_request: (required)
         :type search_payment_intent_request: SearchPaymentIntentRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -623,56 +525,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_payment_intents_serialize(
-            search_payment_intent_request=search_payment_intent_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentIntentExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def search_payment_intents_with_http_info(
-        self,
-        search_payment_intent_request: SearchPaymentIntentRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponsePaymentIntentExternal]:
-        """Search Payment Intents
+    _param = self._search_payment_intents_serialize(
+      search_payment_intent_request=search_payment_intent_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentIntentExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def search_payment_intents_with_http_info(
+    self,
+    search_payment_intent_request: SearchPaymentIntentRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponsePaymentIntentExternal]:
+    """Search Payment Intents
 
 
         :param search_payment_intent_request: (required)
         :type search_payment_intent_request: SearchPaymentIntentRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -691,56 +583,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_payment_intents_serialize(
-            search_payment_intent_request=search_payment_intent_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentIntentExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def search_payment_intents_without_preload_content(
-        self,
-        search_payment_intent_request: SearchPaymentIntentRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Search Payment Intents
+    _param = self._search_payment_intents_serialize(
+      search_payment_intent_request=search_payment_intent_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentIntentExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def search_payment_intents_without_preload_content(
+    self,
+    search_payment_intent_request: SearchPaymentIntentRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Search Payment Intents
 
 
         :param search_payment_intent_request: (required)
         :type search_payment_intent_request: SearchPaymentIntentRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -759,100 +641,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_payment_intents_serialize(
-            search_payment_intent_request=search_payment_intent_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentIntentExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _search_payment_intents_serialize(
-        self,
-        search_payment_intent_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if search_payment_intent_request is not None:
-            _body_params = search_payment_intent_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/payment-intents/search',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._search_payment_intents_serialize(
+      search_payment_intent_request=search_payment_intent_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentIntentExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _search_payment_intents_serialize(
+    self,
+    search_payment_intent_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if search_payment_intent_request is not None:
+      _body_params = search_payment_intent_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/payment-intents/search',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/payment_links_api.py` & `getopenpay-0.0.2/getopenpay/api/payment_links_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,69 +7,59 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_payment_link_request import CreatePaymentLinkRequest
 from getopenpay.models.list_response_payment_link_external import ListResponsePaymentLinkExternal
 from getopenpay.models.payment_link_external import PaymentLinkExternal
 from getopenpay.models.payment_link_query_params import PaymentLinkQueryParams
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class PaymentLinksApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_payment_link(
-        self,
-        create_payment_link_request: CreatePaymentLinkRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PaymentLinkExternal:
-        """Create Payment Link
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_payment_link(
+    self,
+    create_payment_link_request: CreatePaymentLinkRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PaymentLinkExternal:
+    """Create Payment Link
 
 
         :param create_payment_link_request: (required)
         :type create_payment_link_request: CreatePaymentLinkRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -88,56 +78,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_payment_link_serialize(
-            create_payment_link_request=create_payment_link_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PaymentLinkExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_payment_link_with_http_info(
-        self,
-        create_payment_link_request: CreatePaymentLinkRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PaymentLinkExternal]:
-        """Create Payment Link
+    _param = self._create_payment_link_serialize(
+      create_payment_link_request=create_payment_link_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PaymentLinkExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_payment_link_with_http_info(
+    self,
+    create_payment_link_request: CreatePaymentLinkRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PaymentLinkExternal]:
+    """Create Payment Link
 
 
         :param create_payment_link_request: (required)
         :type create_payment_link_request: CreatePaymentLinkRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -156,56 +136,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_payment_link_serialize(
-            create_payment_link_request=create_payment_link_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PaymentLinkExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_payment_link_without_preload_content(
-        self,
-        create_payment_link_request: CreatePaymentLinkRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Payment Link
+    _param = self._create_payment_link_serialize(
+      create_payment_link_request=create_payment_link_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PaymentLinkExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_payment_link_without_preload_content(
+    self,
+    create_payment_link_request: CreatePaymentLinkRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Payment Link
 
 
         :param create_payment_link_request: (required)
         :type create_payment_link_request: CreatePaymentLinkRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -224,127 +194,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_payment_link_serialize(
-            create_payment_link_request=create_payment_link_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PaymentLinkExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_payment_link_serialize(
-        self,
-        create_payment_link_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_payment_link_request is not None:
-            _body_params = create_payment_link_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/payment-link/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_payment_link(
-        self,
-        plink_id: Annotated[StrictStr, Field(description="Unique identifier of the payment link.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PaymentLinkExternal:
-        """Get Payment Link
+    _param = self._create_payment_link_serialize(
+      create_payment_link_request=create_payment_link_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PaymentLinkExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_payment_link_serialize(
+    self,
+    create_payment_link_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_payment_link_request is not None:
+      _body_params = create_payment_link_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/payment-link/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_payment_link(
+    self,
+    plink_id: Annotated[StrictStr,
+                        Field(description='Unique identifier of the payment link.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PaymentLinkExternal:
+    """Get Payment Link
 
 
         :param plink_id: Unique identifier of the payment link. (required)
         :type plink_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -363,56 +306,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_payment_link_serialize(
-            plink_id=plink_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PaymentLinkExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_payment_link_with_http_info(
-        self,
-        plink_id: Annotated[StrictStr, Field(description="Unique identifier of the payment link.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PaymentLinkExternal]:
-        """Get Payment Link
+    _param = self._get_payment_link_serialize(
+      plink_id=plink_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PaymentLinkExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_payment_link_with_http_info(
+    self,
+    plink_id: Annotated[StrictStr,
+                        Field(description='Unique identifier of the payment link.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PaymentLinkExternal]:
+    """Get Payment Link
 
 
         :param plink_id: Unique identifier of the payment link. (required)
         :type plink_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -431,56 +365,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_payment_link_serialize(
-            plink_id=plink_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PaymentLinkExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_payment_link_without_preload_content(
-        self,
-        plink_id: Annotated[StrictStr, Field(description="Unique identifier of the payment link.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Payment Link
+    _param = self._get_payment_link_serialize(
+      plink_id=plink_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PaymentLinkExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_payment_link_without_preload_content(
+    self,
+    plink_id: Annotated[StrictStr,
+                        Field(description='Unique identifier of the payment link.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Payment Link
 
 
         :param plink_id: Unique identifier of the payment link. (required)
         :type plink_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -499,114 +424,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_payment_link_serialize(
-            plink_id=plink_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PaymentLinkExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_payment_link_serialize(
-        self,
-        plink_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if plink_id is not None:
-            _path_params['plink_id'] = plink_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/payment-link/{plink_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_payment_links(
-        self,
-        payment_link_query_params: PaymentLinkQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponsePaymentLinkExternal:
-        """List Payment Links
+    _param = self._get_payment_link_serialize(
+      plink_id=plink_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PaymentLinkExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_payment_link_serialize(
+    self,
+    plink_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if plink_id is not None:
+      _path_params['plink_id'] = plink_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/payment-link/{plink_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_payment_links(
+    self,
+    payment_link_query_params: PaymentLinkQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponsePaymentLinkExternal:
+    """List Payment Links
 
 
         :param payment_link_query_params: (required)
         :type payment_link_query_params: PaymentLinkQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -625,56 +527,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_payment_links_serialize(
-            payment_link_query_params=payment_link_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentLinkExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_payment_links_with_http_info(
-        self,
-        payment_link_query_params: PaymentLinkQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponsePaymentLinkExternal]:
-        """List Payment Links
+    _param = self._list_payment_links_serialize(
+      payment_link_query_params=payment_link_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentLinkExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_payment_links_with_http_info(
+    self,
+    payment_link_query_params: PaymentLinkQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponsePaymentLinkExternal]:
+    """List Payment Links
 
 
         :param payment_link_query_params: (required)
         :type payment_link_query_params: PaymentLinkQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -693,56 +585,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_payment_links_serialize(
-            payment_link_query_params=payment_link_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentLinkExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_payment_links_without_preload_content(
-        self,
-        payment_link_query_params: PaymentLinkQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Payment Links
+    _param = self._list_payment_links_serialize(
+      payment_link_query_params=payment_link_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentLinkExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_payment_links_without_preload_content(
+    self,
+    payment_link_query_params: PaymentLinkQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Payment Links
 
 
         :param payment_link_query_params: (required)
         :type payment_link_query_params: PaymentLinkQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -761,127 +643,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_payment_links_serialize(
-            payment_link_query_params=payment_link_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePaymentLinkExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_payment_links_serialize(
-        self,
-        payment_link_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if payment_link_query_params is not None:
-            _body_params = payment_link_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/payment-link/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def open_payment_link_page_public(
-        self,
-        secure_token: Annotated[StrictStr, Field(description="Secure token of the payment link.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> None:
-        """Open Payment Link Page Public
+    _param = self._list_payment_links_serialize(
+      payment_link_query_params=payment_link_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePaymentLinkExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_payment_links_serialize(
+    self,
+    payment_link_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if payment_link_query_params is not None:
+      _body_params = payment_link_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/payment-link/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def open_payment_link_page_public(
+    self,
+    secure_token: Annotated[StrictStr,
+                            Field(description='Secure token of the payment link.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> None:
+    """Open Payment Link Page Public
 
 
         :param secure_token: Secure token of the payment link. (required)
         :type secure_token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -900,54 +755,44 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._open_payment_link_page_public_serialize(
-            secure_token=secure_token,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def open_payment_link_page_public_with_http_info(
-        self,
-        secure_token: Annotated[StrictStr, Field(description="Secure token of the payment link.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[None]:
-        """Open Payment Link Page Public
+    _param = self._open_payment_link_page_public_serialize(
+      secure_token=secure_token,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {}
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def open_payment_link_page_public_with_http_info(
+    self,
+    secure_token: Annotated[StrictStr,
+                            Field(description='Secure token of the payment link.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[None]:
+    """Open Payment Link Page Public
 
 
         :param secure_token: Secure token of the payment link. (required)
         :type secure_token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -966,54 +811,44 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._open_payment_link_page_public_serialize(
-            secure_token=secure_token,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def open_payment_link_page_public_without_preload_content(
-        self,
-        secure_token: Annotated[StrictStr, Field(description="Secure token of the payment link.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Open Payment Link Page Public
+    _param = self._open_payment_link_page_public_serialize(
+      secure_token=secure_token,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {}
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def open_payment_link_page_public_without_preload_content(
+    self,
+    secure_token: Annotated[StrictStr,
+                            Field(description='Secure token of the payment link.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Open Payment Link Page Public
 
 
         :param secure_token: Secure token of the payment link. (required)
         :type secure_token: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1032,84 +867,67 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._open_payment_link_page_public_serialize(
-            secure_token=secure_token,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _open_payment_link_page_public_serialize(
-        self,
-        secure_token,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if secure_token is not None:
-            _path_params['secure_token'] = secure_token
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/payment-link/public/{secure_token}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._open_payment_link_page_public_serialize(
+      secure_token=secure_token,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {}
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _open_payment_link_page_public_serialize(
+    self,
+    secure_token,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if secure_token is not None:
+      _path_params['secure_token'] = secure_token
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = []
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/payment-link/public/{secure_token}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/payment_methods_api.py` & `getopenpay-0.0.2/getopenpay/api/payment_methods_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,70 +7,61 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictInt, StrictStr
+  from typing_extensions import Annotated
 
 from typing import Optional
 
-from getopenpay.models.attach_payment_method_request import AttachPaymentMethodRequest
-from getopenpay.models.payment_method_external import PaymentMethodExternal
-
 from getopenpay.api_client import ApiClient
 from getopenpay.api_response import ApiResponse
+from getopenpay.models.attach_payment_method_request import AttachPaymentMethodRequest
+from getopenpay.models.payment_method_external import PaymentMethodExternal
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictInt, StrictStr
+from typing_extensions import Annotated
 
 
 class PaymentMethodsApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def attach_payment_method(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        attach_payment_method_request: AttachPaymentMethodRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PaymentMethodExternal:
-        """Attach Payment Method
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def attach_payment_method(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    attach_payment_method_request: AttachPaymentMethodRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PaymentMethodExternal:
+    """Attach Payment Method
 
         Attaches the payment_method to a customer. A Payment_method must be attached to a customer before it can be used for payment. Once attached to a customer, it can not be reattached to a different customer.
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param attach_payment_method_request: (required)
         :type attach_payment_method_request: AttachPaymentMethodRequest
@@ -92,58 +83,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._attach_payment_method_serialize(
-            payment_method_id=payment_method_id,
-            attach_payment_method_request=attach_payment_method_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def attach_payment_method_with_http_info(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        attach_payment_method_request: AttachPaymentMethodRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PaymentMethodExternal]:
-        """Attach Payment Method
+    _param = self._attach_payment_method_serialize(
+      payment_method_id=payment_method_id,
+      attach_payment_method_request=attach_payment_method_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def attach_payment_method_with_http_info(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    attach_payment_method_request: AttachPaymentMethodRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PaymentMethodExternal]:
+    """Attach Payment Method
 
         Attaches the payment_method to a customer. A Payment_method must be attached to a customer before it can be used for payment. Once attached to a customer, it can not be reattached to a different customer.
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param attach_payment_method_request: (required)
         :type attach_payment_method_request: AttachPaymentMethodRequest
@@ -165,58 +147,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._attach_payment_method_serialize(
-            payment_method_id=payment_method_id,
-            attach_payment_method_request=attach_payment_method_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def attach_payment_method_without_preload_content(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        attach_payment_method_request: AttachPaymentMethodRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Attach Payment Method
+    _param = self._attach_payment_method_serialize(
+      payment_method_id=payment_method_id,
+      attach_payment_method_request=attach_payment_method_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def attach_payment_method_without_preload_content(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    attach_payment_method_request: AttachPaymentMethodRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Attach Payment Method
 
         Attaches the payment_method to a customer. A Payment_method must be attached to a customer before it can be used for payment. Once attached to a customer, it can not be reattached to a different customer.
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param attach_payment_method_request: (required)
         :type attach_payment_method_request: AttachPaymentMethodRequest
@@ -238,132 +211,107 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._attach_payment_method_serialize(
-            payment_method_id=payment_method_id,
-            attach_payment_method_request=attach_payment_method_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _attach_payment_method_serialize(
-        self,
-        payment_method_id,
-        attach_payment_method_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if payment_method_id is not None:
-            _path_params['payment_method_id'] = payment_method_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if attach_payment_method_request is not None:
-            _body_params = attach_payment_method_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/payment-methods/{payment_method_id}/attach',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def authorize_credit_card(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        authorization_amount_atom: Annotated[Optional[StrictInt], Field(description="Amount to authorize in the smallest currency unit (e.g., cents).")] = None,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PaymentMethodExternal:
-        """Authorize Credit Card
+    _param = self._attach_payment_method_serialize(
+      payment_method_id=payment_method_id,
+      attach_payment_method_request=attach_payment_method_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _attach_payment_method_serialize(
+    self,
+    payment_method_id,
+    attach_payment_method_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if payment_method_id is not None:
+      _path_params['payment_method_id'] = payment_method_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if attach_payment_method_request is not None:
+      _body_params = attach_payment_method_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/payment-methods/{payment_method_id}/attach',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def authorize_credit_card(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    authorization_amount_atom: Annotated[
+      Optional[StrictInt],
+      Field(description='Amount to authorize in the smallest currency unit (e.g., cents).')] = None,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PaymentMethodExternal:
+    """Authorize Credit Card
 
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param authorization_amount_atom: Amount to authorize in the smallest currency unit (e.g., cents).
         :type authorization_amount_atom: int
         :param _request_timeout: timeout setting for this request. If one
@@ -384,58 +332,51 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._authorize_credit_card_serialize(
-            payment_method_id=payment_method_id,
-            authorization_amount_atom=authorization_amount_atom,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def authorize_credit_card_with_http_info(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        authorization_amount_atom: Annotated[Optional[StrictInt], Field(description="Amount to authorize in the smallest currency unit (e.g., cents).")] = None,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PaymentMethodExternal]:
-        """Authorize Credit Card
+    _param = self._authorize_credit_card_serialize(
+      payment_method_id=payment_method_id,
+      authorization_amount_atom=authorization_amount_atom,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def authorize_credit_card_with_http_info(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    authorization_amount_atom: Annotated[
+      Optional[StrictInt],
+      Field(description='Amount to authorize in the smallest currency unit (e.g., cents).')] = None,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PaymentMethodExternal]:
+    """Authorize Credit Card
 
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param authorization_amount_atom: Amount to authorize in the smallest currency unit (e.g., cents).
         :type authorization_amount_atom: int
         :param _request_timeout: timeout setting for this request. If one
@@ -456,58 +397,51 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._authorize_credit_card_serialize(
-            payment_method_id=payment_method_id,
-            authorization_amount_atom=authorization_amount_atom,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def authorize_credit_card_without_preload_content(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        authorization_amount_atom: Annotated[Optional[StrictInt], Field(description="Amount to authorize in the smallest currency unit (e.g., cents).")] = None,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Authorize Credit Card
+    _param = self._authorize_credit_card_serialize(
+      payment_method_id=payment_method_id,
+      authorization_amount_atom=authorization_amount_atom,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def authorize_credit_card_without_preload_content(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    authorization_amount_atom: Annotated[
+      Optional[StrictInt],
+      Field(description='Amount to authorize in the smallest currency unit (e.g., cents).')] = None,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Authorize Credit Card
 
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param authorization_amount_atom: Amount to authorize in the smallest currency unit (e.g., cents).
         :type authorization_amount_atom: int
         :param _request_timeout: timeout setting for this request. If one
@@ -528,120 +462,98 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._authorize_credit_card_serialize(
-            payment_method_id=payment_method_id,
-            authorization_amount_atom=authorization_amount_atom,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _authorize_credit_card_serialize(
-        self,
-        payment_method_id,
-        authorization_amount_atom,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if payment_method_id is not None:
-            _path_params['payment_method_id'] = payment_method_id
-        # process the query parameters
-        if authorization_amount_atom is not None:
-            
-            _query_params.append(('authorization_amount_atom', authorization_amount_atom))
-            
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/payment-methods/{payment_method_id}/authorize',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def detach_payment_method(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PaymentMethodExternal:
-        """Detach Payment Method
+    _param = self._authorize_credit_card_serialize(
+      payment_method_id=payment_method_id,
+      authorization_amount_atom=authorization_amount_atom,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _authorize_credit_card_serialize(
+    self,
+    payment_method_id,
+    authorization_amount_atom,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if payment_method_id is not None:
+      _path_params['payment_method_id'] = payment_method_id
+    # process the query parameters
+    if authorization_amount_atom is not None:
+
+      _query_params.append(('authorization_amount_atom', authorization_amount_atom))
+
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/payment-methods/{payment_method_id}/authorize',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def detach_payment_method(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PaymentMethodExternal:
+    """Detach Payment Method
 
         Detaches a payment method from a customer.  A detached payment method can no longer be used for payment, nor can it be reattached to the same or a different customer.  A payment method cannot be detached if it is the default payment method for at least one customer, invoice, or active subscription.
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -661,56 +573,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._detach_payment_method_serialize(
-            payment_method_id=payment_method_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def detach_payment_method_with_http_info(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PaymentMethodExternal]:
-        """Detach Payment Method
+    _param = self._detach_payment_method_serialize(
+      payment_method_id=payment_method_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def detach_payment_method_with_http_info(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PaymentMethodExternal]:
+    """Detach Payment Method
 
         Detaches a payment method from a customer.  A detached payment method can no longer be used for payment, nor can it be reattached to the same or a different customer.  A payment method cannot be detached if it is the default payment method for at least one customer, invoice, or active subscription.
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -730,56 +633,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._detach_payment_method_serialize(
-            payment_method_id=payment_method_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def detach_payment_method_without_preload_content(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Detach Payment Method
+    _param = self._detach_payment_method_serialize(
+      payment_method_id=payment_method_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def detach_payment_method_without_preload_content(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Detach Payment Method
 
         Detaches a payment method from a customer.  A detached payment method can no longer be used for payment, nor can it be reattached to the same or a different customer.  A payment method cannot be detached if it is the default payment method for at least one customer, invoice, or active subscription.
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -799,114 +693,92 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._detach_payment_method_serialize(
-            payment_method_id=payment_method_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _detach_payment_method_serialize(
-        self,
-        payment_method_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if payment_method_id is not None:
-            _path_params['payment_method_id'] = payment_method_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/payment-methods/{payment_method_id}/detach',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_payment_method(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PaymentMethodExternal:
-        """Get Payment Method
+    _param = self._detach_payment_method_serialize(
+      payment_method_id=payment_method_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _detach_payment_method_serialize(
+    self,
+    payment_method_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if payment_method_id is not None:
+      _path_params['payment_method_id'] = payment_method_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/payment-methods/{payment_method_id}/detach',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_payment_method(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PaymentMethodExternal:
+    """Get Payment Method
 
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -925,56 +797,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_payment_method_serialize(
-            payment_method_id=payment_method_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_payment_method_with_http_info(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PaymentMethodExternal]:
-        """Get Payment Method
+    _param = self._get_payment_method_serialize(
+      payment_method_id=payment_method_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_payment_method_with_http_info(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PaymentMethodExternal]:
+    """Get Payment Method
 
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -993,56 +856,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_payment_method_serialize(
-            payment_method_id=payment_method_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_payment_method_without_preload_content(
-        self,
-        payment_method_id: Annotated[StrictStr, Field(description="Unique Identifier of the payment_method.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Payment Method
+    _param = self._get_payment_method_serialize(
+      payment_method_id=payment_method_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_payment_method_without_preload_content(
+    self,
+    payment_method_id: Annotated[StrictStr,
+                                 Field(description='Unique Identifier of the payment_method.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Payment Method
 
 
         :param payment_method_id: Unique Identifier of the payment_method. (required)
         :type payment_method_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1061,87 +915,70 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_payment_method_serialize(
-            payment_method_id=payment_method_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PaymentMethodExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_payment_method_serialize(
-        self,
-        payment_method_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if payment_method_id is not None:
-            _path_params['payment_method_id'] = payment_method_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/payment-methods/{payment_method_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
+    _param = self._get_payment_method_serialize(
+      payment_method_id=payment_method_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PaymentMethodExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_payment_method_serialize(
+    self,
+    payment_method_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if payment_method_id is not None:
+      _path_params['payment_method_id'] = payment_method_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
 
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
 
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/payment-methods/{payment_method_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/prices_api.py` & `getopenpay-0.0.2/getopenpay/api/prices_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,72 +7,62 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_price_request import CreatePriceRequest
 from getopenpay.models.delete_price_response import DeletePriceResponse
 from getopenpay.models.list_response_price_external import ListResponsePriceExternal
 from getopenpay.models.price_external import PriceExternal
 from getopenpay.models.price_query_params import PriceQueryParams
 from getopenpay.models.search_price_request import SearchPriceRequest
 from getopenpay.models.update_price_request import UpdatePriceRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class PricesApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_price_for_product(
-        self,
-        create_price_request: CreatePriceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PriceExternal:
-        """Create Price For Product
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_price_for_product(
+    self,
+    create_price_request: CreatePriceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PriceExternal:
+    """Create Price For Product
 
 
         :param create_price_request: (required)
         :type create_price_request: CreatePriceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -91,56 +81,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_price_for_product_serialize(
-            create_price_request=create_price_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_price_for_product_with_http_info(
-        self,
-        create_price_request: CreatePriceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PriceExternal]:
-        """Create Price For Product
+    _param = self._create_price_for_product_serialize(
+      create_price_request=create_price_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_price_for_product_with_http_info(
+    self,
+    create_price_request: CreatePriceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PriceExternal]:
+    """Create Price For Product
 
 
         :param create_price_request: (required)
         :type create_price_request: CreatePriceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -159,56 +139,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_price_for_product_serialize(
-            create_price_request=create_price_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_price_for_product_without_preload_content(
-        self,
-        create_price_request: CreatePriceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Price For Product
+    _param = self._create_price_for_product_serialize(
+      create_price_request=create_price_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_price_for_product_without_preload_content(
+    self,
+    create_price_request: CreatePriceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Price For Product
 
 
         :param create_price_request: (required)
         :type create_price_request: CreatePriceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -227,127 +197,99 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_price_for_product_serialize(
-            create_price_request=create_price_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_price_for_product_serialize(
-        self,
-        create_price_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_price_request is not None:
-            _body_params = create_price_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/prices/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def delete_price_for_product(
-        self,
-        price_id: Annotated[StrictStr, Field(description="Unique identifier of the price.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> DeletePriceResponse:
-        """Delete Price For Product
+    _param = self._create_price_for_product_serialize(
+      create_price_request=create_price_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_price_for_product_serialize(
+    self,
+    create_price_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_price_request is not None:
+      _body_params = create_price_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/prices/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def delete_price_for_product(
+    self,
+    price_id: Annotated[StrictStr, Field(description='Unique identifier of the price.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> DeletePriceResponse:
+    """Delete Price For Product
 
 
         :param price_id: Unique identifier of the price. (required)
         :type price_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -366,56 +308,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_price_for_product_serialize(
-            price_id=price_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeletePriceResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def delete_price_for_product_with_http_info(
-        self,
-        price_id: Annotated[StrictStr, Field(description="Unique identifier of the price.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[DeletePriceResponse]:
-        """Delete Price For Product
+    _param = self._delete_price_for_product_serialize(
+      price_id=price_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeletePriceResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def delete_price_for_product_with_http_info(
+    self,
+    price_id: Annotated[StrictStr, Field(description='Unique identifier of the price.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[DeletePriceResponse]:
+    """Delete Price For Product
 
 
         :param price_id: Unique identifier of the price. (required)
         :type price_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -434,56 +366,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_price_for_product_serialize(
-            price_id=price_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeletePriceResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def delete_price_for_product_without_preload_content(
-        self,
-        price_id: Annotated[StrictStr, Field(description="Unique identifier of the price.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Delete Price For Product
+    _param = self._delete_price_for_product_serialize(
+      price_id=price_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeletePriceResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def delete_price_for_product_without_preload_content(
+    self,
+    price_id: Annotated[StrictStr, Field(description='Unique identifier of the price.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Delete Price For Product
 
 
         :param price_id: Unique identifier of the price. (required)
         :type price_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -502,114 +424,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_price_for_product_serialize(
-            price_id=price_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeletePriceResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _delete_price_for_product_serialize(
-        self,
-        price_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if price_id is not None:
-            _path_params['price_id'] = price_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/prices/{price_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_price_for_product(
-        self,
-        price_id: Annotated[StrictStr, Field(description="Unique identifier of the price.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PriceExternal:
-        """Get Price For Product
+    _param = self._delete_price_for_product_serialize(
+      price_id=price_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeletePriceResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _delete_price_for_product_serialize(
+    self,
+    price_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if price_id is not None:
+      _path_params['price_id'] = price_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='DELETE',
+      resource_path='/prices/{price_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_price_for_product(
+    self,
+    price_id: Annotated[StrictStr, Field(description='Unique identifier of the price.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PriceExternal:
+    """Get Price For Product
 
 
         :param price_id: Unique identifier of the price. (required)
         :type price_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -628,56 +527,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_price_for_product_serialize(
-            price_id=price_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_price_for_product_with_http_info(
-        self,
-        price_id: Annotated[StrictStr, Field(description="Unique identifier of the price.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PriceExternal]:
-        """Get Price For Product
+    _param = self._get_price_for_product_serialize(
+      price_id=price_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_price_for_product_with_http_info(
+    self,
+    price_id: Annotated[StrictStr, Field(description='Unique identifier of the price.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PriceExternal]:
+    """Get Price For Product
 
 
         :param price_id: Unique identifier of the price. (required)
         :type price_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -696,56 +585,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_price_for_product_serialize(
-            price_id=price_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_price_for_product_without_preload_content(
-        self,
-        price_id: Annotated[StrictStr, Field(description="Unique identifier of the price.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Price For Product
+    _param = self._get_price_for_product_serialize(
+      price_id=price_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_price_for_product_without_preload_content(
+    self,
+    price_id: Annotated[StrictStr, Field(description='Unique identifier of the price.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Price For Product
 
 
         :param price_id: Unique identifier of the price. (required)
         :type price_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -764,114 +643,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_price_for_product_serialize(
-            price_id=price_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_price_for_product_serialize(
-        self,
-        price_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if price_id is not None:
-            _path_params['price_id'] = price_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/prices/{price_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_prices(
-        self,
-        price_query_params: PriceQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponsePriceExternal:
-        """List Prices
+    _param = self._get_price_for_product_serialize(
+      price_id=price_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_price_for_product_serialize(
+    self,
+    price_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if price_id is not None:
+      _path_params['price_id'] = price_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/prices/{price_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_prices(
+    self,
+    price_query_params: PriceQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponsePriceExternal:
+    """List Prices
 
 
         :param price_query_params: (required)
         :type price_query_params: PriceQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -890,56 +746,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_prices_serialize(
-            price_query_params=price_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_prices_with_http_info(
-        self,
-        price_query_params: PriceQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponsePriceExternal]:
-        """List Prices
+    _param = self._list_prices_serialize(
+      price_query_params=price_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_prices_with_http_info(
+    self,
+    price_query_params: PriceQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponsePriceExternal]:
+    """List Prices
 
 
         :param price_query_params: (required)
         :type price_query_params: PriceQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -958,56 +804,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_prices_serialize(
-            price_query_params=price_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_prices_without_preload_content(
-        self,
-        price_query_params: PriceQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Prices
+    _param = self._list_prices_serialize(
+      price_query_params=price_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_prices_without_preload_content(
+    self,
+    price_query_params: PriceQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Prices
 
 
         :param price_query_params: (required)
         :type price_query_params: PriceQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1026,127 +862,99 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_prices_serialize(
-            price_query_params=price_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_prices_serialize(
-        self,
-        price_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if price_query_params is not None:
-            _body_params = price_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/prices/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def search_prices(
-        self,
-        search_price_request: SearchPriceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponsePriceExternal:
-        """Search Prices
+    _param = self._list_prices_serialize(
+      price_query_params=price_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_prices_serialize(
+    self,
+    price_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if price_query_params is not None:
+      _body_params = price_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/prices/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def search_prices(
+    self,
+    search_price_request: SearchPriceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponsePriceExternal:
+    """Search Prices
 
 
         :param search_price_request: (required)
         :type search_price_request: SearchPriceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1165,56 +973,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_prices_serialize(
-            search_price_request=search_price_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def search_prices_with_http_info(
-        self,
-        search_price_request: SearchPriceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponsePriceExternal]:
-        """Search Prices
+    _param = self._search_prices_serialize(
+      search_price_request=search_price_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def search_prices_with_http_info(
+    self,
+    search_price_request: SearchPriceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponsePriceExternal]:
+    """Search Prices
 
 
         :param search_price_request: (required)
         :type search_price_request: SearchPriceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1233,56 +1031,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_prices_serialize(
-            search_price_request=search_price_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def search_prices_without_preload_content(
-        self,
-        search_price_request: SearchPriceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Search Prices
+    _param = self._search_prices_serialize(
+      search_price_request=search_price_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def search_prices_without_preload_content(
+    self,
+    search_price_request: SearchPriceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Search Prices
 
 
         :param search_price_request: (required)
         :type search_price_request: SearchPriceRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1301,128 +1089,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_prices_serialize(
-            search_price_request=search_price_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _search_prices_serialize(
-        self,
-        search_price_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if search_price_request is not None:
-            _body_params = search_price_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/prices/search',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def update_price_for_product(
-        self,
-        price_id: Annotated[StrictStr, Field(description="Unique identifier of the price.")],
-        update_price_request: UpdatePriceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PriceExternal:
-        """Update Price For Product
+    _param = self._search_prices_serialize(
+      search_price_request=search_price_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _search_prices_serialize(
+    self,
+    search_price_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if search_price_request is not None:
+      _body_params = search_price_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/prices/search',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def update_price_for_product(
+    self,
+    price_id: Annotated[StrictStr, Field(description='Unique identifier of the price.')],
+    update_price_request: UpdatePriceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PriceExternal:
+    """Update Price For Product
 
 
         :param price_id: Unique identifier of the price. (required)
         :type price_id: str
         :param update_price_request: (required)
         :type update_price_request: UpdatePriceRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1443,58 +1203,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_price_for_product_serialize(
-            price_id=price_id,
-            update_price_request=update_price_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def update_price_for_product_with_http_info(
-        self,
-        price_id: Annotated[StrictStr, Field(description="Unique identifier of the price.")],
-        update_price_request: UpdatePriceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PriceExternal]:
-        """Update Price For Product
+    _param = self._update_price_for_product_serialize(
+      price_id=price_id,
+      update_price_request=update_price_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def update_price_for_product_with_http_info(
+    self,
+    price_id: Annotated[StrictStr, Field(description='Unique identifier of the price.')],
+    update_price_request: UpdatePriceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PriceExternal]:
+    """Update Price For Product
 
 
         :param price_id: Unique identifier of the price. (required)
         :type price_id: str
         :param update_price_request: (required)
         :type update_price_request: UpdatePriceRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1515,58 +1265,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_price_for_product_serialize(
-            price_id=price_id,
-            update_price_request=update_price_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def update_price_for_product_without_preload_content(
-        self,
-        price_id: Annotated[StrictStr, Field(description="Unique identifier of the price.")],
-        update_price_request: UpdatePriceRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Update Price For Product
+    _param = self._update_price_for_product_serialize(
+      price_id=price_id,
+      update_price_request=update_price_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def update_price_for_product_without_preload_content(
+    self,
+    price_id: Annotated[StrictStr, Field(description='Unique identifier of the price.')],
+    update_price_request: UpdatePriceRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Update Price For Product
 
 
         :param price_id: Unique identifier of the price. (required)
         :type price_id: str
         :param update_price_request: (required)
         :type update_price_request: UpdatePriceRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1587,104 +1327,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_price_for_product_serialize(
-            price_id=price_id,
-            update_price_request=update_price_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PriceExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _update_price_for_product_serialize(
-        self,
-        price_id,
-        update_price_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if price_id is not None:
-            _path_params['price_id'] = price_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if update_price_request is not None:
-            _body_params = update_price_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/prices/{price_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._update_price_for_product_serialize(
+      price_id=price_id,
+      update_price_request=update_price_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PriceExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _update_price_for_product_serialize(
+    self,
+    price_id,
+    update_price_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if price_id is not None:
+      _path_params['price_id'] = price_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if update_price_request is not None:
+      _body_params = update_price_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/prices/{price_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/product_family_api.py` & `getopenpay-0.0.2/getopenpay/api/product_family_api.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,68 +7,61 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_product_family_request import CreateProductFamilyRequest
-from getopenpay.models.list_response_product_family_external import ListResponseProductFamilyExternal
+from getopenpay.models.list_response_product_family_external import (
+  ListResponseProductFamilyExternal
+)
 from getopenpay.models.product_family_external import ProductFamilyExternal
 from getopenpay.models.product_family_query_params import ProductFamilyQueryParams
 from getopenpay.models.update_product_family_request import UpdateProductFamilyRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import StrictStr
 
 
 class ProductFamilyApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_product_family(
-        self,
-        create_product_family_request: CreateProductFamilyRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ProductFamilyExternal:
-        """Create Product Family
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_product_family(
+    self,
+    create_product_family_request: CreateProductFamilyRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ProductFamilyExternal:
+    """Create Product Family
 
 
         :param create_product_family_request: (required)
         :type create_product_family_request: CreateProductFamilyRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -87,56 +80,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_product_family_serialize(
-            create_product_family_request=create_product_family_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_product_family_with_http_info(
-        self,
-        create_product_family_request: CreateProductFamilyRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ProductFamilyExternal]:
-        """Create Product Family
+    _param = self._create_product_family_serialize(
+      create_product_family_request=create_product_family_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_product_family_with_http_info(
+    self,
+    create_product_family_request: CreateProductFamilyRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ProductFamilyExternal]:
+    """Create Product Family
 
 
         :param create_product_family_request: (required)
         :type create_product_family_request: CreateProductFamilyRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -155,56 +138,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_product_family_serialize(
-            create_product_family_request=create_product_family_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_product_family_without_preload_content(
-        self,
-        create_product_family_request: CreateProductFamilyRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Product Family
+    _param = self._create_product_family_serialize(
+      create_product_family_request=create_product_family_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_product_family_without_preload_content(
+    self,
+    create_product_family_request: CreateProductFamilyRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Product Family
 
 
         :param create_product_family_request: (required)
         :type create_product_family_request: CreateProductFamilyRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -223,127 +196,99 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_product_family_serialize(
-            create_product_family_request=create_product_family_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_product_family_serialize(
-        self,
-        create_product_family_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_product_family_request is not None:
-            _body_params = create_product_family_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/product-family/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def delete_product_family(
-        self,
-        id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> None:
-        """Delete Product Family
+    _param = self._create_product_family_serialize(
+      create_product_family_request=create_product_family_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_product_family_serialize(
+    self,
+    create_product_family_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_product_family_request is not None:
+      _body_params = create_product_family_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/product-family/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def delete_product_family(
+    self,
+    id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> None:
+    """Delete Product Family
 
 
         :param id: (required)
         :type id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -362,54 +307,43 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_product_family_serialize(
-            id=id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def delete_product_family_with_http_info(
-        self,
-        id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[None]:
-        """Delete Product Family
+    _param = self._delete_product_family_serialize(
+      id=id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {}
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def delete_product_family_with_http_info(
+    self,
+    id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[None]:
+    """Delete Product Family
 
 
         :param id: (required)
         :type id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -428,54 +362,43 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_product_family_serialize(
-            id=id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def delete_product_family_without_preload_content(
-        self,
-        id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Delete Product Family
+    _param = self._delete_product_family_serialize(
+      id=id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {}
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def delete_product_family_without_preload_content(
+    self,
+    id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Delete Product Family
 
 
         :param id: (required)
         :type id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -494,112 +417,88 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_product_family_serialize(
-            id=id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _delete_product_family_serialize(
-        self,
-        id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if id is not None:
-            _path_params['id'] = id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/product-family/{id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_product_family(
-        self,
-        id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ProductFamilyExternal:
-        """Get Product Family
+    _param = self._delete_product_family_serialize(
+      id=id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {}
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _delete_product_family_serialize(
+    self,
+    id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if id is not None:
+      _path_params['id'] = id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='DELETE',
+      resource_path='/product-family/{id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_product_family(
+    self,
+    id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ProductFamilyExternal:
+    """Get Product Family
 
 
         :param id: (required)
         :type id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -618,56 +517,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_product_family_serialize(
-            id=id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_product_family_with_http_info(
-        self,
-        id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ProductFamilyExternal]:
-        """Get Product Family
+    _param = self._get_product_family_serialize(
+      id=id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_product_family_with_http_info(
+    self,
+    id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ProductFamilyExternal]:
+    """Get Product Family
 
 
         :param id: (required)
         :type id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -686,56 +575,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_product_family_serialize(
-            id=id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_product_family_without_preload_content(
-        self,
-        id: StrictStr,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Product Family
+    _param = self._get_product_family_serialize(
+      id=id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_product_family_without_preload_content(
+    self,
+    id: StrictStr,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Product Family
 
 
         :param id: (required)
         :type id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -754,114 +633,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_product_family_serialize(
-            id=id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_product_family_serialize(
-        self,
-        id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if id is not None:
-            _path_params['id'] = id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/product-family/{id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_product_families(
-        self,
-        product_family_query_params: ProductFamilyQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseProductFamilyExternal:
-        """List Product Families
+    _param = self._get_product_family_serialize(
+      id=id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_product_family_serialize(
+    self,
+    id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if id is not None:
+      _path_params['id'] = id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/product-family/{id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_product_families(
+    self,
+    product_family_query_params: ProductFamilyQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseProductFamilyExternal:
+    """List Product Families
 
 
         :param product_family_query_params: (required)
         :type product_family_query_params: ProductFamilyQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -880,56 +736,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_product_families_serialize(
-            product_family_query_params=product_family_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_product_families_with_http_info(
-        self,
-        product_family_query_params: ProductFamilyQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseProductFamilyExternal]:
-        """List Product Families
+    _param = self._list_product_families_serialize(
+      product_family_query_params=product_family_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_product_families_with_http_info(
+    self,
+    product_family_query_params: ProductFamilyQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseProductFamilyExternal]:
+    """List Product Families
 
 
         :param product_family_query_params: (required)
         :type product_family_query_params: ProductFamilyQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -948,56 +794,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_product_families_serialize(
-            product_family_query_params=product_family_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_product_families_without_preload_content(
-        self,
-        product_family_query_params: ProductFamilyQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Product Families
+    _param = self._list_product_families_serialize(
+      product_family_query_params=product_family_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_product_families_without_preload_content(
+    self,
+    product_family_query_params: ProductFamilyQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Product Families
 
 
         :param product_family_query_params: (required)
         :type product_family_query_params: ProductFamilyQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1016,128 +852,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_product_families_serialize(
-            product_family_query_params=product_family_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_product_families_serialize(
-        self,
-        product_family_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if product_family_query_params is not None:
-            _body_params = product_family_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/product-family/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def update_product_family(
-        self,
-        id: StrictStr,
-        update_product_family_request: UpdateProductFamilyRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ProductFamilyExternal:
-        """Update Product Family
+    _param = self._list_product_families_serialize(
+      product_family_query_params=product_family_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_product_families_serialize(
+    self,
+    product_family_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if product_family_query_params is not None:
+      _body_params = product_family_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/product-family/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def update_product_family(
+    self,
+    id: StrictStr,
+    update_product_family_request: UpdateProductFamilyRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ProductFamilyExternal:
+    """Update Product Family
 
 
         :param id: (required)
         :type id: str
         :param update_product_family_request: (required)
         :type update_product_family_request: UpdateProductFamilyRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1158,58 +966,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_product_family_serialize(
-            id=id,
-            update_product_family_request=update_product_family_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def update_product_family_with_http_info(
-        self,
-        id: StrictStr,
-        update_product_family_request: UpdateProductFamilyRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ProductFamilyExternal]:
-        """Update Product Family
+    _param = self._update_product_family_serialize(
+      id=id,
+      update_product_family_request=update_product_family_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def update_product_family_with_http_info(
+    self,
+    id: StrictStr,
+    update_product_family_request: UpdateProductFamilyRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ProductFamilyExternal]:
+    """Update Product Family
 
 
         :param id: (required)
         :type id: str
         :param update_product_family_request: (required)
         :type update_product_family_request: UpdateProductFamilyRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1230,58 +1028,48 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_product_family_serialize(
-            id=id,
-            update_product_family_request=update_product_family_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def update_product_family_without_preload_content(
-        self,
-        id: StrictStr,
-        update_product_family_request: UpdateProductFamilyRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Update Product Family
+    _param = self._update_product_family_serialize(
+      id=id,
+      update_product_family_request=update_product_family_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def update_product_family_without_preload_content(
+    self,
+    id: StrictStr,
+    update_product_family_request: UpdateProductFamilyRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Update Product Family
 
 
         :param id: (required)
         :type id: str
         :param update_product_family_request: (required)
         :type update_product_family_request: UpdateProductFamilyRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1302,104 +1090,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_product_family_serialize(
-            id=id,
-            update_product_family_request=update_product_family_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductFamilyExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _update_product_family_serialize(
-        self,
-        id,
-        update_product_family_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if id is not None:
-            _path_params['id'] = id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if update_product_family_request is not None:
-            _body_params = update_product_family_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/product-family/{id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._update_product_family_serialize(
+      id=id,
+      update_product_family_request=update_product_family_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductFamilyExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _update_product_family_serialize(
+    self,
+    id,
+    update_product_family_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if id is not None:
+      _path_params['id'] = id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if update_product_family_request is not None:
+      _body_params = update_product_family_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/product-family/{id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/products_api.py` & `getopenpay-0.0.2/getopenpay/api/products_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,72 +7,62 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_product_request import CreateProductRequest
 from getopenpay.models.delete_product_response import DeleteProductResponse
 from getopenpay.models.list_response_product_external import ListResponseProductExternal
 from getopenpay.models.product_external import ProductExternal
 from getopenpay.models.product_query_params import ProductQueryParams
 from getopenpay.models.search_product_request import SearchProductRequest
 from getopenpay.models.update_product_request import UpdateProductRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class ProductsApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_product(
-        self,
-        create_product_request: CreateProductRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ProductExternal:
-        """Create Product
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_product(
+    self,
+    create_product_request: CreateProductRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ProductExternal:
+    """Create Product
 
 
         :param create_product_request: (required)
         :type create_product_request: CreateProductRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -91,56 +81,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_product_serialize(
-            create_product_request=create_product_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "ProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_product_with_http_info(
-        self,
-        create_product_request: CreateProductRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ProductExternal]:
-        """Create Product
+    _param = self._create_product_serialize(
+      create_product_request=create_product_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'ProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_product_with_http_info(
+    self,
+    create_product_request: CreateProductRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ProductExternal]:
+    """Create Product
 
 
         :param create_product_request: (required)
         :type create_product_request: CreateProductRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -159,56 +139,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_product_serialize(
-            create_product_request=create_product_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "ProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_product_without_preload_content(
-        self,
-        create_product_request: CreateProductRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Product
+    _param = self._create_product_serialize(
+      create_product_request=create_product_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'ProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_product_without_preload_content(
+    self,
+    create_product_request: CreateProductRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Product
 
 
         :param create_product_request: (required)
         :type create_product_request: CreateProductRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -227,127 +197,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_product_serialize(
-            create_product_request=create_product_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "ProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_product_serialize(
-        self,
-        create_product_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_product_request is not None:
-            _body_params = create_product_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/products/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def delete_product(
-        self,
-        product_id: Annotated[StrictStr, Field(description="Unique identifier of the product.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> DeleteProductResponse:
-        """Delete Product
+    _param = self._create_product_serialize(
+      create_product_request=create_product_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'ProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_product_serialize(
+    self,
+    create_product_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_product_request is not None:
+      _body_params = create_product_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/products/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def delete_product(
+    self,
+    product_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the product.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> DeleteProductResponse:
+    """Delete Product
 
 
         :param product_id: Unique identifier of the product. (required)
         :type product_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -366,56 +309,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_product_serialize(
-            product_id=product_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeleteProductResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def delete_product_with_http_info(
-        self,
-        product_id: Annotated[StrictStr, Field(description="Unique identifier of the product.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[DeleteProductResponse]:
-        """Delete Product
+    _param = self._delete_product_serialize(
+      product_id=product_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeleteProductResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def delete_product_with_http_info(
+    self,
+    product_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the product.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[DeleteProductResponse]:
+    """Delete Product
 
 
         :param product_id: Unique identifier of the product. (required)
         :type product_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -434,56 +368,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_product_serialize(
-            product_id=product_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeleteProductResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def delete_product_without_preload_content(
-        self,
-        product_id: Annotated[StrictStr, Field(description="Unique identifier of the product.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Delete Product
+    _param = self._delete_product_serialize(
+      product_id=product_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeleteProductResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def delete_product_without_preload_content(
+    self,
+    product_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the product.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Delete Product
 
 
         :param product_id: Unique identifier of the product. (required)
         :type product_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -502,114 +427,92 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_product_serialize(
-            product_id=product_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeleteProductResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _delete_product_serialize(
-        self,
-        product_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if product_id is not None:
-            _path_params['product_id'] = product_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/products/{product_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_product(
-        self,
-        product_id: Annotated[StrictStr, Field(description="Unique identifier of the product.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ProductExternal:
-        """Get Product
+    _param = self._delete_product_serialize(
+      product_id=product_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeleteProductResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _delete_product_serialize(
+    self,
+    product_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if product_id is not None:
+      _path_params['product_id'] = product_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='DELETE',
+      resource_path='/products/{product_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_product(
+    self,
+    product_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the product.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ProductExternal:
+    """Get Product
 
 
         :param product_id: Unique identifier of the product. (required)
         :type product_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -628,56 +531,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_product_serialize(
-            product_id=product_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_product_with_http_info(
-        self,
-        product_id: Annotated[StrictStr, Field(description="Unique identifier of the product.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ProductExternal]:
-        """Get Product
+    _param = self._get_product_serialize(
+      product_id=product_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_product_with_http_info(
+    self,
+    product_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the product.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ProductExternal]:
+    """Get Product
 
 
         :param product_id: Unique identifier of the product. (required)
         :type product_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -696,56 +590,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_product_serialize(
-            product_id=product_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_product_without_preload_content(
-        self,
-        product_id: Annotated[StrictStr, Field(description="Unique identifier of the product.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Product
+    _param = self._get_product_serialize(
+      product_id=product_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_product_without_preload_content(
+    self,
+    product_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the product.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Product
 
 
         :param product_id: Unique identifier of the product. (required)
         :type product_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -764,114 +649,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_product_serialize(
-            product_id=product_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_product_serialize(
-        self,
-        product_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if product_id is not None:
-            _path_params['product_id'] = product_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/products/{product_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_products(
-        self,
-        product_query_params: ProductQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseProductExternal:
-        """List Products
+    _param = self._get_product_serialize(
+      product_id=product_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_product_serialize(
+    self,
+    product_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if product_id is not None:
+      _path_params['product_id'] = product_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/products/{product_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_products(
+    self,
+    product_query_params: ProductQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseProductExternal:
+    """List Products
 
 
         :param product_query_params: (required)
         :type product_query_params: ProductQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -890,56 +752,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_products_serialize(
-            product_query_params=product_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_products_with_http_info(
-        self,
-        product_query_params: ProductQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseProductExternal]:
-        """List Products
+    _param = self._list_products_serialize(
+      product_query_params=product_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_products_with_http_info(
+    self,
+    product_query_params: ProductQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseProductExternal]:
+    """List Products
 
 
         :param product_query_params: (required)
         :type product_query_params: ProductQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -958,56 +810,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_products_serialize(
-            product_query_params=product_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_products_without_preload_content(
-        self,
-        product_query_params: ProductQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Products
+    _param = self._list_products_serialize(
+      product_query_params=product_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_products_without_preload_content(
+    self,
+    product_query_params: ProductQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Products
 
 
         :param product_query_params: (required)
         :type product_query_params: ProductQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1026,127 +868,99 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_products_serialize(
-            product_query_params=product_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_products_serialize(
-        self,
-        product_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if product_query_params is not None:
-            _body_params = product_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/products/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def search_products(
-        self,
-        search_product_request: SearchProductRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseProductExternal:
-        """Search Products
+    _param = self._list_products_serialize(
+      product_query_params=product_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_products_serialize(
+    self,
+    product_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if product_query_params is not None:
+      _body_params = product_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/products/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def search_products(
+    self,
+    search_product_request: SearchProductRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseProductExternal:
+    """Search Products
 
 
         :param search_product_request: (required)
         :type search_product_request: SearchProductRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1165,56 +979,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_products_serialize(
-            search_product_request=search_product_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def search_products_with_http_info(
-        self,
-        search_product_request: SearchProductRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseProductExternal]:
-        """Search Products
+    _param = self._search_products_serialize(
+      search_product_request=search_product_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def search_products_with_http_info(
+    self,
+    search_product_request: SearchProductRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseProductExternal]:
+    """Search Products
 
 
         :param search_product_request: (required)
         :type search_product_request: SearchProductRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1233,56 +1037,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_products_serialize(
-            search_product_request=search_product_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def search_products_without_preload_content(
-        self,
-        search_product_request: SearchProductRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Search Products
+    _param = self._search_products_serialize(
+      search_product_request=search_product_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def search_products_without_preload_content(
+    self,
+    search_product_request: SearchProductRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Search Products
 
 
         :param search_product_request: (required)
         :type search_product_request: SearchProductRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1301,128 +1095,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_products_serialize(
-            search_product_request=search_product_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _search_products_serialize(
-        self,
-        search_product_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if search_product_request is not None:
-            _body_params = search_product_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/products/search',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def update_product(
-        self,
-        product_id: Annotated[StrictStr, Field(description="Unique identifier of the product.")],
-        update_product_request: UpdateProductRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ProductExternal:
-        """Update Product
+    _param = self._search_products_serialize(
+      search_product_request=search_product_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _search_products_serialize(
+    self,
+    search_product_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if search_product_request is not None:
+      _body_params = search_product_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/products/search',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def update_product(
+    self,
+    product_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the product.')],
+    update_product_request: UpdateProductRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ProductExternal:
+    """Update Product
 
 
         :param product_id: Unique identifier of the product. (required)
         :type product_id: str
         :param update_product_request: (required)
         :type update_product_request: UpdateProductRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1443,58 +1210,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_product_serialize(
-            product_id=product_id,
-            update_product_request=update_product_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def update_product_with_http_info(
-        self,
-        product_id: Annotated[StrictStr, Field(description="Unique identifier of the product.")],
-        update_product_request: UpdateProductRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ProductExternal]:
-        """Update Product
+    _param = self._update_product_serialize(
+      product_id=product_id,
+      update_product_request=update_product_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def update_product_with_http_info(
+    self,
+    product_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the product.')],
+    update_product_request: UpdateProductRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ProductExternal]:
+    """Update Product
 
 
         :param product_id: Unique identifier of the product. (required)
         :type product_id: str
         :param update_product_request: (required)
         :type update_product_request: UpdateProductRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1515,58 +1273,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_product_serialize(
-            product_id=product_id,
-            update_product_request=update_product_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def update_product_without_preload_content(
-        self,
-        product_id: Annotated[StrictStr, Field(description="Unique identifier of the product.")],
-        update_product_request: UpdateProductRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Update Product
+    _param = self._update_product_serialize(
+      product_id=product_id,
+      update_product_request=update_product_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def update_product_without_preload_content(
+    self,
+    product_id: Annotated[StrictStr,
+                          Field(description='Unique identifier of the product.')],
+    update_product_request: UpdateProductRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Update Product
 
 
         :param product_id: Unique identifier of the product. (required)
         :type product_id: str
         :param update_product_request: (required)
         :type update_product_request: UpdateProductRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1587,104 +1336,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_product_serialize(
-            product_id=product_id,
-            update_product_request=update_product_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ProductExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _update_product_serialize(
-        self,
-        product_id,
-        update_product_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if product_id is not None:
-            _path_params['product_id'] = product_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if update_product_request is not None:
-            _body_params = update_product_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/products/{product_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._update_product_serialize(
+      product_id=product_id,
+      update_product_request=update_product_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ProductExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _update_product_serialize(
+    self,
+    product_id,
+    update_product_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if product_id is not None:
+      _path_params['product_id'] = product_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if update_product_request is not None:
+      _body_params = update_product_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/products/{product_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/promotion_codes_api.py` & `getopenpay-0.0.2/getopenpay/api/promotion_codes_api.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,70 +7,62 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_promo_code_request import CreatePromoCodeRequest
-from getopenpay.models.list_response_promotion_code_external import ListResponsePromotionCodeExternal
+from getopenpay.models.list_response_promotion_code_external import (
+  ListResponsePromotionCodeExternal
+)
 from getopenpay.models.promo_code_query_params import PromoCodeQueryParams
 from getopenpay.models.promotion_code_external import PromotionCodeExternal
 from getopenpay.models.update_promo_code_request import UpdatePromoCodeRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class PromotionCodesApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_promo_code(
-        self,
-        create_promo_code_request: CreatePromoCodeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PromotionCodeExternal:
-        """Create Promo Code
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_promo_code(
+    self,
+    create_promo_code_request: CreatePromoCodeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PromotionCodeExternal:
+    """Create Promo Code
 
 
         :param create_promo_code_request: (required)
         :type create_promo_code_request: CreatePromoCodeRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -89,56 +81,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_promo_code_serialize(
-            create_promo_code_request=create_promo_code_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_promo_code_with_http_info(
-        self,
-        create_promo_code_request: CreatePromoCodeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PromotionCodeExternal]:
-        """Create Promo Code
+    _param = self._create_promo_code_serialize(
+      create_promo_code_request=create_promo_code_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_promo_code_with_http_info(
+    self,
+    create_promo_code_request: CreatePromoCodeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PromotionCodeExternal]:
+    """Create Promo Code
 
 
         :param create_promo_code_request: (required)
         :type create_promo_code_request: CreatePromoCodeRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -157,56 +139,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_promo_code_serialize(
-            create_promo_code_request=create_promo_code_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_promo_code_without_preload_content(
-        self,
-        create_promo_code_request: CreatePromoCodeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Promo Code
+    _param = self._create_promo_code_serialize(
+      create_promo_code_request=create_promo_code_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_promo_code_without_preload_content(
+    self,
+    create_promo_code_request: CreatePromoCodeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Promo Code
 
 
         :param create_promo_code_request: (required)
         :type create_promo_code_request: CreatePromoCodeRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -225,127 +197,100 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_promo_code_serialize(
-            create_promo_code_request=create_promo_code_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "PromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_promo_code_serialize(
-        self,
-        create_promo_code_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_promo_code_request is not None:
-            _body_params = create_promo_code_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/promotion-codes/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_promo_code(
-        self,
-        promo_code_id: Annotated[StrictStr, Field(description="Unique identifier of the PromotionCode.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PromotionCodeExternal:
-        """Get Promo Code
+    _param = self._create_promo_code_serialize(
+      create_promo_code_request=create_promo_code_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'PromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_promo_code_serialize(
+    self,
+    create_promo_code_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_promo_code_request is not None:
+      _body_params = create_promo_code_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/promotion-codes/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_promo_code(
+    self,
+    promo_code_id: Annotated[StrictStr,
+                             Field(description='Unique identifier of the PromotionCode.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PromotionCodeExternal:
+    """Get Promo Code
 
 
         :param promo_code_id: Unique identifier of the PromotionCode. (required)
         :type promo_code_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -364,56 +309,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_promo_code_serialize(
-            promo_code_id=promo_code_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_promo_code_with_http_info(
-        self,
-        promo_code_id: Annotated[StrictStr, Field(description="Unique identifier of the PromotionCode.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PromotionCodeExternal]:
-        """Get Promo Code
+    _param = self._get_promo_code_serialize(
+      promo_code_id=promo_code_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_promo_code_with_http_info(
+    self,
+    promo_code_id: Annotated[StrictStr,
+                             Field(description='Unique identifier of the PromotionCode.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PromotionCodeExternal]:
+    """Get Promo Code
 
 
         :param promo_code_id: Unique identifier of the PromotionCode. (required)
         :type promo_code_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -432,56 +368,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_promo_code_serialize(
-            promo_code_id=promo_code_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_promo_code_without_preload_content(
-        self,
-        promo_code_id: Annotated[StrictStr, Field(description="Unique identifier of the PromotionCode.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Promo Code
+    _param = self._get_promo_code_serialize(
+      promo_code_id=promo_code_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_promo_code_without_preload_content(
+    self,
+    promo_code_id: Annotated[StrictStr,
+                             Field(description='Unique identifier of the PromotionCode.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Promo Code
 
 
         :param promo_code_id: Unique identifier of the PromotionCode. (required)
         :type promo_code_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -500,114 +427,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_promo_code_serialize(
-            promo_code_id=promo_code_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_promo_code_serialize(
-        self,
-        promo_code_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if promo_code_id is not None:
-            _path_params['promo_code_id'] = promo_code_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/promotion-codes/{promo_code_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_promo_codes(
-        self,
-        promo_code_query_params: PromoCodeQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponsePromotionCodeExternal:
-        """List Promo Codes
+    _param = self._get_promo_code_serialize(
+      promo_code_id=promo_code_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_promo_code_serialize(
+    self,
+    promo_code_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if promo_code_id is not None:
+      _path_params['promo_code_id'] = promo_code_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/promotion-codes/{promo_code_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_promo_codes(
+    self,
+    promo_code_query_params: PromoCodeQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponsePromotionCodeExternal:
+    """List Promo Codes
 
 
         :param promo_code_query_params: (required)
         :type promo_code_query_params: PromoCodeQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -626,56 +530,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_promo_codes_serialize(
-            promo_code_query_params=promo_code_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_promo_codes_with_http_info(
-        self,
-        promo_code_query_params: PromoCodeQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponsePromotionCodeExternal]:
-        """List Promo Codes
+    _param = self._list_promo_codes_serialize(
+      promo_code_query_params=promo_code_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_promo_codes_with_http_info(
+    self,
+    promo_code_query_params: PromoCodeQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponsePromotionCodeExternal]:
+    """List Promo Codes
 
 
         :param promo_code_query_params: (required)
         :type promo_code_query_params: PromoCodeQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -694,56 +588,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_promo_codes_serialize(
-            promo_code_query_params=promo_code_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_promo_codes_without_preload_content(
-        self,
-        promo_code_query_params: PromoCodeQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Promo Codes
+    _param = self._list_promo_codes_serialize(
+      promo_code_query_params=promo_code_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_promo_codes_without_preload_content(
+    self,
+    promo_code_query_params: PromoCodeQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Promo Codes
 
 
         :param promo_code_query_params: (required)
         :type promo_code_query_params: PromoCodeQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -762,128 +646,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_promo_codes_serialize(
-            promo_code_query_params=promo_code_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponsePromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_promo_codes_serialize(
-        self,
-        promo_code_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if promo_code_query_params is not None:
-            _body_params = promo_code_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/promotion-codes/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def update_promo_code(
-        self,
-        promo_code_id: Annotated[StrictStr, Field(description="Unique identifier of the PromotionCode.")],
-        update_promo_code_request: UpdatePromoCodeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> PromotionCodeExternal:
-        """Update Promo Code
+    _param = self._list_promo_codes_serialize(
+      promo_code_query_params=promo_code_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponsePromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_promo_codes_serialize(
+    self,
+    promo_code_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if promo_code_query_params is not None:
+      _body_params = promo_code_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/promotion-codes/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def update_promo_code(
+    self,
+    promo_code_id: Annotated[StrictStr,
+                             Field(description='Unique identifier of the PromotionCode.')],
+    update_promo_code_request: UpdatePromoCodeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> PromotionCodeExternal:
+    """Update Promo Code
 
 
         :param promo_code_id: Unique identifier of the PromotionCode. (required)
         :type promo_code_id: str
         :param update_promo_code_request: (required)
         :type update_promo_code_request: UpdatePromoCodeRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -904,58 +761,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_promo_code_serialize(
-            promo_code_id=promo_code_id,
-            update_promo_code_request=update_promo_code_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def update_promo_code_with_http_info(
-        self,
-        promo_code_id: Annotated[StrictStr, Field(description="Unique identifier of the PromotionCode.")],
-        update_promo_code_request: UpdatePromoCodeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[PromotionCodeExternal]:
-        """Update Promo Code
+    _param = self._update_promo_code_serialize(
+      promo_code_id=promo_code_id,
+      update_promo_code_request=update_promo_code_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def update_promo_code_with_http_info(
+    self,
+    promo_code_id: Annotated[StrictStr,
+                             Field(description='Unique identifier of the PromotionCode.')],
+    update_promo_code_request: UpdatePromoCodeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[PromotionCodeExternal]:
+    """Update Promo Code
 
 
         :param promo_code_id: Unique identifier of the PromotionCode. (required)
         :type promo_code_id: str
         :param update_promo_code_request: (required)
         :type update_promo_code_request: UpdatePromoCodeRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -976,58 +824,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_promo_code_serialize(
-            promo_code_id=promo_code_id,
-            update_promo_code_request=update_promo_code_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def update_promo_code_without_preload_content(
-        self,
-        promo_code_id: Annotated[StrictStr, Field(description="Unique identifier of the PromotionCode.")],
-        update_promo_code_request: UpdatePromoCodeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Update Promo Code
+    _param = self._update_promo_code_serialize(
+      promo_code_id=promo_code_id,
+      update_promo_code_request=update_promo_code_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def update_promo_code_without_preload_content(
+    self,
+    promo_code_id: Annotated[StrictStr,
+                             Field(description='Unique identifier of the PromotionCode.')],
+    update_promo_code_request: UpdatePromoCodeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Update Promo Code
 
 
         :param promo_code_id: Unique identifier of the PromotionCode. (required)
         :type promo_code_id: str
         :param update_promo_code_request: (required)
         :type update_promo_code_request: UpdatePromoCodeRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1048,104 +887,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_promo_code_serialize(
-            promo_code_id=promo_code_id,
-            update_promo_code_request=update_promo_code_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "PromotionCodeExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _update_promo_code_serialize(
-        self,
-        promo_code_id,
-        update_promo_code_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if promo_code_id is not None:
-            _path_params['promo_code_id'] = promo_code_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if update_promo_code_request is not None:
-            _body_params = update_promo_code_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/promotion-codes/{promo_code_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._update_promo_code_serialize(
+      promo_code_id=promo_code_id,
+      update_promo_code_request=update_promo_code_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'PromotionCodeExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _update_promo_code_serialize(
+    self,
+    promo_code_id,
+    update_promo_code_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if promo_code_id is not None:
+      _path_params['promo_code_id'] = promo_code_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if update_promo_code_request is not None:
+      _body_params = update_promo_code_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/promotion-codes/{promo_code_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/refunds_api.py` & `getopenpay-0.0.2/getopenpay/api/refunds_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,65 +7,57 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_refund_request import CreateRefundRequest
 from getopenpay.models.list_response_refund_external import ListResponseRefundExternal
 from getopenpay.models.refund_external import RefundExternal
 from getopenpay.models.refund_query_params import RefundQueryParams
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
 
 
 class RefundsApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_refund(
-        self,
-        create_refund_request: CreateRefundRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RefundExternal:
-        """Create Refund
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_refund(
+    self,
+    create_refund_request: CreateRefundRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RefundExternal:
+    """Create Refund
 
 
         :param create_refund_request: (required)
         :type create_refund_request: CreateRefundRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -84,56 +76,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_refund_serialize(
-            create_refund_request=create_refund_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "RefundExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_refund_with_http_info(
-        self,
-        create_refund_request: CreateRefundRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[RefundExternal]:
-        """Create Refund
+    _param = self._create_refund_serialize(
+      create_refund_request=create_refund_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'RefundExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_refund_with_http_info(
+    self,
+    create_refund_request: CreateRefundRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[RefundExternal]:
+    """Create Refund
 
 
         :param create_refund_request: (required)
         :type create_refund_request: CreateRefundRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -152,56 +134,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_refund_serialize(
-            create_refund_request=create_refund_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "RefundExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_refund_without_preload_content(
-        self,
-        create_refund_request: CreateRefundRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Refund
+    _param = self._create_refund_serialize(
+      create_refund_request=create_refund_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'RefundExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_refund_without_preload_content(
+    self,
+    create_refund_request: CreateRefundRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Refund
 
 
         :param create_refund_request: (required)
         :type create_refund_request: CreateRefundRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -220,127 +192,99 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_refund_serialize(
-            create_refund_request=create_refund_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '201': "RefundExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_refund_serialize(
-        self,
-        create_refund_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_refund_request is not None:
-            _body_params = create_refund_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/refunds/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_refunds(
-        self,
-        refund_query_params: RefundQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseRefundExternal:
-        """List Refunds
+    _param = self._create_refund_serialize(
+      create_refund_request=create_refund_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '201': 'RefundExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_refund_serialize(
+    self,
+    create_refund_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_refund_request is not None:
+      _body_params = create_refund_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/refunds/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_refunds(
+    self,
+    refund_query_params: RefundQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseRefundExternal:
+    """List Refunds
 
 
         :param refund_query_params: (required)
         :type refund_query_params: RefundQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -359,56 +303,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_refunds_serialize(
-            refund_query_params=refund_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseRefundExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_refunds_with_http_info(
-        self,
-        refund_query_params: RefundQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseRefundExternal]:
-        """List Refunds
+    _param = self._list_refunds_serialize(
+      refund_query_params=refund_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseRefundExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_refunds_with_http_info(
+    self,
+    refund_query_params: RefundQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseRefundExternal]:
+    """List Refunds
 
 
         :param refund_query_params: (required)
         :type refund_query_params: RefundQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -427,56 +361,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_refunds_serialize(
-            refund_query_params=refund_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseRefundExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_refunds_without_preload_content(
-        self,
-        refund_query_params: RefundQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Refunds
+    _param = self._list_refunds_serialize(
+      refund_query_params=refund_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseRefundExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_refunds_without_preload_content(
+    self,
+    refund_query_params: RefundQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Refunds
 
 
         :param refund_query_params: (required)
         :type refund_query_params: RefundQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -495,100 +419,78 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_refunds_serialize(
-            refund_query_params=refund_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseRefundExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_refunds_serialize(
-        self,
-        refund_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if refund_query_params is not None:
-            _body_params = refund_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/refunds/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._list_refunds_serialize(
+      refund_query_params=refund_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseRefundExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_refunds_serialize(
+    self,
+    refund_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if refund_query_params is not None:
+      _body_params = refund_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/refunds/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/subscription_items_api.py` & `getopenpay-0.0.2/getopenpay/api/subscription_items_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,72 +7,64 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_subscription_item_request import CreateSubscriptionItemRequest
 from getopenpay.models.delete_subscription_item_request import DeleteSubscriptionItemRequest
 from getopenpay.models.delete_subscription_item_response import DeleteSubscriptionItemResponse
-from getopenpay.models.list_response_subscription_item_external import ListResponseSubscriptionItemExternal
+from getopenpay.models.list_response_subscription_item_external import (
+  ListResponseSubscriptionItemExternal
+)
 from getopenpay.models.subscription_item_external import SubscriptionItemExternal
 from getopenpay.models.subscription_item_query_params import SubscriptionItemQueryParams
 from getopenpay.models.update_subscription_item_request import UpdateSubscriptionItemRequest
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class SubscriptionItemsApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_subscription_item(
-        self,
-        create_subscription_item_request: CreateSubscriptionItemRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SubscriptionItemExternal:
-        """Create Subscription Item
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_subscription_item(
+    self,
+    create_subscription_item_request: CreateSubscriptionItemRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> SubscriptionItemExternal:
+    """Create Subscription Item
 
         Adds a new item to an existing subscription. No existing items will be changed or replaced.
 
         :param create_subscription_item_request: (required)
         :type create_subscription_item_request: CreateSubscriptionItemRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -92,56 +84,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_subscription_item_serialize(
-            create_subscription_item_request=create_subscription_item_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_subscription_item_with_http_info(
-        self,
-        create_subscription_item_request: CreateSubscriptionItemRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SubscriptionItemExternal]:
-        """Create Subscription Item
+    _param = self._create_subscription_item_serialize(
+      create_subscription_item_request=create_subscription_item_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_subscription_item_with_http_info(
+    self,
+    create_subscription_item_request: CreateSubscriptionItemRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[SubscriptionItemExternal]:
+    """Create Subscription Item
 
         Adds a new item to an existing subscription. No existing items will be changed or replaced.
 
         :param create_subscription_item_request: (required)
         :type create_subscription_item_request: CreateSubscriptionItemRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -161,56 +143,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_subscription_item_serialize(
-            create_subscription_item_request=create_subscription_item_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_subscription_item_without_preload_content(
-        self,
-        create_subscription_item_request: CreateSubscriptionItemRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Subscription Item
+    _param = self._create_subscription_item_serialize(
+      create_subscription_item_request=create_subscription_item_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_subscription_item_without_preload_content(
+    self,
+    create_subscription_item_request: CreateSubscriptionItemRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Subscription Item
 
         Adds a new item to an existing subscription. No existing items will be changed or replaced.
 
         :param create_subscription_item_request: (required)
         :type create_subscription_item_request: CreateSubscriptionItemRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -230,128 +202,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_subscription_item_serialize(
-            create_subscription_item_request=create_subscription_item_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_subscription_item_serialize(
-        self,
-        create_subscription_item_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_subscription_item_request is not None:
-            _body_params = create_subscription_item_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/subscription-items/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def delete_subscription_item(
-        self,
-        subscription_item_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription_item.")],
-        delete_subscription_item_request: DeleteSubscriptionItemRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> DeleteSubscriptionItemResponse:
-        """Delete Subscription Item
+    _param = self._create_subscription_item_serialize(
+      create_subscription_item_request=create_subscription_item_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_subscription_item_serialize(
+    self,
+    create_subscription_item_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_subscription_item_request is not None:
+      _body_params = create_subscription_item_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/subscription-items/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def delete_subscription_item(
+    self,
+    subscription_item_id: Annotated[
+      StrictStr, Field(description='Unique identifier of the subscription_item.')],
+    delete_subscription_item_request: DeleteSubscriptionItemRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> DeleteSubscriptionItemResponse:
+    """Delete Subscription Item
 
         Deletes an item from the subscription. Removing a subscription item  from a subscription will not cancel the subscription. Default behaviour is to remove the subscription item at time of  renewing the subscription at next billing cycle. You can override  the behaviour by setting cancel_at_end as False. After successful call to this method with drop_at_end as True,  if you want to clear the flag, use update call with drop_at_end as False.
 
         :param subscription_item_id: Unique identifier of the subscription_item. (required)
         :type subscription_item_id: str
         :param delete_subscription_item_request: (required)
         :type delete_subscription_item_request: DeleteSubscriptionItemRequest
@@ -373,58 +318,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_subscription_item_serialize(
-            subscription_item_id=subscription_item_id,
-            delete_subscription_item_request=delete_subscription_item_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeleteSubscriptionItemResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def delete_subscription_item_with_http_info(
-        self,
-        subscription_item_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription_item.")],
-        delete_subscription_item_request: DeleteSubscriptionItemRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[DeleteSubscriptionItemResponse]:
-        """Delete Subscription Item
+    _param = self._delete_subscription_item_serialize(
+      subscription_item_id=subscription_item_id,
+      delete_subscription_item_request=delete_subscription_item_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeleteSubscriptionItemResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def delete_subscription_item_with_http_info(
+    self,
+    subscription_item_id: Annotated[
+      StrictStr, Field(description='Unique identifier of the subscription_item.')],
+    delete_subscription_item_request: DeleteSubscriptionItemRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[DeleteSubscriptionItemResponse]:
+    """Delete Subscription Item
 
         Deletes an item from the subscription. Removing a subscription item  from a subscription will not cancel the subscription. Default behaviour is to remove the subscription item at time of  renewing the subscription at next billing cycle. You can override  the behaviour by setting cancel_at_end as False. After successful call to this method with drop_at_end as True,  if you want to clear the flag, use update call with drop_at_end as False.
 
         :param subscription_item_id: Unique identifier of the subscription_item. (required)
         :type subscription_item_id: str
         :param delete_subscription_item_request: (required)
         :type delete_subscription_item_request: DeleteSubscriptionItemRequest
@@ -446,58 +382,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_subscription_item_serialize(
-            subscription_item_id=subscription_item_id,
-            delete_subscription_item_request=delete_subscription_item_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeleteSubscriptionItemResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def delete_subscription_item_without_preload_content(
-        self,
-        subscription_item_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription_item.")],
-        delete_subscription_item_request: DeleteSubscriptionItemRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Delete Subscription Item
+    _param = self._delete_subscription_item_serialize(
+      subscription_item_id=subscription_item_id,
+      delete_subscription_item_request=delete_subscription_item_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeleteSubscriptionItemResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def delete_subscription_item_without_preload_content(
+    self,
+    subscription_item_id: Annotated[
+      StrictStr, Field(description='Unique identifier of the subscription_item.')],
+    delete_subscription_item_request: DeleteSubscriptionItemRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Delete Subscription Item
 
         Deletes an item from the subscription. Removing a subscription item  from a subscription will not cancel the subscription. Default behaviour is to remove the subscription item at time of  renewing the subscription at next billing cycle. You can override  the behaviour by setting cancel_at_end as False. After successful call to this method with drop_at_end as True,  if you want to clear the flag, use update call with drop_at_end as False.
 
         :param subscription_item_id: Unique identifier of the subscription_item. (required)
         :type subscription_item_id: str
         :param delete_subscription_item_request: (required)
         :type delete_subscription_item_request: DeleteSubscriptionItemRequest
@@ -519,131 +446,104 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_subscription_item_serialize(
-            subscription_item_id=subscription_item_id,
-            delete_subscription_item_request=delete_subscription_item_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "DeleteSubscriptionItemResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _delete_subscription_item_serialize(
-        self,
-        subscription_item_id,
-        delete_subscription_item_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if subscription_item_id is not None:
-            _path_params['subscription_item_id'] = subscription_item_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if delete_subscription_item_request is not None:
-            _body_params = delete_subscription_item_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/subscription-items/{subscription_item_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_subscription_item(
-        self,
-        subscription_item_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription_item.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SubscriptionItemExternal:
-        """Get Subscription Item
+    _param = self._delete_subscription_item_serialize(
+      subscription_item_id=subscription_item_id,
+      delete_subscription_item_request=delete_subscription_item_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'DeleteSubscriptionItemResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _delete_subscription_item_serialize(
+    self,
+    subscription_item_id,
+    delete_subscription_item_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if subscription_item_id is not None:
+      _path_params['subscription_item_id'] = subscription_item_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if delete_subscription_item_request is not None:
+      _body_params = delete_subscription_item_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='DELETE',
+      resource_path='/subscription-items/{subscription_item_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def get_subscription_item(
+    self,
+    subscription_item_id: Annotated[
+      StrictStr, Field(description='Unique identifier of the subscription_item.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> SubscriptionItemExternal:
+    """Get Subscription Item
 
 
         :param subscription_item_id: Unique identifier of the subscription_item. (required)
         :type subscription_item_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -662,56 +562,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_subscription_item_serialize(
-            subscription_item_id=subscription_item_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def get_subscription_item_with_http_info(
-        self,
-        subscription_item_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription_item.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SubscriptionItemExternal]:
-        """Get Subscription Item
+    _param = self._get_subscription_item_serialize(
+      subscription_item_id=subscription_item_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def get_subscription_item_with_http_info(
+    self,
+    subscription_item_id: Annotated[
+      StrictStr, Field(description='Unique identifier of the subscription_item.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[SubscriptionItemExternal]:
+    """Get Subscription Item
 
 
         :param subscription_item_id: Unique identifier of the subscription_item. (required)
         :type subscription_item_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -730,56 +621,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_subscription_item_serialize(
-            subscription_item_id=subscription_item_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def get_subscription_item_without_preload_content(
-        self,
-        subscription_item_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription_item.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Subscription Item
+    _param = self._get_subscription_item_serialize(
+      subscription_item_id=subscription_item_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def get_subscription_item_without_preload_content(
+    self,
+    subscription_item_id: Annotated[
+      StrictStr, Field(description='Unique identifier of the subscription_item.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Subscription Item
 
 
         :param subscription_item_id: Unique identifier of the subscription_item. (required)
         :type subscription_item_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -798,114 +680,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_subscription_item_serialize(
-            subscription_item_id=subscription_item_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_subscription_item_serialize(
-        self,
-        subscription_item_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if subscription_item_id is not None:
-            _path_params['subscription_item_id'] = subscription_item_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/subscription-items/{subscription_item_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def list_subscription_items(
-        self,
-        subscription_item_query_params: SubscriptionItemQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseSubscriptionItemExternal:
-        """List Subscription Items
+    _param = self._get_subscription_item_serialize(
+      subscription_item_id=subscription_item_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _get_subscription_item_serialize(
+    self,
+    subscription_item_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if subscription_item_id is not None:
+      _path_params['subscription_item_id'] = subscription_item_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/subscription-items/{subscription_item_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def list_subscription_items(
+    self,
+    subscription_item_query_params: SubscriptionItemQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseSubscriptionItemExternal:
+    """List Subscription Items
 
 
         :param subscription_item_query_params: (required)
         :type subscription_item_query_params: SubscriptionItemQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -924,56 +783,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_subscription_items_serialize(
-            subscription_item_query_params=subscription_item_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseSubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_subscription_items_with_http_info(
-        self,
-        subscription_item_query_params: SubscriptionItemQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseSubscriptionItemExternal]:
-        """List Subscription Items
+    _param = self._list_subscription_items_serialize(
+      subscription_item_query_params=subscription_item_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseSubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_subscription_items_with_http_info(
+    self,
+    subscription_item_query_params: SubscriptionItemQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseSubscriptionItemExternal]:
+    """List Subscription Items
 
 
         :param subscription_item_query_params: (required)
         :type subscription_item_query_params: SubscriptionItemQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -992,56 +841,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_subscription_items_serialize(
-            subscription_item_query_params=subscription_item_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseSubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_subscription_items_without_preload_content(
-        self,
-        subscription_item_query_params: SubscriptionItemQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Subscription Items
+    _param = self._list_subscription_items_serialize(
+      subscription_item_query_params=subscription_item_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseSubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_subscription_items_without_preload_content(
+    self,
+    subscription_item_query_params: SubscriptionItemQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Subscription Items
 
 
         :param subscription_item_query_params: (required)
         :type subscription_item_query_params: SubscriptionItemQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1060,128 +899,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_subscription_items_serialize(
-            subscription_item_query_params=subscription_item_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseSubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_subscription_items_serialize(
-        self,
-        subscription_item_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if subscription_item_query_params is not None:
-            _body_params = subscription_item_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/subscription-items/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def update_subscription_item(
-        self,
-        subscription_item_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription_item.")],
-        update_subscription_item_request: UpdateSubscriptionItemRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SubscriptionItemExternal:
-        """Update Subscription Item
+    _param = self._list_subscription_items_serialize(
+      subscription_item_query_params=subscription_item_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseSubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_subscription_items_serialize(
+    self,
+    subscription_item_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if subscription_item_query_params is not None:
+      _body_params = subscription_item_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/subscription-items/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def update_subscription_item(
+    self,
+    subscription_item_id: Annotated[
+      StrictStr, Field(description='Unique identifier of the subscription_item.')],
+    update_subscription_item_request: UpdateSubscriptionItemRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> SubscriptionItemExternal:
+    """Update Subscription Item
 
 
         :param subscription_item_id: Unique identifier of the subscription_item. (required)
         :type subscription_item_id: str
         :param update_subscription_item_request: (required)
         :type update_subscription_item_request: UpdateSubscriptionItemRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1202,58 +1014,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_subscription_item_serialize(
-            subscription_item_id=subscription_item_id,
-            update_subscription_item_request=update_subscription_item_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def update_subscription_item_with_http_info(
-        self,
-        subscription_item_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription_item.")],
-        update_subscription_item_request: UpdateSubscriptionItemRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SubscriptionItemExternal]:
-        """Update Subscription Item
+    _param = self._update_subscription_item_serialize(
+      subscription_item_id=subscription_item_id,
+      update_subscription_item_request=update_subscription_item_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def update_subscription_item_with_http_info(
+    self,
+    subscription_item_id: Annotated[
+      StrictStr, Field(description='Unique identifier of the subscription_item.')],
+    update_subscription_item_request: UpdateSubscriptionItemRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[SubscriptionItemExternal]:
+    """Update Subscription Item
 
 
         :param subscription_item_id: Unique identifier of the subscription_item. (required)
         :type subscription_item_id: str
         :param update_subscription_item_request: (required)
         :type update_subscription_item_request: UpdateSubscriptionItemRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1274,58 +1077,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_subscription_item_serialize(
-            subscription_item_id=subscription_item_id,
-            update_subscription_item_request=update_subscription_item_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def update_subscription_item_without_preload_content(
-        self,
-        subscription_item_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription_item.")],
-        update_subscription_item_request: UpdateSubscriptionItemRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Update Subscription Item
+    _param = self._update_subscription_item_serialize(
+      subscription_item_id=subscription_item_id,
+      update_subscription_item_request=update_subscription_item_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def update_subscription_item_without_preload_content(
+    self,
+    subscription_item_id: Annotated[
+      StrictStr, Field(description='Unique identifier of the subscription_item.')],
+    update_subscription_item_request: UpdateSubscriptionItemRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Update Subscription Item
 
 
         :param subscription_item_id: Unique identifier of the subscription_item. (required)
         :type subscription_item_id: str
         :param update_subscription_item_request: (required)
         :type update_subscription_item_request: UpdateSubscriptionItemRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1346,104 +1140,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_subscription_item_serialize(
-            subscription_item_id=subscription_item_id,
-            update_subscription_item_request=update_subscription_item_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionItemExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _update_subscription_item_serialize(
-        self,
-        subscription_item_id,
-        update_subscription_item_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if subscription_item_id is not None:
-            _path_params['subscription_item_id'] = subscription_item_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if update_subscription_item_request is not None:
-            _body_params = update_subscription_item_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/subscription-items/{subscription_item_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._update_subscription_item_serialize(
+      subscription_item_id=subscription_item_id,
+      update_subscription_item_request=update_subscription_item_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionItemExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _update_subscription_item_serialize(
+    self,
+    subscription_item_id,
+    update_subscription_item_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if subscription_item_id is not None:
+      _path_params['subscription_item_id'] = subscription_item_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if update_subscription_item_request is not None:
+      _body_params = update_subscription_item_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/subscription-items/{subscription_item_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api/subscriptions_api.py` & `getopenpay-0.0.2/getopenpay/api/subscriptions_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,78 +7,68 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
+from typing import Any, Dict, List, Optional, Tuple, Union
 
-
-from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
-from typing import Dict, List, Optional, Tuple, Union, Any
+from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
 
 try:
-    from typing import Annotated
+  from typing import Annotated
 except ImportError:
-    from typing_extensions import Annotated
-
-from pydantic import Field
-from typing_extensions import Annotated
-from pydantic import StrictStr
+  from typing_extensions import Annotated
 
 from typing import Optional
 
+from getopenpay.api_client import ApiClient
+from getopenpay.api_response import ApiResponse
 from getopenpay.models.create_subscription_request import CreateSubscriptionRequest
 from getopenpay.models.create_subscription_response import CreateSubscriptionResponse
 from getopenpay.models.delete_subscription_request import DeleteSubscriptionRequest
 from getopenpay.models.list_response_subscription_external import ListResponseSubscriptionExternal
 from getopenpay.models.search_subscription_request import SearchSubscriptionRequest
 from getopenpay.models.subscription_external import SubscriptionExternal
 from getopenpay.models.subscription_pause_request import SubscriptionPauseRequest
 from getopenpay.models.subscription_query_params import SubscriptionQueryParams
 from getopenpay.models.subscription_resume_request import SubscriptionResumeRequest
 from getopenpay.models.update_subscription_request import UpdateSubscriptionRequest
 from getopenpay.models.update_subscription_response import UpdateSubscriptionResponse
-
-from getopenpay.api_client import ApiClient
-from getopenpay.api_response import ApiResponse
 from getopenpay.rest import RESTResponseType
+from pydantic import Field, StrictStr
+from typing_extensions import Annotated
 
 
 class SubscriptionsApi:
-    """NOTE: This class is auto generated by OpenAPI Generator
+  """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
-    def __init__(self, api_client=None) -> None:
-        if api_client is None:
-            api_client = ApiClient.get_default()
-        self.api_client = api_client
-
-
-    @validate_call
-    def create_subscriptions(
-        self,
-        create_subscription_request: CreateSubscriptionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> CreateSubscriptionResponse:
-        """Create Subscriptions
+  def __init__(self, api_client=None) -> None:
+    if api_client is None:
+      api_client = ApiClient.get_default()
+    self.api_client = api_client
+
+  @validate_call
+  def create_subscriptions(
+    self,
+    create_subscription_request: CreateSubscriptionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> CreateSubscriptionResponse:
+    """Create Subscriptions
 
 
         :param create_subscription_request: (required)
         :type create_subscription_request: CreateSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -97,56 +87,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_subscriptions_serialize(
-            create_subscription_request=create_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CreateSubscriptionResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def create_subscriptions_with_http_info(
-        self,
-        create_subscription_request: CreateSubscriptionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[CreateSubscriptionResponse]:
-        """Create Subscriptions
+    _param = self._create_subscriptions_serialize(
+      create_subscription_request=create_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CreateSubscriptionResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def create_subscriptions_with_http_info(
+    self,
+    create_subscription_request: CreateSubscriptionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[CreateSubscriptionResponse]:
+    """Create Subscriptions
 
 
         :param create_subscription_request: (required)
         :type create_subscription_request: CreateSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -165,56 +145,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_subscriptions_serialize(
-            create_subscription_request=create_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CreateSubscriptionResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def create_subscriptions_without_preload_content(
-        self,
-        create_subscription_request: CreateSubscriptionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Create Subscriptions
+    _param = self._create_subscriptions_serialize(
+      create_subscription_request=create_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CreateSubscriptionResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def create_subscriptions_without_preload_content(
+    self,
+    create_subscription_request: CreateSubscriptionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Create Subscriptions
 
 
         :param create_subscription_request: (required)
         :type create_subscription_request: CreateSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -233,128 +203,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._create_subscriptions_serialize(
-            create_subscription_request=create_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "CreateSubscriptionResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _create_subscriptions_serialize(
-        self,
-        create_subscription_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if create_subscription_request is not None:
-            _body_params = create_subscription_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/subscriptions/',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def delete_subscription(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        delete_subscription_request: Optional[DeleteSubscriptionRequest] = None,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SubscriptionExternal:
-        """Delete Subscription
+    _param = self._create_subscriptions_serialize(
+      create_subscription_request=create_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'CreateSubscriptionResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _create_subscriptions_serialize(
+    self,
+    create_subscription_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if create_subscription_request is not None:
+      _body_params = create_subscription_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/subscriptions/',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def delete_subscription(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    delete_subscription_request: Optional[DeleteSubscriptionRequest] = None,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> SubscriptionExternal:
+    """Delete Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param delete_subscription_request:
         :type delete_subscription_request: DeleteSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -375,58 +318,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_subscription_serialize(
-            subscription_id=subscription_id,
-            delete_subscription_request=delete_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def delete_subscription_with_http_info(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        delete_subscription_request: Optional[DeleteSubscriptionRequest] = None,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SubscriptionExternal]:
-        """Delete Subscription
+    _param = self._delete_subscription_serialize(
+      subscription_id=subscription_id,
+      delete_subscription_request=delete_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def delete_subscription_with_http_info(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    delete_subscription_request: Optional[DeleteSubscriptionRequest] = None,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[SubscriptionExternal]:
+    """Delete Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param delete_subscription_request:
         :type delete_subscription_request: DeleteSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -447,58 +381,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_subscription_serialize(
-            subscription_id=subscription_id,
-            delete_subscription_request=delete_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def delete_subscription_without_preload_content(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        delete_subscription_request: Optional[DeleteSubscriptionRequest] = None,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Delete Subscription
+    _param = self._delete_subscription_serialize(
+      subscription_id=subscription_id,
+      delete_subscription_request=delete_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def delete_subscription_without_preload_content(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    delete_subscription_request: Optional[DeleteSubscriptionRequest] = None,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Delete Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param delete_subscription_request:
         :type delete_subscription_request: DeleteSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -519,131 +444,104 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_subscription_serialize(
-            subscription_id=subscription_id,
-            delete_subscription_request=delete_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _delete_subscription_serialize(
-        self,
-        subscription_id,
-        delete_subscription_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
+    _param = self._delete_subscription_serialize(
+      subscription_id=subscription_id,
+      delete_subscription_request=delete_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
-        _host = None
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
 
-        _collection_formats: Dict[str, str] = {
-            
-        }
+  def _delete_subscription_serialize(
+    self,
+    subscription_id,
+    delete_subscription_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
 
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
+    _host = None
 
-        # process the path parameters
-        if subscription_id is not None:
-            _path_params['subscription_id'] = subscription_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if delete_subscription_request is not None:
-            _body_params = delete_subscription_request
+    _collection_formats: Dict[str, str] = {}
 
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
 
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
+    # process the path parameters
+    if subscription_id is not None:
+      _path_params['subscription_id'] = subscription_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if delete_subscription_request is not None:
+      _body_params = delete_subscription_request
 
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
 
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
 
-        return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/subscriptions/{subscription_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
 
+    return self.api_client.param_serialize(
+      method='DELETE',
+      resource_path='/subscriptions/{subscription_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
 
-
-
-    @validate_call
-    def delete_subscription_discount(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SubscriptionExternal:
-        """Delete Subscription Discount
+  @validate_call
+  def delete_subscription_discount(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> SubscriptionExternal:
+    """Delete Subscription Discount
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -662,56 +560,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_subscription_discount_serialize(
-            subscription_id=subscription_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
+    _param = self._delete_subscription_discount_serialize(
+      subscription_id=subscription_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
 
-    @validate_call
-    def delete_subscription_discount_with_http_info(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SubscriptionExternal]:
-        """Delete Subscription Discount
+  @validate_call
+  def delete_subscription_discount_with_http_info(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[SubscriptionExternal]:
+    """Delete Subscription Discount
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -730,56 +619,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_subscription_discount_serialize(
-            subscription_id=subscription_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
+    _param = self._delete_subscription_discount_serialize(
+      subscription_id=subscription_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
 
-
-    @validate_call
-    def delete_subscription_discount_without_preload_content(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Delete Subscription Discount
+  @validate_call
+  def delete_subscription_discount_without_preload_content(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Delete Subscription Discount
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -798,114 +678,92 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._delete_subscription_discount_serialize(
-            subscription_id=subscription_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
+    _param = self._delete_subscription_discount_serialize(
+      subscription_id=subscription_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
-    def _delete_subscription_discount_serialize(
-        self,
-        subscription_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
 
-        _host = None
+  def _delete_subscription_discount_serialize(
+    self,
+    subscription_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
 
-        _collection_formats: Dict[str, str] = {
-            
-        }
+    _host = None
 
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
+    _collection_formats: Dict[str, str] = {}
 
-        # process the path parameters
-        if subscription_id is not None:
-            _path_params['subscription_id'] = subscription_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
 
+    # process the path parameters
+    if subscription_id is not None:
+      _path_params['subscription_id'] = subscription_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
 
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
 
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
 
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
+    return self.api_client.param_serialize(
+      method='DELETE',
+      resource_path='/subscriptions/{subscription_id}/discount',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
 
-        return self.api_client.param_serialize(
-            method='DELETE',
-            resource_path='/subscriptions/{subscription_id}/discount',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def get_subscription(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SubscriptionExternal:
-        """Get Subscription
+  @validate_call
+  def get_subscription(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> SubscriptionExternal:
+    """Get Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -924,56 +782,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_subscription_serialize(
-            subscription_id=subscription_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
+    _param = self._get_subscription_serialize(
+      subscription_id=subscription_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
 
-    @validate_call
-    def get_subscription_with_http_info(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SubscriptionExternal]:
-        """Get Subscription
+  @validate_call
+  def get_subscription_with_http_info(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[SubscriptionExternal]:
+    """Get Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -992,56 +841,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_subscription_serialize(
-            subscription_id=subscription_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
+    _param = self._get_subscription_serialize(
+      subscription_id=subscription_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
 
-
-    @validate_call
-    def get_subscription_without_preload_content(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Get Subscription
+  @validate_call
+  def get_subscription_without_preload_content(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Get Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1060,114 +900,91 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._get_subscription_serialize(
-            subscription_id=subscription_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _get_subscription_serialize(
-        self,
-        subscription_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
+    _param = self._get_subscription_serialize(
+      subscription_id=subscription_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
 
-        # process the path parameters
-        if subscription_id is not None:
-            _path_params['subscription_id'] = subscription_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
+  def _get_subscription_serialize(
+    self,
+    subscription_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
 
+    _host = None
 
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
+    _collection_formats: Dict[str, str] = {}
 
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
 
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
+    # process the path parameters
+    if subscription_id is not None:
+      _path_params['subscription_id'] = subscription_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
 
-        return self.api_client.param_serialize(
-            method='GET',
-            resource_path='/subscriptions/{subscription_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
 
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
 
+    return self.api_client.param_serialize(
+      method='GET',
+      resource_path='/subscriptions/{subscription_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
 
-
-    @validate_call
-    def list_subscriptions(
-        self,
-        subscription_query_params: SubscriptionQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseSubscriptionExternal:
-        """List Subscriptions
+  @validate_call
+  def list_subscriptions(
+    self,
+    subscription_query_params: SubscriptionQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseSubscriptionExternal:
+    """List Subscriptions
 
 
         :param subscription_query_params: (required)
         :type subscription_query_params: SubscriptionQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1186,56 +1003,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_subscriptions_serialize(
-            subscription_query_params=subscription_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseSubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def list_subscriptions_with_http_info(
-        self,
-        subscription_query_params: SubscriptionQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseSubscriptionExternal]:
-        """List Subscriptions
+    _param = self._list_subscriptions_serialize(
+      subscription_query_params=subscription_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseSubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def list_subscriptions_with_http_info(
+    self,
+    subscription_query_params: SubscriptionQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseSubscriptionExternal]:
+    """List Subscriptions
 
 
         :param subscription_query_params: (required)
         :type subscription_query_params: SubscriptionQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1254,56 +1061,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_subscriptions_serialize(
-            subscription_query_params=subscription_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseSubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def list_subscriptions_without_preload_content(
-        self,
-        subscription_query_params: SubscriptionQueryParams,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """List Subscriptions
+    _param = self._list_subscriptions_serialize(
+      subscription_query_params=subscription_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseSubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def list_subscriptions_without_preload_content(
+    self,
+    subscription_query_params: SubscriptionQueryParams,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """List Subscriptions
 
 
         :param subscription_query_params: (required)
         :type subscription_query_params: SubscriptionQueryParams
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1322,128 +1119,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._list_subscriptions_serialize(
-            subscription_query_params=subscription_query_params,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseSubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _list_subscriptions_serialize(
-        self,
-        subscription_query_params,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if subscription_query_params is not None:
-            _body_params = subscription_query_params
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/subscriptions/list',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def pause_subscription(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        subscription_pause_request: SubscriptionPauseRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SubscriptionExternal:
-        """Pause Subscription
+    _param = self._list_subscriptions_serialize(
+      subscription_query_params=subscription_query_params,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseSubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _list_subscriptions_serialize(
+    self,
+    subscription_query_params,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if subscription_query_params is not None:
+      _body_params = subscription_query_params
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/subscriptions/list',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def pause_subscription(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    subscription_pause_request: SubscriptionPauseRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> SubscriptionExternal:
+    """Pause Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param subscription_pause_request: (required)
         :type subscription_pause_request: SubscriptionPauseRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1464,58 +1234,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._pause_subscription_serialize(
-            subscription_id=subscription_id,
-            subscription_pause_request=subscription_pause_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def pause_subscription_with_http_info(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        subscription_pause_request: SubscriptionPauseRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SubscriptionExternal]:
-        """Pause Subscription
+    _param = self._pause_subscription_serialize(
+      subscription_id=subscription_id,
+      subscription_pause_request=subscription_pause_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def pause_subscription_with_http_info(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    subscription_pause_request: SubscriptionPauseRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[SubscriptionExternal]:
+    """Pause Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param subscription_pause_request: (required)
         :type subscription_pause_request: SubscriptionPauseRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1536,58 +1297,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._pause_subscription_serialize(
-            subscription_id=subscription_id,
-            subscription_pause_request=subscription_pause_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def pause_subscription_without_preload_content(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        subscription_pause_request: SubscriptionPauseRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Pause Subscription
+    _param = self._pause_subscription_serialize(
+      subscription_id=subscription_id,
+      subscription_pause_request=subscription_pause_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def pause_subscription_without_preload_content(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    subscription_pause_request: SubscriptionPauseRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Pause Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param subscription_pause_request: (required)
         :type subscription_pause_request: SubscriptionPauseRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -1608,131 +1360,104 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._pause_subscription_serialize(
-            subscription_id=subscription_id,
-            subscription_pause_request=subscription_pause_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _pause_subscription_serialize(
-        self,
-        subscription_id,
-        subscription_pause_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
+    _param = self._pause_subscription_serialize(
+      subscription_id=subscription_id,
+      subscription_pause_request=subscription_pause_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
-        _collection_formats: Dict[str, str] = {
-            
-        }
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
 
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
+  def _pause_subscription_serialize(
+    self,
+    subscription_id,
+    subscription_pause_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
 
-        # process the path parameters
-        if subscription_id is not None:
-            _path_params['subscription_id'] = subscription_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if subscription_pause_request is not None:
-            _body_params = subscription_pause_request
+    _host = None
 
+    _collection_formats: Dict[str, str] = {}
 
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
 
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
+    # process the path parameters
+    if subscription_id is not None:
+      _path_params['subscription_id'] = subscription_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if subscription_pause_request is not None:
+      _body_params = subscription_pause_request
 
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
 
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/subscriptions/{subscription_id}/pause',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
 
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
 
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/subscriptions/{subscription_id}/pause',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
 
-
-    @validate_call
-    def refresh_subscription_status(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SubscriptionExternal:
-        """Refresh Subscription Status
+  @validate_call
+  def refresh_subscription_status(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> SubscriptionExternal:
+    """Refresh Subscription Status
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1751,56 +1476,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._refresh_subscription_status_serialize(
-            subscription_id=subscription_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
+    _param = self._refresh_subscription_status_serialize(
+      subscription_id=subscription_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
 
-    @validate_call
-    def refresh_subscription_status_with_http_info(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SubscriptionExternal]:
-        """Refresh Subscription Status
+  @validate_call
+  def refresh_subscription_status_with_http_info(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[SubscriptionExternal]:
+    """Refresh Subscription Status
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1819,56 +1535,47 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._refresh_subscription_status_serialize(
-            subscription_id=subscription_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
+    _param = self._refresh_subscription_status_serialize(
+      subscription_id=subscription_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
 
-    @validate_call
-    def refresh_subscription_status_without_preload_content(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Refresh Subscription Status
+  @validate_call
+  def refresh_subscription_status_without_preload_content(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Refresh Subscription Status
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -1887,115 +1594,93 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._refresh_subscription_status_serialize(
-            subscription_id=subscription_id,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _refresh_subscription_status_serialize(
-        self,
-        subscription_id,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
+    _param = self._refresh_subscription_status_serialize(
+      subscription_id=subscription_id,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
 
-        _host = None
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
 
-        _collection_formats: Dict[str, str] = {
-            
-        }
+  def _refresh_subscription_status_serialize(
+    self,
+    subscription_id,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
 
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
+    _host = None
 
-        # process the path parameters
-        if subscription_id is not None:
-            _path_params['subscription_id'] = subscription_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
+    _collection_formats: Dict[str, str] = {}
 
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
 
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
+    # process the path parameters
+    if subscription_id is not None:
+      _path_params['subscription_id'] = subscription_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
 
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
 
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
 
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/subscriptions/{subscription_id}/refresh-status',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/subscriptions/{subscription_id}/refresh-status',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
 
-
-
-
-    @validate_call
-    def resume_subscription(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        subscription_resume_request: SubscriptionResumeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> SubscriptionExternal:
-        """Resume Subscription
+  @validate_call
+  def resume_subscription(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    subscription_resume_request: SubscriptionResumeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> SubscriptionExternal:
+    """Resume Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param subscription_resume_request: (required)
         :type subscription_resume_request: SubscriptionResumeRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2016,58 +1701,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._resume_subscription_serialize(
-            subscription_id=subscription_id,
-            subscription_resume_request=subscription_resume_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def resume_subscription_with_http_info(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        subscription_resume_request: SubscriptionResumeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[SubscriptionExternal]:
-        """Resume Subscription
+    _param = self._resume_subscription_serialize(
+      subscription_id=subscription_id,
+      subscription_resume_request=subscription_resume_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def resume_subscription_with_http_info(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    subscription_resume_request: SubscriptionResumeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[SubscriptionExternal]:
+    """Resume Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param subscription_resume_request: (required)
         :type subscription_resume_request: SubscriptionResumeRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2088,58 +1764,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._resume_subscription_serialize(
-            subscription_id=subscription_id,
-            subscription_resume_request=subscription_resume_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def resume_subscription_without_preload_content(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        subscription_resume_request: SubscriptionResumeRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Resume Subscription
+    _param = self._resume_subscription_serialize(
+      subscription_id=subscription_id,
+      subscription_resume_request=subscription_resume_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def resume_subscription_without_preload_content(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    subscription_resume_request: SubscriptionResumeRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Resume Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param subscription_resume_request: (required)
         :type subscription_resume_request: SubscriptionResumeRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2160,131 +1827,103 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._resume_subscription_serialize(
-            subscription_id=subscription_id,
-            subscription_resume_request=subscription_resume_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "SubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _resume_subscription_serialize(
-        self,
-        subscription_id,
-        subscription_resume_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if subscription_id is not None:
-            _path_params['subscription_id'] = subscription_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if subscription_resume_request is not None:
-            _body_params = subscription_resume_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/subscriptions/{subscription_id}/resume',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def search_subscriptions(
-        self,
-        search_subscription_request: SearchSubscriptionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ListResponseSubscriptionExternal:
-        """Search Subscriptions
+    _param = self._resume_subscription_serialize(
+      subscription_id=subscription_id,
+      subscription_resume_request=subscription_resume_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'SubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _resume_subscription_serialize(
+    self,
+    subscription_id,
+    subscription_resume_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if subscription_id is not None:
+      _path_params['subscription_id'] = subscription_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if subscription_resume_request is not None:
+      _body_params = subscription_resume_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/subscriptions/{subscription_id}/resume',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def search_subscriptions(
+    self,
+    search_subscription_request: SearchSubscriptionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ListResponseSubscriptionExternal:
+    """Search Subscriptions
 
 
         :param search_subscription_request: (required)
         :type search_subscription_request: SearchSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2303,56 +1942,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_subscriptions_serialize(
-            search_subscription_request=search_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseSubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def search_subscriptions_with_http_info(
-        self,
-        search_subscription_request: SearchSubscriptionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[ListResponseSubscriptionExternal]:
-        """Search Subscriptions
+    _param = self._search_subscriptions_serialize(
+      search_subscription_request=search_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseSubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def search_subscriptions_with_http_info(
+    self,
+    search_subscription_request: SearchSubscriptionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[ListResponseSubscriptionExternal]:
+    """Search Subscriptions
 
 
         :param search_subscription_request: (required)
         :type search_subscription_request: SearchSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2371,56 +2000,46 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_subscriptions_serialize(
-            search_subscription_request=search_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseSubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def search_subscriptions_without_preload_content(
-        self,
-        search_subscription_request: SearchSubscriptionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Search Subscriptions
+    _param = self._search_subscriptions_serialize(
+      search_subscription_request=search_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseSubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def search_subscriptions_without_preload_content(
+    self,
+    search_subscription_request: SearchSubscriptionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Search Subscriptions
 
 
         :param search_subscription_request: (required)
         :type search_subscription_request: SearchSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
@@ -2439,128 +2058,101 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._search_subscriptions_serialize(
-            search_subscription_request=search_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "ListResponseSubscriptionExternal",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _search_subscriptions_serialize(
-        self,
-        search_subscription_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if search_subscription_request is not None:
-            _body_params = search_subscription_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='POST',
-            resource_path='/subscriptions/search',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
-
-
-    @validate_call
-    def update_subscription(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        update_subscription_request: UpdateSubscriptionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> UpdateSubscriptionResponse:
-        """Update Subscription
+    _param = self._search_subscriptions_serialize(
+      search_subscription_request=search_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'ListResponseSubscriptionExternal',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _search_subscriptions_serialize(
+    self,
+    search_subscription_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if search_subscription_request is not None:
+      _body_params = search_subscription_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='POST',
+      resource_path='/subscriptions/search',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
+
+  @validate_call
+  def update_subscription(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    update_subscription_request: UpdateSubscriptionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> UpdateSubscriptionResponse:
+    """Update Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param update_subscription_request: (required)
         :type update_subscription_request: UpdateSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2581,58 +2173,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_subscription_serialize(
-            subscription_id=subscription_id,
-            update_subscription_request=update_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UpdateSubscriptionResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        ).data
-
-
-    @validate_call
-    def update_subscription_with_http_info(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        update_subscription_request: UpdateSubscriptionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> ApiResponse[UpdateSubscriptionResponse]:
-        """Update Subscription
+    _param = self._update_subscription_serialize(
+      subscription_id=subscription_id,
+      update_subscription_request=update_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'UpdateSubscriptionResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    ).data
+
+  @validate_call
+  def update_subscription_with_http_info(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    update_subscription_request: UpdateSubscriptionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> ApiResponse[UpdateSubscriptionResponse]:
+    """Update Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param update_subscription_request: (required)
         :type update_subscription_request: UpdateSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2653,58 +2236,49 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_subscription_serialize(
-            subscription_id=subscription_id,
-            update_subscription_request=update_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UpdateSubscriptionResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        response_data.read()
-        return self.api_client.response_deserialize(
-            response_data=response_data,
-            response_types_map=_response_types_map,
-        )
-
-
-    @validate_call
-    def update_subscription_without_preload_content(
-        self,
-        subscription_id: Annotated[StrictStr, Field(description="Unique identifier of the subscription.")],
-        update_subscription_request: UpdateSubscriptionRequest,
-        _request_timeout: Union[
-            None,
-            Annotated[StrictFloat, Field(gt=0)],
-            Tuple[
-                Annotated[StrictFloat, Field(gt=0)],
-                Annotated[StrictFloat, Field(gt=0)]
-            ]
-        ] = None,
-        _request_auth: Optional[Dict[StrictStr, Any]] = None,
-        _content_type: Optional[StrictStr] = None,
-        _headers: Optional[Dict[StrictStr, Any]] = None,
-        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
-    ) -> RESTResponseType:
-        """Update Subscription
+    _param = self._update_subscription_serialize(
+      subscription_id=subscription_id,
+      update_subscription_request=update_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'UpdateSubscriptionResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    response_data.read()
+    return self.api_client.response_deserialize(
+      response_data=response_data,
+      response_types_map=_response_types_map,
+    )
+
+  @validate_call
+  def update_subscription_without_preload_content(
+    self,
+    subscription_id: Annotated[StrictStr,
+                               Field(description='Unique identifier of the subscription.')],
+    update_subscription_request: UpdateSubscriptionRequest,
+    _request_timeout: Union[None, Annotated[StrictFloat, Field(gt=0)],
+                            Tuple[Annotated[StrictFloat, Field(gt=0)],
+                                  Annotated[StrictFloat, Field(gt=0)]]] = None,
+    _request_auth: Optional[Dict[StrictStr, Any]] = None,
+    _content_type: Optional[StrictStr] = None,
+    _headers: Optional[Dict[StrictStr, Any]] = None,
+    _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
+  ) -> RESTResponseType:
+    """Update Subscription
 
 
         :param subscription_id: Unique identifier of the subscription. (required)
         :type subscription_id: str
         :param update_subscription_request: (required)
         :type update_subscription_request: UpdateSubscriptionRequest
         :param _request_timeout: timeout setting for this request. If one
@@ -2725,104 +2299,82 @@
         :param _host_index: set to override the host_index for a single
                             request; this effectively ignores the host_index
                             in the spec for a single request.
         :type _host_index: int, optional
         :return: Returns the result object.
         """ # noqa: E501
 
-        _param = self._update_subscription_serialize(
-            subscription_id=subscription_id,
-            update_subscription_request=update_subscription_request,
-            _request_auth=_request_auth,
-            _content_type=_content_type,
-            _headers=_headers,
-            _host_index=_host_index
-        )
-
-        _response_types_map: Dict[str, Optional[str]] = {
-            '200': "UpdateSubscriptionResponse",
-            '422': "HTTPValidationError"
-            
-        }
-        response_data = self.api_client.call_api(
-            *_param,
-            _request_timeout=_request_timeout
-        )
-        return response_data.response
-
-
-    def _update_subscription_serialize(
-        self,
-        subscription_id,
-        update_subscription_request,
-        _request_auth,
-        _content_type,
-        _headers,
-        _host_index,
-    ) -> Tuple:
-
-        _host = None
-
-        _collection_formats: Dict[str, str] = {
-            
-        }
-
-        _path_params: Dict[str, str] = {}
-        _query_params: List[Tuple[str, str]] = []
-        _header_params: Dict[str, Optional[str]] = _headers or {}
-        _form_params: List[Tuple[str, str]] = []
-        _files: Dict[str, str] = {}
-        _body_params: Optional[bytes] = None
-
-        # process the path parameters
-        if subscription_id is not None:
-            _path_params['subscription_id'] = subscription_id
-        # process the query parameters
-        # process the header parameters
-        # process the form parameters
-        # process the body parameter
-        if update_subscription_request is not None:
-            _body_params = update_subscription_request
-
-
-        # set the HTTP header `Accept`
-        _header_params['Accept'] = self.api_client.select_header_accept(
-            [
-                'application/json'
-            ]
-        )
-
-        # set the HTTP header `Content-Type`
-        if _content_type:
-            _header_params['Content-Type'] = _content_type
-        else:
-            _default_content_type = (
-                self.api_client.select_header_content_type(
-                    [
-                        'application/json'
-                    ]
-                )
-            )
-            if _default_content_type is not None:
-                _header_params['Content-Type'] = _default_content_type
-
-        # authentication setting
-        _auth_settings: List[str] = [
-            'HTTPBearer'
-        ]
-
-        return self.api_client.param_serialize(
-            method='PUT',
-            resource_path='/subscriptions/{subscription_id}',
-            path_params=_path_params,
-            query_params=_query_params,
-            header_params=_header_params,
-            body=_body_params,
-            post_params=_form_params,
-            files=_files,
-            auth_settings=_auth_settings,
-            collection_formats=_collection_formats,
-            _host=_host,
-            _request_auth=_request_auth
-        )
-
-
+    _param = self._update_subscription_serialize(
+      subscription_id=subscription_id,
+      update_subscription_request=update_subscription_request,
+      _request_auth=_request_auth,
+      _content_type=_content_type,
+      _headers=_headers,
+      _host_index=_host_index
+    )
+
+    _response_types_map: Dict[str, Optional[str]] = {
+      '200': 'UpdateSubscriptionResponse',
+      '422': 'HTTPValidationError'
+    }
+    response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
+    return response_data.response
+
+  def _update_subscription_serialize(
+    self,
+    subscription_id,
+    update_subscription_request,
+    _request_auth,
+    _content_type,
+    _headers,
+    _host_index,
+  ) -> Tuple:
+
+    _host = None
+
+    _collection_formats: Dict[str, str] = {}
+
+    _path_params: Dict[str, str] = {}
+    _query_params: List[Tuple[str, str]] = []
+    _header_params: Dict[str, Optional[str]] = _headers or {}
+    _form_params: List[Tuple[str, str]] = []
+    _files: Dict[str, str] = {}
+    _body_params: Optional[bytes] = None
+
+    # process the path parameters
+    if subscription_id is not None:
+      _path_params['subscription_id'] = subscription_id
+    # process the query parameters
+    # process the header parameters
+    # process the form parameters
+    # process the body parameter
+    if update_subscription_request is not None:
+      _body_params = update_subscription_request
+
+    # set the HTTP header `Accept`
+    _header_params['Accept'] = self.api_client.select_header_accept(['application/json'])
+
+    # set the HTTP header `Content-Type`
+    if _content_type:
+      _header_params['Content-Type'] = _content_type
+    else:
+      _default_content_type = (self.api_client.select_header_content_type(['application/json']))
+      if _default_content_type is not None:
+        _header_params['Content-Type'] = _default_content_type
+
+    # authentication setting
+    _auth_settings: List[str] = ['HTTPBearer']
+
+    return self.api_client.param_serialize(
+      method='PUT',
+      resource_path='/subscriptions/{subscription_id}',
+      path_params=_path_params,
+      query_params=_query_params,
+      header_params=_header_params,
+      body=_body_params,
+      post_params=_form_params,
+      files=_files,
+      auth_settings=_auth_settings,
+      collection_formats=_collection_formats,
+      _host=_host,
+      _request_auth=_request_auth
+    )
```

### Comparing `getopenpay-0.0.1/getopenpay/api_client.py` & `getopenpay-0.0.2/getopenpay/api_client.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,152 +7,138 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 import datetime
-from dateutil.parser import parse
 import json
 import mimetypes
 import os
 import re
 import tempfile
-
+from typing import List, Optional, Tuple
 from urllib.parse import quote
-from typing import Tuple, Optional, List
 
-from getopenpay.configuration import Configuration
-from getopenpay.api_response import ApiResponse
 import getopenpay.models
+from dateutil.parser import parse
 from getopenpay import rest
+from getopenpay.api_response import ApiResponse
+from getopenpay.configuration import Configuration
 from getopenpay.exceptions import (
-    ApiValueError,
-    ApiException,
-    BadRequestException,
-    UnauthorizedException,
-    ForbiddenException,
-    NotFoundException,
-    ServiceException
+  ApiException, ApiValueError, BadRequestException, ForbiddenException, NotFoundException,
+  ServiceException, UnauthorizedException
 )
 
 
 class ApiClient:
-    """Generic API client for OpenAPI client library builds.
+  """Generic API client for OpenAPI client library builds.
 
     OpenAPI generic API client. This client handles the client-
     server communication, and is invariant across implementations. Specifics of
     the methods and models for each application are generated from the OpenAPI
     templates.
 
     :param configuration: .Configuration object for this client
     :param header_name: a header to pass when making calls to the API.
     :param header_value: a header value to pass when making calls to
         the API.
     :param cookie: a cookie to include in the header when making calls
         to the API
     """
 
-    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
-    NATIVE_TYPES_MAPPING = {
-        'int': int,
-        'long': int, # TODO remove as only py3 is supported?
-        'float': float,
-        'str': str,
-        'bool': bool,
-        'date': datetime.date,
-        'datetime': datetime.datetime,
-        'object': object,
-    }
-    _pool = None
-
-    def __init__(
-        self,
-        configuration=None,
-        header_name=None,
-        header_value=None,
-        cookie=None
-    ) -> None:
-        # use default configuration if none is provided
-        if configuration is None:
-            configuration = Configuration.get_default()
-        self.configuration = configuration
-
-        self.rest_client = rest.RESTClientObject(configuration)
-        self.default_headers = {}
-        if header_name is not None:
-            self.default_headers[header_name] = header_value
-        self.cookie = cookie
-        # Set default User-Agent.
-        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
-        self.client_side_validation = configuration.client_side_validation
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, exc_type, exc_value, traceback):
-        pass
-
-    @property
-    def user_agent(self):
-        """User agent for this API client"""
-        return self.default_headers['User-Agent']
-
-    @user_agent.setter
-    def user_agent(self, value):
-        self.default_headers['User-Agent'] = value
-
-    def set_default_header(self, header_name, header_value):
-        self.default_headers[header_name] = header_value
-
-
-    _default = None
-
-    @classmethod
-    def get_default(cls):
-        """Return new instance of ApiClient.
+  PRIMITIVE_TYPES = (float, bool, bytes, str, int)
+  NATIVE_TYPES_MAPPING = {
+    'int': int,
+    'long': int,  # TODO remove as only py3 is supported?
+    'float': float,
+    'str': str,
+    'bool': bool,
+    'date': datetime.date,
+    'datetime': datetime.datetime,
+    'object': object,
+  }
+  _pool = None
+
+  def __init__(self, configuration=None, header_name=None, header_value=None, cookie=None) -> None:
+    # use default configuration if none is provided
+    if configuration is None:
+      configuration = Configuration.get_default()
+    self.configuration = configuration
+
+    self.rest_client = rest.RESTClientObject(configuration)
+    self.default_headers = {}
+    if header_name is not None:
+      self.default_headers[header_name] = header_value
+    self.cookie = cookie
+    # Set default User-Agent.
+    self.user_agent = 'OpenAPI-Generator/1.0.0/python'
+    self.client_side_validation = configuration.client_side_validation
+
+  def __enter__(self):
+    return self
+
+  def __exit__(self, exc_type, exc_value, traceback):
+    pass
+
+  @property
+  def user_agent(self):
+    """User agent for this API client"""
+    return self.default_headers['User-Agent']
+
+  @user_agent.setter
+  def user_agent(self, value):
+    self.default_headers['User-Agent'] = value
+
+  def set_default_header(self, header_name, header_value):
+    self.default_headers[header_name] = header_value
+
+  _default = None
+
+  @classmethod
+  def get_default(cls):
+    """Return new instance of ApiClient.
 
         This method returns newly created, based on default constructor,
         object of ApiClient class or returns a copy of default
         ApiClient.
 
         :return: The ApiClient object.
         """
-        if cls._default is None:
-            cls._default = ApiClient()
-        return cls._default
-
-    @classmethod
-    def set_default(cls, default):
-        """Set default instance of ApiClient.
+    if cls._default is None:
+      cls._default = ApiClient()
+    return cls._default
+
+  @classmethod
+  def set_default(cls, default):
+    """Set default instance of ApiClient.
 
         It stores default ApiClient.
 
         :param default: object of ApiClient.
         """
-        cls._default = default
+    cls._default = default
 
-    def param_serialize(
-        self,
-        method,
-        resource_path,
-        path_params=None,
-        query_params=None,
-        header_params=None,
-        body=None,
-        post_params=None,
-        files=None, auth_settings=None,
-        collection_formats=None,
-        _host=None,
-        _request_auth=None
-    ) -> Tuple:
-
-        """Builds the HTTP request params needed by the request.
+  def param_serialize(
+    self,
+    method,
+    resource_path,
+    path_params=None,
+    query_params=None,
+    header_params=None,
+    body=None,
+    post_params=None,
+    files=None,
+    auth_settings=None,
+    collection_formats=None,
+    _host=None,
+    _request_auth=None
+  ) -> Tuple:
+    """Builds the HTTP request params needed by the request.
         :param method: Method to call.
         :param resource_path: Path to method endpoint.
         :param path_params: Path parameters in the url.
         :param query_params: Query parameters in the url.
         :param header_params: Header parameters to be
             placed in the request header.
         :param body: Request body.
@@ -166,575 +152,504 @@
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
         :return: tuple of form (path, http_method, query_params, header_params,
             body, post_params, files)
         """
 
-        config = self.configuration
+    config = self.configuration
 
-        # header parameters
-        header_params = header_params or {}
-        header_params.update(self.default_headers)
-        if self.cookie:
-            header_params['Cookie'] = self.cookie
-        if header_params:
-            header_params = self.sanitize_for_serialization(header_params)
-            header_params = dict(
-                self.parameters_to_tuples(header_params,collection_formats)
-            )
-
-        # path parameters
-        if path_params:
-            path_params = self.sanitize_for_serialization(path_params)
-            path_params = self.parameters_to_tuples(
-                path_params,
-                collection_formats
-            )
-            for k, v in path_params:
-                # specified safe chars, encode everything
-                resource_path = resource_path.replace(
-                    '{%s}' % k,
-                    quote(str(v), safe=config.safe_chars_for_path_param)
-                )
-
-        # post parameters
-        if post_params or files:
-            post_params = post_params if post_params else []
-            post_params = self.sanitize_for_serialization(post_params)
-            post_params = self.parameters_to_tuples(
-                post_params,
-                collection_formats
-            )
-            post_params.extend(self.files_parameters(files))
-
-        # auth setting
-        self.update_params_for_auth(
-            header_params,
-            query_params,
-            auth_settings,
-            resource_path,
-            method,
-            body,
-            request_auth=_request_auth
+    # header parameters
+    header_params = header_params or {}
+    header_params.update(self.default_headers)
+    if self.cookie:
+      header_params['Cookie'] = self.cookie
+    if header_params:
+      header_params = self.sanitize_for_serialization(header_params)
+      header_params = dict(self.parameters_to_tuples(header_params, collection_formats))
+
+    # path parameters
+    if path_params:
+      path_params = self.sanitize_for_serialization(path_params)
+      path_params = self.parameters_to_tuples(path_params, collection_formats)
+      for k, v in path_params:
+        # specified safe chars, encode everything
+        resource_path = resource_path.replace(
+          '{%s}' % k, quote(str(v), safe=config.safe_chars_for_path_param)
         )
 
-        # body
-        if body:
-            body = self.sanitize_for_serialization(body)
-
-        # request url
-        if _host is None:
-            url = self.configuration.host + resource_path
-        else:
-            # use server/host defined in path or operation instead
-            url = _host + resource_path
-
-        # query parameters
-        if query_params:
-            query_params = self.sanitize_for_serialization(query_params)
-            url_query = self.parameters_to_url_query(
-                query_params,
-                collection_formats
-            )
-            url += "?" + url_query
-
-        return method, url, header_params, body, post_params
-
-
-    def call_api(
-        self,
-        method,
-        url,
-        header_params=None,
-        body=None,
-        post_params=None,
-        _request_timeout=None
-    ) -> rest.RESTResponse:
-        """Makes the HTTP request (synchronous)
+    # post parameters
+    if post_params or files:
+      post_params = post_params if post_params else []
+      post_params = self.sanitize_for_serialization(post_params)
+      post_params = self.parameters_to_tuples(post_params, collection_formats)
+      post_params.extend(self.files_parameters(files))
+
+    # auth setting
+    self.update_params_for_auth(
+      header_params,
+      query_params,
+      auth_settings,
+      resource_path,
+      method,
+      body,
+      request_auth=_request_auth
+    )
+
+    # body
+    if body:
+      body = self.sanitize_for_serialization(body)
+
+    # request url
+    if _host is None:
+      url = self.configuration.host + resource_path
+    else:
+      # use server/host defined in path or operation instead
+      url = _host + resource_path
+
+    # query parameters
+    if query_params:
+      query_params = self.sanitize_for_serialization(query_params)
+      url_query = self.parameters_to_url_query(query_params, collection_formats)
+      url += '?' + url_query
+
+    return method, url, header_params, body, post_params
+
+  def call_api(
+    self,
+    method,
+    url,
+    header_params=None,
+    body=None,
+    post_params=None,
+    _request_timeout=None
+  ) -> rest.RESTResponse:
+    """Makes the HTTP request (synchronous)
         :param method: Method to call.
         :param url: Path to method endpoint.
         :param header_params: Header parameters to be
             placed in the request header.
         :param body: Request body.
         :param post_params dict: Request post form parameters,
             for `application/x-www-form-urlencoded`, `multipart/form-data`.
         :param _request_timeout: timeout setting for this request.
         :return: RESTResponse
         """
 
-        try:
-            # perform request and return response
-            response_data = self.rest_client.request(
-                method, url,
-                headers=header_params,
-                body=body, post_params=post_params,
-                _request_timeout=_request_timeout
-            )
-
-        except ApiException as e:
-            if e.body:
-                e.body = e.body.decode('utf-8')
-            raise e
-
-        return response_data
-
-    def response_deserialize(
-        self,
-        response_data=None,
-        response_types_map=None
-    ) -> ApiResponse:
-        """Deserializes response into an object.
+    try:
+      # perform request and return response
+      response_data = self.rest_client.request(
+        method,
+        url,
+        headers=header_params,
+        body=body,
+        post_params=post_params,
+        _request_timeout=_request_timeout
+      )
+
+    except ApiException as e:
+      if e.body:
+        e.body = e.body.decode('utf-8')
+      raise e
+
+    return response_data
+
+  def response_deserialize(self, response_data=None, response_types_map=None) -> ApiResponse:
+    """Deserializes response into an object.
         :param response_data: RESTResponse object to be deserialized.
         :param response_types_map: dict of response types.
         :return: ApiResponse
         """
 
+    response_type = response_types_map.get(str(response_data.status), None)
+    if not response_type and isinstance(response_data.status,
+                                        int) and 100 <= response_data.status <= 599:
+      # if not found, look for '1XX', '2XX', etc.
+      response_type = response_types_map.get(str(response_data.status)[0] + 'XX', None)
+
+    if not 200 <= response_data.status <= 299:
+      if response_data.status == 400:
+        raise BadRequestException(http_resp=response_data)
+
+      if response_data.status == 401:
+        raise UnauthorizedException(http_resp=response_data)
+
+      if response_data.status == 403:
+        raise ForbiddenException(http_resp=response_data)
+
+      if response_data.status == 404:
+        raise NotFoundException(http_resp=response_data)
+
+      if 500 <= response_data.status <= 599:
+        raise ServiceException(http_resp=response_data)
+      raise ApiException(http_resp=response_data)
+
+    # deserialize response data
+
+    if response_type == 'bytearray':
+      return_data = response_data.data
+    elif response_type is None:
+      return_data = None
+    elif response_type == 'file':
+      return_data = self.__deserialize_file(response_data)
+    else:
+      match = None
+      content_type = response_data.getheader('content-type')
+      if content_type is not None:
+        match = re.search(r'charset=([a-zA-Z\-\d]+)[\s;]?', content_type)
+      encoding = match.group(1) if match else 'utf-8'
+      response_text = response_data.data.decode(encoding)
+      return_data = self.deserialize(response_text, response_type)
+
+    return ApiResponse(
+      status_code=response_data.status,
+      data=return_data,
+      headers=response_data.getheaders(),
+      raw_data=response_data.data
+    )
 
-        response_type = response_types_map.get(str(response_data.status), None)
-        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
-            # if not found, look for '1XX', '2XX', etc.
-            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)
-
-        if not 200 <= response_data.status <= 299:
-            if response_data.status == 400:
-                raise BadRequestException(http_resp=response_data)
-
-            if response_data.status == 401:
-                raise UnauthorizedException(http_resp=response_data)
-
-            if response_data.status == 403:
-                raise ForbiddenException(http_resp=response_data)
-
-            if response_data.status == 404:
-                raise NotFoundException(http_resp=response_data)
-
-            if 500 <= response_data.status <= 599:
-                raise ServiceException(http_resp=response_data)
-            raise ApiException(http_resp=response_data)
-
-        # deserialize response data
-
-        if response_type == "bytearray":
-            return_data = response_data.data
-        elif response_type is None:
-            return_data = None
-        elif response_type == "file":
-            return_data = self.__deserialize_file(response_data)
-        else:
-            match = None
-            content_type = response_data.getheader('content-type')
-            if content_type is not None:
-                match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
-            encoding = match.group(1) if match else "utf-8"
-            response_text = response_data.data.decode(encoding)
-            return_data = self.deserialize(response_text, response_type)
-
-        return ApiResponse(
-            status_code = response_data.status,
-            data = return_data,
-            headers = response_data.getheaders(),
-            raw_data = response_data.data
-        )
-
-    def sanitize_for_serialization(self, obj):
-        """Builds a JSON POST object.
+  def sanitize_for_serialization(self, obj):
+    """Builds a JSON POST object.
 
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
             convert to string in iso8601 format.
         If obj is list, sanitize each element in the list.
         If obj is dict, return the dict.
         If obj is OpenAPI model, return the properties dict.
 
         :param obj: The data to serialize.
         :return: The serialized form of data.
         """
-        if obj is None:
-            return None
-        elif isinstance(obj, self.PRIMITIVE_TYPES):
-            return obj
-        elif isinstance(obj, list):
-            return [
-                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
-            ]
-        elif isinstance(obj, tuple):
-            return tuple(
-                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
-            )
-        elif isinstance(obj, (datetime.datetime, datetime.date)):
-            return obj.isoformat()
+    if obj is None:
+      return None
+    elif isinstance(obj, self.PRIMITIVE_TYPES):
+      return obj
+    elif isinstance(obj, list):
+      return [self.sanitize_for_serialization(sub_obj) for sub_obj in obj]
+    elif isinstance(obj, tuple):
+      return tuple(self.sanitize_for_serialization(sub_obj) for sub_obj in obj)
+    elif isinstance(obj, (datetime.datetime, datetime.date)):
+      return obj.isoformat()
+
+    elif isinstance(obj, dict):
+      obj_dict = obj
+    else:
+      # Convert model obj to dict except
+      # attributes `openapi_types`, `attribute_map`
+      # and attributes which value is not None.
+      # Convert attribute name to json key in
+      # model definition for request.
+      obj_dict = obj.to_dict()
 
-        elif isinstance(obj, dict):
-            obj_dict = obj
-        else:
-            # Convert model obj to dict except
-            # attributes `openapi_types`, `attribute_map`
-            # and attributes which value is not None.
-            # Convert attribute name to json key in
-            # model definition for request.
-            obj_dict = obj.to_dict()
-
-        return {
-            key: self.sanitize_for_serialization(val)
-            for key, val in obj_dict.items()
-        }
+    return {key: self.sanitize_for_serialization(val) for key, val in obj_dict.items()}
 
-    def deserialize(self, response_text, response_type):
-        """Deserializes response into an object.
+  def deserialize(self, response_text, response_type):
+    """Deserializes response into an object.
 
         :param response: RESTResponse object to be deserialized.
         :param response_type: class literal for
             deserialized object, or string of class name.
 
         :return: deserialized object.
         """
 
-        # fetch data from response object
-        try:
-            data = json.loads(response_text)
-        except ValueError:
-            data = response_text
+    # fetch data from response object
+    try:
+      data = json.loads(response_text)
+    except ValueError:
+      data = response_text
 
-        return self.__deserialize(data, response_type)
+    return self.__deserialize(data, response_type)
 
-    def __deserialize(self, data, klass):
-        """Deserializes dict, list, str into an object.
+  def __deserialize(self, data, klass):
+    """Deserializes dict, list, str into an object.
 
         :param data: dict, list or str.
         :param klass: class literal, or string of class name.
 
         :return: object.
         """
-        if data is None:
-            return None
+    if data is None:
+      return None
 
-        if isinstance(klass, str):
-            if klass.startswith('List['):
-                sub_kls = re.match(r'List\[(.*)]', klass).group(1)
-                return [self.__deserialize(sub_data, sub_kls)
-                        for sub_data in data]
-
-            if klass.startswith('Dict['):
-                sub_kls = re.match(r'Dict\[([^,]*), (.*)]', klass).group(2)
-                return {k: self.__deserialize(v, sub_kls)
-                        for k, v in data.items()}
-
-            # convert str to class
-            if klass in self.NATIVE_TYPES_MAPPING:
-                klass = self.NATIVE_TYPES_MAPPING[klass]
-            else:
-                klass = getattr(getopenpay.models, klass)
-
-        if klass in self.PRIMITIVE_TYPES:
-            return self.__deserialize_primitive(data, klass)
-        elif klass == object:
-            return self.__deserialize_object(data)
-        elif klass == datetime.date:
-            return self.__deserialize_date(data)
-        elif klass == datetime.datetime:
-            return self.__deserialize_datetime(data)
-        else:
-            return self.__deserialize_model(data, klass)
+    if isinstance(klass, str):
+      if klass.startswith('List['):
+        sub_kls = re.match(r'List\[(.*)]', klass).group(1)
+        return [self.__deserialize(sub_data, sub_kls) for sub_data in data]
+
+      if klass.startswith('Dict['):
+        sub_kls = re.match(r'Dict\[([^,]*), (.*)]', klass).group(2)
+        return {k: self.__deserialize(v, sub_kls) for k, v in data.items()}
+
+      # convert str to class
+      if klass in self.NATIVE_TYPES_MAPPING:
+        klass = self.NATIVE_TYPES_MAPPING[klass]
+      else:
+        klass = getattr(getopenpay.models, klass)
+
+    if klass in self.PRIMITIVE_TYPES:
+      return self.__deserialize_primitive(data, klass)
+    elif klass == object:
+      return self.__deserialize_object(data)
+    elif klass == datetime.date:
+      return self.__deserialize_date(data)
+    elif klass == datetime.datetime:
+      return self.__deserialize_datetime(data)
+    else:
+      return self.__deserialize_model(data, klass)
 
-    def parameters_to_tuples(self, params, collection_formats):
-        """Get parameters as list of tuples, formatting collections.
+  def parameters_to_tuples(self, params, collection_formats):
+    """Get parameters as list of tuples, formatting collections.
 
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: Parameters as list of tuples, collections formatted
         """
-        new_params = []
-        if collection_formats is None:
-            collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:
-            if k in collection_formats:
-                collection_format = collection_formats[k]
-                if collection_format == 'multi':
-                    new_params.extend((k, value) for value in v)
-                else:
-                    if collection_format == 'ssv':
-                        delimiter = ' '
-                    elif collection_format == 'tsv':
-                        delimiter = '\t'
-                    elif collection_format == 'pipes':
-                        delimiter = '|'
-                    else:  # csv is the default
-                        delimiter = ','
-                    new_params.append(
-                        (k, delimiter.join(str(value) for value in v)))
-            else:
-                new_params.append((k, v))
-        return new_params
+    new_params = []
+    if collection_formats is None:
+      collection_formats = {}
+    for k, v in params.items() if isinstance(params, dict) else params:
+      if k in collection_formats:
+        collection_format = collection_formats[k]
+        if collection_format == 'multi':
+          new_params.extend((k, value) for value in v)
+        else:
+          if collection_format == 'ssv':
+            delimiter = ' '
+          elif collection_format == 'tsv':
+            delimiter = '\t'
+          elif collection_format == 'pipes':
+            delimiter = '|'
+          else:  # csv is the default
+            delimiter = ','
+          new_params.append((k, delimiter.join(str(value) for value in v)))
+      else:
+        new_params.append((k, v))
+    return new_params
 
-    def parameters_to_url_query(self, params, collection_formats):
-        """Get parameters as list of tuples, formatting collections.
+  def parameters_to_url_query(self, params, collection_formats):
+    """Get parameters as list of tuples, formatting collections.
 
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: URL query string (e.g. a=Hello%20World&b=123)
         """
-        new_params = []
-        if collection_formats is None:
-            collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:
-            if isinstance(v, bool):
-                v = str(v).lower()
-            if isinstance(v, (int, float)):
-                v = str(v)
-            if isinstance(v, dict):
-                v = json.dumps(v)
-
-            if k in collection_formats:
-                collection_format = collection_formats[k]
-                if collection_format == 'multi':
-                    new_params.extend((k, value) for value in v)
-                else:
-                    if collection_format == 'ssv':
-                        delimiter = ' '
-                    elif collection_format == 'tsv':
-                        delimiter = '\t'
-                    elif collection_format == 'pipes':
-                        delimiter = '|'
-                    else:  # csv is the default
-                        delimiter = ','
-                    new_params.append(
-                        (k, delimiter.join(quote(str(value)) for value in v))
-                    )
-            else:
-                new_params.append((k, quote(str(v))))
+    new_params = []
+    if collection_formats is None:
+      collection_formats = {}
+    for k, v in params.items() if isinstance(params, dict) else params:
+      if isinstance(v, bool):
+        v = str(v).lower()
+      if isinstance(v, (int, float)):
+        v = str(v)
+      if isinstance(v, dict):
+        v = json.dumps(v)
+
+      if k in collection_formats:
+        collection_format = collection_formats[k]
+        if collection_format == 'multi':
+          new_params.extend((k, value) for value in v)
+        else:
+          if collection_format == 'ssv':
+            delimiter = ' '
+          elif collection_format == 'tsv':
+            delimiter = '\t'
+          elif collection_format == 'pipes':
+            delimiter = '|'
+          else:  # csv is the default
+            delimiter = ','
+          new_params.append((k, delimiter.join(quote(str(value)) for value in v)))
+      else:
+        new_params.append((k, quote(str(v))))
 
-        return "&".join(["=".join(item) for item in new_params])
+    return '&'.join(['='.join(item) for item in new_params])
 
-    def files_parameters(self, files=None):
-        """Builds form parameters.
+  def files_parameters(self, files=None):
+    """Builds form parameters.
 
         :param files: File parameters.
         :return: Form parameters with files.
         """
-        params = []
+    params = []
 
-        if files:
-            for k, v in files.items():
-                if not v:
-                    continue
-                file_names = v if type(v) is list else [v]
-                for n in file_names:
-                    with open(n, 'rb') as f:
-                        filename = os.path.basename(f.name)
-                        filedata = f.read()
-                        mimetype = (
-                            mimetypes.guess_type(filename)[0]
-                            or 'application/octet-stream'
-                        )
-                        params.append(
-                            tuple([k, tuple([filename, filedata, mimetype])])
-                        )
+    if files:
+      for k, v in files.items():
+        if not v:
+          continue
+        file_names = v if type(v) is list else [v]
+        for n in file_names:
+          with open(n, 'rb') as f:
+            filename = os.path.basename(f.name)
+            filedata = f.read()
+            mimetype = (mimetypes.guess_type(filename)[0] or 'application/octet-stream')
+            params.append(tuple([k, tuple([filename, filedata, mimetype])]))
 
-        return params
+    return params
 
-    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
-        """Returns `Accept` based on an array of accepts provided.
+  def select_header_accept(self, accepts: List[str]) -> Optional[str]:
+    """Returns `Accept` based on an array of accepts provided.
 
         :param accepts: List of headers.
         :return: Accept (e.g. application/json).
         """
-        if not accepts:
-            return None
+    if not accepts:
+      return None
 
-        for accept in accepts:
-            if re.search('json', accept, re.IGNORECASE):
-                return accept
+    for accept in accepts:
+      if re.search('json', accept, re.IGNORECASE):
+        return accept
 
-        return accepts[0]
+    return accepts[0]
 
-    def select_header_content_type(self, content_types):
-        """Returns `Content-Type` based on an array of content_types provided.
+  def select_header_content_type(self, content_types):
+    """Returns `Content-Type` based on an array of content_types provided.
 
         :param content_types: List of content-types.
         :return: Content-Type (e.g. application/json).
         """
-        if not content_types:
-            return None
+    if not content_types:
+      return None
 
-        for content_type in content_types:
-            if re.search('json', content_type, re.IGNORECASE):
-                return content_type
-
-        return content_types[0]
-
-    def update_params_for_auth(
-        self,
-        headers,
-        queries,
-        auth_settings,
-        resource_path,
-        method,
-        body,
-        request_auth=None
-    ) -> None:
-        """Updates header and query params based on authentication setting.
+    for content_type in content_types:
+      if re.search('json', content_type, re.IGNORECASE):
+        return content_type
+
+    return content_types[0]
+
+  def update_params_for_auth(
+    self, headers, queries, auth_settings, resource_path, method, body, request_auth=None
+  ) -> None:
+    """Updates header and query params based on authentication setting.
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_settings: Authentication setting identifiers list.
         :resource_path: A string representation of the HTTP request resource path.
         :method: A string representation of the HTTP request method.
         :body: A object representing the body of the HTTP request.
         The object type is the return value of sanitize_for_serialization().
         :param request_auth: if set, the provided settings will
                              override the token in the configuration.
         """
-        if not auth_settings:
-            return
+    if not auth_settings:
+      return
 
-        if request_auth:
-            self._apply_auth_params(
-                headers,
-                queries,
-                resource_path,
-                method,
-                body,
-                request_auth
-            )
-        else:
-            for auth in auth_settings:
-                auth_setting = self.configuration.auth_settings().get(auth)
-                if auth_setting:
-                    self._apply_auth_params(
-                        headers,
-                        queries,
-                        resource_path,
-                        method,
-                        body,
-                        auth_setting
-                    )
-
-    def _apply_auth_params(
-        self,
-        headers,
-        queries,
-        resource_path,
-        method,
-        body,
-        auth_setting
-    ) -> None:
-        """Updates the request parameters based on a single auth_setting
+    if request_auth:
+      self._apply_auth_params(headers, queries, resource_path, method, body, request_auth)
+    else:
+      for auth in auth_settings:
+        auth_setting = self.configuration.auth_settings().get(auth)
+        if auth_setting:
+          self._apply_auth_params(headers, queries, resource_path, method, body, auth_setting)
+
+  def _apply_auth_params(self, headers, queries, resource_path, method, body, auth_setting) -> None:
+    """Updates the request parameters based on a single auth_setting
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :resource_path: A string representation of the HTTP request resource path.
         :method: A string representation of the HTTP request method.
         :body: A object representing the body of the HTTP request.
         The object type is the return value of sanitize_for_serialization().
         :param auth_setting: auth settings for the endpoint
         """
-        if auth_setting['in'] == 'cookie':
-            headers['Cookie'] = auth_setting['value']
-        elif auth_setting['in'] == 'header':
-            if auth_setting['type'] != 'http-signature':
-                headers[auth_setting['key']] = auth_setting['value']
-        elif auth_setting['in'] == 'query':
-            queries.append((auth_setting['key'], auth_setting['value']))
-        else:
-            raise ApiValueError(
-                'Authentication token must be in `query` or `header`'
-            )
+    if auth_setting['in'] == 'cookie':
+      headers['Cookie'] = auth_setting['value']
+    elif auth_setting['in'] == 'header':
+      if auth_setting['type'] != 'http-signature':
+        headers[auth_setting['key']] = auth_setting['value']
+    elif auth_setting['in'] == 'query':
+      queries.append((auth_setting['key'], auth_setting['value']))
+    else:
+      raise ApiValueError('Authentication token must be in `query` or `header`')
 
-    def __deserialize_file(self, response):
-        """Deserializes body to file
+  def __deserialize_file(self, response):
+    """Deserializes body to file
 
         Saves response body into a file in a temporary folder,
         using the filename from the `Content-Disposition` header if provided.
 
         handle file downloading
         save response body into a tmp file and return the instance
 
         :param response:  RESTResponse.
         :return: file path.
         """
-        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
-        os.close(fd)
-        os.remove(path)
-
-        content_disposition = response.getheader("Content-Disposition")
-        if content_disposition:
-            filename = re.search(
-                r'filename=[\'"]?([^\'"\s]+)[\'"]?',
-                content_disposition
-            ).group(1)
-            path = os.path.join(os.path.dirname(path), filename)
+    fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
+    os.close(fd)
+    os.remove(path)
+
+    content_disposition = response.getheader('Content-Disposition')
+    if content_disposition:
+      filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?', content_disposition).group(1)
+      path = os.path.join(os.path.dirname(path), filename)
 
-        with open(path, "wb") as f:
-            f.write(response.data)
+    with open(path, 'wb') as f:
+      f.write(response.data)
 
-        return path
+    return path
 
-    def __deserialize_primitive(self, data, klass):
-        """Deserializes string to primitive type.
+  def __deserialize_primitive(self, data, klass):
+    """Deserializes string to primitive type.
 
         :param data: str.
         :param klass: class literal.
 
         :return: int, long, float, str, bool.
         """
-        try:
-            return klass(data)
-        except UnicodeEncodeError:
-            return str(data)
-        except TypeError:
-            return data
+    try:
+      return klass(data)
+    except UnicodeEncodeError:
+      return str(data)
+    except TypeError:
+      return data
 
-    def __deserialize_object(self, value):
-        """Return an original value.
+  def __deserialize_object(self, value):
+    """Return an original value.
 
         :return: object.
         """
-        return value
+    return value
 
-    def __deserialize_date(self, string):
-        """Deserializes string to date.
+  def __deserialize_date(self, string):
+    """Deserializes string to date.
 
         :param string: str.
         :return: date.
         """
-        try:
-            return parse(string).date()
-        except ImportError:
-            return string
-        except ValueError:
-            raise rest.ApiException(
-                status=0,
-                reason="Failed to parse `{0}` as date object".format(string)
-            )
+    try:
+      return parse(string).date()
+    except ImportError:
+      return string
+    except ValueError:
+      raise rest.ApiException(
+        status=0, reason='Failed to parse `{0}` as date object'.format(string)
+      )
 
-    def __deserialize_datetime(self, string):
-        """Deserializes string to datetime.
+  def __deserialize_datetime(self, string):
+    """Deserializes string to datetime.
 
         The string should be in iso8601 datetime format.
 
         :param string: str.
         :return: datetime.
         """
-        try:
-            return parse(string)
-        except ImportError:
-            return string
-        except ValueError:
-            raise rest.ApiException(
-                status=0,
-                reason=(
-                    "Failed to parse `{0}` as datetime object"
-                    .format(string)
-                )
-            )
+    try:
+      return parse(string)
+    except ImportError:
+      return string
+    except ValueError:
+      raise rest.ApiException(
+        status=0, reason=('Failed to parse `{0}` as datetime object'.format(string))
+      )
 
-    def __deserialize_model(self, data, klass):
-        """Deserializes list or dict to model.
+  def __deserialize_model(self, data, klass):
+    """Deserializes list or dict to model.
 
         :param data: dict, list.
         :param klass: class literal.
         :return: model object.
         """
 
-        return klass.from_dict(data)
+    return klass.from_dict(data)
```

### Comparing `getopenpay-0.0.1/getopenpay/api_response.py` & `getopenpay-0.0.2/getopenpay/api_response.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 """API response object."""
 
 from __future__ import annotations
-from typing import Dict, Optional, Generic, TypeVar
-from pydantic import Field, StrictInt, StrictStr, StrictBytes, BaseModel
 
-T = TypeVar("T")
+from typing import Dict, Generic, Optional, TypeVar
+
+from pydantic import BaseModel, Field, StrictBytes, StrictInt, StrictStr
+
+T = TypeVar('T')
+
 
 class ApiResponse(BaseModel, Generic[T]):
-    """
+  """
     API response object
     """
 
-    status_code: StrictInt = Field(description="HTTP status code")
-    headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description="HTTP headers")
-    data: T = Field(description="Deserialized data given the data type")
-    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")
-
-    model_config = {
-        "arbitrary_types_allowed": True
-    }
+  status_code: StrictInt = Field(description='HTTP status code')
+  headers: Optional[Dict[StrictStr, StrictStr]] = Field(None, description='HTTP headers')
+  data: T = Field(description='Deserialized data given the data type')
+  raw_data: StrictBytes = Field(description='Raw data (HTTP response body)')
+
+  model_config = {'arbitrary_types_allowed': True}
```

### Comparing `getopenpay-0.0.1/getopenpay/configuration.py` & `getopenpay-0.0.2/getopenpay/configuration.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,30 +7,29 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 import copy
+import http.client as httplib
 import logging
 import sys
-import urllib3
 
-import http.client as httplib
+import urllib3
 
 JSON_SCHEMA_VALIDATION_KEYWORDS = {
-    'multipleOf', 'maximum', 'exclusiveMaximum',
-    'minimum', 'exclusiveMinimum', 'maxLength',
-    'minLength', 'pattern', 'maxItems', 'minItems'
+  'multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum', 'maxLength',
+  'minLength', 'pattern', 'maxItems', 'minItems'
 }
 
+
 class Configuration:
-    """This class contains various settings of the API client.
+  """This class contains various settings of the API client.
 
     :param host: Base url.
     :param api_key: Dict to store API key(s).
       Each entry in the dict specifies an API key.
       The dict key is the name of the security scheme in the OAS specification.
       The dict value is the API key secret.
     :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
@@ -51,388 +50,391 @@
       values before.
     :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
       in PEM format.
 
     :Example:
     """
 
-    _default = None
+  _default = None
 
-    def __init__(self, host=None,
-                 api_key=None, api_key_prefix=None,
-                 username=None, password=None,
-                 access_token=None,
-                 server_index=None, server_variables=None,
-                 server_operation_index=None, server_operation_variables=None,
-                 ssl_ca_cert=None,
-                 ) -> None:
-        """Constructor
-        """
-        self._base_path = "https://connto.getopenpay.com" if host is None else host
-        """Default Base url
-        """
-        self.server_index = 0 if server_index is None and host is None else server_index
-        self.server_operation_index = server_operation_index or {}
-        """Default server index
-        """
-        self.server_variables = server_variables or {}
-        self.server_operation_variables = server_operation_variables or {}
-        """Default server variables
-        """
-        self.temp_folder_path = None
-        """Temp file folder for downloading files
-        """
-        # Authentication Settings
-        self.api_key = {}
-        if api_key:
-            self.api_key = api_key
-        """dict to store API key(s)
+  def __init__(
+    self,
+    host=None,
+    api_key=None,
+    api_key_prefix=None,
+    username=None,
+    password=None,
+    access_token=None,
+    server_index=None,
+    server_variables=None,
+    server_operation_index=None,
+    server_operation_variables=None,
+    ssl_ca_cert=None,
+  ) -> None:
+    """Constructor
+        """
+    self._base_path = 'https://connto.getopenpay.com' if host is None else host
+    """Default Base url
+        """
+    self.server_index = 0 if server_index is None and host is None else server_index
+    self.server_operation_index = server_operation_index or {}
+    """Default server index
+        """
+    self.server_variables = server_variables or {}
+    self.server_operation_variables = server_operation_variables or {}
+    """Default server variables
+        """
+    self.temp_folder_path = None
+    """Temp file folder for downloading files
+        """
+    # Authentication Settings
+    self.api_key = {}
+    if api_key:
+      self.api_key = api_key
+    """dict to store API key(s)
+        """
+    self.api_key_prefix = {}
+    if api_key_prefix:
+      self.api_key_prefix = api_key_prefix
+    """dict to store API prefix (e.g. Bearer)
+        """
+    self.refresh_api_key_hook = None
+    """function hook to refresh API key if expired
+        """
+    self.username = username
+    """Username for HTTP basic authentication
+        """
+    self.password = password
+    """Password for HTTP basic authentication
+        """
+    self.access_token = access_token
+    """Access token
+        """
+    self.logger = {}
+    """Logging Settings
+        """
+    self.logger['package_logger'] = logging.getLogger('getopenpay')
+    self.logger['urllib3_logger'] = logging.getLogger('urllib3')
+    self.logger_format = '%(asctime)s %(levelname)s %(message)s'
+    """Log format
+        """
+    self.logger_stream_handler = None
+    """Log stream handler
+        """
+    self.logger_file_handler = None
+    """Log file handler
+        """
+    self.logger_file = None
+    """Debug file location
         """
-        self.api_key_prefix = {}
-        if api_key_prefix:
-            self.api_key_prefix = api_key_prefix
-        """dict to store API prefix (e.g. Bearer)
-        """
-        self.refresh_api_key_hook = None
-        """function hook to refresh API key if expired
-        """
-        self.username = username
-        """Username for HTTP basic authentication
-        """
-        self.password = password
-        """Password for HTTP basic authentication
-        """
-        self.access_token = access_token
-        """Access token
-        """
-        self.logger = {}
-        """Logging Settings
-        """
-        self.logger["package_logger"] = logging.getLogger("getopenpay")
-        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
-        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
-        """Log format
-        """
-        self.logger_stream_handler = None
-        """Log stream handler
-        """
-        self.logger_file_handler = None
-        """Log file handler
-        """
-        self.logger_file = None
-        """Debug file location
-        """
-        self.debug = False
-        """Debug switch
+    self.debug = False
+    """Debug switch
         """
 
-        self.verify_ssl = True
-        """SSL/TLS verification
+    self.verify_ssl = True
+    """SSL/TLS verification
            Set this to false to skip verifying SSL certificate when calling API
            from https server.
         """
-        self.ssl_ca_cert = ssl_ca_cert
-        """Set this to customize the certificate file to verify the peer.
+    self.ssl_ca_cert = ssl_ca_cert
+    """Set this to customize the certificate file to verify the peer.
         """
-        self.cert_file = None
-        """client certificate file
+    self.cert_file = None
+    """client certificate file
         """
-        self.key_file = None
-        """client key file
+    self.key_file = None
+    """client key file
         """
-        self.assert_hostname = None
-        """Set this to True/False to enable/disable SSL hostname verification.
+    self.assert_hostname = None
+    """Set this to True/False to enable/disable SSL hostname verification.
         """
-        self.tls_server_name = None
-        """SSL/TLS Server Name Indication (SNI)
+    self.tls_server_name = None
+    """SSL/TLS Server Name Indication (SNI)
            Set this to the SNI value expected by the server.
         """
 
-
-        self.proxy = None
-        """Proxy URL
+    self.proxy = None
+    """Proxy URL
         """
-        self.proxy_headers = None
-        """Proxy headers
+    self.proxy_headers = None
+    """Proxy headers
         """
-        self.safe_chars_for_path_param = ''
-        """Safe chars for path_param
+    self.safe_chars_for_path_param = ''
+    """Safe chars for path_param
         """
-        self.retries = None
-        """Adding retries to override urllib3 default value 3
+    self.retries = None
+    """Adding retries to override urllib3 default value 3
         """
-        # Enable client side validation
-        self.client_side_validation = True
+    # Enable client side validation
+    self.client_side_validation = True
 
-        self.socket_options = None
-        """Options to pass down to the underlying urllib3 socket
+    self.socket_options = None
+    """Options to pass down to the underlying urllib3 socket
         """
 
-        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
-        """datetime format
+    self.datetime_format = '%Y-%m-%dT%H:%M:%S.%f%z'
+    """datetime format
         """
 
-        self.date_format = "%Y-%m-%d"
-        """date format
+    self.date_format = '%Y-%m-%d'
+    """date format
         """
 
-    def __deepcopy__(self, memo):
-        cls = self.__class__
-        result = cls.__new__(cls)
-        memo[id(self)] = result
-        for k, v in self.__dict__.items():
-            if k not in ('logger', 'logger_file_handler'):
-                setattr(result, k, copy.deepcopy(v, memo))
-        # shallow copy of loggers
-        result.logger = copy.copy(self.logger)
-        # use setters to configure loggers
-        result.logger_file = self.logger_file
-        result.debug = self.debug
-        return result
+  def __deepcopy__(self, memo):
+    cls = self.__class__
+    result = cls.__new__(cls)
+    memo[id(self)] = result
+    for k, v in self.__dict__.items():
+      if k not in ('logger', 'logger_file_handler'):
+        setattr(result, k, copy.deepcopy(v, memo))
+    # shallow copy of loggers
+    result.logger = copy.copy(self.logger)
+    # use setters to configure loggers
+    result.logger_file = self.logger_file
+    result.debug = self.debug
+    return result
 
-    def __setattr__(self, name, value):
-        object.__setattr__(self, name, value)
+  def __setattr__(self, name, value):
+    object.__setattr__(self, name, value)
 
-    @classmethod
-    def set_default(cls, default):
-        """Set default instance of configuration.
+  @classmethod
+  def set_default(cls, default):
+    """Set default instance of configuration.
 
         It stores default configuration, which can be
         returned by get_default_copy method.
 
         :param default: object of Configuration
         """
-        cls._default = default
+    cls._default = default
 
-    @classmethod
-    def get_default_copy(cls):
-        """Deprecated. Please use `get_default` instead.
+  @classmethod
+  def get_default_copy(cls):
+    """Deprecated. Please use `get_default` instead.
 
         Deprecated. Please use `get_default` instead.
 
         :return: The configuration object.
         """
-        return cls.get_default()
+    return cls.get_default()
 
-    @classmethod
-    def get_default(cls):
-        """Return the default configuration.
+  @classmethod
+  def get_default(cls):
+    """Return the default configuration.
 
         This method returns newly created, based on default constructor,
         object of Configuration class or returns a copy of default
         configuration.
 
         :return: The configuration object.
         """
-        if cls._default is None:
-            cls._default = Configuration()
-        return cls._default
-
-    @property
-    def logger_file(self):
-        """The logger file.
+    if cls._default is None:
+      cls._default = Configuration()
+    return cls._default
+
+  @property
+  def logger_file(self):
+    """The logger file.
 
         If the logger_file is None, then add stream handler and remove file
         handler. Otherwise, add file handler and remove stream handler.
 
         :param value: The logger_file path.
         :type: str
         """
-        return self.__logger_file
+    return self.__logger_file
 
-    @logger_file.setter
-    def logger_file(self, value):
-        """The logger file.
+  @logger_file.setter
+  def logger_file(self, value):
+    """The logger file.
 
         If the logger_file is None, then add stream handler and remove file
         handler. Otherwise, add file handler and remove stream handler.
 
         :param value: The logger_file path.
         :type: str
         """
-        self.__logger_file = value
-        if self.__logger_file:
-            # If set logging file,
-            # then add file handler and remove stream handler.
-            self.logger_file_handler = logging.FileHandler(self.__logger_file)
-            self.logger_file_handler.setFormatter(self.logger_formatter)
-            for _, logger in self.logger.items():
-                logger.addHandler(self.logger_file_handler)
-
-    @property
-    def debug(self):
-        """Debug status
+    self.__logger_file = value
+    if self.__logger_file:
+      # If set logging file,
+      # then add file handler and remove stream handler.
+      self.logger_file_handler = logging.FileHandler(self.__logger_file)
+      self.logger_file_handler.setFormatter(self.logger_formatter)
+      for _, logger in self.logger.items():
+        logger.addHandler(self.logger_file_handler)
+
+  @property
+  def debug(self):
+    """Debug status
 
         :param value: The debug status, True or False.
         :type: bool
         """
-        return self.__debug
+    return self.__debug
 
-    @debug.setter
-    def debug(self, value):
-        """Debug status
+  @debug.setter
+  def debug(self, value):
+    """Debug status
 
         :param value: The debug status, True or False.
         :type: bool
         """
-        self.__debug = value
-        if self.__debug:
-            # if debug status is True, turn on debug logging
-            for _, logger in self.logger.items():
-                logger.setLevel(logging.DEBUG)
-            # turn on httplib debug
-            httplib.HTTPConnection.debuglevel = 1
-        else:
-            # if debug status is False, turn off debug logging,
-            # setting log level to default `logging.WARNING`
-            for _, logger in self.logger.items():
-                logger.setLevel(logging.WARNING)
-            # turn off httplib debug
-            httplib.HTTPConnection.debuglevel = 0
-
-    @property
-    def logger_format(self):
-        """The logger format.
+    self.__debug = value
+    if self.__debug:
+      # if debug status is True, turn on debug logging
+      for _, logger in self.logger.items():
+        logger.setLevel(logging.DEBUG)
+      # turn on httplib debug
+      httplib.HTTPConnection.debuglevel = 1
+    else:
+      # if debug status is False, turn off debug logging,
+      # setting log level to default `logging.WARNING`
+      for _, logger in self.logger.items():
+        logger.setLevel(logging.WARNING)
+      # turn off httplib debug
+      httplib.HTTPConnection.debuglevel = 0
+
+  @property
+  def logger_format(self):
+    """The logger format.
 
         The logger_formatter will be updated when sets logger_format.
 
         :param value: The format string.
         :type: str
         """
-        return self.__logger_format
+    return self.__logger_format
 
-    @logger_format.setter
-    def logger_format(self, value):
-        """The logger format.
+  @logger_format.setter
+  def logger_format(self, value):
+    """The logger format.
 
         The logger_formatter will be updated when sets logger_format.
 
         :param value: The format string.
         :type: str
         """
-        self.__logger_format = value
-        self.logger_formatter = logging.Formatter(self.__logger_format)
+    self.__logger_format = value
+    self.logger_formatter = logging.Formatter(self.__logger_format)
 
-    def get_api_key_with_prefix(self, identifier, alias=None):
-        """Gets API key (with prefix if set).
+  def get_api_key_with_prefix(self, identifier, alias=None):
+    """Gets API key (with prefix if set).
 
         :param identifier: The identifier of apiKey.
         :param alias: The alternative identifier of apiKey.
         :return: The token for api key authentication.
         """
-        if self.refresh_api_key_hook is not None:
-            self.refresh_api_key_hook(self)
-        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
-        if key:
-            prefix = self.api_key_prefix.get(identifier)
-            if prefix:
-                return "%s %s" % (prefix, key)
-            else:
-                return key
+    if self.refresh_api_key_hook is not None:
+      self.refresh_api_key_hook(self)
+    key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
+    if key:
+      prefix = self.api_key_prefix.get(identifier)
+      if prefix:
+        return '%s %s' % (prefix, key)
+      else:
+        return key
 
-    def get_basic_auth_token(self):
-        """Gets HTTP basic authentication header (string).
+  def get_basic_auth_token(self):
+    """Gets HTTP basic authentication header (string).
 
         :return: The token for basic HTTP authentication.
         """
-        username = ""
-        if self.username is not None:
-            username = self.username
-        password = ""
-        if self.password is not None:
-            password = self.password
-        return urllib3.util.make_headers(
-            basic_auth=username + ':' + password
-        ).get('authorization')
+    username = ''
+    if self.username is not None:
+      username = self.username
+    password = ''
+    if self.password is not None:
+      password = self.password
+    return urllib3.util.make_headers(basic_auth=username + ':' + password).get('authorization')
 
-    def auth_settings(self):
-        """Gets Auth Settings dict for api client.
+  def auth_settings(self):
+    """Gets Auth Settings dict for api client.
 
         :return: The Auth Settings information dict.
         """
-        auth = {}
-        if self.access_token is not None:
-            auth['HTTPBearer'] = {
-                'type': 'bearer',
-                'in': 'header',
-                'key': 'Authorization',
-                'value': 'Bearer ' + self.access_token
-            }
-        return auth
+    auth = {}
+    if self.access_token is not None:
+      auth['HTTPBearer'] = {
+        'type': 'bearer',
+        'in': 'header',
+        'key': 'Authorization',
+        'value': 'Bearer ' + self.access_token
+      }
+    return auth
 
-    def to_debug_report(self):
-        """Gets the essential information for debugging.
+  def to_debug_report(self):
+    """Gets the essential information for debugging.
 
         :return: The report for debugging.
         """
-        return "Python SDK Debug Report:\n"\
-               "OS: {env}\n"\
-               "Python Version: {pyversion}\n"\
-               "Version of the API: 1.0.0\n"\
-               "SDK Package Version: 1.0.0".\
-               format(env=sys.platform, pyversion=sys.version)
+    return 'Python SDK Debug Report:\n'\
+           'OS: {env}\n'\
+           'Python Version: {pyversion}\n'\
+           'Version of the API: 1.0.0\n'\
+           'SDK Package Version: 1.0.0'.\
+           format(env=sys.platform, pyversion=sys.version)
 
-    def get_host_settings(self):
-        """Gets an array of host settings
+  def get_host_settings(self):
+    """Gets an array of host settings
 
         :return: An array of host settings
         """
-        return [
-            {
-                'url': "https://connto.getopenpay.com",
-                'description': "OpenPay API server",
-            },
-            {
-                'url': "https://connto.openpaystaging.com",
-                'description': "OpenPay staging API server",
-            }
-        ]
+    return [
+      {
+        'url': 'https://connto.getopenpay.com',
+        'description': 'OpenPay API server',
+      }, {
+        'url': 'https://connto.openpaystaging.com',
+        'description': 'OpenPay staging API server',
+      }
+    ]
 
-    def get_host_from_settings(self, index, variables=None, servers=None):
-        """Gets host URL based on the index and variables
+  def get_host_from_settings(self, index, variables=None, servers=None):
+    """Gets host URL based on the index and variables
         :param index: array index of the host settings
         :param variables: hash of variable and the corresponding value
         :param servers: an array of host settings or None
         :return: URL based on host settings
         """
-        if index is None:
-            return self._base_path
+    if index is None:
+      return self._base_path
 
-        variables = {} if variables is None else variables
-        servers = self.get_host_settings() if servers is None else servers
+    variables = {} if variables is None else variables
+    servers = self.get_host_settings() if servers is None else servers
 
-        try:
-            server = servers[index]
-        except IndexError:
-            raise ValueError(
-                "Invalid index {0} when selecting the host settings. "
-                "Must be less than {1}".format(index, len(servers)))
-
-        url = server['url']
-
-        # go through variables and replace placeholders
-        for variable_name, variable in server.get('variables', {}).items():
-            used_value = variables.get(
-                variable_name, variable['default_value'])
-
-            if 'enum_values' in variable \
-                    and used_value not in variable['enum_values']:
-                raise ValueError(
-                    "The variable `{0}` in the host URL has invalid value "
-                    "{1}. Must be {2}.".format(
-                        variable_name, variables[variable_name],
-                        variable['enum_values']))
-
-            url = url.replace("{" + variable_name + "}", used_value)
-
-        return url
-
-    @property
-    def host(self):
-        """Return generated host."""
-        return self.get_host_from_settings(self.server_index, variables=self.server_variables)
-
-    @host.setter
-    def host(self, value):
-        """Fix base path."""
-        self._base_path = value
-        self.server_index = None
+    try:
+      server = servers[index]
+    except IndexError:
+      raise ValueError(
+        'Invalid index {0} when selecting the host settings. '
+        'Must be less than {1}'.format(index, len(servers))
+      )
+
+    url = server['url']
+
+    # go through variables and replace placeholders
+    for variable_name, variable in server.get('variables', {}).items():
+      used_value = variables.get(variable_name, variable['default_value'])
+
+      if 'enum_values' in variable \
+              and used_value not in variable['enum_values']:
+        raise ValueError(
+          'The variable `{0}` in the host URL has invalid value '
+          '{1}. Must be {2}.'.format(
+            variable_name, variables[variable_name], variable['enum_values']
+          )
+        )
+
+      url = url.replace('{' + variable_name + '}', used_value)
+
+    return url
+
+  @property
+  def host(self):
+    """Return generated host."""
+    return self.get_host_from_settings(self.server_index, variables=self.server_variables)
+
+  @host.setter
+  def host(self, value):
+    """Fix base path."""
+    self._base_path = value
+    self.server_index = None
```

### Comparing `getopenpay-0.0.1/getopenpay/exceptions.py` & `getopenpay-0.0.2/getopenpay/exceptions.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,21 +9,21 @@
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
 
 class OpenApiException(Exception):
-    """The base exception class for all OpenAPIExceptions"""
+  """The base exception class for all OpenAPIExceptions"""
 
 
 class ApiTypeError(OpenApiException, TypeError):
-    def __init__(self, msg, path_to_item=None, valid_classes=None,
-                 key_type=None) -> None:
-        """ Raises an exception for TypeErrors
+
+  def __init__(self, msg, path_to_item=None, valid_classes=None, key_type=None) -> None:
+    """ Raises an exception for TypeErrors
 
         Args:
             msg (str): the exception message
 
         Keyword Args:
             path_to_item (list): a list of keys an indices to get to the
                                  current_item
@@ -32,135 +32,139 @@
                                    should be an instance of
                                    None if unset
             key_type (bool): False if our value is a value in a dict
                              True if it is a key in a dict
                              False if our item is an item in a list
                              None if unset
         """
-        self.path_to_item = path_to_item
-        self.valid_classes = valid_classes
-        self.key_type = key_type
-        full_msg = msg
-        if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
-        super(ApiTypeError, self).__init__(full_msg)
+    self.path_to_item = path_to_item
+    self.valid_classes = valid_classes
+    self.key_type = key_type
+    full_msg = msg
+    if path_to_item:
+      full_msg = '{0} at {1}'.format(msg, render_path(path_to_item))
+    super(ApiTypeError, self).__init__(full_msg)
 
 
 class ApiValueError(OpenApiException, ValueError):
-    def __init__(self, msg, path_to_item=None) -> None:
-        """
+
+  def __init__(self, msg, path_to_item=None) -> None:
+    """
         Args:
             msg (str): the exception message
 
         Keyword Args:
             path_to_item (list) the path to the exception in the
                 received_data dict. None if unset
         """
 
-        self.path_to_item = path_to_item
-        full_msg = msg
-        if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
-        super(ApiValueError, self).__init__(full_msg)
+    self.path_to_item = path_to_item
+    full_msg = msg
+    if path_to_item:
+      full_msg = '{0} at {1}'.format(msg, render_path(path_to_item))
+    super(ApiValueError, self).__init__(full_msg)
 
 
 class ApiAttributeError(OpenApiException, AttributeError):
-    def __init__(self, msg, path_to_item=None) -> None:
-        """
+
+  def __init__(self, msg, path_to_item=None) -> None:
+    """
         Raised when an attribute reference or assignment fails.
 
         Args:
             msg (str): the exception message
 
         Keyword Args:
             path_to_item (None/list) the path to the exception in the
                 received_data dict
         """
-        self.path_to_item = path_to_item
-        full_msg = msg
-        if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
-        super(ApiAttributeError, self).__init__(full_msg)
+    self.path_to_item = path_to_item
+    full_msg = msg
+    if path_to_item:
+      full_msg = '{0} at {1}'.format(msg, render_path(path_to_item))
+    super(ApiAttributeError, self).__init__(full_msg)
 
 
 class ApiKeyError(OpenApiException, KeyError):
-    def __init__(self, msg, path_to_item=None) -> None:
-        """
+
+  def __init__(self, msg, path_to_item=None) -> None:
+    """
         Args:
             msg (str): the exception message
 
         Keyword Args:
             path_to_item (None/list) the path to the exception in the
                 received_data dict
         """
-        self.path_to_item = path_to_item
-        full_msg = msg
-        if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
-        super(ApiKeyError, self).__init__(full_msg)
+    self.path_to_item = path_to_item
+    full_msg = msg
+    if path_to_item:
+      full_msg = '{0} at {1}'.format(msg, render_path(path_to_item))
+    super(ApiKeyError, self).__init__(full_msg)
 
 
 class ApiException(OpenApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        if http_resp:
-            self.status = http_resp.status
-            self.reason = http_resp.reason
-            self.body = http_resp.data.decode('utf-8')
-            self.headers = http_resp.getheaders()
-        else:
-            self.status = status
-            self.reason = reason
-            self.body = None
-            self.headers = None
-
-    def __str__(self):
-        """Custom error messages for exception"""
-        error_message = "({0})\n"\
-                        "Reason: {1}\n".format(self.status, self.reason)
-        if self.headers:
-            error_message += "HTTP response headers: {0}\n".format(
-                self.headers)
+  def __init__(self, status=None, reason=None, http_resp=None) -> None:
+    if http_resp:
+      self.status = http_resp.status
+      self.reason = http_resp.reason
+      self.body = http_resp.data.decode('utf-8')
+      self.headers = http_resp.getheaders()
+    else:
+      self.status = status
+      self.reason = reason
+      self.body = None
+      self.headers = None
+
+  def __str__(self):
+    """Custom error messages for exception"""
+    error_message = '({0})\n'\
+                    'Reason: {1}\n'.format(self.status, self.reason)
+    if self.headers:
+      error_message += 'HTTP response headers: {0}\n'.format(self.headers)
 
-        if self.body:
-            error_message += "HTTP response body: {0}\n".format(self.body)
+    if self.body:
+      error_message += 'HTTP response body: {0}\n'.format(self.body)
+
+    return error_message
 
-        return error_message
 
 class BadRequestException(ApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(BadRequestException, self).__init__(status, reason, http_resp)
+  def __init__(self, status=None, reason=None, http_resp=None) -> None:
+    super(BadRequestException, self).__init__(status, reason, http_resp)
+
 
 class NotFoundException(ApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(NotFoundException, self).__init__(status, reason, http_resp)
+  def __init__(self, status=None, reason=None, http_resp=None) -> None:
+    super(NotFoundException, self).__init__(status, reason, http_resp)
 
 
 class UnauthorizedException(ApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(UnauthorizedException, self).__init__(status, reason, http_resp)
+  def __init__(self, status=None, reason=None, http_resp=None) -> None:
+    super(UnauthorizedException, self).__init__(status, reason, http_resp)
 
 
 class ForbiddenException(ApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(ForbiddenException, self).__init__(status, reason, http_resp)
+  def __init__(self, status=None, reason=None, http_resp=None) -> None:
+    super(ForbiddenException, self).__init__(status, reason, http_resp)
 
 
 class ServiceException(ApiException):
 
-    def __init__(self, status=None, reason=None, http_resp=None) -> None:
-        super(ServiceException, self).__init__(status, reason, http_resp)
+  def __init__(self, status=None, reason=None, http_resp=None) -> None:
+    super(ServiceException, self).__init__(status, reason, http_resp)
 
 
 def render_path(path_to_item):
-    """Returns a string representation of a path"""
-    result = ""
-    for pth in path_to_item:
-        if isinstance(pth, int):
-            result += "[{0}]".format(pth)
-        else:
-            result += "['{0}']".format(pth)
-    return result
+  """Returns a string representation of a path"""
+  result = ''
+  for pth in path_to_item:
+    if isinstance(pth, int):
+      result += '[{0}]'.format(pth)
+    else:
+      result += "['{0}']".format(pth)
+  return result
```

### Comparing `getopenpay-0.0.1/getopenpay/models/__init__.py` & `getopenpay-0.0.2/getopenpay/models/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,27 +8,27 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 # import models into model package
 from getopenpay.models.account_external import AccountExternal
 from getopenpay.models.active_sub_response import ActiveSubResponse
 from getopenpay.models.api_token_external import ApiTokenExternal
 from getopenpay.models.attach_payment_method_request import AttachPaymentMethodRequest
 from getopenpay.models.billing_reason_enum import BillingReasonEnum
 from getopenpay.models.billing_scheme_enum import BillingSchemeEnum
 from getopenpay.models.business_type import BusinessType
 from getopenpay.models.calendar_interval_enum import CalendarIntervalEnum
 from getopenpay.models.charge_external import ChargeExternal
 from getopenpay.models.charge_query_params import ChargeQueryParams
 from getopenpay.models.charge_status_enum import ChargeStatusEnum
+from getopenpay.models.chart_mogul_integration_public import ChartMogulIntegrationPublic
 from getopenpay.models.checkout_mode import CheckoutMode
 from getopenpay.models.checkout_session_external import CheckoutSessionExternal
 from getopenpay.models.checkout_session_line_item_external import CheckoutSessionLineItemExternal
 from getopenpay.models.checkout_session_query_params import CheckoutSessionQueryParams
 from getopenpay.models.checkout_session_status import CheckoutSessionStatus
 from getopenpay.models.collection_method_enum import CollectionMethodEnum
 from getopenpay.models.complete_address import CompleteAddress
@@ -36,15 +36,17 @@
 from getopenpay.models.coupon_external import CouponExternal
 from getopenpay.models.coupon_query_params import CouponQueryParams
 from getopenpay.models.create_checkout_line_item import CreateCheckoutLineItem
 from getopenpay.models.create_checkout_session_request import CreateCheckoutSessionRequest
 from getopenpay.models.create_coupon_request import CreateCouponRequest
 from getopenpay.models.create_credit_note_line import CreateCreditNoteLine
 from getopenpay.models.create_credit_note_request import CreateCreditNoteRequest
-from getopenpay.models.create_customer_balance_transaction_request import CreateCustomerBalanceTransactionRequest
+from getopenpay.models.create_customer_balance_transaction_request import (
+  CreateCustomerBalanceTransactionRequest
+)
 from getopenpay.models.create_customer_request import CreateCustomerRequest
 from getopenpay.models.create_invoice_request import CreateInvoiceRequest
 from getopenpay.models.create_payment_link_request import CreatePaymentLinkRequest
 from getopenpay.models.create_portal_session_request import CreatePortalSessionRequest
 from getopenpay.models.create_price_request import CreatePriceRequest
 from getopenpay.models.create_product_family_request import CreateProductFamilyRequest
 from getopenpay.models.create_product_request import CreateProductRequest
@@ -55,15 +57,17 @@
 from getopenpay.models.create_subscription_response import CreateSubscriptionResponse
 from getopenpay.models.credit_card_type import CreditCardType
 from getopenpay.models.credit_note_external import CreditNoteExternal
 from getopenpay.models.credit_note_item_external import CreditNoteItemExternal
 from getopenpay.models.credit_note_line_type import CreditNoteLineType
 from getopenpay.models.credit_note_query_params import CreditNoteQueryParams
 from getopenpay.models.credit_note_reason import CreditNoteReason
-from getopenpay.models.customer_balance_transaction_external import CustomerBalanceTransactionExternal
+from getopenpay.models.customer_balance_transaction_external import (
+  CustomerBalanceTransactionExternal
+)
 from getopenpay.models.customer_balance_transaction_type import CustomerBalanceTransactionType
 from getopenpay.models.customer_external import CustomerExternal
 from getopenpay.models.customer_payment_method_query_params import CustomerPaymentMethodQueryParams
 from getopenpay.models.customer_query_params import CustomerQueryParams
 from getopenpay.models.date_time_filter import DateTimeFilter
 from getopenpay.models.delete_invoice_item_response import DeleteInvoiceItemResponse
 from getopenpay.models.delete_price_response import DeletePriceResponse
@@ -81,42 +85,56 @@
 from getopenpay.models.inline_subscription_item_update import InlineSubscriptionItemUpdate
 from getopenpay.models.int_range_filter import IntRangeFilter
 from getopenpay.models.invite_external import InviteExternal
 from getopenpay.models.invite_status_enum import InviteStatusEnum
 from getopenpay.models.invoice_discount_amounts_external import InvoiceDiscountAmountsExternal
 from getopenpay.models.invoice_discount_options import InvoiceDiscountOptions
 from getopenpay.models.invoice_external import InvoiceExternal
-from getopenpay.models.invoice_item_discount_amounts_external import InvoiceItemDiscountAmountsExternal
+from getopenpay.models.invoice_item_discount_amounts_external import (
+  InvoiceItemDiscountAmountsExternal
+)
 from getopenpay.models.invoice_item_discount_amounts_public import InvoiceItemDiscountAmountsPublic
 from getopenpay.models.invoice_item_external import InvoiceItemExternal
 from getopenpay.models.invoice_item_public import InvoiceItemPublic
 from getopenpay.models.invoice_items_query_params import InvoiceItemsQueryParams
 from getopenpay.models.invoice_public import InvoicePublic
 from getopenpay.models.invoice_query_params import InvoiceQueryParams
 from getopenpay.models.invoice_settings import InvoiceSettings
 from getopenpay.models.invoice_status_enum import InvoiceStatusEnum
 from getopenpay.models.list_active_sub_params import ListActiveSubParams
 from getopenpay.models.list_response_charge_external import ListResponseChargeExternal
-from getopenpay.models.list_response_checkout_session_external import ListResponseCheckoutSessionExternal
+from getopenpay.models.list_response_checkout_session_external import (
+  ListResponseCheckoutSessionExternal
+)
 from getopenpay.models.list_response_coupon_external import ListResponseCouponExternal
 from getopenpay.models.list_response_credit_note_external import ListResponseCreditNoteExternal
 from getopenpay.models.list_response_customer_external import ListResponseCustomerExternal
 from getopenpay.models.list_response_event_external import ListResponseEventExternal
 from getopenpay.models.list_response_invoice_external import ListResponseInvoiceExternal
 from getopenpay.models.list_response_invoice_item_external import ListResponseInvoiceItemExternal
-from getopenpay.models.list_response_payment_intent_external import ListResponsePaymentIntentExternal
+from getopenpay.models.list_response_payment_intent_external import (
+  ListResponsePaymentIntentExternal
+)
 from getopenpay.models.list_response_payment_link_external import ListResponsePaymentLinkExternal
-from getopenpay.models.list_response_payment_method_external import ListResponsePaymentMethodExternal
+from getopenpay.models.list_response_payment_method_external import (
+  ListResponsePaymentMethodExternal
+)
 from getopenpay.models.list_response_price_external import ListResponsePriceExternal
 from getopenpay.models.list_response_product_external import ListResponseProductExternal
-from getopenpay.models.list_response_product_family_external import ListResponseProductFamilyExternal
-from getopenpay.models.list_response_promotion_code_external import ListResponsePromotionCodeExternal
+from getopenpay.models.list_response_product_family_external import (
+  ListResponseProductFamilyExternal
+)
+from getopenpay.models.list_response_promotion_code_external import (
+  ListResponsePromotionCodeExternal
+)
 from getopenpay.models.list_response_refund_external import ListResponseRefundExternal
 from getopenpay.models.list_response_subscription_external import ListResponseSubscriptionExternal
-from getopenpay.models.list_response_subscription_item_external import ListResponseSubscriptionItemExternal
+from getopenpay.models.list_response_subscription_item_external import (
+  ListResponseSubscriptionItemExternal
+)
 from getopenpay.models.object_name import ObjectName
 from getopenpay.models.pay_invoice_request import PayInvoiceRequest
 from getopenpay.models.payment_intent_external import PaymentIntentExternal
 from getopenpay.models.payment_intent_query_params import PaymentIntentQueryParams
 from getopenpay.models.payment_intent_status import PaymentIntentStatus
 from getopenpay.models.payment_link_external import PaymentLinkExternal
 from getopenpay.models.payment_link_line_item_external import PaymentLinkLineItemExternal
```

### Comparing `getopenpay-0.0.1/getopenpay/models/account_external.py` & `getopenpay-0.0.2/getopenpay/models/portal_session_external.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,102 +7,117 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
-from typing import Any, ClassVar, Dict, List, Optional, Union
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.business_type import BusinessType
+from typing import Any, ClassVar, Dict, List, Optional
+
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class AccountExternal(BaseModel):
+class PortalSessionExternal(BaseModel):
+  """
+    PortalSessionExternal
     """
-    AccountExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the account.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    name: StrictStr = Field(description="The accounts name.")
-    business_type: BusinessType
-    country: StrictStr = Field(description="The accounts country.")
-    created_by_id: StrictInt = Field(description="Unique identifier of the user who created the account.")
-    branding_settings: Union[str, Any] = Field(description="The branding settings associated with this account.")
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "name", "business_type", "country", "created_by_id", "branding_settings"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of AccountExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='The ID of the portal session.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  account_id: StrictStr = Field(description='Unique identifier for the account.')
+  customer_id: StrictStr = Field(description='The ID of an existing customer.')
+  return_url: StrictStr = Field(
+    description=
+    "The default URL to redirect customers to when they click on the portal's link to return to your website."
+  )
+  url: StrictStr = Field(
+    description=
+    'The short-lived URL of the session that gives customers access to the customer portal.'
+  )
+  token: StrictStr = Field(
+    description=
+    'The short-lived token of the session that gives customers access to the customer portal.'
+  )
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'account_id', 'customer_id',
+    'return_url', 'url', 'token'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PortalSessionExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of AccountExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "name": obj.get("name"),
-            "business_type": obj.get("business_type"),
-            "country": obj.get("country"),
-            "created_by_id": obj.get("created_by_id"),
-            "branding_settings": obj.get("branding_settings")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PortalSessionExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'account_id': obj.get('account_id'),
+        'customer_id': obj.get('customer_id'),
+        'return_url': obj.get('return_url'),
+        'url': obj.get('url'),
+        'token': obj.get('token')
+      }
+    )
+    return _obj
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `getopenpay-0.0.1/getopenpay/models/active_sub_response.py` & `getopenpay-0.0.2/getopenpay/models/active_sub_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,91 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictBool
+
 from getopenpay.models.subscription_external import SubscriptionExternal
+from pydantic import BaseModel, StrictBool
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class ActiveSubResponse(BaseModel):
-    """
+  """
     ActiveSubResponse
-    """ # noqa: E501
-    has_active_subscriptions: StrictBool
-    subscriptions: List[SubscriptionExternal]
-    __properties: ClassVar[List[str]] = ["has_active_subscriptions", "subscriptions"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ActiveSubResponse from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  has_active_subscriptions: StrictBool
+  subscriptions: List[SubscriptionExternal]
+  __properties: ClassVar[List[str]] = ['has_active_subscriptions', 'subscriptions']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ActiveSubResponse from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in subscriptions (list)
-        _items = []
-        if self.subscriptions:
-            for _item in self.subscriptions:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['subscriptions'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ActiveSubResponse from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "has_active_subscriptions": obj.get("has_active_subscriptions"),
-            "subscriptions": [SubscriptionExternal.from_dict(_item) for _item in obj.get("subscriptions")] if obj.get("subscriptions") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in subscriptions (list)
+    _items = []
+    if self.subscriptions:
+      for _item in self.subscriptions:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['subscriptions'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ActiveSubResponse from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'has_active_subscriptions': obj.get('has_active_subscriptions'),
+        'subscriptions':
+          [SubscriptionExternal.from_dict(_item) for _item in obj.get('subscriptions')]
+          if obj.get('subscriptions') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/api_token_external.py` & `getopenpay-0.0.2/getopenpay/models/product_family_external.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,107 +7,113 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.object_name import ObjectName
-from getopenpay.models.role_enum import RoleEnum
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ApiTokenExternal(BaseModel):
+class ProductFamilyExternal(BaseModel):
+  """
+    ProductFamilyExternal
     """
-    ApiTokenExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the api token.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    secret_token: StrictStr = Field(description="The secret token used for request authorization.")
-    publishable_token: StrictStr = Field(description="The publishable token used for request authorization.")
-    user_id: StrictInt = Field(description="Unique identifier of the user.")
-    role: RoleEnum
-    description: Optional[StrictStr]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "secret_token", "publishable_token", "user_id", "role", "description"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ApiTokenExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier of the product family.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  name: StrictStr = Field(description='Name of the product family.')
+  description: Optional[StrictStr]
+  products: List[StrictStr]
+  hierarchy: Optional[StrictStr] = Field(
+    default='{}', description='A JSON object representing the hierarchy within the family.'
+  )
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'name', 'description', 'products',
+    'hierarchy'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ProductFamilyExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ApiTokenExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "secret_token": obj.get("secret_token"),
-            "publishable_token": obj.get("publishable_token"),
-            "user_id": obj.get("user_id"),
-            "role": obj.get("role"),
-            "description": obj.get("description")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ProductFamilyExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'name': obj.get('name'),
+        'description': obj.get('description'),
+        'products': obj.get('products'),
+        'hierarchy': obj.get('hierarchy') if obj.get('hierarchy') is not None else '{}'
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/attach_payment_method_request.py` & `getopenpay-0.0.2/getopenpay/models/attach_payment_method_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,82 +7,75 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List
 
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class AttachPaymentMethodRequest(BaseModel):
-    """
+  """
     AttachPaymentMethodRequest
-    """ # noqa: E501
-    customer_id: StrictStr = Field(description="Unique Identifier of the payment_method.")
-    __properties: ClassVar[List[str]] = ["customer_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of AttachPaymentMethodRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  customer_id: StrictStr = Field(description='Unique Identifier of the payment_method.')
+  __properties: ClassVar[List[str]] = ['customer_id']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of AttachPaymentMethodRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of AttachPaymentMethodRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "customer_id": obj.get("customer_id")
-        })
-        return _obj
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of AttachPaymentMethodRequest from a dict"""
+    if obj is None:
+      return None
 
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
 
+    _obj = cls.model_validate({'customer_id': obj.get('customer_id')})
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/billing_reason_enum.py` & `getopenpay-0.0.2/getopenpay/models/billing_reason_enum.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,42 +7,37 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class BillingReasonEnum(str, Enum):
-    """
+  """
     BillingReasonEnum
     """
-
-    """
+  """
     allowed enum values
     """
-    MANUAL = 'manual'
-    SUBSCRIPTION_CREATE = 'subscription_create'
-    SUBSCRIPTION_CYCLE = 'subscription_cycle'
-    SUBSCRIPTION_THRESHOLD = 'subscription_threshold'
-    SUBSCRIPTION_UPDATE = 'subscription_update'
-    UPCOMING = 'upcoming'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of BillingReasonEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  MANUAL = 'manual'
+  SUBSCRIPTION_CREATE = 'subscription_create'
+  SUBSCRIPTION_CYCLE = 'subscription_cycle'
+  SUBSCRIPTION_THRESHOLD = 'subscription_threshold'
+  SUBSCRIPTION_UPDATE = 'subscription_update'
+  UPCOMING = 'upcoming'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of BillingReasonEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/billing_scheme_enum.py` & `getopenpay-0.0.2/getopenpay/models/billing_scheme_enum.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,38 +7,33 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class BillingSchemeEnum(str, Enum):
-    """
+  """
     BillingSchemeEnum
     """
-
-    """
+  """
     allowed enum values
     """
-    PER_UNIT = 'per_unit'
-    TIERED = 'tiered'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of BillingSchemeEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
+  PER_UNIT = 'per_unit'
+  TIERED = 'tiered'
 
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of BillingSchemeEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/business_type.py` & `getopenpay-0.0.2/getopenpay/models/business_type.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,40 +7,35 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class BusinessType(str, Enum):
-    """
+  """
     BusinessType
     """
-
-    """
+  """
     allowed enum values
     """
-    INDIVIDUAL = 'individual'
-    COMPANY = 'company'
-    NON_PROFIT = 'non_profit'
-    GOVERNMENT_ENTITY = 'government_entity'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of BusinessType from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  INDIVIDUAL = 'individual'
+  COMPANY = 'company'
+  NON_PROFIT = 'non_profit'
+  GOVERNMENT_ENTITY = 'government_entity'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of BusinessType from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/calendar_interval_enum.py` & `getopenpay-0.0.2/getopenpay/models/role_enum.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,40 +7,35 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class CalendarIntervalEnum(str, Enum):
-    """
-    CalendarIntervalEnum
-    """
-
+class RoleEnum(str, Enum):
+  """
+    RoleEnum
     """
+  """
     allowed enum values
     """
-    DAY = 'day'
-    WEEK = 'week'
-    MONTH = 'month'
-    YEAR = 'year'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CalendarIntervalEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  ADMIN = 'admin'
+  DEVELOPER = 'developer'
+  SUPPORT_SPECIALIST = 'support_specialist'
+  READ_ONLY = 'read_only'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of RoleEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/charge_external.py` & `getopenpay-0.0.2/getopenpay/models/coupon_external.py`

 * *Files 23% similar despite different names*

```diff
@@ -7,131 +7,157 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.charge_status_enum import ChargeStatusEnum
+
+from getopenpay.models.coupon_duration import CouponDuration
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ChargeExternal(BaseModel):
+class CouponExternal(BaseModel):
+  """
+    CouponExternal
     """
-    ChargeExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the charge.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    amount_atom: StrictInt = Field(description="Amount charged, in smallest currency unit.")
-    currency: StrictStr
-    customer_id: StrictStr = Field(description="Unique Identifier of the customer associated with this charge.")
-    payment_method_id: StrictStr = Field(description="Unique Identifier of the payment method used for this charge.")
-    payment_intent_id: StrictStr = Field(description="Unique Identifier of the payment intent associated with this charge.")
-    invoice_id: Optional[StrictStr]
-    status: ChargeStatusEnum
-    refunded: StrictBool = Field(description="Indicates whether the charge has been refunded.")
-    refunded_amount_atom: StrictInt = Field(description="Amount refunded, in smallest currency unit.")
-    disputed: StrictBool = Field(description="Indicates whether the charge is disputed.")
-    failure_code: Optional[StrictStr]
-    failure_message: Optional[StrictStr]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "amount_atom", "currency", "customer_id", "payment_method_id", "payment_intent_id", "invoice_id", "status", "refunded", "refunded_amount_atom", "disputed", "failure_code", "failure_message"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ChargeExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  name: StrictStr
+  is_active: StrictBool
+  amount_atom_off: Optional[StrictInt]
+  percent_off: Optional[StrictInt]
+  currency: StrictStr
+  duration: CouponDuration
+  duration_in_months: Optional[StrictInt]
+  max_redemptions: Optional[StrictInt]
+  times_redeemed: Optional[StrictInt]
+  redeem_by: Optional[datetime]
+  products: Optional[List[StrictStr]] = None
+  product_families: Optional[List[StrictStr]] = None
+  promotion_codes: Optional[List[StrictStr]] = None
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'name', 'is_active',
+    'amount_atom_off', 'percent_off', 'currency', 'duration', 'duration_in_months',
+    'max_redemptions', 'times_redeemed', 'redeem_by', 'products', 'product_families',
+    'promotion_codes'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CouponExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if invoice_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_id is None and "invoice_id" in self.model_fields_set:
-            _dict['invoice_id'] = None
-
-        # set to None if failure_code (nullable) is None
-        # and model_fields_set contains the field
-        if self.failure_code is None and "failure_code" in self.model_fields_set:
-            _dict['failure_code'] = None
-
-        # set to None if failure_message (nullable) is None
-        # and model_fields_set contains the field
-        if self.failure_message is None and "failure_message" in self.model_fields_set:
-            _dict['failure_message'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ChargeExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "amount_atom": obj.get("amount_atom"),
-            "currency": obj.get("currency"),
-            "customer_id": obj.get("customer_id"),
-            "payment_method_id": obj.get("payment_method_id"),
-            "payment_intent_id": obj.get("payment_intent_id"),
-            "invoice_id": obj.get("invoice_id"),
-            "status": obj.get("status"),
-            "refunded": obj.get("refunded"),
-            "refunded_amount_atom": obj.get("refunded_amount_atom"),
-            "disputed": obj.get("disputed"),
-            "failure_code": obj.get("failure_code"),
-            "failure_message": obj.get("failure_message")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if amount_atom_off (nullable) is None
+    # and model_fields_set contains the field
+    if self.amount_atom_off is None and 'amount_atom_off' in self.model_fields_set:
+      _dict['amount_atom_off'] = None
+
+    # set to None if percent_off (nullable) is None
+    # and model_fields_set contains the field
+    if self.percent_off is None and 'percent_off' in self.model_fields_set:
+      _dict['percent_off'] = None
+
+    # set to None if duration_in_months (nullable) is None
+    # and model_fields_set contains the field
+    if self.duration_in_months is None and 'duration_in_months' in self.model_fields_set:
+      _dict['duration_in_months'] = None
+
+    # set to None if max_redemptions (nullable) is None
+    # and model_fields_set contains the field
+    if self.max_redemptions is None and 'max_redemptions' in self.model_fields_set:
+      _dict['max_redemptions'] = None
+
+    # set to None if times_redeemed (nullable) is None
+    # and model_fields_set contains the field
+    if self.times_redeemed is None and 'times_redeemed' in self.model_fields_set:
+      _dict['times_redeemed'] = None
+
+    # set to None if redeem_by (nullable) is None
+    # and model_fields_set contains the field
+    if self.redeem_by is None and 'redeem_by' in self.model_fields_set:
+      _dict['redeem_by'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CouponExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'name': obj.get('name'),
+        'is_active': obj.get('is_active'),
+        'amount_atom_off': obj.get('amount_atom_off'),
+        'percent_off': obj.get('percent_off'),
+        'currency': obj.get('currency'),
+        'duration': obj.get('duration'),
+        'duration_in_months': obj.get('duration_in_months'),
+        'max_redemptions': obj.get('max_redemptions'),
+        'times_redeemed': obj.get('times_redeemed'),
+        'redeem_by': obj.get('redeem_by'),
+        'products': obj.get('products'),
+        'product_families': obj.get('product_families'),
+        'promotion_codes': obj.get('promotion_codes')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/charge_query_params.py` & `getopenpay-0.0.2/getopenpay/models/charge_query_params.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,145 +7,154 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.charge_status_enum import ChargeStatusEnum
 from getopenpay.models.date_time_filter import DateTimeFilter
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class ChargeQueryParams(BaseModel):
-    """
+  """
     ChargeQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    customer_id: Optional[StrictStr] = None
-    payment_method_id: Optional[StrictStr] = None
-    payment_intent_id: Optional[StrictStr] = None
-    invoice_id: Optional[StrictStr] = None
-    status: Optional[ChargeStatusEnum] = None
-    refunded: Optional[StrictBool] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "customer_id", "payment_method_id", "payment_intent_id", "invoice_id", "status", "refunded"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ChargeQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  customer_id: Optional[StrictStr] = None
+  payment_method_id: Optional[StrictStr] = None
+  payment_intent_id: Optional[StrictStr] = None
+  invoice_id: Optional[StrictStr] = None
+  status: Optional[ChargeStatusEnum] = None
+  refunded: Optional[StrictBool] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand',
+    'customer_id', 'payment_method_id', 'payment_intent_id', 'invoice_id', 'status', 'refunded'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ChargeQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if payment_method_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.payment_method_id is None and "payment_method_id" in self.model_fields_set:
-            _dict['payment_method_id'] = None
-
-        # set to None if payment_intent_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.payment_intent_id is None and "payment_intent_id" in self.model_fields_set:
-            _dict['payment_intent_id'] = None
-
-        # set to None if invoice_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_id is None and "invoice_id" in self.model_fields_set:
-            _dict['invoice_id'] = None
-
-        # set to None if status (nullable) is None
-        # and model_fields_set contains the field
-        if self.status is None and "status" in self.model_fields_set:
-            _dict['status'] = None
-
-        # set to None if refunded (nullable) is None
-        # and model_fields_set contains the field
-        if self.refunded is None and "refunded" in self.model_fields_set:
-            _dict['refunded'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ChargeQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "customer_id": obj.get("customer_id"),
-            "payment_method_id": obj.get("payment_method_id"),
-            "payment_intent_id": obj.get("payment_intent_id"),
-            "invoice_id": obj.get("invoice_id"),
-            "status": obj.get("status"),
-            "refunded": obj.get("refunded")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if payment_method_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_method_id is None and 'payment_method_id' in self.model_fields_set:
+      _dict['payment_method_id'] = None
+
+    # set to None if payment_intent_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_intent_id is None and 'payment_intent_id' in self.model_fields_set:
+      _dict['payment_intent_id'] = None
+
+    # set to None if invoice_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_id is None and 'invoice_id' in self.model_fields_set:
+      _dict['invoice_id'] = None
+
+    # set to None if status (nullable) is None
+    # and model_fields_set contains the field
+    if self.status is None and 'status' in self.model_fields_set:
+      _dict['status'] = None
+
+    # set to None if refunded (nullable) is None
+    # and model_fields_set contains the field
+    if self.refunded is None and 'refunded' in self.model_fields_set:
+      _dict['refunded'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ChargeQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'customer_id': obj.get('customer_id'),
+        'payment_method_id': obj.get('payment_method_id'),
+        'payment_intent_id': obj.get('payment_intent_id'),
+        'invoice_id': obj.get('invoice_id'),
+        'status': obj.get('status'),
+        'refunded': obj.get('refunded')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/charge_status_enum.py` & `getopenpay-0.0.2/getopenpay/models/usage_record_action.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,39 +7,33 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class ChargeStatusEnum(str, Enum):
-    """
-    ChargeStatusEnum
-    """
-
+class UsageRecordAction(str, Enum):
+  """
+    UsageRecordAction
     """
+  """
     allowed enum values
     """
-    SUCCEEDED = 'succeeded'
-    FAILED = 'failed'
-    PENDING = 'pending'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ChargeStatusEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
+  INCREMENT = 'increment'
+  SET = 'set'
 
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UsageRecordAction from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/checkout_mode.py` & `getopenpay-0.0.2/getopenpay/models/charge_status_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,39 +7,34 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class CheckoutMode(str, Enum):
-    """
-    CheckoutMode
-    """
-
+class ChargeStatusEnum(str, Enum):
+  """
+    ChargeStatusEnum
     """
+  """
     allowed enum values
     """
-    PAYMENT = 'payment'
-    SETUP = 'setup'
-    SUBSCRIPTION = 'subscription'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CheckoutMode from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  SUCCEEDED = 'succeeded'
+  FAILED = 'failed'
+  PENDING = 'pending'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ChargeStatusEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/checkout_session_external.py` & `getopenpay-0.0.2/getopenpay/models/invoice_query_params.py`

 * *Files 26% similar despite different names*

```diff
@@ -7,177 +7,186 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.checkout_mode import CheckoutMode
-from getopenpay.models.checkout_session_line_item_external import CheckoutSessionLineItemExternal
-from getopenpay.models.checkout_session_status import CheckoutSessionStatus
-from getopenpay.models.object_name import ObjectName
+
+from getopenpay.models.billing_reason_enum import BillingReasonEnum
+from getopenpay.models.date_time_filter import DateTimeFilter
+from getopenpay.models.int_range_filter import IntRangeFilter
+from getopenpay.models.invoice_status_enum import InvoiceStatusEnum
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CheckoutSessionExternal(BaseModel):
+class InvoiceQueryParams(BaseModel):
+  """
+    InvoiceQueryParams
     """
-    CheckoutSessionExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the checkout session.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    account_id: StrictStr = Field(description="Unique Identifier of the account.")
-    account_name: StrictStr = Field(description="Name of the account.")
-    amount_subtotal_atom: StrictInt = Field(description="The integer amount representing the subtotal amount for the line items.")
-    amount_total_atom: StrictInt = Field(description="The integer amount representing the total amount for the line items, after discounts and taxes.")
-    client_reference_id: Optional[StrictStr] = None
-    currency: Optional[StrictStr]
-    customer_id: Optional[StrictStr]
-    customer_email: Optional[StrictStr]
-    line_items: List[CheckoutSessionLineItemExternal]
-    mode: CheckoutMode
-    payment_intent_id: Optional[StrictStr]
-    return_url: Optional[StrictStr]
-    secure_token: StrictStr = Field(description="The random secure token associated with the checkout session.")
-    status: CheckoutSessionStatus
-    subscription_id: Optional[StrictStr]
-    success_url: Optional[StrictStr]
-    tax_amount_atom: StrictInt = Field(description="The integer amount representing the tax amount for the line items.")
-    url: StrictStr = Field(description="The main URL for this checkout session.")
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "account_id", "account_name", "amount_subtotal_atom", "amount_total_atom", "client_reference_id", "currency", "customer_id", "customer_email", "line_items", "mode", "payment_intent_id", "return_url", "secure_token", "status", "subscription_id", "success_url", "tax_amount_atom", "url"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CheckoutSessionExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  customer_id: Optional[StrictStr] = None
+  status: Optional[InvoiceStatusEnum] = None
+  subscription_id: Optional[StrictStr] = None
+  billing_reason: Optional[BillingReasonEnum] = None
+  total_amount_atom: Optional[IntRangeFilter] = None
+  period_start: Optional[DateTimeFilter] = None
+  period_end: Optional[DateTimeFilter] = None
+  coupon_id: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand',
+    'customer_id', 'status', 'subscription_id', 'billing_reason', 'total_amount_atom',
+    'period_start', 'period_end', 'coupon_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
-        _items = []
-        if self.line_items:
-            for _item in self.line_items:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['line_items'] = _items
-        # set to None if client_reference_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.client_reference_id is None and "client_reference_id" in self.model_fields_set:
-            _dict['client_reference_id'] = None
-
-        # set to None if currency (nullable) is None
-        # and model_fields_set contains the field
-        if self.currency is None and "currency" in self.model_fields_set:
-            _dict['currency'] = None
-
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if customer_email (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_email is None and "customer_email" in self.model_fields_set:
-            _dict['customer_email'] = None
-
-        # set to None if payment_intent_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.payment_intent_id is None and "payment_intent_id" in self.model_fields_set:
-            _dict['payment_intent_id'] = None
-
-        # set to None if return_url (nullable) is None
-        # and model_fields_set contains the field
-        if self.return_url is None and "return_url" in self.model_fields_set:
-            _dict['return_url'] = None
-
-        # set to None if subscription_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.subscription_id is None and "subscription_id" in self.model_fields_set:
-            _dict['subscription_id'] = None
-
-        # set to None if success_url (nullable) is None
-        # and model_fields_set contains the field
-        if self.success_url is None and "success_url" in self.model_fields_set:
-            _dict['success_url'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CheckoutSessionExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "account_id": obj.get("account_id"),
-            "account_name": obj.get("account_name"),
-            "amount_subtotal_atom": obj.get("amount_subtotal_atom"),
-            "amount_total_atom": obj.get("amount_total_atom"),
-            "client_reference_id": obj.get("client_reference_id"),
-            "currency": obj.get("currency"),
-            "customer_id": obj.get("customer_id"),
-            "customer_email": obj.get("customer_email"),
-            "line_items": [CheckoutSessionLineItemExternal.from_dict(_item) for _item in obj.get("line_items")] if obj.get("line_items") is not None else None,
-            "mode": obj.get("mode"),
-            "payment_intent_id": obj.get("payment_intent_id"),
-            "return_url": obj.get("return_url"),
-            "secure_token": obj.get("secure_token"),
-            "status": obj.get("status"),
-            "subscription_id": obj.get("subscription_id"),
-            "success_url": obj.get("success_url"),
-            "tax_amount_atom": obj.get("tax_amount_atom"),
-            "url": obj.get("url")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of total_amount_atom
+    if self.total_amount_atom:
+      _dict['total_amount_atom'] = self.total_amount_atom.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of period_start
+    if self.period_start:
+      _dict['period_start'] = self.period_start.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of period_end
+    if self.period_end:
+      _dict['period_end'] = self.period_end.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if status (nullable) is None
+    # and model_fields_set contains the field
+    if self.status is None and 'status' in self.model_fields_set:
+      _dict['status'] = None
+
+    # set to None if subscription_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.subscription_id is None and 'subscription_id' in self.model_fields_set:
+      _dict['subscription_id'] = None
+
+    # set to None if billing_reason (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_reason is None and 'billing_reason' in self.model_fields_set:
+      _dict['billing_reason'] = None
+
+    # set to None if total_amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.total_amount_atom is None and 'total_amount_atom' in self.model_fields_set:
+      _dict['total_amount_atom'] = None
+
+    # set to None if period_start (nullable) is None
+    # and model_fields_set contains the field
+    if self.period_start is None and 'period_start' in self.model_fields_set:
+      _dict['period_start'] = None
+
+    # set to None if period_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.period_end is None and 'period_end' in self.model_fields_set:
+      _dict['period_end'] = None
+
+    # set to None if coupon_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_id is None and 'coupon_id' in self.model_fields_set:
+      _dict['coupon_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoiceQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'customer_id': obj.get('customer_id'),
+        'status': obj.get('status'),
+        'subscription_id': obj.get('subscription_id'),
+        'billing_reason': obj.get('billing_reason'),
+        'total_amount_atom':
+          IntRangeFilter.from_dict(obj.get('total_amount_atom'))
+          if obj.get('total_amount_atom') is not None else None,
+        'period_start':
+          DateTimeFilter.from_dict(obj.get('period_start'))
+          if obj.get('period_start') is not None else None,
+        'period_end':
+          DateTimeFilter.from_dict(obj.get('period_end'))
+          if obj.get('period_end') is not None else None,
+        'coupon_id': obj.get('coupon_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/checkout_session_line_item_external.py` & `getopenpay-0.0.2/getopenpay/models/checkout_session_line_item_external.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,123 +7,131 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.calendar_interval_enum import CalendarIntervalEnum
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CheckoutSessionLineItemExternal(BaseModel):
-    """
+  """
     CheckoutSessionLineItemExternal
-    """ # noqa: E501
-    id: StrictStr
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    amount_subtotal_atom: StrictInt
-    amount_total_atom: StrictInt
-    checkout_session_id: Optional[StrictStr]
-    description: Optional[StrictStr]
-    currency: StrictStr
-    price_id: StrictStr
-    billing_interval: Optional[CalendarIntervalEnum]
-    quantity: StrictInt
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "amount_subtotal_atom", "amount_total_atom", "checkout_session_id", "description", "currency", "price_id", "billing_interval", "quantity"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CheckoutSessionLineItemExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  amount_subtotal_atom: StrictInt
+  amount_total_atom: StrictInt
+  checkout_session_id: Optional[StrictStr]
+  description: Optional[StrictStr]
+  currency: StrictStr
+  price_id: StrictStr
+  billing_interval: Optional[CalendarIntervalEnum]
+  quantity: StrictInt
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'amount_subtotal_atom',
+    'amount_total_atom', 'checkout_session_id', 'description', 'currency', 'price_id',
+    'billing_interval', 'quantity'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CheckoutSessionLineItemExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if checkout_session_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.checkout_session_id is None and "checkout_session_id" in self.model_fields_set:
-            _dict['checkout_session_id'] = None
-
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        # set to None if billing_interval (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_interval is None and "billing_interval" in self.model_fields_set:
-            _dict['billing_interval'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CheckoutSessionLineItemExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "amount_subtotal_atom": obj.get("amount_subtotal_atom"),
-            "amount_total_atom": obj.get("amount_total_atom"),
-            "checkout_session_id": obj.get("checkout_session_id"),
-            "description": obj.get("description"),
-            "currency": obj.get("currency"),
-            "price_id": obj.get("price_id"),
-            "billing_interval": obj.get("billing_interval"),
-            "quantity": obj.get("quantity")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if checkout_session_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.checkout_session_id is None and 'checkout_session_id' in self.model_fields_set:
+      _dict['checkout_session_id'] = None
+
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    # set to None if billing_interval (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_interval is None and 'billing_interval' in self.model_fields_set:
+      _dict['billing_interval'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CheckoutSessionLineItemExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'amount_subtotal_atom': obj.get('amount_subtotal_atom'),
+        'amount_total_atom': obj.get('amount_total_atom'),
+        'checkout_session_id': obj.get('checkout_session_id'),
+        'description': obj.get('description'),
+        'currency': obj.get('currency'),
+        'price_id': obj.get('price_id'),
+        'billing_interval': obj.get('billing_interval'),
+        'quantity': obj.get('quantity')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/checkout_session_query_params.py` & `getopenpay-0.0.2/getopenpay/models/promo_code_query_params.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,109 +7,139 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CheckoutSessionQueryParams(BaseModel):
+class PromoCodeQueryParams(BaseModel):
+  """
+    PromoCodeQueryParams
     """
-    CheckoutSessionQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    payment_link_id: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "payment_link_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CheckoutSessionQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  coupon_id: Optional[StrictStr] = None
+  customer_id: Optional[StrictStr] = None
+  is_active: Optional[StrictBool] = None
+  code: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'coupon_id',
+    'customer_id', 'is_active', 'code'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PromoCodeQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if payment_link_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.payment_link_id is None and "payment_link_id" in self.model_fields_set:
-            _dict['payment_link_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CheckoutSessionQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "payment_link_id": obj.get("payment_link_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if coupon_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_id is None and 'coupon_id' in self.model_fields_set:
+      _dict['coupon_id'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if is_active (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_active is None and 'is_active' in self.model_fields_set:
+      _dict['is_active'] = None
+
+    # set to None if code (nullable) is None
+    # and model_fields_set contains the field
+    if self.code is None and 'code' in self.model_fields_set:
+      _dict['code'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PromoCodeQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'coupon_id': obj.get('coupon_id'),
+        'customer_id': obj.get('customer_id'),
+        'is_active': obj.get('is_active'),
+        'code': obj.get('code')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/checkout_session_status.py` & `getopenpay-0.0.2/getopenpay/models/checkout_session_status.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,39 +7,34 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class CheckoutSessionStatus(str, Enum):
-    """
+  """
     CheckoutSessionStatus
     """
-
-    """
+  """
     allowed enum values
     """
-    OPEN = 'open'
-    EXPIRED = 'expired'
-    COMPLETE = 'complete'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CheckoutSessionStatus from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  OPEN = 'open'
+  EXPIRED = 'expired'
+  COMPLETE = 'complete'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CheckoutSessionStatus from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/collection_method_enum.py` & `getopenpay-0.0.2/getopenpay/models/collection_method_enum.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,38 +7,33 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class CollectionMethodEnum(str, Enum):
-    """
+  """
     CollectionMethodEnum
     """
-
-    """
+  """
     allowed enum values
     """
-    CHARGE_AUTOMATICALLY = 'charge_automatically'
-    SEND_INVOICE = 'send_invoice'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CollectionMethodEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
+  CHARGE_AUTOMATICALLY = 'charge_automatically'
+  SEND_INVOICE = 'send_invoice'
 
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CollectionMethodEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/complete_address.py` & `getopenpay-0.0.2/getopenpay/models/tokenized_credit_card_input.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,128 +7,136 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.credit_card_type import CreditCardType
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CompleteAddress(BaseModel):
+class TokenizedCreditCardInput(BaseModel):
+  """
+    TokenizedCreditCardInput
     """
-    CompleteAddress
-    """ # noqa: E501
-    line1: Optional[StrictStr] = None
-    line2: Optional[StrictStr] = None
-    line3: Optional[StrictStr] = None
-    city: Optional[StrictStr] = None
-    state: Optional[StrictStr] = None
-    zip_code: Optional[StrictStr] = None
-    country: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["line1", "line2", "line3", "city", "state", "zip_code", "country"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CompleteAddress from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  cde_external_id: StrictStr = Field(description='Card token.')
+  last_four: StrictStr = Field(description='Last four digits of credit card')
+  zip_code: StrictStr = Field(description='ZIP or postal code.')
+  line1: Optional[StrictStr] = None
+  line2: Optional[StrictStr] = None
+  line3: Optional[StrictStr] = None
+  city: Optional[StrictStr] = None
+  state: Optional[StrictStr] = None
+  country: Optional[StrictStr] = None
+  card_type: Optional[CreditCardType] = None
+  __properties: ClassVar[List[str]] = [
+    'cde_external_id', 'last_four', 'zip_code', 'line1', 'line2', 'line3', 'city', 'state',
+    'country', 'card_type'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of TokenizedCreditCardInput from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if line1 (nullable) is None
-        # and model_fields_set contains the field
-        if self.line1 is None and "line1" in self.model_fields_set:
-            _dict['line1'] = None
-
-        # set to None if line2 (nullable) is None
-        # and model_fields_set contains the field
-        if self.line2 is None and "line2" in self.model_fields_set:
-            _dict['line2'] = None
-
-        # set to None if line3 (nullable) is None
-        # and model_fields_set contains the field
-        if self.line3 is None and "line3" in self.model_fields_set:
-            _dict['line3'] = None
-
-        # set to None if city (nullable) is None
-        # and model_fields_set contains the field
-        if self.city is None and "city" in self.model_fields_set:
-            _dict['city'] = None
-
-        # set to None if state (nullable) is None
-        # and model_fields_set contains the field
-        if self.state is None and "state" in self.model_fields_set:
-            _dict['state'] = None
-
-        # set to None if zip_code (nullable) is None
-        # and model_fields_set contains the field
-        if self.zip_code is None and "zip_code" in self.model_fields_set:
-            _dict['zip_code'] = None
-
-        # set to None if country (nullable) is None
-        # and model_fields_set contains the field
-        if self.country is None and "country" in self.model_fields_set:
-            _dict['country'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CompleteAddress from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "line1": obj.get("line1"),
-            "line2": obj.get("line2"),
-            "line3": obj.get("line3"),
-            "city": obj.get("city"),
-            "state": obj.get("state"),
-            "zip_code": obj.get("zip_code"),
-            "country": obj.get("country")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if line1 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line1 is None and 'line1' in self.model_fields_set:
+      _dict['line1'] = None
+
+    # set to None if line2 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line2 is None and 'line2' in self.model_fields_set:
+      _dict['line2'] = None
+
+    # set to None if line3 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line3 is None and 'line3' in self.model_fields_set:
+      _dict['line3'] = None
+
+    # set to None if city (nullable) is None
+    # and model_fields_set contains the field
+    if self.city is None and 'city' in self.model_fields_set:
+      _dict['city'] = None
+
+    # set to None if state (nullable) is None
+    # and model_fields_set contains the field
+    if self.state is None and 'state' in self.model_fields_set:
+      _dict['state'] = None
+
+    # set to None if country (nullable) is None
+    # and model_fields_set contains the field
+    if self.country is None and 'country' in self.model_fields_set:
+      _dict['country'] = None
+
+    # set to None if card_type (nullable) is None
+    # and model_fields_set contains the field
+    if self.card_type is None and 'card_type' in self.model_fields_set:
+      _dict['card_type'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of TokenizedCreditCardInput from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'cde_external_id': obj.get('cde_external_id'),
+        'last_four': obj.get('last_four'),
+        'zip_code': obj.get('zip_code'),
+        'line1': obj.get('line1'),
+        'line2': obj.get('line2'),
+        'line3': obj.get('line3'),
+        'city': obj.get('city'),
+        'state': obj.get('state'),
+        'country': obj.get('country'),
+        'card_type': obj.get('card_type')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/coupon_duration.py` & `getopenpay-0.0.2/getopenpay/models/coupon_duration.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,39 +7,34 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class CouponDuration(str, Enum):
-    """
+  """
     CouponDuration
     """
-
-    """
+  """
     allowed enum values
     """
-    ONCE = 'once'
-    REPEATING = 'repeating'
-    FOREVER = 'forever'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CouponDuration from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  ONCE = 'once'
+  REPEATING = 'repeating'
+  FOREVER = 'forever'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CouponDuration from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/coupon_external.py` & `getopenpay-0.0.2/getopenpay/models/refund_query_params.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,148 +7,161 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.coupon_duration import CouponDuration
-from getopenpay.models.object_name import ObjectName
+
+from getopenpay.models.date_time_filter import DateTimeFilter
+from getopenpay.models.int_range_filter import IntRangeFilter
+from getopenpay.models.refund_reason_enum import RefundReasonEnum
+from getopenpay.models.refund_status_enum import RefundStatusEnum
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CouponExternal(BaseModel):
+class RefundQueryParams(BaseModel):
+  """
+    RefundQueryParams
     """
-    CouponExternal
-    """ # noqa: E501
-    id: StrictStr
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    name: StrictStr
-    is_active: StrictBool
-    amount_atom_off: Optional[StrictInt]
-    percent_off: Optional[StrictInt]
-    currency: StrictStr
-    duration: CouponDuration
-    duration_in_months: Optional[StrictInt]
-    max_redemptions: Optional[StrictInt]
-    times_redeemed: Optional[StrictInt]
-    redeem_by: Optional[datetime]
-    products: Optional[List[StrictStr]] = None
-    product_families: Optional[List[StrictStr]] = None
-    promotion_codes: Optional[List[StrictStr]] = None
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "name", "is_active", "amount_atom_off", "percent_off", "currency", "duration", "duration_in_months", "max_redemptions", "times_redeemed", "redeem_by", "products", "product_families", "promotion_codes"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CouponExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  charge_id: Optional[StrictStr] = None
+  payment_intent_id: Optional[StrictStr] = None
+  customer_id: Optional[StrictStr] = None
+  reason: Optional[RefundReasonEnum] = None
+  status: Optional[RefundStatusEnum] = None
+  amount_atom: Optional[IntRangeFilter] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'charge_id',
+    'payment_intent_id', 'customer_id', 'reason', 'status', 'amount_atom'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of RefundQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if amount_atom_off (nullable) is None
-        # and model_fields_set contains the field
-        if self.amount_atom_off is None and "amount_atom_off" in self.model_fields_set:
-            _dict['amount_atom_off'] = None
-
-        # set to None if percent_off (nullable) is None
-        # and model_fields_set contains the field
-        if self.percent_off is None and "percent_off" in self.model_fields_set:
-            _dict['percent_off'] = None
-
-        # set to None if duration_in_months (nullable) is None
-        # and model_fields_set contains the field
-        if self.duration_in_months is None and "duration_in_months" in self.model_fields_set:
-            _dict['duration_in_months'] = None
-
-        # set to None if max_redemptions (nullable) is None
-        # and model_fields_set contains the field
-        if self.max_redemptions is None and "max_redemptions" in self.model_fields_set:
-            _dict['max_redemptions'] = None
-
-        # set to None if times_redeemed (nullable) is None
-        # and model_fields_set contains the field
-        if self.times_redeemed is None and "times_redeemed" in self.model_fields_set:
-            _dict['times_redeemed'] = None
-
-        # set to None if redeem_by (nullable) is None
-        # and model_fields_set contains the field
-        if self.redeem_by is None and "redeem_by" in self.model_fields_set:
-            _dict['redeem_by'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CouponExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "name": obj.get("name"),
-            "is_active": obj.get("is_active"),
-            "amount_atom_off": obj.get("amount_atom_off"),
-            "percent_off": obj.get("percent_off"),
-            "currency": obj.get("currency"),
-            "duration": obj.get("duration"),
-            "duration_in_months": obj.get("duration_in_months"),
-            "max_redemptions": obj.get("max_redemptions"),
-            "times_redeemed": obj.get("times_redeemed"),
-            "redeem_by": obj.get("redeem_by"),
-            "products": obj.get("products"),
-            "product_families": obj.get("product_families"),
-            "promotion_codes": obj.get("promotion_codes")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of amount_atom
+    if self.amount_atom:
+      _dict['amount_atom'] = self.amount_atom.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if charge_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.charge_id is None and 'charge_id' in self.model_fields_set:
+      _dict['charge_id'] = None
+
+    # set to None if payment_intent_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_intent_id is None and 'payment_intent_id' in self.model_fields_set:
+      _dict['payment_intent_id'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if reason (nullable) is None
+    # and model_fields_set contains the field
+    if self.reason is None and 'reason' in self.model_fields_set:
+      _dict['reason'] = None
+
+    # set to None if status (nullable) is None
+    # and model_fields_set contains the field
+    if self.status is None and 'status' in self.model_fields_set:
+      _dict['status'] = None
+
+    # set to None if amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.amount_atom is None and 'amount_atom' in self.model_fields_set:
+      _dict['amount_atom'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of RefundQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'charge_id': obj.get('charge_id'),
+        'payment_intent_id': obj.get('payment_intent_id'),
+        'customer_id': obj.get('customer_id'),
+        'reason': obj.get('reason'),
+        'status': obj.get('status'),
+        'amount_atom':
+          IntRangeFilter.from_dict(obj.get('amount_atom'))
+          if obj.get('amount_atom') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/coupon_query_params.py` & `getopenpay-0.0.2/getopenpay/models/price_query_params.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,109 +7,135 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
+from getopenpay.models.price_type_enum import PriceTypeEnum
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CouponQueryParams(BaseModel):
+class PriceQueryParams(BaseModel):
+  """
+    PriceQueryParams
     """
-    CouponQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    is_active: Optional[StrictBool] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "is_active"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CouponQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  product_id: Optional[StrictStr] = None
+  is_active: Optional[StrictBool] = None
+  currency: Optional[StrictStr] = None
+  price_type: Optional[PriceTypeEnum] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'product_id',
+    'is_active', 'currency', 'price_type'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PriceQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if is_active (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_active is None and "is_active" in self.model_fields_set:
-            _dict['is_active'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CouponQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "is_active": obj.get("is_active")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if product_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.product_id is None and 'product_id' in self.model_fields_set:
+      _dict['product_id'] = None
+
+    # set to None if is_active (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_active is None and 'is_active' in self.model_fields_set:
+      _dict['is_active'] = None
+
+    # set to None if price_type (nullable) is None
+    # and model_fields_set contains the field
+    if self.price_type is None and 'price_type' in self.model_fields_set:
+      _dict['price_type'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PriceQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'product_id': obj.get('product_id'),
+        'is_active': obj.get('is_active'),
+        'currency': obj.get('currency'),
+        'price_type': obj.get('price_type')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_checkout_line_item.py` & `getopenpay-0.0.2/getopenpay/models/create_checkout_line_item.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,84 +7,76 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List
 
+from pydantic import BaseModel, Field, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateCheckoutLineItem(BaseModel):
-    """
+  """
     CreateCheckoutLineItem
-    """ # noqa: E501
-    price_id: StrictStr = Field(description="Unique ID of the price corresponding to this line item")
-    quantity: StrictInt = Field(description="The quantity of the line item being purchased.")
-    __properties: ClassVar[List[str]] = ["price_id", "quantity"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateCheckoutLineItem from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  price_id: StrictStr = Field(description='Unique ID of the price corresponding to this line item')
+  quantity: StrictInt = Field(description='The quantity of the line item being purchased.')
+  __properties: ClassVar[List[str]] = ['price_id', 'quantity']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateCheckoutLineItem from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateCheckoutLineItem from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "price_id": obj.get("price_id"),
-            "quantity": obj.get("quantity")
-        })
-        return _obj
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateCheckoutLineItem from a dict"""
+    if obj is None:
+      return None
 
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
 
+    _obj = cls.model_validate({'price_id': obj.get('price_id'), 'quantity': obj.get('quantity')})
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_checkout_session_request.py` & `getopenpay-0.0.2/getopenpay/models/create_checkout_session_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,129 +7,132 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
+
 from getopenpay.models.checkout_mode import CheckoutMode
 from getopenpay.models.create_checkout_line_item import CreateCheckoutLineItem
+from pydantic import BaseModel, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateCheckoutSessionRequest(BaseModel):
-    """
+  """
     CreateCheckoutSessionRequest
-    """ # noqa: E501
-    client_reference_id: Optional[StrictStr] = None
-    currency: Optional[StrictStr] = None
-    customer_id: Optional[StrictStr] = None
-    customer_email: Optional[StrictStr] = None
-    line_items: Optional[List[CreateCheckoutLineItem]] = None
-    mode: CheckoutMode
-    return_url: Optional[StrictStr] = None
-    success_url: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["client_reference_id", "currency", "customer_id", "customer_email", "line_items", "mode", "return_url", "success_url"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateCheckoutSessionRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  client_reference_id: Optional[StrictStr] = None
+  currency: Optional[StrictStr] = None
+  customer_id: Optional[StrictStr] = None
+  customer_email: Optional[StrictStr] = None
+  line_items: Optional[List[CreateCheckoutLineItem]] = None
+  mode: CheckoutMode
+  return_url: Optional[StrictStr] = None
+  success_url: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'client_reference_id', 'currency', 'customer_id', 'customer_email', 'line_items', 'mode',
+    'return_url', 'success_url'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateCheckoutSessionRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
-        _items = []
-        if self.line_items:
-            for _item in self.line_items:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['line_items'] = _items
-        # set to None if client_reference_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.client_reference_id is None and "client_reference_id" in self.model_fields_set:
-            _dict['client_reference_id'] = None
-
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if customer_email (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_email is None and "customer_email" in self.model_fields_set:
-            _dict['customer_email'] = None
-
-        # set to None if return_url (nullable) is None
-        # and model_fields_set contains the field
-        if self.return_url is None and "return_url" in self.model_fields_set:
-            _dict['return_url'] = None
-
-        # set to None if success_url (nullable) is None
-        # and model_fields_set contains the field
-        if self.success_url is None and "success_url" in self.model_fields_set:
-            _dict['success_url'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateCheckoutSessionRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "client_reference_id": obj.get("client_reference_id"),
-            "currency": obj.get("currency"),
-            "customer_id": obj.get("customer_id"),
-            "customer_email": obj.get("customer_email"),
-            "line_items": [CreateCheckoutLineItem.from_dict(_item) for _item in obj.get("line_items")] if obj.get("line_items") is not None else None,
-            "mode": obj.get("mode"),
-            "return_url": obj.get("return_url"),
-            "success_url": obj.get("success_url")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
+    _items = []
+    if self.line_items:
+      for _item in self.line_items:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['line_items'] = _items
+    # set to None if client_reference_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.client_reference_id is None and 'client_reference_id' in self.model_fields_set:
+      _dict['client_reference_id'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if customer_email (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_email is None and 'customer_email' in self.model_fields_set:
+      _dict['customer_email'] = None
+
+    # set to None if return_url (nullable) is None
+    # and model_fields_set contains the field
+    if self.return_url is None and 'return_url' in self.model_fields_set:
+      _dict['return_url'] = None
+
+    # set to None if success_url (nullable) is None
+    # and model_fields_set contains the field
+    if self.success_url is None and 'success_url' in self.model_fields_set:
+      _dict['success_url'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateCheckoutSessionRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'client_reference_id': obj.get('client_reference_id'),
+        'currency': obj.get('currency'),
+        'customer_id': obj.get('customer_id'),
+        'customer_email': obj.get('customer_email'),
+        'line_items':
+          [CreateCheckoutLineItem.from_dict(_item) for _item in obj.get('line_items')]
+          if obj.get('line_items') is not None else None,
+        'mode': obj.get('mode'),
+        'return_url': obj.get('return_url'),
+        'success_url': obj.get('success_url')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_coupon_request.py` & `getopenpay-0.0.2/getopenpay/models/create_coupon_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,129 +7,134 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.coupon_duration import CouponDuration
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateCouponRequest(BaseModel):
-    """
+  """
     CreateCouponRequest
-    """ # noqa: E501
-    name: StrictStr = Field(description="Name of the coupon displayed to customers on, for instance invoices, or receipts.")
-    amount_atom_off: Optional[StrictInt] = None
-    percent_off: Optional[Annotated[int, Field(le=100, strict=True)]] = None
-    currency: Optional[StrictStr] = None
-    duration: Optional[CouponDuration] = None
-    duration_in_months: Optional[StrictInt] = None
-    product_ids: Optional[List[StrictStr]] = None
-    product_family_ids: Optional[List[StrictStr]] = None
-    max_redemptions: Optional[StrictInt] = None
-    redeem_by: Optional[datetime] = None
-    is_active: Optional[StrictBool] = Field(default=True, description="Whether the coupon is available to be redeemed.")
-    __properties: ClassVar[List[str]] = ["name", "amount_atom_off", "percent_off", "currency", "duration", "duration_in_months", "product_ids", "product_family_ids", "max_redemptions", "redeem_by", "is_active"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateCouponRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  name: StrictStr = Field(
+    description='Name of the coupon displayed to customers on, for instance invoices, or receipts.'
+  )
+  amount_atom_off: Optional[StrictInt] = None
+  percent_off: Optional[Annotated[int, Field(le=100, strict=True)]] = None
+  currency: Optional[StrictStr] = None
+  duration: Optional[CouponDuration] = None
+  duration_in_months: Optional[StrictInt] = None
+  product_ids: Optional[List[StrictStr]] = None
+  product_family_ids: Optional[List[StrictStr]] = None
+  max_redemptions: Optional[StrictInt] = None
+  redeem_by: Optional[datetime] = None
+  is_active: Optional[StrictBool] = Field(
+    default=True, description='Whether the coupon is available to be redeemed.'
+  )
+  __properties: ClassVar[List[str]] = [
+    'name', 'amount_atom_off', 'percent_off', 'currency', 'duration', 'duration_in_months',
+    'product_ids', 'product_family_ids', 'max_redemptions', 'redeem_by', 'is_active'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateCouponRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if amount_atom_off (nullable) is None
-        # and model_fields_set contains the field
-        if self.amount_atom_off is None and "amount_atom_off" in self.model_fields_set:
-            _dict['amount_atom_off'] = None
-
-        # set to None if percent_off (nullable) is None
-        # and model_fields_set contains the field
-        if self.percent_off is None and "percent_off" in self.model_fields_set:
-            _dict['percent_off'] = None
-
-        # set to None if duration_in_months (nullable) is None
-        # and model_fields_set contains the field
-        if self.duration_in_months is None and "duration_in_months" in self.model_fields_set:
-            _dict['duration_in_months'] = None
-
-        # set to None if max_redemptions (nullable) is None
-        # and model_fields_set contains the field
-        if self.max_redemptions is None and "max_redemptions" in self.model_fields_set:
-            _dict['max_redemptions'] = None
-
-        # set to None if redeem_by (nullable) is None
-        # and model_fields_set contains the field
-        if self.redeem_by is None and "redeem_by" in self.model_fields_set:
-            _dict['redeem_by'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateCouponRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "name": obj.get("name"),
-            "amount_atom_off": obj.get("amount_atom_off"),
-            "percent_off": obj.get("percent_off"),
-            "currency": obj.get("currency"),
-            "duration": obj.get("duration"),
-            "duration_in_months": obj.get("duration_in_months"),
-            "product_ids": obj.get("product_ids"),
-            "product_family_ids": obj.get("product_family_ids"),
-            "max_redemptions": obj.get("max_redemptions"),
-            "redeem_by": obj.get("redeem_by"),
-            "is_active": obj.get("is_active") if obj.get("is_active") is not None else True
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if amount_atom_off (nullable) is None
+    # and model_fields_set contains the field
+    if self.amount_atom_off is None and 'amount_atom_off' in self.model_fields_set:
+      _dict['amount_atom_off'] = None
+
+    # set to None if percent_off (nullable) is None
+    # and model_fields_set contains the field
+    if self.percent_off is None and 'percent_off' in self.model_fields_set:
+      _dict['percent_off'] = None
+
+    # set to None if duration_in_months (nullable) is None
+    # and model_fields_set contains the field
+    if self.duration_in_months is None and 'duration_in_months' in self.model_fields_set:
+      _dict['duration_in_months'] = None
+
+    # set to None if max_redemptions (nullable) is None
+    # and model_fields_set contains the field
+    if self.max_redemptions is None and 'max_redemptions' in self.model_fields_set:
+      _dict['max_redemptions'] = None
+
+    # set to None if redeem_by (nullable) is None
+    # and model_fields_set contains the field
+    if self.redeem_by is None and 'redeem_by' in self.model_fields_set:
+      _dict['redeem_by'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateCouponRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'name': obj.get('name'),
+        'amount_atom_off': obj.get('amount_atom_off'),
+        'percent_off': obj.get('percent_off'),
+        'currency': obj.get('currency'),
+        'duration': obj.get('duration'),
+        'duration_in_months': obj.get('duration_in_months'),
+        'product_ids': obj.get('product_ids'),
+        'product_family_ids': obj.get('product_family_ids'),
+        'max_redemptions': obj.get('max_redemptions'),
+        'redeem_by': obj.get('redeem_by'),
+        'is_active': obj.get('is_active') if obj.get('is_active') is not None else True
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_credit_note_line.py` & `getopenpay-0.0.2/getopenpay/models/create_credit_note_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,103 +7,122 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.create_credit_note_line import CreateCreditNoteLine
+from getopenpay.models.credit_note_reason import CreditNoteReason
+from pydantic import BaseModel, Field, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.credit_note_line_type import CreditNoteLineType
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CreateCreditNoteLine(BaseModel):
+class CreateCreditNoteRequest(BaseModel):
+  """
+    CreateCreditNoteRequest
     """
-    CreateCreditNoteLine
-    """ # noqa: E501
-    amount_atom: StrictInt = Field(description="The integer amount representing the gross amount being credited for this line item.")
-    currency: StrictStr
-    type: CreditNoteLineType
-    quantity: Optional[StrictInt] = 1
-    invoice_item_id: Optional[StrictStr] = None
-    unit_amount_atom: Optional[StrictInt] = None
-    __properties: ClassVar[List[str]] = ["amount_atom", "currency", "type", "quantity", "invoice_item_id", "unit_amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateCreditNoteLine from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  invoice_id: StrictStr = Field(description='ID of the invoice')
+  reason: Optional[CreditNoteReason] = None
+  total_amount_atom: StrictInt = Field(
+    description='The int amount representing the total amount of the credit note.'
+  )
+  credit_amount_atom: Optional[StrictInt] = Field(
+    default=0,
+    description=
+    'The integer amount representing the amount to credit the customers balance, which will be automatically applied to their next invoice.'
+  )
+  refund_amount_atom: Optional[StrictInt] = Field(
+    default=0,
+    description=
+    'The integer amount representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.'
+  )
+  lines: List[CreateCreditNoteLine]
+  currency: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'invoice_id', 'reason', 'total_amount_atom', 'credit_amount_atom', 'refund_amount_atom',
+    'lines', 'currency'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateCreditNoteRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if invoice_item_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_item_id is None and "invoice_item_id" in self.model_fields_set:
-            _dict['invoice_item_id'] = None
-
-        # set to None if unit_amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.unit_amount_atom is None and "unit_amount_atom" in self.model_fields_set:
-            _dict['unit_amount_atom'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateCreditNoteLine from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "amount_atom": obj.get("amount_atom"),
-            "currency": obj.get("currency"),
-            "type": obj.get("type"),
-            "quantity": obj.get("quantity") if obj.get("quantity") is not None else 1,
-            "invoice_item_id": obj.get("invoice_item_id"),
-            "unit_amount_atom": obj.get("unit_amount_atom")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in lines (list)
+    _items = []
+    if self.lines:
+      for _item in self.lines:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['lines'] = _items
+    # set to None if reason (nullable) is None
+    # and model_fields_set contains the field
+    if self.reason is None and 'reason' in self.model_fields_set:
+      _dict['reason'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateCreditNoteRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'invoice_id': obj.get('invoice_id'),
+        'reason': obj.get('reason'),
+        'total_amount_atom': obj.get('total_amount_atom'),
+        'credit_amount_atom':
+          obj.get('credit_amount_atom') if obj.get('credit_amount_atom') is not None else 0,
+        'refund_amount_atom':
+          obj.get('refund_amount_atom') if obj.get('refund_amount_atom') is not None else 0,
+        'lines':
+          [CreateCreditNoteLine.from_dict(_item) for _item in obj.get('lines')]
+          if obj.get('lines') is not None else None,
+        'currency': obj.get('currency')
+      }
+    )
+    return _obj
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_credit_note_request.py` & `getopenpay-0.0.2/getopenpay/models/create_invoice_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,108 +7,112 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.collection_method_enum import CollectionMethodEnum
+from getopenpay.models.discounts import Discounts
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.create_credit_note_line import CreateCreditNoteLine
-from getopenpay.models.credit_note_reason import CreditNoteReason
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CreateCreditNoteRequest(BaseModel):
+class CreateInvoiceRequest(BaseModel):
+  """
+    CreateInvoiceRequest
     """
-    CreateCreditNoteRequest
-    """ # noqa: E501
-    invoice_id: StrictStr = Field(description="ID of the invoice")
-    reason: Optional[CreditNoteReason] = None
-    total_amount_atom: StrictInt = Field(description="The int amount representing the total amount of the credit note.")
-    credit_amount_atom: Optional[StrictInt] = Field(default=0, description="The integer amount representing the amount to credit the customers balance, which will be automatically applied to their next invoice.")
-    refund_amount_atom: Optional[StrictInt] = Field(default=0, description="The integer amount representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.")
-    lines: List[CreateCreditNoteLine]
-    currency: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["invoice_id", "reason", "total_amount_atom", "credit_amount_atom", "refund_amount_atom", "lines", "currency"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateCreditNoteRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  subscription_id: StrictStr = Field(
+    description=
+    'Unique identifier of the subscription. The created invoice will only include pending invoice items for that subscription. The subscriptions billing cycle and regular subscription events wont be affected.'
+  )
+  payment_method_id: Optional[StrictStr] = None
+  collection_method: Optional[CollectionMethodEnum] = None
+  description: Optional[StrictStr] = Field(
+    default='Manual creation of invoice', description='Description for newly created invoice'
+  )
+  discounts: Optional[Discounts] = None
+  __properties: ClassVar[List[str]] = [
+    'subscription_id', 'payment_method_id', 'collection_method', 'description', 'discounts'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateInvoiceRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in lines (list)
-        _items = []
-        if self.lines:
-            for _item in self.lines:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['lines'] = _items
-        # set to None if reason (nullable) is None
-        # and model_fields_set contains the field
-        if self.reason is None and "reason" in self.model_fields_set:
-            _dict['reason'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateCreditNoteRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "invoice_id": obj.get("invoice_id"),
-            "reason": obj.get("reason"),
-            "total_amount_atom": obj.get("total_amount_atom"),
-            "credit_amount_atom": obj.get("credit_amount_atom") if obj.get("credit_amount_atom") is not None else 0,
-            "refund_amount_atom": obj.get("refund_amount_atom") if obj.get("refund_amount_atom") is not None else 0,
-            "lines": [CreateCreditNoteLine.from_dict(_item) for _item in obj.get("lines")] if obj.get("lines") is not None else None,
-            "currency": obj.get("currency")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of discounts
+    if self.discounts:
+      _dict['discounts'] = self.discounts.to_dict()
+    # set to None if payment_method_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_method_id is None and 'payment_method_id' in self.model_fields_set:
+      _dict['payment_method_id'] = None
+
+    # set to None if discounts (nullable) is None
+    # and model_fields_set contains the field
+    if self.discounts is None and 'discounts' in self.model_fields_set:
+      _dict['discounts'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateInvoiceRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'subscription_id': obj.get('subscription_id'),
+        'payment_method_id': obj.get('payment_method_id'),
+        'collection_method': obj.get('collection_method'),
+        'description':
+          obj.get('description')
+          if obj.get('description') is not None else 'Manual creation of invoice',
+        'discounts':
+          Discounts.from_dict(obj.get('discounts')) if obj.get('discounts') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_customer_balance_transaction_request.py` & `getopenpay-0.0.2/getopenpay/models/create_customer_balance_transaction_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,91 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateCustomerBalanceTransactionRequest(BaseModel):
-    """
+  """
     CreateCustomerBalanceTransactionRequest
-    """ # noqa: E501
-    amount_atom: StrictInt = Field(description="The amount of the transaction in atomic units (in USD this is cents). A negative value is a credit for the customers balance, and a positive value is a debit to the customers balance.")
-    currency: Optional[StrictStr] = None
-    description: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["amount_atom", "currency", "description"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateCustomerBalanceTransactionRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  amount_atom: StrictInt = Field(
+    description=
+    'The amount of the transaction in atomic units (in USD this is cents). A negative value is a credit for the customers balance, and a positive value is a debit to the customers balance.'
+  )
+  currency: Optional[StrictStr] = None
+  description: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = ['amount_atom', 'currency', 'description']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateCustomerBalanceTransactionRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateCustomerBalanceTransactionRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "amount_atom": obj.get("amount_atom"),
-            "currency": obj.get("currency"),
-            "description": obj.get("description")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateCustomerBalanceTransactionRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'amount_atom': obj.get('amount_atom'),
+        'currency': obj.get('currency'),
+        'description': obj.get('description')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_customer_request.py` & `getopenpay-0.0.2/getopenpay/models/create_customer_request.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,134 +7,134 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateCustomerRequest(BaseModel):
-    """
+  """
     CreateCustomerRequest
-    """ # noqa: E501
-    first_name: StrictStr = Field(description="The customers first name.")
-    last_name: StrictStr = Field(description="The customers last name.")
-    line1: Optional[StrictStr] = None
-    line2: Optional[StrictStr] = None
-    line3: Optional[StrictStr] = None
-    city: Optional[StrictStr] = None
-    state: StrictStr = Field(description="State, province, or region.")
-    country: StrictStr = Field(description="Country name. If possible two-letter country code.")
-    zip_code: StrictStr = Field(description="ZIP or postal code.")
-    coupon_id: Optional[StrictStr] = None
-    promotion_code_id: Optional[StrictStr] = None
-    email: StrictStr = Field(description="The customers email address.")
-    __properties: ClassVar[List[str]] = ["first_name", "last_name", "line1", "line2", "line3", "city", "state", "country", "zip_code", "coupon_id", "promotion_code_id", "email"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateCustomerRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  first_name: StrictStr = Field(description='The customers first name.')
+  last_name: StrictStr = Field(description='The customers last name.')
+  line1: Optional[StrictStr] = None
+  line2: Optional[StrictStr] = None
+  line3: Optional[StrictStr] = None
+  city: Optional[StrictStr] = None
+  state: StrictStr = Field(description='State, province, or region.')
+  country: StrictStr = Field(description='Country name. If possible two-letter country code.')
+  zip_code: StrictStr = Field(description='ZIP or postal code.')
+  coupon_id: Optional[StrictStr] = None
+  promotion_code_id: Optional[StrictStr] = None
+  email: StrictStr = Field(description='The customers email address.')
+  __properties: ClassVar[List[str]] = [
+    'first_name', 'last_name', 'line1', 'line2', 'line3', 'city', 'state', 'country', 'zip_code',
+    'coupon_id', 'promotion_code_id', 'email'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateCustomerRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if line1 (nullable) is None
-        # and model_fields_set contains the field
-        if self.line1 is None and "line1" in self.model_fields_set:
-            _dict['line1'] = None
-
-        # set to None if line2 (nullable) is None
-        # and model_fields_set contains the field
-        if self.line2 is None and "line2" in self.model_fields_set:
-            _dict['line2'] = None
-
-        # set to None if line3 (nullable) is None
-        # and model_fields_set contains the field
-        if self.line3 is None and "line3" in self.model_fields_set:
-            _dict['line3'] = None
-
-        # set to None if city (nullable) is None
-        # and model_fields_set contains the field
-        if self.city is None and "city" in self.model_fields_set:
-            _dict['city'] = None
-
-        # set to None if coupon_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.coupon_id is None and "coupon_id" in self.model_fields_set:
-            _dict['coupon_id'] = None
-
-        # set to None if promotion_code_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.promotion_code_id is None and "promotion_code_id" in self.model_fields_set:
-            _dict['promotion_code_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateCustomerRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "first_name": obj.get("first_name"),
-            "last_name": obj.get("last_name"),
-            "line1": obj.get("line1"),
-            "line2": obj.get("line2"),
-            "line3": obj.get("line3"),
-            "city": obj.get("city"),
-            "state": obj.get("state"),
-            "country": obj.get("country"),
-            "zip_code": obj.get("zip_code"),
-            "coupon_id": obj.get("coupon_id"),
-            "promotion_code_id": obj.get("promotion_code_id"),
-            "email": obj.get("email")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if line1 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line1 is None and 'line1' in self.model_fields_set:
+      _dict['line1'] = None
+
+    # set to None if line2 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line2 is None and 'line2' in self.model_fields_set:
+      _dict['line2'] = None
+
+    # set to None if line3 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line3 is None and 'line3' in self.model_fields_set:
+      _dict['line3'] = None
+
+    # set to None if city (nullable) is None
+    # and model_fields_set contains the field
+    if self.city is None and 'city' in self.model_fields_set:
+      _dict['city'] = None
+
+    # set to None if coupon_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_id is None and 'coupon_id' in self.model_fields_set:
+      _dict['coupon_id'] = None
+
+    # set to None if promotion_code_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.promotion_code_id is None and 'promotion_code_id' in self.model_fields_set:
+      _dict['promotion_code_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateCustomerRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'first_name': obj.get('first_name'),
+        'last_name': obj.get('last_name'),
+        'line1': obj.get('line1'),
+        'line2': obj.get('line2'),
+        'line3': obj.get('line3'),
+        'city': obj.get('city'),
+        'state': obj.get('state'),
+        'country': obj.get('country'),
+        'zip_code': obj.get('zip_code'),
+        'coupon_id': obj.get('coupon_id'),
+        'promotion_code_id': obj.get('promotion_code_id'),
+        'email': obj.get('email')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_invoice_request.py` & `getopenpay-0.0.2/getopenpay/models/create_refund_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,105 +7,109 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.refund_reason_enum import RefundReasonEnum
+from pydantic import BaseModel, Field, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
-from getopenpay.models.collection_method_enum import CollectionMethodEnum
-from getopenpay.models.discounts import Discounts
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CreateInvoiceRequest(BaseModel):
+class CreateRefundRequest(BaseModel):
+  """
+    CreateRefundRequest
     """
-    CreateInvoiceRequest
-    """ # noqa: E501
-    subscription_id: StrictStr = Field(description="Unique identifier of the subscription. The created invoice will only include pending invoice items for that subscription. The subscriptions billing cycle and regular subscription events wont be affected.")
-    payment_method_id: Optional[StrictStr] = None
-    collection_method: Optional[CollectionMethodEnum] = None
-    description: Optional[StrictStr] = Field(default='Manual creation of invoice', description="Description for newly created invoice")
-    discounts: Optional[Discounts] = None
-    __properties: ClassVar[List[str]] = ["subscription_id", "payment_method_id", "collection_method", "description", "discounts"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateInvoiceRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  charge_id: Optional[StrictStr] = None
+  payment_intent_id: Optional[StrictStr] = None
+  amount_atom: Optional[StrictInt] = None
+  reason: Optional[RefundReasonEnum] = None
+  description: Optional[StrictStr] = Field(
+    default='Manually triggered refund by admin.', description='Description of the refund.'
+  )
+  __properties: ClassVar[List[str]] = [
+    'charge_id', 'payment_intent_id', 'amount_atom', 'reason', 'description'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateRefundRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of discounts
-        if self.discounts:
-            _dict['discounts'] = self.discounts.to_dict()
-        # set to None if payment_method_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.payment_method_id is None and "payment_method_id" in self.model_fields_set:
-            _dict['payment_method_id'] = None
-
-        # set to None if discounts (nullable) is None
-        # and model_fields_set contains the field
-        if self.discounts is None and "discounts" in self.model_fields_set:
-            _dict['discounts'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateInvoiceRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "subscription_id": obj.get("subscription_id"),
-            "payment_method_id": obj.get("payment_method_id"),
-            "collection_method": obj.get("collection_method"),
-            "description": obj.get("description") if obj.get("description") is not None else 'Manual creation of invoice',
-            "discounts": Discounts.from_dict(obj.get("discounts")) if obj.get("discounts") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if charge_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.charge_id is None and 'charge_id' in self.model_fields_set:
+      _dict['charge_id'] = None
+
+    # set to None if payment_intent_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_intent_id is None and 'payment_intent_id' in self.model_fields_set:
+      _dict['payment_intent_id'] = None
+
+    # set to None if amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.amount_atom is None and 'amount_atom' in self.model_fields_set:
+      _dict['amount_atom'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateRefundRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'charge_id': obj.get('charge_id'),
+        'payment_intent_id': obj.get('payment_intent_id'),
+        'amount_atom': obj.get('amount_atom'),
+        'reason': obj.get('reason'),
+        'description':
+          obj.get('description')
+          if obj.get('description') is not None else 'Manually triggered refund by admin.'
+      }
+    )
+    return _obj
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_payment_link_request.py` & `getopenpay-0.0.2/getopenpay/models/create_payment_link_request.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,95 +7,96 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
+
 from getopenpay.models.checkout_mode import CheckoutMode
 from getopenpay.models.create_checkout_line_item import CreateCheckoutLineItem
+from pydantic import BaseModel, Field, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreatePaymentLinkRequest(BaseModel):
-    """
+  """
     CreatePaymentLinkRequest
-    """ # noqa: E501
-    line_items: Optional[List[CreateCheckoutLineItem]] = None
-    mode: CheckoutMode
-    success_url: StrictStr = Field(description="The URL to which OpenPay should send customers when payment or setup is complete.")
-    __properties: ClassVar[List[str]] = ["line_items", "mode", "success_url"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreatePaymentLinkRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  line_items: Optional[List[CreateCheckoutLineItem]] = None
+  mode: CheckoutMode
+  success_url: StrictStr = Field(
+    description='The URL to which OpenPay should send customers when payment or setup is complete.'
+  )
+  __properties: ClassVar[List[str]] = ['line_items', 'mode', 'success_url']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreatePaymentLinkRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
-        _items = []
-        if self.line_items:
-            for _item in self.line_items:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['line_items'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreatePaymentLinkRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "line_items": [CreateCheckoutLineItem.from_dict(_item) for _item in obj.get("line_items")] if obj.get("line_items") is not None else None,
-            "mode": obj.get("mode"),
-            "success_url": obj.get("success_url")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
+    _items = []
+    if self.line_items:
+      for _item in self.line_items:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['line_items'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreatePaymentLinkRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'line_items':
+          [CreateCheckoutLineItem.from_dict(_item) for _item in obj.get('line_items')]
+          if obj.get('line_items') is not None else None,
+        'mode': obj.get('mode'),
+        'success_url': obj.get('success_url')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_portal_session_request.py` & `getopenpay-0.0.2/getopenpay/models/create_portal_session_request.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,84 +7,84 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List
 
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreatePortalSessionRequest(BaseModel):
-    """
+  """
     CreatePortalSessionRequest
-    """ # noqa: E501
-    customer_id: StrictStr = Field(description="The ID of an existing customer.")
-    return_url: StrictStr = Field(description="The default URL to redirect customers to when they click on the portal's link to return to your website.")
-    __properties: ClassVar[List[str]] = ["customer_id", "return_url"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreatePortalSessionRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  customer_id: StrictStr = Field(description='The ID of an existing customer.')
+  return_url: StrictStr = Field(
+    description=
+    "The default URL to redirect customers to when they click on the portal's link to return to your website."
+  )
+  __properties: ClassVar[List[str]] = ['customer_id', 'return_url']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreatePortalSessionRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreatePortalSessionRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "customer_id": obj.get("customer_id"),
-            "return_url": obj.get("return_url")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreatePortalSessionRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'customer_id': obj.get('customer_id'),
+        'return_url': obj.get('return_url')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_price_request.py` & `getopenpay-0.0.2/getopenpay/models/create_price_request.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,178 +7,192 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional, Union
-from pydantic import BaseModel, StrictBool, StrictFloat, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.calendar_interval_enum import CalendarIntervalEnum
 from getopenpay.models.price_tier_params import PriceTierParams
 from getopenpay.models.price_type_enum import PriceTypeEnum
 from getopenpay.models.pricing_model import PricingModel
 from getopenpay.models.usage_agg_method_enum import UsageAggMethodEnum
 from getopenpay.models.usage_type_enum import UsageTypeEnum
+from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreatePriceRequest(BaseModel):
-    """
+  """
     CreatePriceRequest
-    """ # noqa: E501
-    is_active: StrictBool = Field(description="Whether the price can be used for new purchases.")
-    internal_description: Optional[StrictStr] = None
-    pricing_model: PricingModel
-    unit_amount_atom: Optional[StrictInt]
-    transform_quantity_divide_by: Optional[Union[StrictFloat, StrictInt]] = Field(default=1.0, description="This transformation will be applied on quantity before multiplying by unit_amount_atom.")
-    price_tiers: Optional[List[PriceTierParams]] = None
-    price_type: PriceTypeEnum
-    billing_interval: Optional[CalendarIntervalEnum] = None
-    billing_interval_count: Optional[StrictInt] = None
-    contract_term_multiple: Optional[StrictInt] = None
-    contract_auto_renew: Optional[StrictBool] = None
-    trial_period_days: Optional[StrictInt] = Field(default=0, description="Number of trail days for this Price.")
-    usage_type: Optional[UsageTypeEnum] = None
-    aggregate_usage: Optional[UsageAggMethodEnum] = None
-    default_net_d: Optional[StrictInt] = None
-    is_exclusive: Optional[StrictBool] = None
-    listed_exclusively_for_customers: Optional[List[StrictStr]] = None
-    can_only_be_purchased_with: Optional[List[StrictStr]] = None
-    product_id: StrictStr = Field(description="Unique identifier of the product.")
-    is_default: Optional[StrictBool] = None
-    __properties: ClassVar[List[str]] = ["is_active", "internal_description", "pricing_model", "unit_amount_atom", "transform_quantity_divide_by", "price_tiers", "price_type", "billing_interval", "billing_interval_count", "contract_term_multiple", "contract_auto_renew", "trial_period_days", "usage_type", "aggregate_usage", "default_net_d", "is_exclusive", "listed_exclusively_for_customers", "can_only_be_purchased_with", "product_id", "is_default"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreatePriceRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  is_active: StrictBool = Field(description='Whether the price can be used for new purchases.')
+  internal_description: Optional[StrictStr] = None
+  pricing_model: PricingModel
+  unit_amount_atom: Optional[StrictInt]
+  transform_quantity_divide_by: Optional[Union[StrictFloat, StrictInt]] = Field(
+    default=1.0,
+    description=
+    'This transformation will be applied on quantity before multiplying by unit_amount_atom.'
+  )
+  price_tiers: Optional[List[PriceTierParams]] = None
+  price_type: PriceTypeEnum
+  billing_interval: Optional[CalendarIntervalEnum] = None
+  billing_interval_count: Optional[StrictInt] = None
+  contract_term_multiple: Optional[StrictInt] = None
+  contract_auto_renew: Optional[StrictBool] = None
+  trial_period_days: Optional[StrictInt] = Field(
+    default=0, description='Number of trail days for this Price.'
+  )
+  usage_type: Optional[UsageTypeEnum] = None
+  aggregate_usage: Optional[UsageAggMethodEnum] = None
+  default_net_d: Optional[StrictInt] = None
+  is_exclusive: Optional[StrictBool] = None
+  listed_exclusively_for_customers: Optional[List[StrictStr]] = None
+  can_only_be_purchased_with: Optional[List[StrictStr]] = None
+  product_id: StrictStr = Field(description='Unique identifier of the product.')
+  is_default: Optional[StrictBool] = None
+  __properties: ClassVar[List[str]] = [
+    'is_active', 'internal_description', 'pricing_model', 'unit_amount_atom',
+    'transform_quantity_divide_by', 'price_tiers', 'price_type', 'billing_interval',
+    'billing_interval_count', 'contract_term_multiple', 'contract_auto_renew', 'trial_period_days',
+    'usage_type', 'aggregate_usage', 'default_net_d', 'is_exclusive',
+    'listed_exclusively_for_customers', 'can_only_be_purchased_with', 'product_id', 'is_default'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreatePriceRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in price_tiers (list)
-        _items = []
-        if self.price_tiers:
-            for _item in self.price_tiers:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['price_tiers'] = _items
-        # set to None if internal_description (nullable) is None
-        # and model_fields_set contains the field
-        if self.internal_description is None and "internal_description" in self.model_fields_set:
-            _dict['internal_description'] = None
-
-        # set to None if unit_amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.unit_amount_atom is None and "unit_amount_atom" in self.model_fields_set:
-            _dict['unit_amount_atom'] = None
-
-        # set to None if billing_interval (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_interval is None and "billing_interval" in self.model_fields_set:
-            _dict['billing_interval'] = None
-
-        # set to None if billing_interval_count (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_interval_count is None and "billing_interval_count" in self.model_fields_set:
-            _dict['billing_interval_count'] = None
-
-        # set to None if contract_term_multiple (nullable) is None
-        # and model_fields_set contains the field
-        if self.contract_term_multiple is None and "contract_term_multiple" in self.model_fields_set:
-            _dict['contract_term_multiple'] = None
-
-        # set to None if contract_auto_renew (nullable) is None
-        # and model_fields_set contains the field
-        if self.contract_auto_renew is None and "contract_auto_renew" in self.model_fields_set:
-            _dict['contract_auto_renew'] = None
-
-        # set to None if default_net_d (nullable) is None
-        # and model_fields_set contains the field
-        if self.default_net_d is None and "default_net_d" in self.model_fields_set:
-            _dict['default_net_d'] = None
-
-        # set to None if is_exclusive (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_exclusive is None and "is_exclusive" in self.model_fields_set:
-            _dict['is_exclusive'] = None
-
-        # set to None if is_default (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_default is None and "is_default" in self.model_fields_set:
-            _dict['is_default'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreatePriceRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "is_active": obj.get("is_active"),
-            "internal_description": obj.get("internal_description"),
-            "pricing_model": obj.get("pricing_model"),
-            "unit_amount_atom": obj.get("unit_amount_atom"),
-            "transform_quantity_divide_by": obj.get("transform_quantity_divide_by") if obj.get("transform_quantity_divide_by") is not None else 1.0,
-            "price_tiers": [PriceTierParams.from_dict(_item) for _item in obj.get("price_tiers")] if obj.get("price_tiers") is not None else None,
-            "price_type": obj.get("price_type"),
-            "billing_interval": obj.get("billing_interval"),
-            "billing_interval_count": obj.get("billing_interval_count"),
-            "contract_term_multiple": obj.get("contract_term_multiple"),
-            "contract_auto_renew": obj.get("contract_auto_renew"),
-            "trial_period_days": obj.get("trial_period_days") if obj.get("trial_period_days") is not None else 0,
-            "usage_type": obj.get("usage_type"),
-            "aggregate_usage": obj.get("aggregate_usage"),
-            "default_net_d": obj.get("default_net_d"),
-            "is_exclusive": obj.get("is_exclusive"),
-            "listed_exclusively_for_customers": obj.get("listed_exclusively_for_customers"),
-            "can_only_be_purchased_with": obj.get("can_only_be_purchased_with"),
-            "product_id": obj.get("product_id"),
-            "is_default": obj.get("is_default")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in price_tiers (list)
+    _items = []
+    if self.price_tiers:
+      for _item in self.price_tiers:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['price_tiers'] = _items
+    # set to None if internal_description (nullable) is None
+    # and model_fields_set contains the field
+    if self.internal_description is None and 'internal_description' in self.model_fields_set:
+      _dict['internal_description'] = None
+
+    # set to None if unit_amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.unit_amount_atom is None and 'unit_amount_atom' in self.model_fields_set:
+      _dict['unit_amount_atom'] = None
+
+    # set to None if billing_interval (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_interval is None and 'billing_interval' in self.model_fields_set:
+      _dict['billing_interval'] = None
+
+    # set to None if billing_interval_count (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_interval_count is None and 'billing_interval_count' in self.model_fields_set:
+      _dict['billing_interval_count'] = None
+
+    # set to None if contract_term_multiple (nullable) is None
+    # and model_fields_set contains the field
+    if self.contract_term_multiple is None and 'contract_term_multiple' in self.model_fields_set:
+      _dict['contract_term_multiple'] = None
+
+    # set to None if contract_auto_renew (nullable) is None
+    # and model_fields_set contains the field
+    if self.contract_auto_renew is None and 'contract_auto_renew' in self.model_fields_set:
+      _dict['contract_auto_renew'] = None
+
+    # set to None if default_net_d (nullable) is None
+    # and model_fields_set contains the field
+    if self.default_net_d is None and 'default_net_d' in self.model_fields_set:
+      _dict['default_net_d'] = None
+
+    # set to None if is_exclusive (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_exclusive is None and 'is_exclusive' in self.model_fields_set:
+      _dict['is_exclusive'] = None
+
+    # set to None if is_default (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_default is None and 'is_default' in self.model_fields_set:
+      _dict['is_default'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreatePriceRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'is_active': obj.get('is_active'),
+        'internal_description': obj.get('internal_description'),
+        'pricing_model': obj.get('pricing_model'),
+        'unit_amount_atom': obj.get('unit_amount_atom'),
+        'transform_quantity_divide_by':
+          obj.get('transform_quantity_divide_by')
+          if obj.get('transform_quantity_divide_by') is not None else 1.0,
+        'price_tiers':
+          [PriceTierParams.from_dict(_item) for _item in obj.get('price_tiers')]
+          if obj.get('price_tiers') is not None else None,
+        'price_type': obj.get('price_type'),
+        'billing_interval': obj.get('billing_interval'),
+        'billing_interval_count': obj.get('billing_interval_count'),
+        'contract_term_multiple': obj.get('contract_term_multiple'),
+        'contract_auto_renew': obj.get('contract_auto_renew'),
+        'trial_period_days':
+          obj.get('trial_period_days') if obj.get('trial_period_days') is not None else 0,
+        'usage_type': obj.get('usage_type'),
+        'aggregate_usage': obj.get('aggregate_usage'),
+        'default_net_d': obj.get('default_net_d'),
+        'is_exclusive': obj.get('is_exclusive'),
+        'listed_exclusively_for_customers': obj.get('listed_exclusively_for_customers'),
+        'can_only_be_purchased_with': obj.get('can_only_be_purchased_with'),
+        'product_id': obj.get('product_id'),
+        'is_default': obj.get('is_default')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_product_family_request.py` & `getopenpay-0.0.2/getopenpay/models/create_product_family_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,93 +7,92 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateProductFamilyRequest(BaseModel):
-    """
+  """
     CreateProductFamilyRequest
-    """ # noqa: E501
-    name: StrictStr = Field(description="The name of the product family.")
-    description: Optional[StrictStr] = None
-    products: List[StrictStr]
-    hierarchy: Optional[StrictStr] = Field(default='{}', description="A JSON object representing the hierarchy within the family.")
-    __properties: ClassVar[List[str]] = ["name", "description", "products", "hierarchy"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateProductFamilyRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  name: StrictStr = Field(description='The name of the product family.')
+  description: Optional[StrictStr] = None
+  products: List[StrictStr]
+  hierarchy: Optional[StrictStr] = Field(
+    default='{}', description='A JSON object representing the hierarchy within the family.'
+  )
+  __properties: ClassVar[List[str]] = ['name', 'description', 'products', 'hierarchy']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateProductFamilyRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateProductFamilyRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "products": obj.get("products"),
-            "hierarchy": obj.get("hierarchy") if obj.get("hierarchy") is not None else '{}'
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateProductFamilyRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'name': obj.get('name'),
+        'description': obj.get('description'),
+        'products': obj.get('products'),
+        'hierarchy': obj.get('hierarchy') if obj.get('hierarchy') is not None else '{}'
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_product_request.py` & `getopenpay-0.0.2/getopenpay/models/create_product_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,102 +7,103 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictBool, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateProductRequest(BaseModel):
-    """
+  """
     CreateProductRequest
-    """ # noqa: E501
-    name: StrictStr = Field(description="Name of product.")
-    description: StrictStr = Field(description="Product's description.")
-    account_sku: Optional[StrictStr] = None
-    features: Optional[List[StrictStr]] = None
-    unit_label: Optional[StrictStr] = None
-    is_active: Optional[StrictBool] = Field(default=True, description="Whether or not this product is accepting new subscriptions.")
-    __properties: ClassVar[List[str]] = ["name", "description", "account_sku", "features", "unit_label", "is_active"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateProductRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  name: StrictStr = Field(description='Name of product.')
+  description: StrictStr = Field(description="Product's description.")
+  account_sku: Optional[StrictStr] = None
+  features: Optional[List[StrictStr]] = None
+  unit_label: Optional[StrictStr] = None
+  is_active: Optional[StrictBool] = Field(
+    default=True, description='Whether or not this product is accepting new subscriptions.'
+  )
+  __properties: ClassVar[List[str]] = [
+    'name', 'description', 'account_sku', 'features', 'unit_label', 'is_active'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateProductRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if account_sku (nullable) is None
-        # and model_fields_set contains the field
-        if self.account_sku is None and "account_sku" in self.model_fields_set:
-            _dict['account_sku'] = None
-
-        # set to None if unit_label (nullable) is None
-        # and model_fields_set contains the field
-        if self.unit_label is None and "unit_label" in self.model_fields_set:
-            _dict['unit_label'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateProductRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "account_sku": obj.get("account_sku"),
-            "features": obj.get("features"),
-            "unit_label": obj.get("unit_label"),
-            "is_active": obj.get("is_active") if obj.get("is_active") is not None else True
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if account_sku (nullable) is None
+    # and model_fields_set contains the field
+    if self.account_sku is None and 'account_sku' in self.model_fields_set:
+      _dict['account_sku'] = None
+
+    # set to None if unit_label (nullable) is None
+    # and model_fields_set contains the field
+    if self.unit_label is None and 'unit_label' in self.model_fields_set:
+      _dict['unit_label'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateProductRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'name': obj.get('name'),
+        'description': obj.get('description'),
+        'account_sku': obj.get('account_sku'),
+        'features': obj.get('features'),
+        'unit_label': obj.get('unit_label'),
+        'is_active': obj.get('is_active') if obj.get('is_active') is not None else True
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_promo_code_request.py` & `getopenpay-0.0.2/getopenpay/models/create_promo_code_request.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,116 +7,121 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.promo_restrictions import PromoRestrictions
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreatePromoCodeRequest(BaseModel):
-    """
+  """
     CreatePromoCodeRequest
-    """ # noqa: E501
-    coupon_id: StrictStr = Field(description="The unique id of coupon for this promotion code.")
-    code: StrictStr = Field(description="The customer-facing code. Regardless of case, this code must be unique across all active promotion codes for a specific customer.")
-    customer_id: Optional[StrictStr] = None
-    expires_at: Optional[datetime] = None
-    max_redemptions: Optional[StrictInt] = None
-    restrictions: Optional[PromoRestrictions] = None
-    __properties: ClassVar[List[str]] = ["coupon_id", "code", "customer_id", "expires_at", "max_redemptions", "restrictions"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreatePromoCodeRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  coupon_id: StrictStr = Field(description='The unique id of coupon for this promotion code.')
+  code: StrictStr = Field(
+    description=
+    'The customer-facing code. Regardless of case, this code must be unique across all active promotion codes for a specific customer.'
+  )
+  customer_id: Optional[StrictStr] = None
+  expires_at: Optional[datetime] = None
+  max_redemptions: Optional[StrictInt] = None
+  restrictions: Optional[PromoRestrictions] = None
+  __properties: ClassVar[List[str]] = [
+    'coupon_id', 'code', 'customer_id', 'expires_at', 'max_redemptions', 'restrictions'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreatePromoCodeRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of restrictions
-        if self.restrictions:
-            _dict['restrictions'] = self.restrictions.to_dict()
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if expires_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.expires_at is None and "expires_at" in self.model_fields_set:
-            _dict['expires_at'] = None
-
-        # set to None if max_redemptions (nullable) is None
-        # and model_fields_set contains the field
-        if self.max_redemptions is None and "max_redemptions" in self.model_fields_set:
-            _dict['max_redemptions'] = None
-
-        # set to None if restrictions (nullable) is None
-        # and model_fields_set contains the field
-        if self.restrictions is None and "restrictions" in self.model_fields_set:
-            _dict['restrictions'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreatePromoCodeRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "coupon_id": obj.get("coupon_id"),
-            "code": obj.get("code"),
-            "customer_id": obj.get("customer_id"),
-            "expires_at": obj.get("expires_at"),
-            "max_redemptions": obj.get("max_redemptions"),
-            "restrictions": PromoRestrictions.from_dict(obj.get("restrictions")) if obj.get("restrictions") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of restrictions
+    if self.restrictions:
+      _dict['restrictions'] = self.restrictions.to_dict()
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if expires_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.expires_at is None and 'expires_at' in self.model_fields_set:
+      _dict['expires_at'] = None
+
+    # set to None if max_redemptions (nullable) is None
+    # and model_fields_set contains the field
+    if self.max_redemptions is None and 'max_redemptions' in self.model_fields_set:
+      _dict['max_redemptions'] = None
+
+    # set to None if restrictions (nullable) is None
+    # and model_fields_set contains the field
+    if self.restrictions is None and 'restrictions' in self.model_fields_set:
+      _dict['restrictions'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreatePromoCodeRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'coupon_id': obj.get('coupon_id'),
+        'code': obj.get('code'),
+        'customer_id': obj.get('customer_id'),
+        'expires_at': obj.get('expires_at'),
+        'max_redemptions': obj.get('max_redemptions'),
+        'restrictions':
+          PromoRestrictions.from_dict(obj.get('restrictions'))
+          if obj.get('restrictions') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_refund_request.py` & `getopenpay-0.0.2/getopenpay/models/int_range_filter.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,106 +7,112 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, StrictInt
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.refund_reason_enum import RefundReasonEnum
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CreateRefundRequest(BaseModel):
+class IntRangeFilter(BaseModel):
+  """
+    IntRangeFilter
     """
-    CreateRefundRequest
-    """ # noqa: E501
-    charge_id: Optional[StrictStr] = None
-    payment_intent_id: Optional[StrictStr] = None
-    amount_atom: Optional[StrictInt] = None
-    reason: Optional[RefundReasonEnum] = None
-    description: Optional[StrictStr] = Field(default='Manually triggered refund by admin.', description="Description of the refund.")
-    __properties: ClassVar[List[str]] = ["charge_id", "payment_intent_id", "amount_atom", "reason", "description"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateRefundRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  eq: Optional[StrictInt] = None
+  lt: Optional[StrictInt] = None
+  lte: Optional[StrictInt] = None
+  gt: Optional[StrictInt] = None
+  gte: Optional[StrictInt] = None
+  __properties: ClassVar[List[str]] = ['eq', 'lt', 'lte', 'gt', 'gte']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of IntRangeFilter from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if charge_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.charge_id is None and "charge_id" in self.model_fields_set:
-            _dict['charge_id'] = None
-
-        # set to None if payment_intent_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.payment_intent_id is None and "payment_intent_id" in self.model_fields_set:
-            _dict['payment_intent_id'] = None
-
-        # set to None if amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.amount_atom is None and "amount_atom" in self.model_fields_set:
-            _dict['amount_atom'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateRefundRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "charge_id": obj.get("charge_id"),
-            "payment_intent_id": obj.get("payment_intent_id"),
-            "amount_atom": obj.get("amount_atom"),
-            "reason": obj.get("reason"),
-            "description": obj.get("description") if obj.get("description") is not None else 'Manually triggered refund by admin.'
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if eq (nullable) is None
+    # and model_fields_set contains the field
+    if self.eq is None and 'eq' in self.model_fields_set:
+      _dict['eq'] = None
+
+    # set to None if lt (nullable) is None
+    # and model_fields_set contains the field
+    if self.lt is None and 'lt' in self.model_fields_set:
+      _dict['lt'] = None
+
+    # set to None if lte (nullable) is None
+    # and model_fields_set contains the field
+    if self.lte is None and 'lte' in self.model_fields_set:
+      _dict['lte'] = None
+
+    # set to None if gt (nullable) is None
+    # and model_fields_set contains the field
+    if self.gt is None and 'gt' in self.model_fields_set:
+      _dict['gt'] = None
+
+    # set to None if gte (nullable) is None
+    # and model_fields_set contains the field
+    if self.gte is None and 'gte' in self.model_fields_set:
+      _dict['gte'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of IntRangeFilter from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'eq': obj.get('eq'),
+        'lt': obj.get('lt'),
+        'lte': obj.get('lte'),
+        'gt': obj.get('gt'),
+        'gte': obj.get('gte')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_subscription_item_request.py` & `getopenpay-0.0.2/getopenpay/models/create_subscription_item_request.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,91 +7,98 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.proration_enum import ProrationEnum
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateSubscriptionItemRequest(BaseModel):
-    """
+  """
     CreateSubscriptionItemRequest
-    """ # noqa: E501
-    subscription_id: StrictStr = Field(description="The identifier of the subscription to modify")
-    add_at_period_end: Optional[StrictBool] = Field(default=False, description="If the flag is set to True, item will be added when renewing the subscription at next billing cycle.")
-    price_id: StrictStr = Field(description="The ID of the price.")
-    quantity: Optional[StrictInt] = Field(default=1, description="The quantity youd like to apply to the subscription item youre creating.")
-    proration_behavior: Optional[ProrationEnum] = None
-    __properties: ClassVar[List[str]] = ["subscription_id", "add_at_period_end", "price_id", "quantity", "proration_behavior"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateSubscriptionItemRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  subscription_id: StrictStr = Field(description='The identifier of the subscription to modify')
+  add_at_period_end: Optional[StrictBool] = Field(
+    default=False,
+    description=
+    'If the flag is set to True, item will be added when renewing the subscription at next billing cycle.'
+  )
+  price_id: StrictStr = Field(description='The ID of the price.')
+  quantity: Optional[StrictInt] = Field(
+    default=1,
+    description='The quantity youd like to apply to the subscription item youre creating.'
+  )
+  proration_behavior: Optional[ProrationEnum] = None
+  __properties: ClassVar[List[str]] = [
+    'subscription_id', 'add_at_period_end', 'price_id', 'quantity', 'proration_behavior'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateSubscriptionItemRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateSubscriptionItemRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "subscription_id": obj.get("subscription_id"),
-            "add_at_period_end": obj.get("add_at_period_end") if obj.get("add_at_period_end") is not None else False,
-            "price_id": obj.get("price_id"),
-            "quantity": obj.get("quantity") if obj.get("quantity") is not None else 1,
-            "proration_behavior": obj.get("proration_behavior")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateSubscriptionItemRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'subscription_id': obj.get('subscription_id'),
+        'add_at_period_end':
+          obj.get('add_at_period_end') if obj.get('add_at_period_end') is not None else False,
+        'price_id': obj.get('price_id'),
+        'quantity': obj.get('quantity') if obj.get('quantity') is not None else 1,
+        'proration_behavior': obj.get('proration_behavior')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_subscription_request.py` & `getopenpay-0.0.2/getopenpay/models/create_subscription_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,140 +7,156 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.selected_price_quantity import SelectedPriceQuantity
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateSubscriptionRequest(BaseModel):
-    """
+  """
     CreateSubscriptionRequest
-    """ # noqa: E501
-    customer_id: StrictStr = Field(description="Unique Identifier of the customer.")
-    payment_method_id: StrictStr = Field(description="ID of the default payment method for the subscription. It must belong to the customer associated with the subscription.")
-    selected_product_price_quantity: List[SelectedPriceQuantity]
-    total_amount_atom: StrictInt = Field(description="Total amount of this subscription. It is in atomic units (in USD this is cents).")
-    cancel_at_end: Optional[StrictBool] = Field(default=False, description="Boolean indicating whether this subscription should cancel at the end of the current period.")
-    description: Optional[StrictStr] = None
-    trial_end: Optional[datetime] = None
-    trial_period_days: Optional[StrictInt] = None
-    trial_from_price: Optional[StrictBool] = None
-    coupon_id: Optional[StrictStr] = None
-    promotion_code_id: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["customer_id", "payment_method_id", "selected_product_price_quantity", "total_amount_atom", "cancel_at_end", "description", "trial_end", "trial_period_days", "trial_from_price", "coupon_id", "promotion_code_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateSubscriptionRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  customer_id: StrictStr = Field(description='Unique Identifier of the customer.')
+  payment_method_id: StrictStr = Field(
+    description=
+    'ID of the default payment method for the subscription. It must belong to the customer associated with the subscription.'
+  )
+  selected_product_price_quantity: List[SelectedPriceQuantity]
+  total_amount_atom: StrictInt = Field(
+    description='Total amount of this subscription. It is in atomic units (in USD this is cents).'
+  )
+  cancel_at_end: Optional[StrictBool] = Field(
+    default=False,
+    description=
+    'Boolean indicating whether this subscription should cancel at the end of the current period.'
+  )
+  description: Optional[StrictStr] = None
+  trial_end: Optional[datetime] = None
+  trial_period_days: Optional[StrictInt] = None
+  trial_from_price: Optional[StrictBool] = None
+  coupon_id: Optional[StrictStr] = None
+  promotion_code_id: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'customer_id', 'payment_method_id', 'selected_product_price_quantity', 'total_amount_atom',
+    'cancel_at_end', 'description', 'trial_end', 'trial_period_days', 'trial_from_price',
+    'coupon_id', 'promotion_code_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateSubscriptionRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in selected_product_price_quantity (list)
-        _items = []
-        if self.selected_product_price_quantity:
-            for _item in self.selected_product_price_quantity:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['selected_product_price_quantity'] = _items
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        # set to None if trial_end (nullable) is None
-        # and model_fields_set contains the field
-        if self.trial_end is None and "trial_end" in self.model_fields_set:
-            _dict['trial_end'] = None
-
-        # set to None if trial_period_days (nullable) is None
-        # and model_fields_set contains the field
-        if self.trial_period_days is None and "trial_period_days" in self.model_fields_set:
-            _dict['trial_period_days'] = None
-
-        # set to None if trial_from_price (nullable) is None
-        # and model_fields_set contains the field
-        if self.trial_from_price is None and "trial_from_price" in self.model_fields_set:
-            _dict['trial_from_price'] = None
-
-        # set to None if coupon_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.coupon_id is None and "coupon_id" in self.model_fields_set:
-            _dict['coupon_id'] = None
-
-        # set to None if promotion_code_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.promotion_code_id is None and "promotion_code_id" in self.model_fields_set:
-            _dict['promotion_code_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateSubscriptionRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "customer_id": obj.get("customer_id"),
-            "payment_method_id": obj.get("payment_method_id"),
-            "selected_product_price_quantity": [SelectedPriceQuantity.from_dict(_item) for _item in obj.get("selected_product_price_quantity")] if obj.get("selected_product_price_quantity") is not None else None,
-            "total_amount_atom": obj.get("total_amount_atom"),
-            "cancel_at_end": obj.get("cancel_at_end") if obj.get("cancel_at_end") is not None else False,
-            "description": obj.get("description"),
-            "trial_end": obj.get("trial_end"),
-            "trial_period_days": obj.get("trial_period_days"),
-            "trial_from_price": obj.get("trial_from_price"),
-            "coupon_id": obj.get("coupon_id"),
-            "promotion_code_id": obj.get("promotion_code_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in selected_product_price_quantity (list)
+    _items = []
+    if self.selected_product_price_quantity:
+      for _item in self.selected_product_price_quantity:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['selected_product_price_quantity'] = _items
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    # set to None if trial_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.trial_end is None and 'trial_end' in self.model_fields_set:
+      _dict['trial_end'] = None
+
+    # set to None if trial_period_days (nullable) is None
+    # and model_fields_set contains the field
+    if self.trial_period_days is None and 'trial_period_days' in self.model_fields_set:
+      _dict['trial_period_days'] = None
+
+    # set to None if trial_from_price (nullable) is None
+    # and model_fields_set contains the field
+    if self.trial_from_price is None and 'trial_from_price' in self.model_fields_set:
+      _dict['trial_from_price'] = None
+
+    # set to None if coupon_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_id is None and 'coupon_id' in self.model_fields_set:
+      _dict['coupon_id'] = None
+
+    # set to None if promotion_code_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.promotion_code_id is None and 'promotion_code_id' in self.model_fields_set:
+      _dict['promotion_code_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateSubscriptionRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'customer_id': obj.get('customer_id'),
+        'payment_method_id': obj.get('payment_method_id'),
+        'selected_product_price_quantity':
+          [
+            SelectedPriceQuantity.from_dict(_item)
+            for _item in obj.get('selected_product_price_quantity')
+          ] if obj.get('selected_product_price_quantity') is not None else None,
+        'total_amount_atom': obj.get('total_amount_atom'),
+        'cancel_at_end': obj.get('cancel_at_end')
+                         if obj.get('cancel_at_end') is not None else False,
+        'description': obj.get('description'),
+        'trial_end': obj.get('trial_end'),
+        'trial_period_days': obj.get('trial_period_days'),
+        'trial_from_price': obj.get('trial_from_price'),
+        'coupon_id': obj.get('coupon_id'),
+        'promotion_code_id': obj.get('promotion_code_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/create_subscription_response.py` & `getopenpay-0.0.2/getopenpay/models/create_subscription_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,99 +7,101 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel
+
 from getopenpay.models.invoice_external import InvoiceExternal
 from getopenpay.models.subscription_external import SubscriptionExternal
+from pydantic import BaseModel
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreateSubscriptionResponse(BaseModel):
-    """
+  """
     CreateSubscriptionResponse
-    """ # noqa: E501
-    created: List[SubscriptionExternal]
-    invoices: List[InvoiceExternal]
-    __properties: ClassVar[List[str]] = ["created", "invoices"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreateSubscriptionResponse from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  created: List[SubscriptionExternal]
+  invoices: List[InvoiceExternal]
+  __properties: ClassVar[List[str]] = ['created', 'invoices']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateSubscriptionResponse from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in created (list)
-        _items = []
-        if self.created:
-            for _item in self.created:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['created'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in invoices (list)
-        _items = []
-        if self.invoices:
-            for _item in self.invoices:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['invoices'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreateSubscriptionResponse from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "created": [SubscriptionExternal.from_dict(_item) for _item in obj.get("created")] if obj.get("created") is not None else None,
-            "invoices": [InvoiceExternal.from_dict(_item) for _item in obj.get("invoices")] if obj.get("invoices") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in created (list)
+    _items = []
+    if self.created:
+      for _item in self.created:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['created'] = _items
+    # override the default output from pydantic by calling `to_dict()` of each item in invoices (list)
+    _items = []
+    if self.invoices:
+      for _item in self.invoices:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['invoices'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateSubscriptionResponse from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'created':
+          [SubscriptionExternal.from_dict(_item) for _item in obj.get('created')]
+          if obj.get('created') is not None else None,
+        'invoices':
+          [InvoiceExternal.from_dict(_item) for _item in obj.get('invoices')]
+          if obj.get('invoices') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/credit_card_type.py` & `getopenpay-0.0.2/getopenpay/models/credit_card_type.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,49 +7,44 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class CreditCardType(str, Enum):
-    """
+  """
     CreditCardType
     """
-
-    """
+  """
     allowed enum values
     """
-    VISA = 'visa'
-    MASTERCARD = 'mastercard'
-    AMERICAN_EXPRESS = 'american_express'
-    JCB = 'jcb'
-    DISCOVER = 'discover'
-    ENROUTE = 'enroute'
-    UNIONPAY = 'unionpay'
-    PAYPAL = 'paypal'
-    DINERS_CLUB = 'diners_club'
-    MIR = 'mir'
-    EFTPOS_AUSTRALIA = 'eftpos_australia'
-    ECHECK_DOT_NET = 'echeck.net'
-    OTHER = 'other'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreditCardType from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  VISA = 'visa'
+  MASTERCARD = 'mastercard'
+  AMERICAN_EXPRESS = 'american_express'
+  JCB = 'jcb'
+  DISCOVER = 'discover'
+  ENROUTE = 'enroute'
+  UNIONPAY = 'unionpay'
+  PAYPAL = 'paypal'
+  DINERS_CLUB = 'diners_club'
+  MIR = 'mir'
+  EFTPOS_AUSTRALIA = 'eftpos_australia'
+  ECHECK_DOT_NET = 'echeck.net'
+  OTHER = 'other'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreditCardType from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/credit_note_external.py` & `getopenpay-0.0.2/getopenpay/models/credit_note_external.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,119 +7,137 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.credit_note_item_external import CreditNoteItemExternal
 from getopenpay.models.credit_note_reason import CreditNoteReason
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreditNoteExternal(BaseModel):
-    """
+  """
     CreditNoteExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the credit_note.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    total_amount_atom: StrictInt = Field(description="The integer amount representing the total amount of the credit note. It is in atomic units (in USD this is cents).")
-    currency: StrictStr
-    reason: Optional[CreditNoteReason]
-    invoice_id: StrictStr = Field(description="Unique ID of the invoice.")
-    items: List[CreditNoteItemExternal]
-    credit_amount_atom: StrictInt = Field(description="The integer amount representing the amount to credit the customers balance, which will be automatically applied to their next invoice. It is in atomic units (in USD this is cents).")
-    refund_amount_atom: StrictInt = Field(description="The integer amount representing the amount to refund. If set, a refund will be created for the charge associated with the invoice. It is in atomic units (in USD this is cents).")
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "total_amount_atom", "currency", "reason", "invoice_id", "items", "credit_amount_atom", "refund_amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreditNoteExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique Identifier of the credit_note.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  total_amount_atom: StrictInt = Field(
+    description=
+    'The integer amount representing the total amount of the credit note. It is in atomic units (in USD this is cents).'
+  )
+  currency: StrictStr
+  reason: Optional[CreditNoteReason]
+  invoice_id: StrictStr = Field(description='Unique ID of the invoice.')
+  items: List[CreditNoteItemExternal]
+  credit_amount_atom: StrictInt = Field(
+    description=
+    'The integer amount representing the amount to credit the customers balance, which will be automatically applied to their next invoice. It is in atomic units (in USD this is cents).'
+  )
+  refund_amount_atom: StrictInt = Field(
+    description=
+    'The integer amount representing the amount to refund. If set, a refund will be created for the charge associated with the invoice. It is in atomic units (in USD this is cents).'
+  )
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'total_amount_atom', 'currency',
+    'reason', 'invoice_id', 'items', 'credit_amount_atom', 'refund_amount_atom'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreditNoteExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in items (list)
-        _items = []
-        if self.items:
-            for _item in self.items:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['items'] = _items
-        # set to None if reason (nullable) is None
-        # and model_fields_set contains the field
-        if self.reason is None and "reason" in self.model_fields_set:
-            _dict['reason'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreditNoteExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "total_amount_atom": obj.get("total_amount_atom"),
-            "currency": obj.get("currency"),
-            "reason": obj.get("reason"),
-            "invoice_id": obj.get("invoice_id"),
-            "items": [CreditNoteItemExternal.from_dict(_item) for _item in obj.get("items")] if obj.get("items") is not None else None,
-            "credit_amount_atom": obj.get("credit_amount_atom"),
-            "refund_amount_atom": obj.get("refund_amount_atom")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in items (list)
+    _items = []
+    if self.items:
+      for _item in self.items:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['items'] = _items
+    # set to None if reason (nullable) is None
+    # and model_fields_set contains the field
+    if self.reason is None and 'reason' in self.model_fields_set:
+      _dict['reason'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreditNoteExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'total_amount_atom': obj.get('total_amount_atom'),
+        'currency': obj.get('currency'),
+        'reason': obj.get('reason'),
+        'invoice_id': obj.get('invoice_id'),
+        'items':
+          [CreditNoteItemExternal.from_dict(_item) for _item in obj.get('items')]
+          if obj.get('items') is not None else None,
+        'credit_amount_atom': obj.get('credit_amount_atom'),
+        'refund_amount_atom': obj.get('refund_amount_atom')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/credit_note_item_external.py` & `getopenpay-0.0.2/getopenpay/models/discount_external.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,114 +7,151 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.credit_note_line_type import CreditNoteLineType
+
+from getopenpay.models.coupon_external import CouponExternal
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CreditNoteItemExternal(BaseModel):
+class DiscountExternal(BaseModel):
+  """
+    DiscountExternal
     """
-    CreditNoteItemExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the credit_note_item.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    amount_atom: StrictInt = Field(description="The integer amount representing the gross amount being credited for this credit_note_item. It is in atomic units (in USD this is cents).")
-    currency: StrictStr
-    type: CreditNoteLineType
-    quantity: Optional[StrictInt] = Field(default=1, description="Quantity of the product being credited.")
-    invoice_item_id: Optional[StrictStr] = None
-    unit_amount_atom: Optional[StrictInt] = None
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "amount_atom", "currency", "type", "quantity", "invoice_item_id", "unit_amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreditNoteItemExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  start_date: datetime
+  end_date: Optional[datetime]
+  coupon_id: StrictStr
+  coupon: CouponExternal
+  customer_id: Optional[StrictStr]
+  subscription_id: Optional[StrictStr]
+  invoice_id: Optional[StrictStr]
+  invoice_item_id: Optional[StrictStr]
+  promotion_code_id: Optional[StrictStr]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'start_date', 'end_date', 'coupon_id',
+    'coupon', 'customer_id', 'subscription_id', 'invoice_id', 'invoice_item_id', 'promotion_code_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of DiscountExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if invoice_item_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_item_id is None and "invoice_item_id" in self.model_fields_set:
-            _dict['invoice_item_id'] = None
-
-        # set to None if unit_amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.unit_amount_atom is None and "unit_amount_atom" in self.model_fields_set:
-            _dict['unit_amount_atom'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreditNoteItemExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "amount_atom": obj.get("amount_atom"),
-            "currency": obj.get("currency"),
-            "type": obj.get("type"),
-            "quantity": obj.get("quantity") if obj.get("quantity") is not None else 1,
-            "invoice_item_id": obj.get("invoice_item_id"),
-            "unit_amount_atom": obj.get("unit_amount_atom")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of coupon
+    if self.coupon:
+      _dict['coupon'] = self.coupon.to_dict()
+    # set to None if end_date (nullable) is None
+    # and model_fields_set contains the field
+    if self.end_date is None and 'end_date' in self.model_fields_set:
+      _dict['end_date'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if subscription_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.subscription_id is None and 'subscription_id' in self.model_fields_set:
+      _dict['subscription_id'] = None
+
+    # set to None if invoice_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_id is None and 'invoice_id' in self.model_fields_set:
+      _dict['invoice_id'] = None
+
+    # set to None if invoice_item_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_item_id is None and 'invoice_item_id' in self.model_fields_set:
+      _dict['invoice_item_id'] = None
+
+    # set to None if promotion_code_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.promotion_code_id is None and 'promotion_code_id' in self.model_fields_set:
+      _dict['promotion_code_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of DiscountExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'start_date': obj.get('start_date'),
+        'end_date': obj.get('end_date'),
+        'coupon_id': obj.get('coupon_id'),
+        'coupon':
+          CouponExternal.from_dict(obj.get('coupon')) if obj.get('coupon') is not None else None,
+        'customer_id': obj.get('customer_id'),
+        'subscription_id': obj.get('subscription_id'),
+        'invoice_id': obj.get('invoice_id'),
+        'invoice_item_id': obj.get('invoice_item_id'),
+        'promotion_code_id': obj.get('promotion_code_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/credit_note_line_type.py` & `getopenpay-0.0.2/getopenpay/models/credit_note_line_type.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,38 +7,33 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class CreditNoteLineType(str, Enum):
-    """
+  """
     CreditNoteLineType
     """
-
-    """
+  """
     allowed enum values
     """
-    INVOICE_LINE_ITEM = 'invoice_line_item'
-    CUSTOM_LINE_ITEM = 'custom_line_item'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreditNoteLineType from a JSON string"""
-        return cls(json.loads(json_str))
-
+  INVOICE_LINE_ITEM = 'invoice_line_item'
+  CUSTOM_LINE_ITEM = 'custom_line_item'
 
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreditNoteLineType from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/credit_note_query_params.py` & `getopenpay-0.0.2/getopenpay/models/credit_note_query_params.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,116 +7,125 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CreditNoteQueryParams(BaseModel):
-    """
+  """
     CreditNoteQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    invoice_id: Optional[StrictStr] = None
-    customer_id: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "invoice_id", "customer_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreditNoteQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  invoice_id: Optional[StrictStr] = None
+  customer_id: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'invoice_id',
+    'customer_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreditNoteQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if invoice_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_id is None and "invoice_id" in self.model_fields_set:
-            _dict['invoice_id'] = None
-
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CreditNoteQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "invoice_id": obj.get("invoice_id"),
-            "customer_id": obj.get("customer_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if invoice_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_id is None and 'invoice_id' in self.model_fields_set:
+      _dict['invoice_id'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreditNoteQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'invoice_id': obj.get('invoice_id'),
+        'customer_id': obj.get('customer_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/credit_note_reason.py` & `getopenpay-0.0.2/getopenpay/models/payment_processor_name.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,40 +7,34 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class CreditNoteReason(str, Enum):
-    """
-    CreditNoteReason
-    """
-
+class PaymentProcessorName(str, Enum):
+  """
+    PaymentProcessors are api's that we support and can charge.   
     """
+  """
     allowed enum values
     """
-    DUPLICATE = 'duplicate'
-    FRAUDULENT = 'fraudulent'
-    ORDER_CHANGE = 'order_change'
-    PRODUCT_UNSATISFACTORY = 'product_unsatisfactory'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CreditNoteReason from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  BRAINTREE = 'braintree'
+  STRIPE = 'stripe'
+  AUTHORIZE_NET = 'authorize_net'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PaymentProcessorName from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/customer_balance_transaction_external.py` & `getopenpay-0.0.2/getopenpay/models/customer_balance_transaction_external.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,121 +7,128 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.customer_balance_transaction_type import CustomerBalanceTransactionType
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CustomerBalanceTransactionExternal(BaseModel):
-    """
+  """
     CustomerBalanceTransactionExternal
-    """ # noqa: E501
-    id: StrictStr
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    amount_atom: StrictInt
-    currency: StrictStr
-    ending_balance_amount_atom: StrictInt
-    type: CustomerBalanceTransactionType
-    invoice_id: Optional[StrictStr]
-    credit_note_id: Optional[StrictStr]
-    description: Optional[StrictStr]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "amount_atom", "currency", "ending_balance_amount_atom", "type", "invoice_id", "credit_note_id", "description"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CustomerBalanceTransactionExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  amount_atom: StrictInt
+  currency: StrictStr
+  ending_balance_amount_atom: StrictInt
+  type: CustomerBalanceTransactionType
+  invoice_id: Optional[StrictStr]
+  credit_note_id: Optional[StrictStr]
+  description: Optional[StrictStr]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'amount_atom', 'currency',
+    'ending_balance_amount_atom', 'type', 'invoice_id', 'credit_note_id', 'description'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CustomerBalanceTransactionExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if invoice_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_id is None and "invoice_id" in self.model_fields_set:
-            _dict['invoice_id'] = None
-
-        # set to None if credit_note_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.credit_note_id is None and "credit_note_id" in self.model_fields_set:
-            _dict['credit_note_id'] = None
-
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CustomerBalanceTransactionExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "amount_atom": obj.get("amount_atom"),
-            "currency": obj.get("currency"),
-            "ending_balance_amount_atom": obj.get("ending_balance_amount_atom"),
-            "type": obj.get("type"),
-            "invoice_id": obj.get("invoice_id"),
-            "credit_note_id": obj.get("credit_note_id"),
-            "description": obj.get("description")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if invoice_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_id is None and 'invoice_id' in self.model_fields_set:
+      _dict['invoice_id'] = None
+
+    # set to None if credit_note_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.credit_note_id is None and 'credit_note_id' in self.model_fields_set:
+      _dict['credit_note_id'] = None
+
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CustomerBalanceTransactionExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'amount_atom': obj.get('amount_atom'),
+        'currency': obj.get('currency'),
+        'ending_balance_amount_atom': obj.get('ending_balance_amount_atom'),
+        'type': obj.get('type'),
+        'invoice_id': obj.get('invoice_id'),
+        'credit_note_id': obj.get('credit_note_id'),
+        'description': obj.get('description')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/customer_balance_transaction_type.py` & `getopenpay-0.0.2/getopenpay/models/customer_balance_transaction_type.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,45 +7,40 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class CustomerBalanceTransactionType(str, Enum):
-    """
+  """
     refer https://stripe.com/docs/billing/customer/balance#types
     """
-
-    """
+  """
     allowed enum values
     """
-    ADJUSTMENT = 'adjustment'
-    APPLIED_TO_INVOICE = 'applied_to_invoice'
-    CREDIT_NOTE = 'credit_note'
-    INITIAL = 'initial'
-    INVOICE_OVERPAID = 'invoice_overpaid'
-    INVOICE_TOO_LARGE = 'invoice_too_large'
-    INVOICE_TOO_SMALL = 'invoice_too_small'
-    UNSPENT_RECEIVER_CREDIT = 'unspent_receiver_credit'
-    UNAPPLIED_FROM_INVOICE = 'unapplied_from_invoice'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CustomerBalanceTransactionType from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  ADJUSTMENT = 'adjustment'
+  APPLIED_TO_INVOICE = 'applied_to_invoice'
+  CREDIT_NOTE = 'credit_note'
+  INITIAL = 'initial'
+  INVOICE_OVERPAID = 'invoice_overpaid'
+  INVOICE_TOO_LARGE = 'invoice_too_large'
+  INVOICE_TOO_SMALL = 'invoice_too_small'
+  UNSPENT_RECEIVER_CREDIT = 'unspent_receiver_credit'
+  UNAPPLIED_FROM_INVOICE = 'unapplied_from_invoice'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CustomerBalanceTransactionType from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/customer_external.py` & `getopenpay-0.0.2/getopenpay/models/customer_external.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,148 +7,160 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.complete_address import CompleteAddress
 from getopenpay.models.discount_external import DiscountExternal
 from getopenpay.models.object_name import ObjectName
 from getopenpay.models.subscription_external import SubscriptionExternal
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CustomerExternal(BaseModel):
-    """
+  """
     CustomerExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the customer.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    account_id: StrictStr = Field(description="Unique identifier for the account.")
-    email: StrictStr = Field(description="Customers email address.")
-    first_name: Optional[StrictStr]
-    last_name: Optional[StrictStr]
-    address: Optional[CompleteAddress]
-    subscriptions: Optional[List[SubscriptionExternal]] = None
-    balance_atom: Optional[StrictInt] = None
-    discount: Optional[DiscountExternal] = None
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "account_id", "email", "first_name", "last_name", "address", "subscriptions", "balance_atom", "discount"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CustomerExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier of the customer.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  account_id: StrictStr = Field(description='Unique identifier for the account.')
+  email: StrictStr = Field(description='Customers email address.')
+  first_name: Optional[StrictStr]
+  last_name: Optional[StrictStr]
+  address: Optional[CompleteAddress]
+  subscriptions: Optional[List[SubscriptionExternal]] = None
+  balance_atom: Optional[StrictInt] = None
+  discount: Optional[DiscountExternal] = None
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'account_id', 'email', 'first_name',
+    'last_name', 'address', 'subscriptions', 'balance_atom', 'discount'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CustomerExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of address
-        if self.address:
-            _dict['address'] = self.address.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in subscriptions (list)
-        _items = []
-        if self.subscriptions:
-            for _item in self.subscriptions:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['subscriptions'] = _items
-        # override the default output from pydantic by calling `to_dict()` of discount
-        if self.discount:
-            _dict['discount'] = self.discount.to_dict()
-        # set to None if first_name (nullable) is None
-        # and model_fields_set contains the field
-        if self.first_name is None and "first_name" in self.model_fields_set:
-            _dict['first_name'] = None
-
-        # set to None if last_name (nullable) is None
-        # and model_fields_set contains the field
-        if self.last_name is None and "last_name" in self.model_fields_set:
-            _dict['last_name'] = None
-
-        # set to None if address (nullable) is None
-        # and model_fields_set contains the field
-        if self.address is None and "address" in self.model_fields_set:
-            _dict['address'] = None
-
-        # set to None if balance_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.balance_atom is None and "balance_atom" in self.model_fields_set:
-            _dict['balance_atom'] = None
-
-        # set to None if discount (nullable) is None
-        # and model_fields_set contains the field
-        if self.discount is None and "discount" in self.model_fields_set:
-            _dict['discount'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CustomerExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "account_id": obj.get("account_id"),
-            "email": obj.get("email"),
-            "first_name": obj.get("first_name"),
-            "last_name": obj.get("last_name"),
-            "address": CompleteAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
-            "subscriptions": [SubscriptionExternal.from_dict(_item) for _item in obj.get("subscriptions")] if obj.get("subscriptions") is not None else None,
-            "balance_atom": obj.get("balance_atom"),
-            "discount": DiscountExternal.from_dict(obj.get("discount")) if obj.get("discount") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of address
+    if self.address:
+      _dict['address'] = self.address.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of each item in subscriptions (list)
+    _items = []
+    if self.subscriptions:
+      for _item in self.subscriptions:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['subscriptions'] = _items
+    # override the default output from pydantic by calling `to_dict()` of discount
+    if self.discount:
+      _dict['discount'] = self.discount.to_dict()
+    # set to None if first_name (nullable) is None
+    # and model_fields_set contains the field
+    if self.first_name is None and 'first_name' in self.model_fields_set:
+      _dict['first_name'] = None
+
+    # set to None if last_name (nullable) is None
+    # and model_fields_set contains the field
+    if self.last_name is None and 'last_name' in self.model_fields_set:
+      _dict['last_name'] = None
+
+    # set to None if address (nullable) is None
+    # and model_fields_set contains the field
+    if self.address is None and 'address' in self.model_fields_set:
+      _dict['address'] = None
+
+    # set to None if balance_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.balance_atom is None and 'balance_atom' in self.model_fields_set:
+      _dict['balance_atom'] = None
+
+    # set to None if discount (nullable) is None
+    # and model_fields_set contains the field
+    if self.discount is None and 'discount' in self.model_fields_set:
+      _dict['discount'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CustomerExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'account_id': obj.get('account_id'),
+        'email': obj.get('email'),
+        'first_name': obj.get('first_name'),
+        'last_name': obj.get('last_name'),
+        'address':
+          CompleteAddress.from_dict(obj.get('address')) if obj.get('address') is not None else None,
+        'subscriptions':
+          [SubscriptionExternal.from_dict(_item) for _item in obj.get('subscriptions')]
+          if obj.get('subscriptions') is not None else None,
+        'balance_atom': obj.get('balance_atom'),
+        'discount':
+          DiscountExternal.from_dict(obj.get('discount'))
+          if obj.get('discount') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/customer_payment_method_query_params.py` & `getopenpay-0.0.2/getopenpay/models/checkout_session_query_params.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,104 +7,118 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class CustomerPaymentMethodQueryParams(BaseModel):
+class CheckoutSessionQueryParams(BaseModel):
+  """
+    CheckoutSessionQueryParams
     """
-    CustomerPaymentMethodQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    provider_type: Optional[StrictStr] = Field(default=None, description="Not to be confused with PaymentProcessor, this type is used in PaymentMethod which are methods that are visible to customer (i.e. customer has an option to pay with these different providers).")
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "provider_type"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CustomerPaymentMethodQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  payment_link_id: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand',
+    'payment_link_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CheckoutSessionQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CustomerPaymentMethodQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "provider_type": obj.get("provider_type")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if payment_link_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_link_id is None and 'payment_link_id' in self.model_fields_set:
+      _dict['payment_link_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CheckoutSessionQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'payment_link_id': obj.get('payment_link_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/customer_query_params.py` & `getopenpay-0.0.2/getopenpay/models/customer_query_params.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,116 +7,125 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class CustomerQueryParams(BaseModel):
-    """
+  """
     CustomerQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    email: Optional[StrictStr] = None
-    coupon_id: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "email", "coupon_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of CustomerQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  email: Optional[StrictStr] = None
+  coupon_id: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'email',
+    'coupon_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CustomerQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if email (nullable) is None
-        # and model_fields_set contains the field
-        if self.email is None and "email" in self.model_fields_set:
-            _dict['email'] = None
-
-        # set to None if coupon_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.coupon_id is None and "coupon_id" in self.model_fields_set:
-            _dict['coupon_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of CustomerQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "email": obj.get("email"),
-            "coupon_id": obj.get("coupon_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if email (nullable) is None
+    # and model_fields_set contains the field
+    if self.email is None and 'email' in self.model_fields_set:
+      _dict['email'] = None
+
+    # set to None if coupon_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_id is None and 'coupon_id' in self.model_fields_set:
+      _dict['coupon_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CustomerQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'email': obj.get('email'),
+        'coupon_id': obj.get('coupon_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/date_time_filter.py` & `getopenpay-0.0.2/getopenpay/models/date_time_filter.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,114 +7,113 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
+
 from pydantic import BaseModel
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class DateTimeFilter(BaseModel):
-    """
+  """
     DateTimeFilter
-    """ # noqa: E501
-    eq: Optional[datetime] = None
-    lt: Optional[datetime] = None
-    lte: Optional[datetime] = None
-    gt: Optional[datetime] = None
-    gte: Optional[datetime] = None
-    __properties: ClassVar[List[str]] = ["eq", "lt", "lte", "gt", "gte"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of DateTimeFilter from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  eq: Optional[datetime] = None
+  lt: Optional[datetime] = None
+  lte: Optional[datetime] = None
+  gt: Optional[datetime] = None
+  gte: Optional[datetime] = None
+  __properties: ClassVar[List[str]] = ['eq', 'lt', 'lte', 'gt', 'gte']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of DateTimeFilter from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if eq (nullable) is None
-        # and model_fields_set contains the field
-        if self.eq is None and "eq" in self.model_fields_set:
-            _dict['eq'] = None
-
-        # set to None if lt (nullable) is None
-        # and model_fields_set contains the field
-        if self.lt is None and "lt" in self.model_fields_set:
-            _dict['lt'] = None
-
-        # set to None if lte (nullable) is None
-        # and model_fields_set contains the field
-        if self.lte is None and "lte" in self.model_fields_set:
-            _dict['lte'] = None
-
-        # set to None if gt (nullable) is None
-        # and model_fields_set contains the field
-        if self.gt is None and "gt" in self.model_fields_set:
-            _dict['gt'] = None
-
-        # set to None if gte (nullable) is None
-        # and model_fields_set contains the field
-        if self.gte is None and "gte" in self.model_fields_set:
-            _dict['gte'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of DateTimeFilter from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "eq": obj.get("eq"),
-            "lt": obj.get("lt"),
-            "lte": obj.get("lte"),
-            "gt": obj.get("gt"),
-            "gte": obj.get("gte")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if eq (nullable) is None
+    # and model_fields_set contains the field
+    if self.eq is None and 'eq' in self.model_fields_set:
+      _dict['eq'] = None
+
+    # set to None if lt (nullable) is None
+    # and model_fields_set contains the field
+    if self.lt is None and 'lt' in self.model_fields_set:
+      _dict['lt'] = None
+
+    # set to None if lte (nullable) is None
+    # and model_fields_set contains the field
+    if self.lte is None and 'lte' in self.model_fields_set:
+      _dict['lte'] = None
+
+    # set to None if gt (nullable) is None
+    # and model_fields_set contains the field
+    if self.gt is None and 'gt' in self.model_fields_set:
+      _dict['gt'] = None
+
+    # set to None if gte (nullable) is None
+    # and model_fields_set contains the field
+    if self.gte is None and 'gte' in self.model_fields_set:
+      _dict['gte'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of DateTimeFilter from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'eq': obj.get('eq'),
+        'lt': obj.get('lt'),
+        'lte': obj.get('lte'),
+        'gt': obj.get('gt'),
+        'gte': obj.get('gte')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/delete_invoice_item_response.py` & `getopenpay-0.0.2/getopenpay/models/delete_invoice_item_response.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,84 +7,86 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class DeleteInvoiceItemResponse(BaseModel):
-    """
+  """
     DeleteInvoiceItemResponse
-    """ # noqa: E501
-    message: Optional[StrictStr] = Field(default='Invoice Item Deleted successfully.', description="Message describing result of API call.")
-    invoice_item_id: StrictStr = Field(description="Unique identifier of the invoice_item.")
-    __properties: ClassVar[List[str]] = ["message", "invoice_item_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of DeleteInvoiceItemResponse from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  message: Optional[StrictStr] = Field(
+    default='Invoice Item Deleted successfully.',
+    description='Message describing result of API call.'
+  )
+  invoice_item_id: StrictStr = Field(description='Unique identifier of the invoice_item.')
+  __properties: ClassVar[List[str]] = ['message', 'invoice_item_id']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of DeleteInvoiceItemResponse from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of DeleteInvoiceItemResponse from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "message": obj.get("message") if obj.get("message") is not None else 'Invoice Item Deleted successfully.',
-            "invoice_item_id": obj.get("invoice_item_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of DeleteInvoiceItemResponse from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'message':
+          obj.get('message')
+          if obj.get('message') is not None else 'Invoice Item Deleted successfully.',
+        'invoice_item_id': obj.get('invoice_item_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/delete_price_response.py` & `getopenpay-0.0.2/getopenpay/models/delete_product_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,84 +7,84 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class DeletePriceResponse(BaseModel):
+class DeleteProductResponse(BaseModel):
+  """
+    DeleteProductResponse
     """
-    DeletePriceResponse
-    """ # noqa: E501
-    message: Optional[StrictStr] = Field(default='Price deleted Successfully.', description="Message describing result of API call.")
-    price_id: StrictStr = Field(description="Unique identifier of the price.")
-    __properties: ClassVar[List[str]] = ["message", "price_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of DeletePriceResponse from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  message: Optional[StrictStr] = Field(
+    default='Product deleted Successfully.', description='Message describing result of API call.'
+  )
+  product_id: StrictStr = Field(description='Unique identifier of the product.')
+  __properties: ClassVar[List[str]] = ['message', 'product_id']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of DeleteProductResponse from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of DeletePriceResponse from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "message": obj.get("message") if obj.get("message") is not None else 'Price deleted Successfully.',
-            "price_id": obj.get("price_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of DeleteProductResponse from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'message':
+          obj.get('message') if obj.get('message') is not None else 'Product deleted Successfully.',
+        'product_id': obj.get('product_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/delete_product_response.py` & `getopenpay-0.0.2/getopenpay/models/search_payment_intent_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,84 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictStr
+from typing_extensions import Annotated
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class DeleteProductResponse(BaseModel):
+class SearchPaymentIntentRequest(BaseModel):
+  """
+    SearchPaymentIntentRequest
     """
-    DeleteProductResponse
-    """ # noqa: E501
-    message: Optional[StrictStr] = Field(default='Product deleted Successfully.', description="Message describing result of API call.")
-    product_id: StrictStr = Field(description="Unique identifier of the product.")
-    __properties: ClassVar[List[str]] = ["message", "product_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of DeleteProductResponse from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  query: StrictStr = Field(
+    description=
+    "The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     "
+  )
+  __properties: ClassVar[List[str]] = ['page_number', 'page_size', 'query']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SearchPaymentIntentRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of DeleteProductResponse from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "message": obj.get("message") if obj.get("message") is not None else 'Product deleted Successfully.',
-            "product_id": obj.get("product_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SearchPaymentIntentRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'query': obj.get('query')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/delete_subscription_item_request.py` & `getopenpay-0.0.2/getopenpay/models/subscription_pause_request.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,85 +7,79 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List
 
+from pydantic import BaseModel, Field, StrictInt
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool
-from pydantic import Field
-from getopenpay.models.proration_enum import ProrationEnum
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
-class DeleteSubscriptionItemRequest(BaseModel):
+
+class SubscriptionPauseRequest(BaseModel):
+  """
+    SubscriptionPauseRequest
     """
-    DeleteSubscriptionItemRequest
-    """ # noqa: E501
-    drop_at_end: Optional[StrictBool] = Field(default=True, description="Whether or not this item will be dropped from subscription before next renewal")
-    proration_behavior: Optional[ProrationEnum] = None
-    __properties: ClassVar[List[str]] = ["drop_at_end", "proration_behavior"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of DeleteSubscriptionItemRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  number_of_billing_cycles_to_skip: StrictInt = Field(
+    description='Number of billing cycles this subscription will be paused.'
+  )
+  __properties: ClassVar[List[str]] = ['number_of_billing_cycles_to_skip']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SubscriptionPauseRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of DeleteSubscriptionItemRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "drop_at_end": obj.get("drop_at_end") if obj.get("drop_at_end") is not None else True,
-            "proration_behavior": obj.get("proration_behavior")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SubscriptionPauseRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {'number_of_billing_cycles_to_skip': obj.get('number_of_billing_cycles_to_skip')}
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/delete_subscription_item_response.py` & `getopenpay-0.0.2/getopenpay/models/delete_subscription_item_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,93 +7,100 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
+
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class DeleteSubscriptionItemResponse(BaseModel):
-    """
+  """
     DeleteSubscriptionItemResponse
-    """ # noqa: E501
-    message: Optional[StrictStr] = Field(default='SubscriptionItem deleted successfully.', description="Message describing result of API call.")
-    subscription_item_id: StrictStr = Field(description="Unique identifier of the subscription_item.")
-    deleted_at: Optional[datetime]
-    drop_at_end: Optional[StrictBool] = Field(default=False, description="Whether or not this item will be dropped from subscription before next renewal")
-    __properties: ClassVar[List[str]] = ["message", "subscription_item_id", "deleted_at", "drop_at_end"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of DeleteSubscriptionItemResponse from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  message: Optional[StrictStr] = Field(
+    default='SubscriptionItem deleted successfully.',
+    description='Message describing result of API call.'
+  )
+  subscription_item_id: StrictStr = Field(description='Unique identifier of the subscription_item.')
+  deleted_at: Optional[datetime]
+  drop_at_end: Optional[StrictBool] = Field(
+    default=False,
+    description='Whether or not this item will be dropped from subscription before next renewal'
+  )
+  __properties: ClassVar[List[str]
+                         ] = ['message', 'subscription_item_id', 'deleted_at', 'drop_at_end']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of DeleteSubscriptionItemResponse from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if deleted_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.deleted_at is None and "deleted_at" in self.model_fields_set:
-            _dict['deleted_at'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of DeleteSubscriptionItemResponse from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "message": obj.get("message") if obj.get("message") is not None else 'SubscriptionItem deleted successfully.',
-            "subscription_item_id": obj.get("subscription_item_id"),
-            "deleted_at": obj.get("deleted_at"),
-            "drop_at_end": obj.get("drop_at_end") if obj.get("drop_at_end") is not None else False
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if deleted_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.deleted_at is None and 'deleted_at' in self.model_fields_set:
+      _dict['deleted_at'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of DeleteSubscriptionItemResponse from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'message':
+          obj.get('message')
+          if obj.get('message') is not None else 'SubscriptionItem deleted successfully.',
+        'subscription_item_id': obj.get('subscription_item_id'),
+        'deleted_at': obj.get('deleted_at'),
+        'drop_at_end': obj.get('drop_at_end') if obj.get('drop_at_end') is not None else False
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/delete_subscription_request.py` & `getopenpay-0.0.2/getopenpay/models/delete_subscription_request.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,93 +7,96 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool
-from pydantic import Field
+
 from getopenpay.models.subscription_cancellation_details import SubscriptionCancellationDetails
+from pydantic import BaseModel, Field, StrictBool
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class DeleteSubscriptionRequest(BaseModel):
-    """
+  """
     DeleteSubscriptionRequest
-    """ # noqa: E501
-    cancellation_details: Optional[SubscriptionCancellationDetails] = None
-    prorate: Optional[StrictBool] = Field(default=True, description="Will generate a proration invoice_item that credits remaining unused time until the subscription period end, also creates invoice_item for un-invoiced metered usage.Setting this to false will not invoice for un-invoiced metered usage.")
-    __properties: ClassVar[List[str]] = ["cancellation_details", "prorate"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of DeleteSubscriptionRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  cancellation_details: Optional[SubscriptionCancellationDetails] = None
+  prorate: Optional[StrictBool] = Field(
+    default=True,
+    description=
+    'Will generate a proration invoice_item that credits remaining unused time until the subscription period end, also creates invoice_item for un-invoiced metered usage.Setting this to false will not invoice for un-invoiced metered usage.'
+  )
+  __properties: ClassVar[List[str]] = ['cancellation_details', 'prorate']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of DeleteSubscriptionRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of cancellation_details
-        if self.cancellation_details:
-            _dict['cancellation_details'] = self.cancellation_details.to_dict()
-        # set to None if cancellation_details (nullable) is None
-        # and model_fields_set contains the field
-        if self.cancellation_details is None and "cancellation_details" in self.model_fields_set:
-            _dict['cancellation_details'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of DeleteSubscriptionRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "cancellation_details": SubscriptionCancellationDetails.from_dict(obj.get("cancellation_details")) if obj.get("cancellation_details") is not None else None,
-            "prorate": obj.get("prorate") if obj.get("prorate") is not None else True
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of cancellation_details
+    if self.cancellation_details:
+      _dict['cancellation_details'] = self.cancellation_details.to_dict()
+    # set to None if cancellation_details (nullable) is None
+    # and model_fields_set contains the field
+    if self.cancellation_details is None and 'cancellation_details' in self.model_fields_set:
+      _dict['cancellation_details'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of DeleteSubscriptionRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'cancellation_details':
+          SubscriptionCancellationDetails.from_dict(obj.get('cancellation_details'))
+          if obj.get('cancellation_details') is not None else None,
+        'prorate': obj.get('prorate') if obj.get('prorate') is not None else True
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/discount_external.py` & `getopenpay-0.0.2/getopenpay/models/payment_intent_query_params.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,143 +7,146 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from getopenpay.models.coupon_external import CouponExternal
-from getopenpay.models.object_name import ObjectName
+
+from getopenpay.models.date_time_filter import DateTimeFilter
+from getopenpay.models.int_range_filter import IntRangeFilter
+from getopenpay.models.payment_intent_status import PaymentIntentStatus
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class DiscountExternal(BaseModel):
+class PaymentIntentQueryParams(BaseModel):
+  """
+    PaymentIntentQueryParams
     """
-    DiscountExternal
-    """ # noqa: E501
-    id: StrictStr
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    start_date: datetime
-    end_date: Optional[datetime]
-    coupon_id: StrictStr
-    coupon: CouponExternal
-    customer_id: Optional[StrictStr]
-    subscription_id: Optional[StrictStr]
-    invoice_id: Optional[StrictStr]
-    invoice_item_id: Optional[StrictStr]
-    promotion_code_id: Optional[StrictStr]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "start_date", "end_date", "coupon_id", "coupon", "customer_id", "subscription_id", "invoice_id", "invoice_item_id", "promotion_code_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of DiscountExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  customer_id: Optional[StrictStr] = None
+  status: Optional[PaymentIntentStatus] = None
+  invoice_id: Optional[StrictStr] = None
+  amount_atom: Optional[IntRangeFilter] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand',
+    'customer_id', 'status', 'invoice_id', 'amount_atom'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PaymentIntentQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of coupon
-        if self.coupon:
-            _dict['coupon'] = self.coupon.to_dict()
-        # set to None if end_date (nullable) is None
-        # and model_fields_set contains the field
-        if self.end_date is None and "end_date" in self.model_fields_set:
-            _dict['end_date'] = None
-
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if subscription_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.subscription_id is None and "subscription_id" in self.model_fields_set:
-            _dict['subscription_id'] = None
-
-        # set to None if invoice_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_id is None and "invoice_id" in self.model_fields_set:
-            _dict['invoice_id'] = None
-
-        # set to None if invoice_item_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_item_id is None and "invoice_item_id" in self.model_fields_set:
-            _dict['invoice_item_id'] = None
-
-        # set to None if promotion_code_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.promotion_code_id is None and "promotion_code_id" in self.model_fields_set:
-            _dict['promotion_code_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of DiscountExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "start_date": obj.get("start_date"),
-            "end_date": obj.get("end_date"),
-            "coupon_id": obj.get("coupon_id"),
-            "coupon": CouponExternal.from_dict(obj.get("coupon")) if obj.get("coupon") is not None else None,
-            "customer_id": obj.get("customer_id"),
-            "subscription_id": obj.get("subscription_id"),
-            "invoice_id": obj.get("invoice_id"),
-            "invoice_item_id": obj.get("invoice_item_id"),
-            "promotion_code_id": obj.get("promotion_code_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of amount_atom
+    if self.amount_atom:
+      _dict['amount_atom'] = self.amount_atom.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if status (nullable) is None
+    # and model_fields_set contains the field
+    if self.status is None and 'status' in self.model_fields_set:
+      _dict['status'] = None
+
+    # set to None if invoice_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_id is None and 'invoice_id' in self.model_fields_set:
+      _dict['invoice_id'] = None
+
+    # set to None if amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.amount_atom is None and 'amount_atom' in self.model_fields_set:
+      _dict['amount_atom'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PaymentIntentQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'customer_id': obj.get('customer_id'),
+        'status': obj.get('status'),
+        'invoice_id': obj.get('invoice_id'),
+        'amount_atom':
+          IntRangeFilter.from_dict(obj.get('amount_atom'))
+          if obj.get('amount_atom') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/discounts.py` & `getopenpay-0.0.2/getopenpay/models/discounts.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,141 +7,145 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import pprint
 import re  # noqa: F401
+from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union
 
-from typing import Optional
-from pydantic import BaseModel, StrictStr, ValidationError, field_validator
 from getopenpay.models.invoice_discount_options import InvoiceDiscountOptions
-from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
+from pydantic import BaseModel, StrictStr, ValidationError, field_validator
 from typing_extensions import Literal
-from pydantic import StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
+DISCOUNTS_ANY_OF_SCHEMAS = ['InvoiceDiscountOptions', 'str']
 
-DISCOUNTS_ANY_OF_SCHEMAS = ["InvoiceDiscountOptions", "str"]
 
 class Discounts(BaseModel):
-    """
+  """
     The coupons to redeem into discounts for the invoice. If not specified, inherits the discount from one of its ancestors. Pass 'null' to not apply any discounts to this invoice.
     """
 
-    # data type: str
-    anyof_schema_1_validator: Optional[StrictStr] = None
-    # data type: InvoiceDiscountOptions
-    anyof_schema_2_validator: Optional[InvoiceDiscountOptions] = None
-    if TYPE_CHECKING:
-        actual_instance: Optional[Union[InvoiceDiscountOptions, str]] = None
-    else:
-        actual_instance: Any = None
-    any_of_schemas: List[str] = Literal[DISCOUNTS_ANY_OF_SCHEMAS]
-
-    model_config = {
-        "validate_assignment": True
-    }
-
-    def __init__(self, *args, **kwargs) -> None:
-        if args:
-            if len(args) > 1:
-                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
-            if kwargs:
-                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
-            super().__init__(actual_instance=args[0])
-        else:
-            super().__init__(**kwargs)
-
-    @field_validator('actual_instance')
-    def actual_instance_must_validate_anyof(cls, v):
-        if v is None:
-            return v
-
-        instance = Discounts.model_construct()
-        error_messages = []
-        # validate data type: str
-        try:
-            instance.anyof_schema_1_validator = v
-            return v
-        except (ValidationError, ValueError) as e:
-            error_messages.append(str(e))
-        # validate data type: InvoiceDiscountOptions
-        if not isinstance(v, InvoiceDiscountOptions):
-            error_messages.append(f"Error! Input type `{type(v)}` is not `InvoiceDiscountOptions`")
-        else:
-            return v
-
-        if error_messages:
-            # no match
-            raise ValueError("No match found when setting the actual_instance in Discounts with anyOf schemas: InvoiceDiscountOptions, str. Details: " + ", ".join(error_messages))
-        else:
-            return v
-
-    @classmethod
-    def from_dict(cls, obj: dict) -> Self:
-        return cls.from_json(json.dumps(obj))
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Returns the object represented by the json string"""
-        instance = cls.model_construct()
-        if json_str is None:
-            return instance
-
-        error_messages = []
-        # deserialize data into str
-        try:
-            # validation
-            instance.anyof_schema_1_validator = json.loads(json_str)
-            # assign value to actual_instance
-            instance.actual_instance = instance.anyof_schema_1_validator
-            return instance
-        except (ValidationError, ValueError) as e:
-            error_messages.append(str(e))
-        # anyof_schema_2_validator: Optional[InvoiceDiscountOptions] = None
-        try:
-            instance.actual_instance = InvoiceDiscountOptions.from_json(json_str)
-            return instance
-        except (ValidationError, ValueError) as e:
-             error_messages.append(str(e))
-
-        if error_messages:
-            # no match
-            raise ValueError("No match found when deserializing the JSON string into Discounts with anyOf schemas: InvoiceDiscountOptions, str. Details: " + ", ".join(error_messages))
-        else:
-            return instance
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the actual instance"""
-        if self.actual_instance is None:
-            return "null"
-
-        to_json = getattr(self.actual_instance, "to_json", None)
-        if callable(to_json):
-            return self.actual_instance.to_json()
-        else:
-            return json.dumps(self.actual_instance)
-
-    def to_dict(self) -> Dict:
-        """Returns the dict representation of the actual instance"""
-        if self.actual_instance is None:
-            return "null"
-
-        to_json = getattr(self.actual_instance, "to_json", None)
-        if callable(to_json):
-            return self.actual_instance.to_dict()
-        else:
-            return json.dumps(self.actual_instance)
-
-    def to_str(self) -> str:
-        """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.model_dump())
+  # data type: str
+  anyof_schema_1_validator: Optional[StrictStr] = None
+  # data type: InvoiceDiscountOptions
+  anyof_schema_2_validator: Optional[InvoiceDiscountOptions] = None
+  if TYPE_CHECKING:
+    actual_instance: Optional[Union[InvoiceDiscountOptions, str]] = None
+  else:
+    actual_instance: Any = None
+  any_of_schemas: List[str] = Literal[DISCOUNTS_ANY_OF_SCHEMAS]
+
+  model_config = {'validate_assignment': True}
+
+  def __init__(self, *args, **kwargs) -> None:
+    if args:
+      if len(args) > 1:
+        raise ValueError(
+          'If a position argument is used, only 1 is allowed to set `actual_instance`'
+        )
+      if kwargs:
+        raise ValueError('If a position argument is used, keyword arguments cannot be used.')
+      super().__init__(actual_instance=args[0])
+    else:
+      super().__init__(**kwargs)
 
+  @field_validator('actual_instance')
+  def actual_instance_must_validate_anyof(cls, v):
+    if v is None:
+      return v
+
+    instance = Discounts.model_construct()
+    error_messages = []
+    # validate data type: str
+    try:
+      instance.anyof_schema_1_validator = v
+      return v
+    except (ValidationError, ValueError) as e:
+      error_messages.append(str(e))
+    # validate data type: InvoiceDiscountOptions
+    if not isinstance(v, InvoiceDiscountOptions):
+      error_messages.append(f'Error! Input type `{type(v)}` is not `InvoiceDiscountOptions`')
+    else:
+      return v
+
+    if error_messages:
+      # no match
+      raise ValueError(
+        'No match found when setting the actual_instance in Discounts with anyOf schemas: InvoiceDiscountOptions, str. Details: '
+        + ', '.join(error_messages)
+      )
+    else:
+      return v
+
+  @classmethod
+  def from_dict(cls, obj: dict) -> Self:
+    return cls.from_json(json.dumps(obj))
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Returns the object represented by the json string"""
+    instance = cls.model_construct()
+    if json_str is None:
+      return instance
+
+    error_messages = []
+    # deserialize data into str
+    try:
+      # validation
+      instance.anyof_schema_1_validator = json.loads(json_str)
+      # assign value to actual_instance
+      instance.actual_instance = instance.anyof_schema_1_validator
+      return instance
+    except (ValidationError, ValueError) as e:
+      error_messages.append(str(e))
+    # anyof_schema_2_validator: Optional[InvoiceDiscountOptions] = None
+    try:
+      instance.actual_instance = InvoiceDiscountOptions.from_json(json_str)
+      return instance
+    except (ValidationError, ValueError) as e:
+      error_messages.append(str(e))
+
+    if error_messages:
+      # no match
+      raise ValueError(
+        'No match found when deserializing the JSON string into Discounts with anyOf schemas: InvoiceDiscountOptions, str. Details: '
+        + ', '.join(error_messages)
+      )
+    else:
+      return instance
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the actual instance"""
+    if self.actual_instance is None:
+      return 'null'
+
+    to_json = getattr(self.actual_instance, 'to_json', None)
+    if callable(to_json):
+      return self.actual_instance.to_json()
+    else:
+      return json.dumps(self.actual_instance)
+
+  def to_dict(self) -> Dict:
+    """Returns the dict representation of the actual instance"""
+    if self.actual_instance is None:
+      return 'null'
+
+    to_json = getattr(self.actual_instance, 'to_json', None)
+    if callable(to_json):
+      return self.actual_instance.to_dict()
+    else:
+      return json.dumps(self.actual_instance)
 
+  def to_str(self) -> str:
+    """Returns the string representation of the actual instance"""
+    return pprint.pformat(self.model_dump())
```

### Comparing `getopenpay-0.0.1/getopenpay/models/event_external.py` & `getopenpay-0.0.2/getopenpay/models/payment_intent_external.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,121 +7,140 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
-from typing import Any, ClassVar, Dict, List, Optional, Union
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.event_type import EventType
+from typing import Any, ClassVar, Dict, List, Optional
+
 from getopenpay.models.object_name import ObjectName
+from getopenpay.models.payment_intent_status import PaymentIntentStatus
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class EventExternal(BaseModel):
+class PaymentIntentExternal(BaseModel):
+  """
+    PaymentIntentExternal
     """
-    EventExternal
-    """ # noqa: E501
-    id: StrictStr
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    account_id: StrictStr
-    type: EventType
-    data: Union[str, Any]
-    data_previous: Optional[Union[str, Any]]
-    request_id: Optional[StrictStr]
-    request_idempotency_key: Optional[StrictStr]
-    pending_webhooks: StrictInt
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "account_id", "type", "data", "data_previous", "request_id", "request_idempotency_key", "pending_webhooks"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of EventExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  amount_atom: StrictInt
+  amount_atom_capturable: Optional[StrictInt]
+  amount_atom_received: Optional[StrictInt]
+  currency: StrictStr
+  customer_id: StrictStr
+  payment_method_id: Optional[StrictStr]
+  status: PaymentIntentStatus
+  invoice_id: Optional[StrictStr]
+  charge_ids: List[StrictStr]
+  refund_ids: List[StrictStr]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'amount_atom',
+    'amount_atom_capturable', 'amount_atom_received', 'currency', 'customer_id',
+    'payment_method_id', 'status', 'invoice_id', 'charge_ids', 'refund_ids'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PaymentIntentExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if data_previous (nullable) is None
-        # and model_fields_set contains the field
-        if self.data_previous is None and "data_previous" in self.model_fields_set:
-            _dict['data_previous'] = None
-
-        # set to None if request_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.request_id is None and "request_id" in self.model_fields_set:
-            _dict['request_id'] = None
-
-        # set to None if request_idempotency_key (nullable) is None
-        # and model_fields_set contains the field
-        if self.request_idempotency_key is None and "request_idempotency_key" in self.model_fields_set:
-            _dict['request_idempotency_key'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of EventExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "account_id": obj.get("account_id"),
-            "type": obj.get("type"),
-            "data": obj.get("data"),
-            "data_previous": obj.get("data_previous"),
-            "request_id": obj.get("request_id"),
-            "request_idempotency_key": obj.get("request_idempotency_key"),
-            "pending_webhooks": obj.get("pending_webhooks")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if amount_atom_capturable (nullable) is None
+    # and model_fields_set contains the field
+    if self.amount_atom_capturable is None and 'amount_atom_capturable' in self.model_fields_set:
+      _dict['amount_atom_capturable'] = None
+
+    # set to None if amount_atom_received (nullable) is None
+    # and model_fields_set contains the field
+    if self.amount_atom_received is None and 'amount_atom_received' in self.model_fields_set:
+      _dict['amount_atom_received'] = None
+
+    # set to None if payment_method_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_method_id is None and 'payment_method_id' in self.model_fields_set:
+      _dict['payment_method_id'] = None
+
+    # set to None if invoice_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_id is None and 'invoice_id' in self.model_fields_set:
+      _dict['invoice_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PaymentIntentExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'amount_atom': obj.get('amount_atom'),
+        'amount_atom_capturable': obj.get('amount_atom_capturable'),
+        'amount_atom_received': obj.get('amount_atom_received'),
+        'currency': obj.get('currency'),
+        'customer_id': obj.get('customer_id'),
+        'payment_method_id': obj.get('payment_method_id'),
+        'status': obj.get('status'),
+        'invoice_id': obj.get('invoice_id'),
+        'charge_ids': obj.get('charge_ids'),
+        'refund_ids': obj.get('refund_ids')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/event_search_params.py` & `getopenpay-0.0.2/getopenpay/models/product_family_query_params.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,109 +7,117 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
-from getopenpay.models.event_type import EventType
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class EventSearchParams(BaseModel):
+class ProductFamilyQueryParams(BaseModel):
+  """
+    ProductFamilyQueryParams
     """
-    EventSearchParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    object_id: StrictStr = Field(description="Unique ID of the object.")
-    types: Optional[List[EventType]] = None
-    limit: Optional[StrictInt] = Field(default=50, description="Maximum number of documents to retrieve.")
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "object_id", "types", "limit"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of EventSearchParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  is_deleted: Optional[StrictBool] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'is_deleted'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ProductFamilyQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of EventSearchParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "object_id": obj.get("object_id"),
-            "types": obj.get("types"),
-            "limit": obj.get("limit") if obj.get("limit") is not None else 50
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if is_deleted (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_deleted is None and 'is_deleted' in self.model_fields_set:
+      _dict['is_deleted'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ProductFamilyQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'is_deleted': obj.get('is_deleted')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/event_type.py` & `getopenpay-0.0.2/getopenpay/models/event_type.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,132 +7,127 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class EventType(str, Enum):
-    """
+  """
     EventType
     """
-
-    """
+  """
     allowed enum values
     """
-    ALL = 'all'
-    ACCOUNT_DOT_CREATED = 'account.created'
-    ACCOUNT_DOT_UPDATED = 'account.updated'
-    ACCOUNT_DOT_DELETED = 'account.deleted'
-    API_TOKEN_DOT_CREATED = 'api_token.created'
-    API_TOKEN_DOT_UPDATED = 'api_token.updated'
-    API_TOKEN_DOT_DELETED = 'api_token.deleted'
-    CHARGE_DOT_CREATED = 'charge.created'
-    CHARGE_DOT_UPDATED = 'charge.updated'
-    CHARGE_DOT_DELETED = 'charge.deleted'
-    COUPON_DOT_CREATED = 'coupon.created'
-    COUPON_DOT_UPDATED = 'coupon.updated'
-    COUPON_DOT_DELETED = 'coupon.deleted'
-    CREDIT_NOTE_DOT_CREATED = 'credit_note.created'
-    CREDIT_NOTE_DOT_UPDATED = 'credit_note.updated'
-    CREDIT_NOTE_DOT_DELETED = 'credit_note.deleted'
-    CREDIT_NOTE_ITEM_DOT_CREATED = 'credit_note_item.created'
-    CREDIT_NOTE_ITEM_DOT_UPDATED = 'credit_note_item.updated'
-    CREDIT_NOTE_ITEM_DOT_DELETED = 'credit_note_item.deleted'
-    CUSTOMER_DOT_CREATED = 'customer.created'
-    CUSTOMER_DOT_UPDATED = 'customer.updated'
-    CUSTOMER_DOT_DELETED = 'customer.deleted'
-    CUSTOMER_BALANCE_TRANSACTION_DOT_CREATED = 'customer_balance_transaction.created'
-    CUSTOMER_BALANCE_TRANSACTION_DOT_UPDATED = 'customer_balance_transaction.updated'
-    CUSTOMER_BALANCE_TRANSACTION_DOT_DELETED = 'customer_balance_transaction.deleted'
-    DELIVERY_ATTEMPT_DOT_CREATED = 'delivery_attempt.created'
-    DELIVERY_ATTEMPT_DOT_UPDATED = 'delivery_attempt.updated'
-    DELIVERY_ATTEMPT_DOT_DELETED = 'delivery_attempt.deleted'
-    DISCOUNT_DOT_CREATED = 'discount.created'
-    DISCOUNT_DOT_UPDATED = 'discount.updated'
-    DISCOUNT_DOT_DELETED = 'discount.deleted'
-    EVENT_DOT_CREATED = 'event.created'
-    EVENT_DOT_UPDATED = 'event.updated'
-    EVENT_DOT_DELETED = 'event.deleted'
-    INVITE_DOT_CREATED = 'invite.created'
-    INVITE_DOT_UPDATED = 'invite.updated'
-    INVITE_DOT_DELETED = 'invite.deleted'
-    INVITE_ITEM_DISCOUNT_DOT_CREATED = 'invite_item_discount.created'
-    INVITE_ITEM_DISCOUNT_DOT_UPDATED = 'invite_item_discount.updated'
-    INVITE_ITEM_DISCOUNT_DOT_DELETED = 'invite_item_discount.deleted'
-    INVOICE_DOT_CREATED = 'invoice.created'
-    INVOICE_DOT_UPDATED = 'invoice.updated'
-    INVOICE_DOT_DELETED = 'invoice.deleted'
-    INVOICE_DOT_UPCOMING = 'invoice.upcoming'
-    INVOICE_DISCOUNT_DOT_CREATED = 'invoice_discount.created'
-    INVOICE_DISCOUNT_DOT_UPDATED = 'invoice_discount.updated'
-    INVOICE_DISCOUNT_DOT_DELETED = 'invoice_discount.deleted'
-    INVOICE_ITEM_DOT_CREATED = 'invoice_item.created'
-    INVOICE_ITEM_DOT_UPDATED = 'invoice_item.updated'
-    INVOICE_ITEM_DOT_DELETED = 'invoice_item.deleted'
-    PAYMENT_INTENT_DOT_CREATED = 'payment_intent.created'
-    PAYMENT_INTENT_DOT_UPDATED = 'payment_intent.updated'
-    PAYMENT_INTENT_DOT_DELETED = 'payment_intent.deleted'
-    PAYMENT_METHOD_DOT_CREATED = 'payment_method.created'
-    PAYMENT_METHOD_DOT_UPDATED = 'payment_method.updated'
-    PAYMENT_METHOD_DOT_DELETED = 'payment_method.deleted'
-    PAYMENT_PROCESSOR_DOT_CREATED = 'payment_processor.created'
-    PAYMENT_PROCESSOR_DOT_UPDATED = 'payment_processor.updated'
-    PAYMENT_PROCESSOR_DOT_DELETED = 'payment_processor.deleted'
-    PRICE_DOT_CREATED = 'price.created'
-    PRICE_DOT_UPDATED = 'price.updated'
-    PRICE_DOT_DELETED = 'price.deleted'
-    PRICE_TIER_DOT_CREATED = 'price_tier.created'
-    PRICE_TIER_DOT_UPDATED = 'price_tier.updated'
-    PRICE_TIER_DOT_DELETED = 'price_tier.deleted'
-    PRODUCT_DOT_CREATED = 'product.created'
-    PRODUCT_DOT_UPDATED = 'product.updated'
-    PRODUCT_DOT_DELETED = 'product.deleted'
-    PROMOTION_CODE_DOT_CREATED = 'promotion_code.created'
-    PROMOTION_CODE_DOT_UPDATED = 'promotion_code.updated'
-    PROMOTION_CODE_DOT_DELETED = 'promotion_code.deleted'
-    REFUND_DOT_CREATED = 'refund.created'
-    REFUND_DOT_UPDATED = 'refund.updated'
-    REFUND_DOT_DELETED = 'refund.deleted'
-    CUSTOMER_DOT_SUBSCRIPTION_DOT_CREATED = 'customer.subscription.created'
-    CUSTOMER_DOT_SUBSCRIPTION_DOT_UPDATED = 'customer.subscription.updated'
-    CUSTOMER_DOT_SUBSCRIPTION_DOT_DELETED = 'customer.subscription.deleted'
-    CUSTOMER_DOT_SUBSCRIPTION_DOT_TRIAL_WILL_END = 'customer.subscription.trial_will_end'
-    SUBSCRIPTION_ITEM_DOT_CREATED = 'subscription_item.created'
-    SUBSCRIPTION_ITEM_DOT_UPDATED = 'subscription_item.updated'
-    SUBSCRIPTION_ITEM_DOT_DELETED = 'subscription_item.deleted'
-    USER_DOT_CREATED = 'user.created'
-    USER_DOT_UPDATED = 'user.updated'
-    USER_DOT_DELETED = 'user.deleted'
-    USER_LOGIN_DOT_CREATED = 'user_login.created'
-    USER_LOGIN_DOT_UPDATED = 'user_login.updated'
-    USER_LOGIN_DOT_DELETED = 'user_login.deleted'
-    USER_RECORD_DOT_CREATED = 'user_record.created'
-    USER_RECORD_DOT_UPDATED = 'user_record.updated'
-    USER_RECORD_DOT_DELETED = 'user_record.deleted'
-    USER_RECORD_SUMMARY_DOT_CREATED = 'user_record_summary.created'
-    USER_RECORD_SUMMARY_DOT_UPDATED = 'user_record_summary.updated'
-    USER_RECORD_SUMMARY_DOT_DELETED = 'user_record_summary.deleted'
-    WEBHOOK_ENDPOINT_DOT_CREATED = 'webhook_endpoint.created'
-    WEBHOOK_ENDPOINT_DOT_UPDATED = 'webhook_endpoint.updated'
-    WEBHOOK_ENDPOINT_DOT_DELETED = 'webhook_endpoint.deleted'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of EventType from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  ALL = 'all'
+  ACCOUNT_DOT_CREATED = 'account.created'
+  ACCOUNT_DOT_UPDATED = 'account.updated'
+  ACCOUNT_DOT_DELETED = 'account.deleted'
+  API_TOKEN_DOT_CREATED = 'api_token.created'
+  API_TOKEN_DOT_UPDATED = 'api_token.updated'
+  API_TOKEN_DOT_DELETED = 'api_token.deleted'
+  CHARGE_DOT_CREATED = 'charge.created'
+  CHARGE_DOT_UPDATED = 'charge.updated'
+  CHARGE_DOT_DELETED = 'charge.deleted'
+  COUPON_DOT_CREATED = 'coupon.created'
+  COUPON_DOT_UPDATED = 'coupon.updated'
+  COUPON_DOT_DELETED = 'coupon.deleted'
+  CREDIT_NOTE_DOT_CREATED = 'credit_note.created'
+  CREDIT_NOTE_DOT_UPDATED = 'credit_note.updated'
+  CREDIT_NOTE_DOT_DELETED = 'credit_note.deleted'
+  CREDIT_NOTE_ITEM_DOT_CREATED = 'credit_note_item.created'
+  CREDIT_NOTE_ITEM_DOT_UPDATED = 'credit_note_item.updated'
+  CREDIT_NOTE_ITEM_DOT_DELETED = 'credit_note_item.deleted'
+  CUSTOMER_DOT_CREATED = 'customer.created'
+  CUSTOMER_DOT_UPDATED = 'customer.updated'
+  CUSTOMER_DOT_DELETED = 'customer.deleted'
+  CUSTOMER_BALANCE_TRANSACTION_DOT_CREATED = 'customer_balance_transaction.created'
+  CUSTOMER_BALANCE_TRANSACTION_DOT_UPDATED = 'customer_balance_transaction.updated'
+  CUSTOMER_BALANCE_TRANSACTION_DOT_DELETED = 'customer_balance_transaction.deleted'
+  DELIVERY_ATTEMPT_DOT_CREATED = 'delivery_attempt.created'
+  DELIVERY_ATTEMPT_DOT_UPDATED = 'delivery_attempt.updated'
+  DELIVERY_ATTEMPT_DOT_DELETED = 'delivery_attempt.deleted'
+  DISCOUNT_DOT_CREATED = 'discount.created'
+  DISCOUNT_DOT_UPDATED = 'discount.updated'
+  DISCOUNT_DOT_DELETED = 'discount.deleted'
+  EVENT_DOT_CREATED = 'event.created'
+  EVENT_DOT_UPDATED = 'event.updated'
+  EVENT_DOT_DELETED = 'event.deleted'
+  INVITE_DOT_CREATED = 'invite.created'
+  INVITE_DOT_UPDATED = 'invite.updated'
+  INVITE_DOT_DELETED = 'invite.deleted'
+  INVITE_ITEM_DISCOUNT_DOT_CREATED = 'invite_item_discount.created'
+  INVITE_ITEM_DISCOUNT_DOT_UPDATED = 'invite_item_discount.updated'
+  INVITE_ITEM_DISCOUNT_DOT_DELETED = 'invite_item_discount.deleted'
+  INVOICE_DOT_CREATED = 'invoice.created'
+  INVOICE_DOT_UPDATED = 'invoice.updated'
+  INVOICE_DOT_DELETED = 'invoice.deleted'
+  INVOICE_DOT_UPCOMING = 'invoice.upcoming'
+  INVOICE_DISCOUNT_DOT_CREATED = 'invoice_discount.created'
+  INVOICE_DISCOUNT_DOT_UPDATED = 'invoice_discount.updated'
+  INVOICE_DISCOUNT_DOT_DELETED = 'invoice_discount.deleted'
+  INVOICE_ITEM_DOT_CREATED = 'invoice_item.created'
+  INVOICE_ITEM_DOT_UPDATED = 'invoice_item.updated'
+  INVOICE_ITEM_DOT_DELETED = 'invoice_item.deleted'
+  PAYMENT_INTENT_DOT_CREATED = 'payment_intent.created'
+  PAYMENT_INTENT_DOT_UPDATED = 'payment_intent.updated'
+  PAYMENT_INTENT_DOT_DELETED = 'payment_intent.deleted'
+  PAYMENT_METHOD_DOT_CREATED = 'payment_method.created'
+  PAYMENT_METHOD_DOT_UPDATED = 'payment_method.updated'
+  PAYMENT_METHOD_DOT_DELETED = 'payment_method.deleted'
+  PAYMENT_PROCESSOR_DOT_CREATED = 'payment_processor.created'
+  PAYMENT_PROCESSOR_DOT_UPDATED = 'payment_processor.updated'
+  PAYMENT_PROCESSOR_DOT_DELETED = 'payment_processor.deleted'
+  PRICE_DOT_CREATED = 'price.created'
+  PRICE_DOT_UPDATED = 'price.updated'
+  PRICE_DOT_DELETED = 'price.deleted'
+  PRICE_TIER_DOT_CREATED = 'price_tier.created'
+  PRICE_TIER_DOT_UPDATED = 'price_tier.updated'
+  PRICE_TIER_DOT_DELETED = 'price_tier.deleted'
+  PRODUCT_DOT_CREATED = 'product.created'
+  PRODUCT_DOT_UPDATED = 'product.updated'
+  PRODUCT_DOT_DELETED = 'product.deleted'
+  PROMOTION_CODE_DOT_CREATED = 'promotion_code.created'
+  PROMOTION_CODE_DOT_UPDATED = 'promotion_code.updated'
+  PROMOTION_CODE_DOT_DELETED = 'promotion_code.deleted'
+  REFUND_DOT_CREATED = 'refund.created'
+  REFUND_DOT_UPDATED = 'refund.updated'
+  REFUND_DOT_DELETED = 'refund.deleted'
+  CUSTOMER_DOT_SUBSCRIPTION_DOT_CREATED = 'customer.subscription.created'
+  CUSTOMER_DOT_SUBSCRIPTION_DOT_UPDATED = 'customer.subscription.updated'
+  CUSTOMER_DOT_SUBSCRIPTION_DOT_DELETED = 'customer.subscription.deleted'
+  CUSTOMER_DOT_SUBSCRIPTION_DOT_TRIAL_WILL_END = 'customer.subscription.trial_will_end'
+  SUBSCRIPTION_ITEM_DOT_CREATED = 'subscription_item.created'
+  SUBSCRIPTION_ITEM_DOT_UPDATED = 'subscription_item.updated'
+  SUBSCRIPTION_ITEM_DOT_DELETED = 'subscription_item.deleted'
+  USER_DOT_CREATED = 'user.created'
+  USER_DOT_UPDATED = 'user.updated'
+  USER_DOT_DELETED = 'user.deleted'
+  USER_LOGIN_DOT_CREATED = 'user_login.created'
+  USER_LOGIN_DOT_UPDATED = 'user_login.updated'
+  USER_LOGIN_DOT_DELETED = 'user_login.deleted'
+  USER_RECORD_DOT_CREATED = 'user_record.created'
+  USER_RECORD_DOT_UPDATED = 'user_record.updated'
+  USER_RECORD_DOT_DELETED = 'user_record.deleted'
+  USER_RECORD_SUMMARY_DOT_CREATED = 'user_record_summary.created'
+  USER_RECORD_SUMMARY_DOT_UPDATED = 'user_record_summary.updated'
+  USER_RECORD_SUMMARY_DOT_DELETED = 'user_record_summary.deleted'
+  WEBHOOK_ENDPOINT_DOT_CREATED = 'webhook_endpoint.created'
+  WEBHOOK_ENDPOINT_DOT_UPDATED = 'webhook_endpoint.updated'
+  WEBHOOK_ENDPOINT_DOT_DELETED = 'webhook_endpoint.deleted'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of EventType from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/events_query_params.py` & `getopenpay-0.0.2/getopenpay/models/events_query_params.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,112 +7,121 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
 from getopenpay.models.event_type import EventType
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class EventsQueryParams(BaseModel):
-    """
+  """
     EventsQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    types: Optional[List[EventType]] = None
-    delivery_success: Optional[StrictBool] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "types", "delivery_success"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of EventsQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  types: Optional[List[EventType]] = None
+  delivery_success: Optional[StrictBool] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'types',
+    'delivery_success'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of EventsQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if delivery_success (nullable) is None
-        # and model_fields_set contains the field
-        if self.delivery_success is None and "delivery_success" in self.model_fields_set:
-            _dict['delivery_success'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of EventsQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "types": obj.get("types"),
-            "delivery_success": obj.get("delivery_success")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if delivery_success (nullable) is None
+    # and model_fields_set contains the field
+    if self.delivery_success is None and 'delivery_success' in self.model_fields_set:
+      _dict['delivery_success'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of EventsQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'types': obj.get('types'),
+        'delivery_success': obj.get('delivery_success')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/http_validation_error.py` & `getopenpay-0.0.2/getopenpay/models/http_validation_error.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,89 +7,89 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel
+
 from getopenpay.models.validation_error import ValidationError
+from pydantic import BaseModel
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class HTTPValidationError(BaseModel):
-    """
+  """
     HTTPValidationError
-    """ # noqa: E501
-    detail: Optional[List[ValidationError]] = None
-    __properties: ClassVar[List[str]] = ["detail"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of HTTPValidationError from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  detail: Optional[List[ValidationError]] = None
+  __properties: ClassVar[List[str]] = ['detail']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of HTTPValidationError from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in detail (list)
-        _items = []
-        if self.detail:
-            for _item in self.detail:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['detail'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of HTTPValidationError from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "detail": [ValidationError.from_dict(_item) for _item in obj.get("detail")] if obj.get("detail") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in detail (list)
+    _items = []
+    if self.detail:
+      for _item in self.detail:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['detail'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of HTTPValidationError from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'detail':
+          [ValidationError.from_dict(_item) for _item in obj.get('detail')]
+          if obj.get('detail') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/inline_subscription_item_update.py` & `getopenpay-0.0.2/getopenpay/models/inline_subscription_item_update.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,124 +7,128 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InlineSubscriptionItemUpdate(BaseModel):
-    """
+  """
     InlineSubscriptionItemUpdate
-    """ # noqa: E501
-    id: Optional[StrictStr] = None
-    delete: Optional[StrictBool] = Field(default=False, description="A flag that, if set to true, will delete the specified item immediately from subscription. drop_at_end flag cannot be used while using this behaviour")
-    add_at_period_end: Optional[StrictBool] = None
-    drop_at_end: Optional[StrictBool] = None
-    price_id: Optional[StrictStr] = None
-    quantity: Optional[StrictInt] = None
-    starts_at: Optional[datetime] = None
-    __properties: ClassVar[List[str]] = ["id", "delete", "add_at_period_end", "drop_at_end", "price_id", "quantity", "starts_at"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InlineSubscriptionItemUpdate from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: Optional[StrictStr] = None
+  delete: Optional[StrictBool] = Field(
+    default=False,
+    description=
+    'A flag that, if set to true, will delete the specified item immediately from subscription. drop_at_end flag cannot be used while using this behaviour'
+  )
+  add_at_period_end: Optional[StrictBool] = None
+  drop_at_end: Optional[StrictBool] = None
+  price_id: Optional[StrictStr] = None
+  quantity: Optional[StrictInt] = None
+  starts_at: Optional[datetime] = None
+  __properties: ClassVar[List[str]] = [
+    'id', 'delete', 'add_at_period_end', 'drop_at_end', 'price_id', 'quantity', 'starts_at'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InlineSubscriptionItemUpdate from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if id (nullable) is None
-        # and model_fields_set contains the field
-        if self.id is None and "id" in self.model_fields_set:
-            _dict['id'] = None
-
-        # set to None if add_at_period_end (nullable) is None
-        # and model_fields_set contains the field
-        if self.add_at_period_end is None and "add_at_period_end" in self.model_fields_set:
-            _dict['add_at_period_end'] = None
-
-        # set to None if drop_at_end (nullable) is None
-        # and model_fields_set contains the field
-        if self.drop_at_end is None and "drop_at_end" in self.model_fields_set:
-            _dict['drop_at_end'] = None
-
-        # set to None if price_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.price_id is None and "price_id" in self.model_fields_set:
-            _dict['price_id'] = None
-
-        # set to None if quantity (nullable) is None
-        # and model_fields_set contains the field
-        if self.quantity is None and "quantity" in self.model_fields_set:
-            _dict['quantity'] = None
-
-        # set to None if starts_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.starts_at is None and "starts_at" in self.model_fields_set:
-            _dict['starts_at'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InlineSubscriptionItemUpdate from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "delete": obj.get("delete") if obj.get("delete") is not None else False,
-            "add_at_period_end": obj.get("add_at_period_end"),
-            "drop_at_end": obj.get("drop_at_end"),
-            "price_id": obj.get("price_id"),
-            "quantity": obj.get("quantity"),
-            "starts_at": obj.get("starts_at")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if id (nullable) is None
+    # and model_fields_set contains the field
+    if self.id is None and 'id' in self.model_fields_set:
+      _dict['id'] = None
+
+    # set to None if add_at_period_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.add_at_period_end is None and 'add_at_period_end' in self.model_fields_set:
+      _dict['add_at_period_end'] = None
+
+    # set to None if drop_at_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.drop_at_end is None and 'drop_at_end' in self.model_fields_set:
+      _dict['drop_at_end'] = None
+
+    # set to None if price_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.price_id is None and 'price_id' in self.model_fields_set:
+      _dict['price_id'] = None
+
+    # set to None if quantity (nullable) is None
+    # and model_fields_set contains the field
+    if self.quantity is None and 'quantity' in self.model_fields_set:
+      _dict['quantity'] = None
+
+    # set to None if starts_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.starts_at is None and 'starts_at' in self.model_fields_set:
+      _dict['starts_at'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InlineSubscriptionItemUpdate from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'delete': obj.get('delete') if obj.get('delete') is not None else False,
+        'add_at_period_end': obj.get('add_at_period_end'),
+        'drop_at_end': obj.get('drop_at_end'),
+        'price_id': obj.get('price_id'),
+        'quantity': obj.get('quantity'),
+        'starts_at': obj.get('starts_at')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/int_range_filter.py` & `getopenpay-0.0.2/getopenpay/models/update_subscription_item_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,114 +7,101 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.proration_enum import ProrationEnum
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class IntRangeFilter(BaseModel):
+class UpdateSubscriptionItemRequest(BaseModel):
+  """
+    UpdateSubscriptionItemRequest
     """
-    IntRangeFilter
-    """ # noqa: E501
-    eq: Optional[StrictInt] = None
-    lt: Optional[StrictInt] = None
-    lte: Optional[StrictInt] = None
-    gt: Optional[StrictInt] = None
-    gte: Optional[StrictInt] = None
-    __properties: ClassVar[List[str]] = ["eq", "lt", "lte", "gt", "gte"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of IntRangeFilter from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  price_id: Optional[StrictStr] = None
+  quantity: Optional[StrictInt] = None
+  proration_behavior: Optional[ProrationEnum] = None
+  drop_at_end: Optional[StrictBool] = None
+  __properties: ClassVar[List[str]] = ['price_id', 'quantity', 'proration_behavior', 'drop_at_end']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdateSubscriptionItemRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if eq (nullable) is None
-        # and model_fields_set contains the field
-        if self.eq is None and "eq" in self.model_fields_set:
-            _dict['eq'] = None
-
-        # set to None if lt (nullable) is None
-        # and model_fields_set contains the field
-        if self.lt is None and "lt" in self.model_fields_set:
-            _dict['lt'] = None
-
-        # set to None if lte (nullable) is None
-        # and model_fields_set contains the field
-        if self.lte is None and "lte" in self.model_fields_set:
-            _dict['lte'] = None
-
-        # set to None if gt (nullable) is None
-        # and model_fields_set contains the field
-        if self.gt is None and "gt" in self.model_fields_set:
-            _dict['gt'] = None
-
-        # set to None if gte (nullable) is None
-        # and model_fields_set contains the field
-        if self.gte is None and "gte" in self.model_fields_set:
-            _dict['gte'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of IntRangeFilter from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "eq": obj.get("eq"),
-            "lt": obj.get("lt"),
-            "lte": obj.get("lte"),
-            "gt": obj.get("gt"),
-            "gte": obj.get("gte")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if price_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.price_id is None and 'price_id' in self.model_fields_set:
+      _dict['price_id'] = None
+
+    # set to None if quantity (nullable) is None
+    # and model_fields_set contains the field
+    if self.quantity is None and 'quantity' in self.model_fields_set:
+      _dict['quantity'] = None
+
+    # set to None if drop_at_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.drop_at_end is None and 'drop_at_end' in self.model_fields_set:
+      _dict['drop_at_end'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdateSubscriptionItemRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'price_id': obj.get('price_id'),
+        'quantity': obj.get('quantity'),
+        'proration_behavior': obj.get('proration_behavior'),
+        'drop_at_end': obj.get('drop_at_end')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invite_external.py` & `getopenpay-0.0.2/getopenpay/models/subscription_item_external.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,103 +7,129 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from getopenpay.models.invite_status_enum import InviteStatusEnum
+
 from getopenpay.models.object_name import ObjectName
-from getopenpay.models.role_enum import RoleEnum
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class InviteExternal(BaseModel):
+class SubscriptionItemExternal(BaseModel):
+  """
+    SubscriptionItemExternal
     """
-    InviteExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the account.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    email: StrictStr = Field(description="Email of the user.")
-    role: RoleEnum
-    account_id: StrictStr = Field(description="Unique Identifier of the account.")
-    account_name: StrictStr = Field(description="Account name to which user is invited.")
-    status: InviteStatusEnum
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "email", "role", "account_id", "account_name", "status"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InviteExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique Identifier of the subscription_item.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  subscription_id: Optional[StrictStr] = None
+  pending_attachment_to_subscription_id: Optional[StrictStr] = None
+  price_id: StrictStr = Field(description='Unique Identifier of the price.')
+  quantity: StrictInt = Field(
+    description='Quantity of the product selected for the subscription_item.'
+  )
+  deleted_at: Optional[datetime]
+  drop_at_end: StrictBool = Field(
+    description='Whether or not this item will be dropped from subscription before next renewal'
+  )
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'subscription_id',
+    'pending_attachment_to_subscription_id', 'price_id', 'quantity', 'deleted_at', 'drop_at_end'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SubscriptionItemExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InviteExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "email": obj.get("email"),
-            "role": obj.get("role"),
-            "account_id": obj.get("account_id"),
-            "account_name": obj.get("account_name"),
-            "status": obj.get("status")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if subscription_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.subscription_id is None and 'subscription_id' in self.model_fields_set:
+      _dict['subscription_id'] = None
+
+    # set to None if pending_attachment_to_subscription_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.pending_attachment_to_subscription_id is None and 'pending_attachment_to_subscription_id' in self.model_fields_set:
+      _dict['pending_attachment_to_subscription_id'] = None
+
+    # set to None if deleted_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.deleted_at is None and 'deleted_at' in self.model_fields_set:
+      _dict['deleted_at'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SubscriptionItemExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'subscription_id': obj.get('subscription_id'),
+        'pending_attachment_to_subscription_id': obj.get('pending_attachment_to_subscription_id'),
+        'price_id': obj.get('price_id'),
+        'quantity': obj.get('quantity'),
+        'deleted_at': obj.get('deleted_at'),
+        'drop_at_end': obj.get('drop_at_end')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invite_status_enum.py` & `getopenpay-0.0.2/getopenpay/models/invite_status_enum.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,40 +7,35 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class InviteStatusEnum(str, Enum):
-    """
+  """
     InviteStatusEnum
     """
-
-    """
+  """
     allowed enum values
     """
-    PENDING = 'pending'
-    ACCEPTED = 'accepted'
-    DECLINED = 'declined'
-    CANCELED = 'canceled'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InviteStatusEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  PENDING = 'pending'
+  ACCEPTED = 'accepted'
+  DECLINED = 'declined'
+  CANCELED = 'canceled'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InviteStatusEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_discount_amounts_external.py` & `getopenpay-0.0.2/getopenpay/models/invoice_discount_amounts_external.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,87 +7,88 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InvoiceDiscountAmountsExternal(BaseModel):
-    """
+  """
     InvoiceDiscountAmountsExternal
-    """ # noqa: E501
-    object: Optional[ObjectName] = None
-    discount_id: StrictStr = Field(description="Id of the discount that was applied to get this discount amount.")
-    amount_atom: StrictInt = Field(description="Amount in units of atom (for usd that is cents, e.g. 1200 for $12)")
-    __properties: ClassVar[List[str]] = ["object", "discount_id", "amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceDiscountAmountsExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  object: Optional[ObjectName] = None
+  discount_id: StrictStr = Field(
+    description='Id of the discount that was applied to get this discount amount.'
+  )
+  amount_atom: StrictInt = Field(
+    description='Amount in units of atom (for usd that is cents, e.g. 1200 for $12)'
+  )
+  __properties: ClassVar[List[str]] = ['object', 'discount_id', 'amount_atom']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceDiscountAmountsExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoiceDiscountAmountsExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "object": obj.get("object"),
-            "discount_id": obj.get("discount_id"),
-            "amount_atom": obj.get("amount_atom")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoiceDiscountAmountsExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'object': obj.get('object'),
+        'discount_id': obj.get('discount_id'),
+        'amount_atom': obj.get('amount_atom')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_discount_options.py` & `getopenpay-0.0.2/getopenpay/models/invoice_discount_options.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,88 +7,81 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
+
 from pydantic import BaseModel, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InvoiceDiscountOptions(BaseModel):
-    """
+  """
     InvoiceDiscountOptions
-    """ # noqa: E501
-    coupons: Optional[List[StrictStr]] = None
-    discount: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["coupons", "discount"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceDiscountOptions from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  coupons: Optional[List[StrictStr]] = None
+  discount: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = ['coupons', 'discount']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceDiscountOptions from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if discount (nullable) is None
-        # and model_fields_set contains the field
-        if self.discount is None and "discount" in self.model_fields_set:
-            _dict['discount'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoiceDiscountOptions from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "coupons": obj.get("coupons"),
-            "discount": obj.get("discount")
-        })
-        return _obj
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if discount (nullable) is None
+    # and model_fields_set contains the field
+    if self.discount is None and 'discount' in self.model_fields_set:
+      _dict['discount'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoiceDiscountOptions from a dict"""
+    if obj is None:
+      return None
 
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
 
+    _obj = cls.model_validate({'coupons': obj.get('coupons'), 'discount': obj.get('discount')})
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_external.py` & `getopenpay-0.0.2/getopenpay/models/invoice_external.py`

 * *Files 26% similar despite different names*

```diff
@@ -7,235 +7,281 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.billing_reason_enum import BillingReasonEnum
 from getopenpay.models.collection_method_enum import CollectionMethodEnum
 from getopenpay.models.discount_external import DiscountExternal
 from getopenpay.models.invoice_discount_amounts_external import InvoiceDiscountAmountsExternal
 from getopenpay.models.invoice_item_external import InvoiceItemExternal
 from getopenpay.models.invoice_status_enum import InvoiceStatusEnum
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InvoiceExternal(BaseModel):
-    """
+  """
     InvoiceExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the invoice.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    account_id: StrictStr = Field(description="Unique identifier of the account.")
-    billing_reason: BillingReasonEnum
-    collection_method: CollectionMethodEnum
-    customer_id: StrictStr = Field(description="Unique identifier of the customer.")
-    currency: StrictStr
-    default_payment_method_id: Optional[StrictStr] = None
-    description: Optional[StrictStr] = None
-    latest_payment_intent_id: Optional[StrictStr] = None
-    period_end: datetime = Field(description="End of the usage period during which invoice_items were added to this invoice. It is in 'ISO 8601' format.")
-    period_start: datetime = Field(description="Start of the usage period during which invoice_items were added to this invoice. It is in 'ISO 8601' format.")
-    status: InvoiceStatusEnum
-    paid_out_of_band: Optional[StrictBool]
-    subscription_id: Optional[StrictStr] = None
-    total_amount_atom: StrictInt = Field(description="Total amount of the invoice. Sum of invoice_items total amount. It is in atomic units (in USD this is cents).")
-    remaining_amount_atom: StrictInt = Field(description="Remaining amount of the invoice to be paid. It is in atomic units (in USD this is cents).")
-    tax_amount_atom: StrictInt = Field(description="Total tax amount in atomic units.")
-    lines: List[InvoiceItemExternal]
-    pre_payment_credit_notes_amount: Optional[StrictInt] = None
-    post_payment_credit_notes_amount: Optional[StrictInt] = None
-    credit_note_ids: Optional[List[StrictStr]] = None
-    applied_balance_amount_atom: StrictInt = Field(description="Amount applied from customer balance either from credit or debit. It is in atomic units (in USD this is cents).")
-    due_amount_atom: StrictInt = Field(description="Final amount due at this time for this invoice. It isin atomic units (in USD this is cents).")
-    paid_amount_atom: StrictInt = Field(description="The amount that was paid in atomic units (in USD this is cents).")
-    discounts: Optional[List[DiscountExternal]] = None
-    total_discount_amount_atoms: Optional[List[InvoiceDiscountAmountsExternal]] = None
-    net_d: Optional[StrictInt] = Field(default=-1, description="Number of days the customer has to pay the invoice, from 0 to 365, where -1 indicates due immediately.")
-    hosted_invoice_url: Optional[StrictStr] = None
-    latest_payment_attempt_failure_message: Optional[StrictStr] = None
-    tax_processor_updated_at: Optional[datetime] = None
-    refund_ids: List[StrictStr]
-    refunded_amount_atom: Optional[StrictInt]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "account_id", "billing_reason", "collection_method", "customer_id", "currency", "default_payment_method_id", "description", "latest_payment_intent_id", "period_end", "period_start", "status", "paid_out_of_band", "subscription_id", "total_amount_atom", "remaining_amount_atom", "tax_amount_atom", "lines", "pre_payment_credit_notes_amount", "post_payment_credit_notes_amount", "credit_note_ids", "applied_balance_amount_atom", "due_amount_atom", "paid_amount_atom", "discounts", "total_discount_amount_atoms", "net_d", "hosted_invoice_url", "latest_payment_attempt_failure_message", "tax_processor_updated_at", "refund_ids", "refunded_amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier of the invoice.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  account_id: StrictStr = Field(description='Unique identifier of the account.')
+  billing_reason: BillingReasonEnum
+  collection_method: CollectionMethodEnum
+  customer_id: StrictStr = Field(description='Unique identifier of the customer.')
+  currency: StrictStr
+  default_payment_method_id: Optional[StrictStr] = None
+  description: Optional[StrictStr] = None
+  latest_payment_intent_id: Optional[StrictStr] = None
+  period_end: datetime = Field(
+    description=
+    "End of the usage period during which invoice_items were added to this invoice. It is in 'ISO 8601' format."
+  )
+  period_start: datetime = Field(
+    description=
+    "Start of the usage period during which invoice_items were added to this invoice. It is in 'ISO 8601' format."
+  )
+  status: InvoiceStatusEnum
+  paid_out_of_band: Optional[StrictBool]
+  subscription_id: Optional[StrictStr] = None
+  total_amount_atom: StrictInt = Field(
+    description=
+    'Total amount of the invoice. Sum of invoice_items total amount. It is in atomic units (in USD this is cents).'
+  )
+  remaining_amount_atom: StrictInt = Field(
+    description=
+    'Remaining amount of the invoice to be paid. It is in atomic units (in USD this is cents).'
+  )
+  tax_amount_atom: StrictInt = Field(description='Total tax amount in atomic units.')
+  lines: List[InvoiceItemExternal]
+  pre_payment_credit_notes_amount: Optional[StrictInt] = None
+  post_payment_credit_notes_amount: Optional[StrictInt] = None
+  credit_note_ids: Optional[List[StrictStr]] = None
+  applied_balance_amount_atom: StrictInt = Field(
+    description=
+    'Amount applied from customer balance either from credit or debit. It is in atomic units (in USD this is cents).'
+  )
+  due_amount_atom: StrictInt = Field(
+    description=
+    'Final amount due at this time for this invoice. It isin atomic units (in USD this is cents).'
+  )
+  paid_amount_atom: StrictInt = Field(
+    description='The amount that was paid in atomic units (in USD this is cents).'
+  )
+  discounts: Optional[List[DiscountExternal]] = None
+  total_discount_amount_atoms: Optional[List[InvoiceDiscountAmountsExternal]] = None
+  net_d: Optional[StrictInt] = Field(
+    default=-1,
+    description=
+    'Number of days the customer has to pay the invoice, from 0 to 365, where -1 indicates due immediately.'
+  )
+  hosted_invoice_url: Optional[StrictStr] = None
+  latest_payment_attempt_failure_message: Optional[StrictStr] = None
+  tax_processor_updated_at: Optional[datetime] = None
+  refund_ids: List[StrictStr]
+  refunded_amount_atom: Optional[StrictInt]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'account_id', 'billing_reason',
+    'collection_method', 'customer_id', 'currency', 'default_payment_method_id', 'description',
+    'latest_payment_intent_id', 'period_end', 'period_start', 'status', 'paid_out_of_band',
+    'subscription_id', 'total_amount_atom', 'remaining_amount_atom', 'tax_amount_atom', 'lines',
+    'pre_payment_credit_notes_amount', 'post_payment_credit_notes_amount', 'credit_note_ids',
+    'applied_balance_amount_atom', 'due_amount_atom', 'paid_amount_atom', 'discounts',
+    'total_discount_amount_atoms', 'net_d', 'hosted_invoice_url',
+    'latest_payment_attempt_failure_message', 'tax_processor_updated_at', 'refund_ids',
+    'refunded_amount_atom'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in lines (list)
-        _items = []
-        if self.lines:
-            for _item in self.lines:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['lines'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in discounts (list)
-        _items = []
-        if self.discounts:
-            for _item in self.discounts:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['discounts'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in total_discount_amount_atoms (list)
-        _items = []
-        if self.total_discount_amount_atoms:
-            for _item in self.total_discount_amount_atoms:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['total_discount_amount_atoms'] = _items
-        # set to None if default_payment_method_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.default_payment_method_id is None and "default_payment_method_id" in self.model_fields_set:
-            _dict['default_payment_method_id'] = None
-
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        # set to None if latest_payment_intent_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.latest_payment_intent_id is None and "latest_payment_intent_id" in self.model_fields_set:
-            _dict['latest_payment_intent_id'] = None
-
-        # set to None if paid_out_of_band (nullable) is None
-        # and model_fields_set contains the field
-        if self.paid_out_of_band is None and "paid_out_of_band" in self.model_fields_set:
-            _dict['paid_out_of_band'] = None
-
-        # set to None if subscription_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.subscription_id is None and "subscription_id" in self.model_fields_set:
-            _dict['subscription_id'] = None
-
-        # set to None if pre_payment_credit_notes_amount (nullable) is None
-        # and model_fields_set contains the field
-        if self.pre_payment_credit_notes_amount is None and "pre_payment_credit_notes_amount" in self.model_fields_set:
-            _dict['pre_payment_credit_notes_amount'] = None
-
-        # set to None if post_payment_credit_notes_amount (nullable) is None
-        # and model_fields_set contains the field
-        if self.post_payment_credit_notes_amount is None and "post_payment_credit_notes_amount" in self.model_fields_set:
-            _dict['post_payment_credit_notes_amount'] = None
-
-        # set to None if hosted_invoice_url (nullable) is None
-        # and model_fields_set contains the field
-        if self.hosted_invoice_url is None and "hosted_invoice_url" in self.model_fields_set:
-            _dict['hosted_invoice_url'] = None
-
-        # set to None if latest_payment_attempt_failure_message (nullable) is None
-        # and model_fields_set contains the field
-        if self.latest_payment_attempt_failure_message is None and "latest_payment_attempt_failure_message" in self.model_fields_set:
-            _dict['latest_payment_attempt_failure_message'] = None
-
-        # set to None if tax_processor_updated_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.tax_processor_updated_at is None and "tax_processor_updated_at" in self.model_fields_set:
-            _dict['tax_processor_updated_at'] = None
-
-        # set to None if refunded_amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.refunded_amount_atom is None and "refunded_amount_atom" in self.model_fields_set:
-            _dict['refunded_amount_atom'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoiceExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "account_id": obj.get("account_id"),
-            "billing_reason": obj.get("billing_reason"),
-            "collection_method": obj.get("collection_method"),
-            "customer_id": obj.get("customer_id"),
-            "currency": obj.get("currency"),
-            "default_payment_method_id": obj.get("default_payment_method_id"),
-            "description": obj.get("description"),
-            "latest_payment_intent_id": obj.get("latest_payment_intent_id"),
-            "period_end": obj.get("period_end"),
-            "period_start": obj.get("period_start"),
-            "status": obj.get("status"),
-            "paid_out_of_band": obj.get("paid_out_of_band"),
-            "subscription_id": obj.get("subscription_id"),
-            "total_amount_atom": obj.get("total_amount_atom"),
-            "remaining_amount_atom": obj.get("remaining_amount_atom"),
-            "tax_amount_atom": obj.get("tax_amount_atom"),
-            "lines": [InvoiceItemExternal.from_dict(_item) for _item in obj.get("lines")] if obj.get("lines") is not None else None,
-            "pre_payment_credit_notes_amount": obj.get("pre_payment_credit_notes_amount"),
-            "post_payment_credit_notes_amount": obj.get("post_payment_credit_notes_amount"),
-            "credit_note_ids": obj.get("credit_note_ids"),
-            "applied_balance_amount_atom": obj.get("applied_balance_amount_atom"),
-            "due_amount_atom": obj.get("due_amount_atom"),
-            "paid_amount_atom": obj.get("paid_amount_atom"),
-            "discounts": [DiscountExternal.from_dict(_item) for _item in obj.get("discounts")] if obj.get("discounts") is not None else None,
-            "total_discount_amount_atoms": [InvoiceDiscountAmountsExternal.from_dict(_item) for _item in obj.get("total_discount_amount_atoms")] if obj.get("total_discount_amount_atoms") is not None else None,
-            "net_d": obj.get("net_d") if obj.get("net_d") is not None else -1,
-            "hosted_invoice_url": obj.get("hosted_invoice_url"),
-            "latest_payment_attempt_failure_message": obj.get("latest_payment_attempt_failure_message"),
-            "tax_processor_updated_at": obj.get("tax_processor_updated_at"),
-            "refund_ids": obj.get("refund_ids"),
-            "refunded_amount_atom": obj.get("refunded_amount_atom")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in lines (list)
+    _items = []
+    if self.lines:
+      for _item in self.lines:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['lines'] = _items
+    # override the default output from pydantic by calling `to_dict()` of each item in discounts (list)
+    _items = []
+    if self.discounts:
+      for _item in self.discounts:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['discounts'] = _items
+    # override the default output from pydantic by calling `to_dict()` of each item in total_discount_amount_atoms (list)
+    _items = []
+    if self.total_discount_amount_atoms:
+      for _item in self.total_discount_amount_atoms:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['total_discount_amount_atoms'] = _items
+    # set to None if default_payment_method_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.default_payment_method_id is None and 'default_payment_method_id' in self.model_fields_set:
+      _dict['default_payment_method_id'] = None
+
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    # set to None if latest_payment_intent_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.latest_payment_intent_id is None and 'latest_payment_intent_id' in self.model_fields_set:
+      _dict['latest_payment_intent_id'] = None
+
+    # set to None if paid_out_of_band (nullable) is None
+    # and model_fields_set contains the field
+    if self.paid_out_of_band is None and 'paid_out_of_band' in self.model_fields_set:
+      _dict['paid_out_of_band'] = None
+
+    # set to None if subscription_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.subscription_id is None and 'subscription_id' in self.model_fields_set:
+      _dict['subscription_id'] = None
+
+    # set to None if pre_payment_credit_notes_amount (nullable) is None
+    # and model_fields_set contains the field
+    if self.pre_payment_credit_notes_amount is None and 'pre_payment_credit_notes_amount' in self.model_fields_set:
+      _dict['pre_payment_credit_notes_amount'] = None
+
+    # set to None if post_payment_credit_notes_amount (nullable) is None
+    # and model_fields_set contains the field
+    if self.post_payment_credit_notes_amount is None and 'post_payment_credit_notes_amount' in self.model_fields_set:
+      _dict['post_payment_credit_notes_amount'] = None
+
+    # set to None if hosted_invoice_url (nullable) is None
+    # and model_fields_set contains the field
+    if self.hosted_invoice_url is None and 'hosted_invoice_url' in self.model_fields_set:
+      _dict['hosted_invoice_url'] = None
+
+    # set to None if latest_payment_attempt_failure_message (nullable) is None
+    # and model_fields_set contains the field
+    if self.latest_payment_attempt_failure_message is None and 'latest_payment_attempt_failure_message' in self.model_fields_set:
+      _dict['latest_payment_attempt_failure_message'] = None
+
+    # set to None if tax_processor_updated_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.tax_processor_updated_at is None and 'tax_processor_updated_at' in self.model_fields_set:
+      _dict['tax_processor_updated_at'] = None
+
+    # set to None if refunded_amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.refunded_amount_atom is None and 'refunded_amount_atom' in self.model_fields_set:
+      _dict['refunded_amount_atom'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoiceExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'account_id': obj.get('account_id'),
+        'billing_reason': obj.get('billing_reason'),
+        'collection_method': obj.get('collection_method'),
+        'customer_id': obj.get('customer_id'),
+        'currency': obj.get('currency'),
+        'default_payment_method_id': obj.get('default_payment_method_id'),
+        'description': obj.get('description'),
+        'latest_payment_intent_id': obj.get('latest_payment_intent_id'),
+        'period_end': obj.get('period_end'),
+        'period_start': obj.get('period_start'),
+        'status': obj.get('status'),
+        'paid_out_of_band': obj.get('paid_out_of_band'),
+        'subscription_id': obj.get('subscription_id'),
+        'total_amount_atom': obj.get('total_amount_atom'),
+        'remaining_amount_atom': obj.get('remaining_amount_atom'),
+        'tax_amount_atom': obj.get('tax_amount_atom'),
+        'lines':
+          [InvoiceItemExternal.from_dict(_item) for _item in obj.get('lines')]
+          if obj.get('lines') is not None else None,
+        'pre_payment_credit_notes_amount': obj.get('pre_payment_credit_notes_amount'),
+        'post_payment_credit_notes_amount': obj.get('post_payment_credit_notes_amount'),
+        'credit_note_ids': obj.get('credit_note_ids'),
+        'applied_balance_amount_atom': obj.get('applied_balance_amount_atom'),
+        'due_amount_atom': obj.get('due_amount_atom'),
+        'paid_amount_atom': obj.get('paid_amount_atom'),
+        'discounts':
+          [DiscountExternal.from_dict(_item) for _item in obj.get('discounts')]
+          if obj.get('discounts') is not None else None,
+        'total_discount_amount_atoms':
+          [
+            InvoiceDiscountAmountsExternal.from_dict(_item)
+            for _item in obj.get('total_discount_amount_atoms')
+          ] if obj.get('total_discount_amount_atoms') is not None else None,
+        'net_d': obj.get('net_d') if obj.get('net_d') is not None else -1,
+        'hosted_invoice_url': obj.get('hosted_invoice_url'),
+        'latest_payment_attempt_failure_message': obj.get('latest_payment_attempt_failure_message'),
+        'tax_processor_updated_at': obj.get('tax_processor_updated_at'),
+        'refund_ids': obj.get('refund_ids'),
+        'refunded_amount_atom': obj.get('refunded_amount_atom')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_item_discount_amounts_external.py` & `getopenpay-0.0.2/getopenpay/models/invoice_item_discount_amounts_external.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,87 +7,86 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InvoiceItemDiscountAmountsExternal(BaseModel):
-    """
+  """
     InvoiceItemDiscountAmountsExternal
-    """ # noqa: E501
-    object: Optional[ObjectName] = None
-    discount_id: StrictStr = Field(description="Id of the discount that was applied to get this discount amount.")
-    amount_atom: StrictInt = Field(description="The amount_atom, of the discount.")
-    __properties: ClassVar[List[str]] = ["object", "discount_id", "amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceItemDiscountAmountsExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  object: Optional[ObjectName] = None
+  discount_id: StrictStr = Field(
+    description='Id of the discount that was applied to get this discount amount.'
+  )
+  amount_atom: StrictInt = Field(description='The amount_atom, of the discount.')
+  __properties: ClassVar[List[str]] = ['object', 'discount_id', 'amount_atom']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceItemDiscountAmountsExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoiceItemDiscountAmountsExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "object": obj.get("object"),
-            "discount_id": obj.get("discount_id"),
-            "amount_atom": obj.get("amount_atom")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoiceItemDiscountAmountsExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'object': obj.get('object'),
+        'discount_id': obj.get('discount_id'),
+        'amount_atom': obj.get('amount_atom')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_item_discount_amounts_public.py` & `getopenpay-0.0.2/getopenpay/models/invoice_item_discount_amounts_public.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,91 +7,90 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InvoiceItemDiscountAmountsPublic(BaseModel):
-    """
+  """
     InvoiceItemDiscountAmountsPublic
-    """ # noqa: E501
-    amount_atom: StrictInt = Field(description="The amount_atom of the discount.")
-    coupon_name: StrictStr = Field(description="Name of the coupon that was applied to get this discount.")
-    coupon_description: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["amount_atom", "coupon_name", "coupon_description"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceItemDiscountAmountsPublic from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  amount_atom: StrictInt = Field(description='The amount_atom of the discount.')
+  coupon_name: StrictStr = Field(
+    description='Name of the coupon that was applied to get this discount.'
+  )
+  coupon_description: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = ['amount_atom', 'coupon_name', 'coupon_description']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceItemDiscountAmountsPublic from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if coupon_description (nullable) is None
-        # and model_fields_set contains the field
-        if self.coupon_description is None and "coupon_description" in self.model_fields_set:
-            _dict['coupon_description'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoiceItemDiscountAmountsPublic from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "amount_atom": obj.get("amount_atom"),
-            "coupon_name": obj.get("coupon_name"),
-            "coupon_description": obj.get("coupon_description")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if coupon_description (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_description is None and 'coupon_description' in self.model_fields_set:
+      _dict['coupon_description'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoiceItemDiscountAmountsPublic from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'amount_atom': obj.get('amount_atom'),
+        'coupon_name': obj.get('coupon_name'),
+        'coupon_description': obj.get('coupon_description')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_item_public.py` & `getopenpay-0.0.2/getopenpay/models/invoice_item_public.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,119 +7,130 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.invoice_item_discount_amounts_public import InvoiceItemDiscountAmountsPublic
 from getopenpay.models.price_tier_public import PriceTierPublic
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InvoiceItemPublic(BaseModel):
-    """
+  """
     InvoiceItemPublic
-    """ # noqa: E501
-    name: StrictStr = Field(description="The name of the line item as it appears in the invoice.")
-    quantity: StrictInt = Field(description="Quantity of the line item.")
-    amount_atom: StrictInt = Field(description="Total amount of invoice_item in atomic units (in USD this is cents).")
-    currency: StrictStr
-    invoice_item_description: Optional[StrictStr]
-    discounts: List[StrictStr]
-    discount_amount_atoms: List[InvoiceItemDiscountAmountsPublic]
-    amount_atom_considering_discount_applied: StrictInt = Field(description="Total amount of invoice_item in atomic units considering discounts")
-    price_tiers: Optional[List[PriceTierPublic]] = None
-    __properties: ClassVar[List[str]] = ["name", "quantity", "amount_atom", "currency", "invoice_item_description", "discounts", "discount_amount_atoms", "amount_atom_considering_discount_applied", "price_tiers"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceItemPublic from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  name: StrictStr = Field(description='The name of the line item as it appears in the invoice.')
+  quantity: StrictInt = Field(description='Quantity of the line item.')
+  amount_atom: StrictInt = Field(
+    description='Total amount of invoice_item in atomic units (in USD this is cents).'
+  )
+  currency: StrictStr
+  invoice_item_description: Optional[StrictStr]
+  discounts: List[StrictStr]
+  discount_amount_atoms: List[InvoiceItemDiscountAmountsPublic]
+  amount_atom_considering_discount_applied: StrictInt = Field(
+    description='Total amount of invoice_item in atomic units considering discounts'
+  )
+  price_tiers: Optional[List[PriceTierPublic]] = None
+  __properties: ClassVar[List[str]] = [
+    'name', 'quantity', 'amount_atom', 'currency', 'invoice_item_description', 'discounts',
+    'discount_amount_atoms', 'amount_atom_considering_discount_applied', 'price_tiers'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceItemPublic from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in discount_amount_atoms (list)
-        _items = []
-        if self.discount_amount_atoms:
-            for _item in self.discount_amount_atoms:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['discount_amount_atoms'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in price_tiers (list)
-        _items = []
-        if self.price_tiers:
-            for _item in self.price_tiers:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['price_tiers'] = _items
-        # set to None if invoice_item_description (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_item_description is None and "invoice_item_description" in self.model_fields_set:
-            _dict['invoice_item_description'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoiceItemPublic from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "name": obj.get("name"),
-            "quantity": obj.get("quantity"),
-            "amount_atom": obj.get("amount_atom"),
-            "currency": obj.get("currency"),
-            "invoice_item_description": obj.get("invoice_item_description"),
-            "discounts": obj.get("discounts"),
-            "discount_amount_atoms": [InvoiceItemDiscountAmountsPublic.from_dict(_item) for _item in obj.get("discount_amount_atoms")] if obj.get("discount_amount_atoms") is not None else None,
-            "amount_atom_considering_discount_applied": obj.get("amount_atom_considering_discount_applied"),
-            "price_tiers": [PriceTierPublic.from_dict(_item) for _item in obj.get("price_tiers")] if obj.get("price_tiers") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in discount_amount_atoms (list)
+    _items = []
+    if self.discount_amount_atoms:
+      for _item in self.discount_amount_atoms:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['discount_amount_atoms'] = _items
+    # override the default output from pydantic by calling `to_dict()` of each item in price_tiers (list)
+    _items = []
+    if self.price_tiers:
+      for _item in self.price_tiers:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['price_tiers'] = _items
+    # set to None if invoice_item_description (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_item_description is None and 'invoice_item_description' in self.model_fields_set:
+      _dict['invoice_item_description'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoiceItemPublic from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'name': obj.get('name'),
+        'quantity': obj.get('quantity'),
+        'amount_atom': obj.get('amount_atom'),
+        'currency': obj.get('currency'),
+        'invoice_item_description': obj.get('invoice_item_description'),
+        'discounts': obj.get('discounts'),
+        'discount_amount_atoms':
+          [
+            InvoiceItemDiscountAmountsPublic.from_dict(_item)
+            for _item in obj.get('discount_amount_atoms')
+          ] if obj.get('discount_amount_atoms') is not None else None,
+        'amount_atom_considering_discount_applied':
+          obj.get('amount_atom_considering_discount_applied'),
+        'price_tiers':
+          [PriceTierPublic.from_dict(_item) for _item in obj.get('price_tiers')]
+          if obj.get('price_tiers') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_items_query_params.py` & `getopenpay-0.0.2/getopenpay/models/invoice_items_query_params.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,123 +7,132 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InvoiceItemsQueryParams(BaseModel):
-    """
+  """
     InvoiceItemsQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    customer_id: Optional[StrictStr] = None
-    invoice_id: Optional[StrictStr] = None
-    coupon_id: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "customer_id", "invoice_id", "coupon_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceItemsQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  customer_id: Optional[StrictStr] = None
+  invoice_id: Optional[StrictStr] = None
+  coupon_id: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand',
+    'customer_id', 'invoice_id', 'coupon_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceItemsQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if invoice_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_id is None and "invoice_id" in self.model_fields_set:
-            _dict['invoice_id'] = None
-
-        # set to None if coupon_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.coupon_id is None and "coupon_id" in self.model_fields_set:
-            _dict['coupon_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoiceItemsQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "customer_id": obj.get("customer_id"),
-            "invoice_id": obj.get("invoice_id"),
-            "coupon_id": obj.get("coupon_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if invoice_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_id is None and 'invoice_id' in self.model_fields_set:
+      _dict['invoice_id'] = None
+
+    # set to None if coupon_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_id is None and 'coupon_id' in self.model_fields_set:
+      _dict['coupon_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoiceItemsQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'customer_id': obj.get('customer_id'),
+        'invoice_id': obj.get('invoice_id'),
+        'coupon_id': obj.get('coupon_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_public.py` & `getopenpay-0.0.2/getopenpay/models/invoice_public.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,127 +7,132 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional, Union
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.credit_card_type import CreditCardType
 from getopenpay.models.invoice_item_public import InvoiceItemPublic
+from pydantic import BaseModel, Field, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InvoicePublic(BaseModel):
-    """
+  """
     InvoicePublic
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the invoice.")
-    paid_at: datetime = Field(description="When the invoice is paid, in 'ISO 8601' format.")
-    paid_amount_atom: StrictInt = Field(description="Total amount paid. It is in atomic units (in USD this is cents).")
-    billed_to: Optional[StrictStr] = None
-    billing_address: Optional[StrictStr] = None
-    card_type: Optional[CreditCardType] = None
-    last_four: Optional[StrictStr] = None
-    lines: Optional[List[InvoiceItemPublic]] = None
-    branding: Union[str, Any] = Field(description="The branding settings associated with the account")
-    __properties: ClassVar[List[str]] = ["id", "paid_at", "paid_amount_atom", "billed_to", "billing_address", "card_type", "last_four", "lines", "branding"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoicePublic from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier of the invoice.')
+  paid_at: datetime = Field(description="When the invoice is paid, in 'ISO 8601' format.")
+  paid_amount_atom: StrictInt = Field(
+    description='Total amount paid. It is in atomic units (in USD this is cents).'
+  )
+  billed_to: Optional[StrictStr] = None
+  billing_address: Optional[StrictStr] = None
+  card_type: Optional[CreditCardType] = None
+  last_four: Optional[StrictStr] = None
+  lines: Optional[List[InvoiceItemPublic]] = None
+  branding: Union[str, Any] = Field(description='The branding settings associated with the account')
+  __properties: ClassVar[List[str]] = [
+    'id', 'paid_at', 'paid_amount_atom', 'billed_to', 'billing_address', 'card_type', 'last_four',
+    'lines', 'branding'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoicePublic from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in lines (list)
-        _items = []
-        if self.lines:
-            for _item in self.lines:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['lines'] = _items
-        # set to None if billed_to (nullable) is None
-        # and model_fields_set contains the field
-        if self.billed_to is None and "billed_to" in self.model_fields_set:
-            _dict['billed_to'] = None
-
-        # set to None if billing_address (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_address is None and "billing_address" in self.model_fields_set:
-            _dict['billing_address'] = None
-
-        # set to None if card_type (nullable) is None
-        # and model_fields_set contains the field
-        if self.card_type is None and "card_type" in self.model_fields_set:
-            _dict['card_type'] = None
-
-        # set to None if last_four (nullable) is None
-        # and model_fields_set contains the field
-        if self.last_four is None and "last_four" in self.model_fields_set:
-            _dict['last_four'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoicePublic from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "paid_at": obj.get("paid_at"),
-            "paid_amount_atom": obj.get("paid_amount_atom"),
-            "billed_to": obj.get("billed_to"),
-            "billing_address": obj.get("billing_address"),
-            "card_type": obj.get("card_type"),
-            "last_four": obj.get("last_four"),
-            "lines": [InvoiceItemPublic.from_dict(_item) for _item in obj.get("lines")] if obj.get("lines") is not None else None,
-            "branding": obj.get("branding")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in lines (list)
+    _items = []
+    if self.lines:
+      for _item in self.lines:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['lines'] = _items
+    # set to None if billed_to (nullable) is None
+    # and model_fields_set contains the field
+    if self.billed_to is None and 'billed_to' in self.model_fields_set:
+      _dict['billed_to'] = None
+
+    # set to None if billing_address (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_address is None and 'billing_address' in self.model_fields_set:
+      _dict['billing_address'] = None
+
+    # set to None if card_type (nullable) is None
+    # and model_fields_set contains the field
+    if self.card_type is None and 'card_type' in self.model_fields_set:
+      _dict['card_type'] = None
+
+    # set to None if last_four (nullable) is None
+    # and model_fields_set contains the field
+    if self.last_four is None and 'last_four' in self.model_fields_set:
+      _dict['last_four'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoicePublic from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'paid_at': obj.get('paid_at'),
+        'paid_amount_atom': obj.get('paid_amount_atom'),
+        'billed_to': obj.get('billed_to'),
+        'billing_address': obj.get('billing_address'),
+        'card_type': obj.get('card_type'),
+        'last_four': obj.get('last_four'),
+        'lines':
+          [InvoiceItemPublic.from_dict(_item) for _item in obj.get('lines')]
+          if obj.get('lines') is not None else None,
+        'branding': obj.get('branding')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_query_params.py` & `getopenpay-0.0.2/getopenpay/models/subscription_query_params.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,170 +7,172 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
-from getopenpay.models.billing_reason_enum import BillingReasonEnum
+
 from getopenpay.models.date_time_filter import DateTimeFilter
-from getopenpay.models.int_range_filter import IntRangeFilter
-from getopenpay.models.invoice_status_enum import InvoiceStatusEnum
+from getopenpay.models.subscription_status_enum import SubscriptionStatusEnum
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class InvoiceQueryParams(BaseModel):
+class SubscriptionQueryParams(BaseModel):
+  """
+    SubscriptionQueryParams
     """
-    InvoiceQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    customer_id: Optional[StrictStr] = None
-    status: Optional[InvoiceStatusEnum] = None
-    subscription_id: Optional[StrictStr] = None
-    billing_reason: Optional[BillingReasonEnum] = None
-    total_amount_atom: Optional[IntRangeFilter] = None
-    period_start: Optional[DateTimeFilter] = None
-    period_end: Optional[DateTimeFilter] = None
-    coupon_id: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "customer_id", "status", "subscription_id", "billing_reason", "total_amount_atom", "period_start", "period_end", "coupon_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  customer_id: Optional[StrictStr] = None
+  product_id: Optional[StrictStr] = None
+  price_id: Optional[StrictStr] = None
+  status: Optional[SubscriptionStatusEnum] = None
+  current_period_start: Optional[DateTimeFilter] = None
+  current_period_end: Optional[DateTimeFilter] = None
+  coupon_id: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand',
+    'customer_id', 'product_id', 'price_id', 'status', 'current_period_start', 'current_period_end',
+    'coupon_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SubscriptionQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of total_amount_atom
-        if self.total_amount_atom:
-            _dict['total_amount_atom'] = self.total_amount_atom.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of period_start
-        if self.period_start:
-            _dict['period_start'] = self.period_start.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of period_end
-        if self.period_end:
-            _dict['period_end'] = self.period_end.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if status (nullable) is None
-        # and model_fields_set contains the field
-        if self.status is None and "status" in self.model_fields_set:
-            _dict['status'] = None
-
-        # set to None if subscription_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.subscription_id is None and "subscription_id" in self.model_fields_set:
-            _dict['subscription_id'] = None
-
-        # set to None if billing_reason (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_reason is None and "billing_reason" in self.model_fields_set:
-            _dict['billing_reason'] = None
-
-        # set to None if total_amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.total_amount_atom is None and "total_amount_atom" in self.model_fields_set:
-            _dict['total_amount_atom'] = None
-
-        # set to None if period_start (nullable) is None
-        # and model_fields_set contains the field
-        if self.period_start is None and "period_start" in self.model_fields_set:
-            _dict['period_start'] = None
-
-        # set to None if period_end (nullable) is None
-        # and model_fields_set contains the field
-        if self.period_end is None and "period_end" in self.model_fields_set:
-            _dict['period_end'] = None
-
-        # set to None if coupon_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.coupon_id is None and "coupon_id" in self.model_fields_set:
-            _dict['coupon_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoiceQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "customer_id": obj.get("customer_id"),
-            "status": obj.get("status"),
-            "subscription_id": obj.get("subscription_id"),
-            "billing_reason": obj.get("billing_reason"),
-            "total_amount_atom": IntRangeFilter.from_dict(obj.get("total_amount_atom")) if obj.get("total_amount_atom") is not None else None,
-            "period_start": DateTimeFilter.from_dict(obj.get("period_start")) if obj.get("period_start") is not None else None,
-            "period_end": DateTimeFilter.from_dict(obj.get("period_end")) if obj.get("period_end") is not None else None,
-            "coupon_id": obj.get("coupon_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of current_period_start
+    if self.current_period_start:
+      _dict['current_period_start'] = self.current_period_start.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of current_period_end
+    if self.current_period_end:
+      _dict['current_period_end'] = self.current_period_end.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if product_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.product_id is None and 'product_id' in self.model_fields_set:
+      _dict['product_id'] = None
+
+    # set to None if price_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.price_id is None and 'price_id' in self.model_fields_set:
+      _dict['price_id'] = None
+
+    # set to None if status (nullable) is None
+    # and model_fields_set contains the field
+    if self.status is None and 'status' in self.model_fields_set:
+      _dict['status'] = None
+
+    # set to None if current_period_start (nullable) is None
+    # and model_fields_set contains the field
+    if self.current_period_start is None and 'current_period_start' in self.model_fields_set:
+      _dict['current_period_start'] = None
+
+    # set to None if current_period_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.current_period_end is None and 'current_period_end' in self.model_fields_set:
+      _dict['current_period_end'] = None
+
+    # set to None if coupon_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_id is None and 'coupon_id' in self.model_fields_set:
+      _dict['coupon_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SubscriptionQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'customer_id': obj.get('customer_id'),
+        'product_id': obj.get('product_id'),
+        'price_id': obj.get('price_id'),
+        'status': obj.get('status'),
+        'current_period_start':
+          DateTimeFilter.from_dict(obj.get('current_period_start'))
+          if obj.get('current_period_start') is not None else None,
+        'current_period_end':
+          DateTimeFilter.from_dict(obj.get('current_period_end'))
+          if obj.get('current_period_end') is not None else None,
+        'coupon_id': obj.get('coupon_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_settings.py` & `getopenpay-0.0.2/getopenpay/models/invoice_settings.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,86 +7,80 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
+
 from pydantic import BaseModel, StrictInt
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class InvoiceSettings(BaseModel):
-    """
+  """
     InvoiceSettings
-    """ # noqa: E501
-    default_net_d: Optional[StrictInt] = None
-    __properties: ClassVar[List[str]] = ["default_net_d"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceSettings from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  default_net_d: Optional[StrictInt] = None
+  __properties: ClassVar[List[str]] = ['default_net_d']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceSettings from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if default_net_d (nullable) is None
-        # and model_fields_set contains the field
-        if self.default_net_d is None and "default_net_d" in self.model_fields_set:
-            _dict['default_net_d'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of InvoiceSettings from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "default_net_d": obj.get("default_net_d")
-        })
-        return _obj
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if default_net_d (nullable) is None
+    # and model_fields_set contains the field
+    if self.default_net_d is None and 'default_net_d' in self.model_fields_set:
+      _dict['default_net_d'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of InvoiceSettings from a dict"""
+    if obj is None:
+      return None
 
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
 
+    _obj = cls.model_validate({'default_net_d': obj.get('default_net_d')})
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/invoice_status_enum.py` & `getopenpay-0.0.2/getopenpay/models/invoice_status_enum.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,42 +7,37 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class InvoiceStatusEnum(str, Enum):
-    """
+  """
     InvoiceStatusEnum
     """
-
-    """
+  """
     allowed enum values
     """
-    DRAFT = 'draft'
-    OPEN = 'open'
-    VOID = 'void'
-    PAID = 'paid'
-    PAST_DUE = 'past_due'
-    UNCOLLECTIBLE = 'uncollectible'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of InvoiceStatusEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  DRAFT = 'draft'
+  OPEN = 'open'
+  VOID = 'void'
+  PAID = 'paid'
+  PAST_DUE = 'past_due'
+  UNCOLLECTIBLE = 'uncollectible'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of InvoiceStatusEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_active_sub_params.py` & `getopenpay-0.0.2/getopenpay/models/list_active_sub_params.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,93 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
+
 from pydantic import BaseModel, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class ListActiveSubParams(BaseModel):
-    """
+  """
     ListActiveSubParams
-    """ # noqa: E501
-    product_id: Optional[StrictStr] = None
-    price_id: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["product_id", "price_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListActiveSubParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  product_id: Optional[StrictStr] = None
+  price_id: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = ['product_id', 'price_id']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListActiveSubParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if product_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.product_id is None and "product_id" in self.model_fields_set:
-            _dict['product_id'] = None
-
-        # set to None if price_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.price_id is None and "price_id" in self.model_fields_set:
-            _dict['price_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListActiveSubParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "product_id": obj.get("product_id"),
-            "price_id": obj.get("price_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if product_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.product_id is None and 'product_id' in self.model_fields_set:
+      _dict['product_id'] = None
+
+    # set to None if price_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.price_id is None and 'price_id' in self.model_fields_set:
+      _dict['price_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListActiveSubParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'product_id': obj.get('product_id'),
+        'price_id': obj.get('price_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_charge_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_invoice_item_external.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.invoice_item_external import InvoiceItemExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.charge_external import ChargeExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponseChargeExternal(BaseModel):
+class ListResponseInvoiceItemExternal(BaseModel):
+  """
+    ListResponseInvoiceItemExternal
     """
-    ListResponseChargeExternal
-    """ # noqa: E501
-    data: List[ChargeExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseChargeExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[InvoiceItemExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseInvoiceItemExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseChargeExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [ChargeExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseInvoiceItemExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [InvoiceItemExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_checkout_session_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_checkout_session_external.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt
+
 from getopenpay.models.checkout_session_external import CheckoutSessionExternal
+from pydantic import BaseModel, StrictInt
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class ListResponseCheckoutSessionExternal(BaseModel):
-    """
+  """
     ListResponseCheckoutSessionExternal
-    """ # noqa: E501
-    data: List[CheckoutSessionExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseCheckoutSessionExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  data: List[CheckoutSessionExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseCheckoutSessionExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseCheckoutSessionExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [CheckoutSessionExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseCheckoutSessionExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [CheckoutSessionExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_coupon_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_credit_note_external.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.credit_note_external import CreditNoteExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.coupon_external import CouponExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponseCouponExternal(BaseModel):
+class ListResponseCreditNoteExternal(BaseModel):
+  """
+    ListResponseCreditNoteExternal
     """
-    ListResponseCouponExternal
-    """ # noqa: E501
-    data: List[CouponExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseCouponExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[CreditNoteExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseCreditNoteExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseCouponExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [CouponExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseCreditNoteExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [CreditNoteExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_credit_note_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_payment_method_external.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.payment_method_external import PaymentMethodExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.credit_note_external import CreditNoteExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponseCreditNoteExternal(BaseModel):
+class ListResponsePaymentMethodExternal(BaseModel):
+  """
+    ListResponsePaymentMethodExternal
     """
-    ListResponseCreditNoteExternal
-    """ # noqa: E501
-    data: List[CreditNoteExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseCreditNoteExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[PaymentMethodExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponsePaymentMethodExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseCreditNoteExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [CreditNoteExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponsePaymentMethodExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [PaymentMethodExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_customer_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_payment_link_external.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.payment_link_external import PaymentLinkExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.customer_external import CustomerExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponseCustomerExternal(BaseModel):
+class ListResponsePaymentLinkExternal(BaseModel):
+  """
+    ListResponsePaymentLinkExternal
     """
-    ListResponseCustomerExternal
-    """ # noqa: E501
-    data: List[CustomerExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseCustomerExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[PaymentLinkExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponsePaymentLinkExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseCustomerExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [CustomerExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponsePaymentLinkExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [PaymentLinkExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_event_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_event_external.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt
+
 from getopenpay.models.event_external import EventExternal
+from pydantic import BaseModel, StrictInt
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class ListResponseEventExternal(BaseModel):
-    """
+  """
     ListResponseEventExternal
-    """ # noqa: E501
-    data: List[EventExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseEventExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  data: List[EventExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseEventExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseEventExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [EventExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseEventExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [EventExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_invoice_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_subscription_external.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.subscription_external import SubscriptionExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.invoice_external import InvoiceExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponseInvoiceExternal(BaseModel):
+class ListResponseSubscriptionExternal(BaseModel):
+  """
+    ListResponseSubscriptionExternal
     """
-    ListResponseInvoiceExternal
-    """ # noqa: E501
-    data: List[InvoiceExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseInvoiceExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[SubscriptionExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseSubscriptionExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseInvoiceExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [InvoiceExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseSubscriptionExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [SubscriptionExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_invoice_item_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_charge_external.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.charge_external import ChargeExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.invoice_item_external import InvoiceItemExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponseInvoiceItemExternal(BaseModel):
+class ListResponseChargeExternal(BaseModel):
+  """
+    ListResponseChargeExternal
     """
-    ListResponseInvoiceItemExternal
-    """ # noqa: E501
-    data: List[InvoiceItemExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseInvoiceItemExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[ChargeExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseChargeExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseInvoiceItemExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [InvoiceItemExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseChargeExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [ChargeExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_payment_intent_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_payment_intent_external.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt
+
 from getopenpay.models.payment_intent_external import PaymentIntentExternal
+from pydantic import BaseModel, StrictInt
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class ListResponsePaymentIntentExternal(BaseModel):
-    """
+  """
     ListResponsePaymentIntentExternal
-    """ # noqa: E501
-    data: List[PaymentIntentExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponsePaymentIntentExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  data: List[PaymentIntentExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponsePaymentIntentExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponsePaymentIntentExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [PaymentIntentExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponsePaymentIntentExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [PaymentIntentExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_payment_link_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_subscription_item_external.py`

 * *Files 19% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.subscription_item_external import SubscriptionItemExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.payment_link_external import PaymentLinkExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponsePaymentLinkExternal(BaseModel):
+class ListResponseSubscriptionItemExternal(BaseModel):
+  """
+    ListResponseSubscriptionItemExternal
     """
-    ListResponsePaymentLinkExternal
-    """ # noqa: E501
-    data: List[PaymentLinkExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponsePaymentLinkExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[SubscriptionItemExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseSubscriptionItemExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponsePaymentLinkExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [PaymentLinkExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseSubscriptionItemExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [SubscriptionItemExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_payment_method_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_price_external.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.price_external import PriceExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.payment_method_external import PaymentMethodExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponsePaymentMethodExternal(BaseModel):
+class ListResponsePriceExternal(BaseModel):
+  """
+    ListResponsePriceExternal
     """
-    ListResponsePaymentMethodExternal
-    """ # noqa: E501
-    data: List[PaymentMethodExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponsePaymentMethodExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[PriceExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponsePriceExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponsePaymentMethodExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [PaymentMethodExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponsePriceExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [PriceExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_price_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_invoice_external.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.invoice_external import InvoiceExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.price_external import PriceExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponsePriceExternal(BaseModel):
+class ListResponseInvoiceExternal(BaseModel):
+  """
+    ListResponseInvoiceExternal
     """
-    ListResponsePriceExternal
-    """ # noqa: E501
-    data: List[PriceExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponsePriceExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[InvoiceExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseInvoiceExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponsePriceExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [PriceExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseInvoiceExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [InvoiceExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_product_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_product_external.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt
+
 from getopenpay.models.product_external import ProductExternal
+from pydantic import BaseModel, StrictInt
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class ListResponseProductExternal(BaseModel):
-    """
+  """
     ListResponseProductExternal
-    """ # noqa: E501
-    data: List[ProductExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseProductExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  data: List[ProductExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseProductExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseProductExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [ProductExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseProductExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [ProductExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_product_family_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_customer_external.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.customer_external import CustomerExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.product_family_external import ProductFamilyExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponseProductFamilyExternal(BaseModel):
+class ListResponseCustomerExternal(BaseModel):
+  """
+    ListResponseCustomerExternal
     """
-    ListResponseProductFamilyExternal
-    """ # noqa: E501
-    data: List[ProductFamilyExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseProductFamilyExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[CustomerExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseCustomerExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseProductFamilyExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [ProductFamilyExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseCustomerExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [CustomerExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_promotion_code_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_coupon_external.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
+
+from getopenpay.models.coupon_external import CouponExternal
 from pydantic import BaseModel, StrictInt
-from getopenpay.models.promotion_code_external import PromotionCodeExternal
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponsePromotionCodeExternal(BaseModel):
+class ListResponseCouponExternal(BaseModel):
+  """
+    ListResponseCouponExternal
     """
-    ListResponsePromotionCodeExternal
-    """ # noqa: E501
-    data: List[PromotionCodeExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponsePromotionCodeExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[CouponExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseCouponExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponsePromotionCodeExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [PromotionCodeExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseCouponExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [CouponExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_refund_external.py` & `getopenpay-0.0.2/getopenpay/models/list_response_refund_external.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt
+
 from getopenpay.models.refund_external import RefundExternal
+from pydantic import BaseModel, StrictInt
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class ListResponseRefundExternal(BaseModel):
-    """
+  """
     ListResponseRefundExternal
-    """ # noqa: E501
-    data: List[RefundExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseRefundExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  data: List[RefundExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponseRefundExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseRefundExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [RefundExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponseRefundExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [RefundExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_subscription_external.py` & `getopenpay-0.0.2/getopenpay/models/update_subscription_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,95 +7,101 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt
+
+from getopenpay.models.invoice_external import InvoiceExternal
 from getopenpay.models.subscription_external import SubscriptionExternal
+from pydantic import BaseModel
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponseSubscriptionExternal(BaseModel):
+class UpdateSubscriptionResponse(BaseModel):
+  """
+    UpdateSubscriptionResponse
     """
-    ListResponseSubscriptionExternal
-    """ # noqa: E501
-    data: List[SubscriptionExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseSubscriptionExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  subscriptions: List[SubscriptionExternal]
+  invoices: List[InvoiceExternal]
+  __properties: ClassVar[List[str]] = ['subscriptions', 'invoices']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdateSubscriptionResponse from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseSubscriptionExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [SubscriptionExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in subscriptions (list)
+    _items = []
+    if self.subscriptions:
+      for _item in self.subscriptions:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['subscriptions'] = _items
+    # override the default output from pydantic by calling `to_dict()` of each item in invoices (list)
+    _items = []
+    if self.invoices:
+      for _item in self.invoices:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['invoices'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdateSubscriptionResponse from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'subscriptions':
+          [SubscriptionExternal.from_dict(_item) for _item in obj.get('subscriptions')]
+          if obj.get('subscriptions') is not None else None,
+        'invoices':
+          [InvoiceExternal.from_dict(_item) for _item in obj.get('invoices')]
+          if obj.get('invoices') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/list_response_subscription_item_external.py` & `getopenpay-0.0.2/getopenpay/models/subscription_resume_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,95 +7,76 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.proration_enum import ProrationEnum
+from pydantic import BaseModel
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt
-from getopenpay.models.subscription_item_external import SubscriptionItemExternal
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ListResponseSubscriptionItemExternal(BaseModel):
+class SubscriptionResumeRequest(BaseModel):
+  """
+    SubscriptionResumeRequest
     """
-    ListResponseSubscriptionItemExternal
-    """ # noqa: E501
-    data: List[SubscriptionItemExternal]
-    total_objects: StrictInt
-    page_number: StrictInt
-    page_size: StrictInt
-    __properties: ClassVar[List[str]] = ["data", "total_objects", "page_number", "page_size"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ListResponseSubscriptionItemExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  proration_behavior: Optional[ProrationEnum] = None
+  __properties: ClassVar[List[str]] = ['proration_behavior']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SubscriptionResumeRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in data (list)
-        _items = []
-        if self.data:
-            for _item in self.data:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['data'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ListResponseSubscriptionItemExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "data": [SubscriptionItemExternal.from_dict(_item) for _item in obj.get("data")] if obj.get("data") is not None else None,
-            "total_objects": obj.get("total_objects"),
-            "page_number": obj.get("page_number"),
-            "page_size": obj.get("page_size")
-        })
-        return _obj
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SubscriptionResumeRequest from a dict"""
+    if obj is None:
+      return None
 
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
 
+    _obj = cls.model_validate({'proration_behavior': obj.get('proration_behavior')})
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/object_name.py` & `getopenpay-0.0.2/getopenpay/models/object_name.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,76 +7,72 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class ObjectName(str, Enum):
-    """
+  """
     ObjectName
     """
-
-    """
+  """
     allowed enum values
     """
-    ACCOUNT = 'account'
-    API_TOKEN = 'api_token'
-    CHARGE = 'charge'
-    CHECKOUT_SESSION = 'checkout_session'
-    CHECKOUT_SESSION_ITEM = 'checkout_session_item'
-    COUPON = 'coupon'
-    CREDIT_NOTE = 'credit_note'
-    CREDIT_NOTE_ITEM = 'credit_note_item'
-    CUSTOMER = 'customer'
-    CUSTOMER_BALANCE_TRANSACTION = 'customer_balance_transaction'
-    DELIVERY_ATTEMPT = 'delivery_attempt'
-    DISCOUNT = 'discount'
-    EVENT = 'event'
-    INVITE = 'invite'
-    INVOICE_ITEM_DISCOUNT = 'invoice_item_discount'
-    INVOICE = 'invoice'
-    INVOICE_DISCOUNT = 'invoice_discount'
-    INVOICE_ITEM = 'invoice_item'
-    PAYMENT_INTENT = 'payment_intent'
-    PAYMENT_LINK = 'payment_link'
-    PAYMENT_LINK_LINE_ITEM = 'payment_link_line_item'
-    PAYMENT_METHOD = 'payment_method'
-    PAYMENT_METHOD_MAPPING = 'payment_method_mapping'
-    PAYMENT_PROCESSOR = 'payment_processor'
-    PORTAL_SESSION = 'portal_session'
-    PRICE = 'price'
-    PRICE_TIER = 'price_tier'
-    PRODUCT = 'product'
-    PRODUCT_FAMILY = 'product_family'
-    PROMOTION_CODE = 'promotion_code'
-    REFUND = 'refund'
-    SUBSCRIPTION = 'subscription'
-    SUBSCRIPTION_ITEM = 'subscription_item'
-    TAX_INTEGRATION = 'tax_integration'
-    USER = 'user'
-    USER_LOGIN = 'user_login'
-    USER_RECORD = 'user_record'
-    USER_RECORD_SUMMARY = 'user_record_summary'
-    TRANSITION_ELIGIBILITY = 'transition_eligibility'
-    WEBHOOK_ENDPOINT = 'webhook_endpoint'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ObjectName from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  ACCOUNT = 'account'
+  API_TOKEN = 'api_token'
+  CHARGE = 'charge'
+  CHARTMOGUL_INTEGRATION = 'chartmogul_integration'
+  CHECKOUT_SESSION = 'checkout_session'
+  CHECKOUT_SESSION_ITEM = 'checkout_session_item'
+  COUPON = 'coupon'
+  CREDIT_NOTE = 'credit_note'
+  CREDIT_NOTE_ITEM = 'credit_note_item'
+  CUSTOMER = 'customer'
+  CUSTOMER_BALANCE_TRANSACTION = 'customer_balance_transaction'
+  DELIVERY_ATTEMPT = 'delivery_attempt'
+  DISCOUNT = 'discount'
+  EVENT = 'event'
+  INVITE = 'invite'
+  INVOICE_ITEM_DISCOUNT = 'invoice_item_discount'
+  INVOICE = 'invoice'
+  INVOICE_DISCOUNT = 'invoice_discount'
+  INVOICE_ITEM = 'invoice_item'
+  PAYMENT_INTENT = 'payment_intent'
+  PAYMENT_LINK = 'payment_link'
+  PAYMENT_LINK_LINE_ITEM = 'payment_link_line_item'
+  PAYMENT_METHOD = 'payment_method'
+  PAYMENT_METHOD_MAPPING = 'payment_method_mapping'
+  PAYMENT_PROCESSOR = 'payment_processor'
+  PORTAL_SESSION = 'portal_session'
+  PRICE = 'price'
+  PRICE_TIER = 'price_tier'
+  PRODUCT = 'product'
+  PRODUCT_FAMILY = 'product_family'
+  PROMOTION_CODE = 'promotion_code'
+  REFUND = 'refund'
+  SUBSCRIPTION = 'subscription'
+  SUBSCRIPTION_ITEM = 'subscription_item'
+  TAX_INTEGRATION = 'tax_integration'
+  USER = 'user'
+  USER_LOGIN = 'user_login'
+  USER_RECORD = 'user_record'
+  USER_RECORD_SUMMARY = 'user_record_summary'
+  TRANSITION_ELIGIBILITY = 'transition_eligibility'
+  WEBHOOK_ENDPOINT = 'webhook_endpoint'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ObjectName from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/pay_invoice_request.py` & `getopenpay-0.0.2/getopenpay/models/pay_invoice_request.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,89 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictBool, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class PayInvoiceRequest(BaseModel):
-    """
+  """
     PayInvoiceRequest
-    """ # noqa: E501
-    payment_method_id: Optional[StrictStr] = None
-    paid_out_of_band: Optional[StrictBool] = Field(default=False, description="Boolean representing whether an invoice is paid outside of OpenPay. This will result in no charge being made. Defaults to false.")
-    __properties: ClassVar[List[str]] = ["payment_method_id", "paid_out_of_band"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PayInvoiceRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  payment_method_id: Optional[StrictStr] = None
+  paid_out_of_band: Optional[StrictBool] = Field(
+    default=False,
+    description=
+    'Boolean representing whether an invoice is paid outside of OpenPay. This will result in no charge being made. Defaults to false.'
+  )
+  __properties: ClassVar[List[str]] = ['payment_method_id', 'paid_out_of_band']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PayInvoiceRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if payment_method_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.payment_method_id is None and "payment_method_id" in self.model_fields_set:
-            _dict['payment_method_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PayInvoiceRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "payment_method_id": obj.get("payment_method_id"),
-            "paid_out_of_band": obj.get("paid_out_of_band") if obj.get("paid_out_of_band") is not None else False
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if payment_method_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_method_id is None and 'payment_method_id' in self.model_fields_set:
+      _dict['payment_method_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PayInvoiceRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'payment_method_id': obj.get('payment_method_id'),
+        'paid_out_of_band':
+          obj.get('paid_out_of_band') if obj.get('paid_out_of_band') is not None else False
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/payment_intent_query_params.py` & `getopenpay-0.0.2/getopenpay/models/update_subscription_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,135 +7,145 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from datetime import datetime
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.inline_subscription_item_update import InlineSubscriptionItemUpdate
+from getopenpay.models.proration_enum import ProrationEnum
+from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
-from getopenpay.models.date_time_filter import DateTimeFilter
-from getopenpay.models.int_range_filter import IntRangeFilter
-from getopenpay.models.payment_intent_status import PaymentIntentStatus
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class PaymentIntentQueryParams(BaseModel):
+class UpdateSubscriptionRequest(BaseModel):
+  """
+    UpdateSubscriptionRequest
     """
-    PaymentIntentQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    customer_id: Optional[StrictStr] = None
-    status: Optional[PaymentIntentStatus] = None
-    invoice_id: Optional[StrictStr] = None
-    amount_atom: Optional[IntRangeFilter] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "customer_id", "status", "invoice_id", "amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PaymentIntentQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  payment_method_id: Optional[StrictStr] = None
+  cancel_at_end: Optional[StrictBool] = None
+  description: Optional[StrictStr] = None
+  proration_behavior: Optional[ProrationEnum] = None
+  trial_end: Optional[datetime] = None
+  trial_period_days: Optional[StrictInt] = None
+  coupon_id: Optional[StrictStr] = None
+  promotion_code_id: Optional[StrictStr] = None
+  items: Optional[List[InlineSubscriptionItemUpdate]] = None
+  __properties: ClassVar[List[str]] = [
+    'payment_method_id', 'cancel_at_end', 'description', 'proration_behavior', 'trial_end',
+    'trial_period_days', 'coupon_id', 'promotion_code_id', 'items'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdateSubscriptionRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of amount_atom
-        if self.amount_atom:
-            _dict['amount_atom'] = self.amount_atom.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if status (nullable) is None
-        # and model_fields_set contains the field
-        if self.status is None and "status" in self.model_fields_set:
-            _dict['status'] = None
-
-        # set to None if invoice_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_id is None and "invoice_id" in self.model_fields_set:
-            _dict['invoice_id'] = None
-
-        # set to None if amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.amount_atom is None and "amount_atom" in self.model_fields_set:
-            _dict['amount_atom'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PaymentIntentQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "customer_id": obj.get("customer_id"),
-            "status": obj.get("status"),
-            "invoice_id": obj.get("invoice_id"),
-            "amount_atom": IntRangeFilter.from_dict(obj.get("amount_atom")) if obj.get("amount_atom") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in items (list)
+    _items = []
+    if self.items:
+      for _item in self.items:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['items'] = _items
+    # set to None if payment_method_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_method_id is None and 'payment_method_id' in self.model_fields_set:
+      _dict['payment_method_id'] = None
+
+    # set to None if cancel_at_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.cancel_at_end is None and 'cancel_at_end' in self.model_fields_set:
+      _dict['cancel_at_end'] = None
+
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    # set to None if trial_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.trial_end is None and 'trial_end' in self.model_fields_set:
+      _dict['trial_end'] = None
+
+    # set to None if trial_period_days (nullable) is None
+    # and model_fields_set contains the field
+    if self.trial_period_days is None and 'trial_period_days' in self.model_fields_set:
+      _dict['trial_period_days'] = None
+
+    # set to None if coupon_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_id is None and 'coupon_id' in self.model_fields_set:
+      _dict['coupon_id'] = None
+
+    # set to None if promotion_code_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.promotion_code_id is None and 'promotion_code_id' in self.model_fields_set:
+      _dict['promotion_code_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdateSubscriptionRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'payment_method_id': obj.get('payment_method_id'),
+        'cancel_at_end': obj.get('cancel_at_end'),
+        'description': obj.get('description'),
+        'proration_behavior': obj.get('proration_behavior'),
+        'trial_end': obj.get('trial_end'),
+        'trial_period_days': obj.get('trial_period_days'),
+        'coupon_id': obj.get('coupon_id'),
+        'promotion_code_id': obj.get('promotion_code_id'),
+        'items':
+          [InlineSubscriptionItemUpdate.from_dict(_item) for _item in obj.get('items')]
+          if obj.get('items') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/payment_intent_status.py` & `getopenpay-0.0.2/getopenpay/models/payment_intent_status.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,44 +7,39 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class PaymentIntentStatus(str, Enum):
-    """
+  """
     PaymentIntentStatus
     """
-
-    """
+  """
     allowed enum values
     """
-    REQUIRES_CONFIRMATION = 'requires_confirmation'
-    REQUIRES_CAPTURE = 'requires_capture'
-    REQUIRES_ACTION = 'requires_action'
-    REQUIRES_PAYMENT_METHOD = 'requires_payment_method'
-    PROCESSING = 'processing'
-    CANCELED = 'canceled'
-    SUCCEEDED = 'succeeded'
-    EXCEPTION = 'exception'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PaymentIntentStatus from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  REQUIRES_CONFIRMATION = 'requires_confirmation'
+  REQUIRES_CAPTURE = 'requires_capture'
+  REQUIRES_ACTION = 'requires_action'
+  REQUIRES_PAYMENT_METHOD = 'requires_payment_method'
+  PROCESSING = 'processing'
+  CANCELED = 'canceled'
+  SUCCEEDED = 'succeeded'
+  EXCEPTION = 'exception'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PaymentIntentStatus from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/payment_link_external.py` & `getopenpay-0.0.2/getopenpay/models/webhook_endpoint_external.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,118 +7,119 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from getopenpay.models.checkout_mode import CheckoutMode
+
+from getopenpay.models.event_type import EventType
 from getopenpay.models.object_name import ObjectName
-from getopenpay.models.payment_link_line_item_external import PaymentLinkLineItemExternal
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class PaymentLinkExternal(BaseModel):
+class WebhookEndpointExternal(BaseModel):
+  """
+    WebhookEndpointExternal
     """
-    PaymentLinkExternal
-    """ # noqa: E501
-    id: StrictStr
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    account_id: StrictStr
-    account_name: StrictStr
-    active: StrictBool
-    currency: Optional[StrictStr] = None
-    line_items: Optional[List[PaymentLinkLineItemExternal]] = None
-    mode: CheckoutMode
-    secure_token: StrictStr
-    success_url: StrictStr
-    url: StrictStr
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "account_id", "account_name", "active", "currency", "line_items", "mode", "secure_token", "success_url", "url"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PaymentLinkExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  url: StrictStr
+  is_active: StrictBool
+  enabled_events: List[EventType]
+  description: Optional[StrictStr]
+  secret: Optional[StrictStr]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'url', 'is_active', 'enabled_events',
+    'description', 'secret'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of WebhookEndpointExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in line_items (list)
-        _items = []
-        if self.line_items:
-            for _item in self.line_items:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['line_items'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PaymentLinkExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "account_id": obj.get("account_id"),
-            "account_name": obj.get("account_name"),
-            "active": obj.get("active"),
-            "currency": obj.get("currency"),
-            "line_items": [PaymentLinkLineItemExternal.from_dict(_item) for _item in obj.get("line_items")] if obj.get("line_items") is not None else None,
-            "mode": obj.get("mode"),
-            "secure_token": obj.get("secure_token"),
-            "success_url": obj.get("success_url"),
-            "url": obj.get("url")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    # set to None if secret (nullable) is None
+    # and model_fields_set contains the field
+    if self.secret is None and 'secret' in self.model_fields_set:
+      _dict['secret'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of WebhookEndpointExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'url': obj.get('url'),
+        'is_active': obj.get('is_active'),
+        'enabled_events': obj.get('enabled_events'),
+        'description': obj.get('description'),
+        'secret': obj.get('secret')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/payment_link_line_item_external.py` & `getopenpay-0.0.2/getopenpay/models/refund_external.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,97 +7,112 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.object_name import ObjectName
+from getopenpay.models.refund_reason_enum import RefundReasonEnum
+from getopenpay.models.refund_status_enum import RefundStatusEnum
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class PaymentLinkLineItemExternal(BaseModel):
+class RefundExternal(BaseModel):
+  """
+    RefundExternal
     """
-    PaymentLinkLineItemExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the payment link line item.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    payment_link_id: StrictStr = Field(description="The ID of the payment link associated with this item")
-    price_id: StrictStr = Field(description="Unique identifier of the price.")
-    quantity: StrictInt = Field(description="Quantity of the item.")
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "payment_link_id", "price_id", "quantity"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PaymentLinkLineItemExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique Identifier of the refund.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  amount_atom: StrictInt = Field(description='amount_atom that you want to refund.')
+  charge_id: StrictStr = Field(description='Unique Identifier of the charge.')
+  invoice_id: StrictStr = Field(description='Invoice id to which the refund is attached.')
+  payment_intent_id: StrictStr = Field(description='Unique Identifier of the payment_intent.')
+  reason: RefundReasonEnum
+  status: RefundStatusEnum
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'amount_atom', 'charge_id',
+    'invoice_id', 'payment_intent_id', 'reason', 'status'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of RefundExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PaymentLinkLineItemExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "payment_link_id": obj.get("payment_link_id"),
-            "price_id": obj.get("price_id"),
-            "quantity": obj.get("quantity")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of RefundExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'amount_atom': obj.get('amount_atom'),
+        'charge_id': obj.get('charge_id'),
+        'invoice_id': obj.get('invoice_id'),
+        'payment_intent_id': obj.get('payment_intent_id'),
+        'reason': obj.get('reason'),
+        'status': obj.get('status')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/payment_link_query_params.py` & `getopenpay-0.0.2/getopenpay/models/event_search_params.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,102 +7,120 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
+from getopenpay.models.event_type import EventType
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class PaymentLinkQueryParams(BaseModel):
+class EventSearchParams(BaseModel):
+  """
+    EventSearchParams
     """
-    PaymentLinkQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PaymentLinkQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  object_id: StrictStr = Field(description='Unique ID of the object.')
+  types: Optional[List[EventType]] = None
+  limit: Optional[StrictInt] = Field(
+    default=50, description='Maximum number of documents to retrieve.'
+  )
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'object_id',
+    'types', 'limit'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of EventSearchParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PaymentLinkQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of EventSearchParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'object_id': obj.get('object_id'),
+        'types': obj.get('types'),
+        'limit': obj.get('limit') if obj.get('limit') is not None else 50
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/payment_method_external.py` & `getopenpay-0.0.2/getopenpay/models/payment_method_external.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,117 +7,126 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
+
 from getopenpay.models.complete_address import CompleteAddress
 from getopenpay.models.credit_card_type import CreditCardType
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class PaymentMethodExternal(BaseModel):
-    """
+  """
     PaymentMethodExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the payment_method.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    card_type: Optional[CreditCardType]
-    last_four: Optional[StrictStr]
-    billing_address: Optional[CompleteAddress]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "card_type", "last_four", "billing_address"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PaymentMethodExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique Identifier of the payment_method.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  card_type: Optional[CreditCardType]
+  last_four: Optional[StrictStr]
+  billing_address: Optional[CompleteAddress]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'card_type', 'last_four',
+    'billing_address'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PaymentMethodExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of billing_address
-        if self.billing_address:
-            _dict['billing_address'] = self.billing_address.to_dict()
-        # set to None if card_type (nullable) is None
-        # and model_fields_set contains the field
-        if self.card_type is None and "card_type" in self.model_fields_set:
-            _dict['card_type'] = None
-
-        # set to None if last_four (nullable) is None
-        # and model_fields_set contains the field
-        if self.last_four is None and "last_four" in self.model_fields_set:
-            _dict['last_four'] = None
-
-        # set to None if billing_address (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_address is None and "billing_address" in self.model_fields_set:
-            _dict['billing_address'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PaymentMethodExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "card_type": obj.get("card_type"),
-            "last_four": obj.get("last_four"),
-            "billing_address": CompleteAddress.from_dict(obj.get("billing_address")) if obj.get("billing_address") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of billing_address
+    if self.billing_address:
+      _dict['billing_address'] = self.billing_address.to_dict()
+    # set to None if card_type (nullable) is None
+    # and model_fields_set contains the field
+    if self.card_type is None and 'card_type' in self.model_fields_set:
+      _dict['card_type'] = None
+
+    # set to None if last_four (nullable) is None
+    # and model_fields_set contains the field
+    if self.last_four is None and 'last_four' in self.model_fields_set:
+      _dict['last_four'] = None
+
+    # set to None if billing_address (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_address is None and 'billing_address' in self.model_fields_set:
+      _dict['billing_address'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PaymentMethodExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'card_type': obj.get('card_type'),
+        'last_four': obj.get('last_four'),
+        'billing_address':
+          CompleteAddress.from_dict(obj.get('billing_address'))
+          if obj.get('billing_address') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/payment_processor_external.py` & `getopenpay-0.0.2/getopenpay/models/payment_processor_external.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,107 +7,118 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional, Union
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
+
 from getopenpay.models.object_name import ObjectName
 from getopenpay.models.payment_processor_name import PaymentProcessorName
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class PaymentProcessorExternal(BaseModel):
-    """
+  """
     PaymentProcessorExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the payment_processor.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    account_id: StrictStr = Field(description="Unique identifier of the account.")
-    processor_name: PaymentProcessorName
-    api_keys: Union[str, Any] = Field(description="These keys will allow to authenticate API requests to payment processor.")
-    description: Optional[StrictStr]
-    is_default: StrictBool = Field(description="Indicates whether this payment processor is default or not")
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "account_id", "processor_name", "api_keys", "description", "is_default"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PaymentProcessorExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier of the payment_processor.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  account_id: StrictStr = Field(description='Unique identifier of the account.')
+  processor_name: PaymentProcessorName
+  api_keys: Union[str, Any] = Field(
+    description='These keys will allow to authenticate API requests to payment processor.'
+  )
+  description: Optional[StrictStr]
+  is_default: StrictBool = Field(
+    description='Indicates whether this payment processor is default or not'
+  )
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'account_id', 'processor_name',
+    'api_keys', 'description', 'is_default'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PaymentProcessorExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PaymentProcessorExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "account_id": obj.get("account_id"),
-            "processor_name": obj.get("processor_name"),
-            "api_keys": obj.get("api_keys"),
-            "description": obj.get("description"),
-            "is_default": obj.get("is_default")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PaymentProcessorExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'account_id': obj.get('account_id'),
+        'processor_name': obj.get('processor_name'),
+        'api_keys': obj.get('api_keys'),
+        'description': obj.get('description'),
+        'is_default': obj.get('is_default')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/payment_processor_name.py` & `getopenpay-0.0.2/getopenpay/models/price_type_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,39 +7,33 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class PaymentProcessorName(str, Enum):
-    """
-    PaymentProcessors are api's that we support and can charge.   
-    """
-
+class PriceTypeEnum(str, Enum):
+  """
+    PriceTypeEnum
     """
+  """
     allowed enum values
     """
-    BRAINTREE = 'braintree'
-    STRIPE = 'stripe'
-    AUTHORIZE_NET = 'authorize_net'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PaymentProcessorName from a JSON string"""
-        return cls(json.loads(json_str))
-
+  ONE_TIME = 'one_time'
+  RECURRING = 'recurring'
 
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PriceTypeEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/portal_session_external.py` & `getopenpay-0.0.2/getopenpay/models/coupon_query_params.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,101 +7,117 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from getopenpay.models.object_name import ObjectName
+
+from getopenpay.models.date_time_filter import DateTimeFilter
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class PortalSessionExternal(BaseModel):
+class CouponQueryParams(BaseModel):
+  """
+    CouponQueryParams
     """
-    PortalSessionExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="The ID of the portal session.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    account_id: StrictStr = Field(description="Unique identifier for the account.")
-    customer_id: StrictStr = Field(description="The ID of an existing customer.")
-    return_url: StrictStr = Field(description="The default URL to redirect customers to when they click on the portal's link to return to your website.")
-    url: StrictStr = Field(description="The short-lived URL of the session that gives customers access to the customer portal.")
-    token: StrictStr = Field(description="The short-lived token of the session that gives customers access to the customer portal.")
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "account_id", "customer_id", "return_url", "url", "token"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PortalSessionExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  is_active: Optional[StrictBool] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'is_active'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CouponQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PortalSessionExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "account_id": obj.get("account_id"),
-            "customer_id": obj.get("customer_id"),
-            "return_url": obj.get("return_url"),
-            "url": obj.get("url"),
-            "token": obj.get("token")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if is_active (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_active is None and 'is_active' in self.model_fields_set:
+      _dict['is_active'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CouponQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'is_active': obj.get('is_active')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/price_external.py` & `getopenpay-0.0.2/getopenpay/models/price_external.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,200 +7,226 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional, Union
-from pydantic import BaseModel, StrictBool, StrictFloat, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.billing_scheme_enum import BillingSchemeEnum
 from getopenpay.models.calendar_interval_enum import CalendarIntervalEnum
 from getopenpay.models.invoice_settings import InvoiceSettings
 from getopenpay.models.object_name import ObjectName
 from getopenpay.models.price_tier_external import PriceTierExternal
 from getopenpay.models.price_type_enum import PriceTypeEnum
 from getopenpay.models.pricing_tiers_enum import PricingTiersEnum
 from getopenpay.models.recurring_details import RecurringDetails
+from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class PriceExternal(BaseModel):
-    """
+  """
     PriceExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the price.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    is_active: StrictBool = Field(description="Whether the price can be used for new purchases. Price can be activated later.")
-    product_id: StrictStr = Field(description="Unique identifier of the product.")
-    internal_description: Optional[StrictStr]
-    billing_scheme: BillingSchemeEnum
-    unit_amount_atom: Optional[StrictInt]
-    transform_quantity_divide_by: Union[StrictFloat, StrictInt] = Field(description="This transformation will be applied on quantity before mulitplying by 'unit_amount_atom'.")
-    price_tiers: List[PriceTierExternal]
-    price_type: PriceTypeEnum
-    recurring_details: Optional[RecurringDetails]
-    tiers_mode: Optional[PricingTiersEnum]
-    billing_interval: Optional[CalendarIntervalEnum]
-    billing_interval_count: Optional[StrictInt]
-    contract_term_multiple: Optional[StrictInt]
-    contract_auto_renew: Optional[StrictBool]
-    invoice_settings: Optional[InvoiceSettings]
-    is_licensed: StrictBool = Field(description="Whether the price is licensed or not.")
-    is_exclusive: Optional[StrictBool] = Field(default=False, description="Whether the price is exclusive or not.")
-    listed_exclusively_for_customers: List[StrictStr]
-    can_only_be_purchased_with: List[StrictStr]
-    optional_add_ons: List[StrictStr]
-    eligible_for_updates: StrictBool = Field(description="If the price can be updated or not.")
-    currency: StrictStr
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "is_active", "product_id", "internal_description", "billing_scheme", "unit_amount_atom", "transform_quantity_divide_by", "price_tiers", "price_type", "recurring_details", "tiers_mode", "billing_interval", "billing_interval_count", "contract_term_multiple", "contract_auto_renew", "invoice_settings", "is_licensed", "is_exclusive", "listed_exclusively_for_customers", "can_only_be_purchased_with", "optional_add_ons", "eligible_for_updates", "currency"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PriceExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier of the price.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  is_active: StrictBool = Field(
+    description='Whether the price can be used for new purchases. Price can be activated later.'
+  )
+  product_name: StrictStr = Field(description='Name of the product associated with this price.')
+  product_id: StrictStr = Field(description='Unique identifier of the product.')
+  internal_description: Optional[StrictStr]
+  billing_scheme: BillingSchemeEnum
+  unit_amount_atom: Optional[StrictInt]
+  transform_quantity_divide_by: Union[StrictFloat, StrictInt] = Field(
+    description=
+    "This transformation will be applied on quantity before mulitplying by 'unit_amount_atom'."
+  )
+  price_tiers: List[PriceTierExternal]
+  price_type: PriceTypeEnum
+  recurring_details: Optional[RecurringDetails]
+  tiers_mode: Optional[PricingTiersEnum]
+  billing_interval: Optional[CalendarIntervalEnum]
+  billing_interval_count: Optional[StrictInt]
+  contract_term_multiple: Optional[StrictInt]
+  contract_auto_renew: Optional[StrictBool]
+  invoice_settings: Optional[InvoiceSettings]
+  is_licensed: StrictBool = Field(description='Whether the price is licensed or not.')
+  is_exclusive: Optional[StrictBool] = Field(
+    default=False, description='Whether the price is exclusive or not.'
+  )
+  listed_exclusively_for_customers: List[StrictStr]
+  can_only_be_purchased_with: List[StrictStr]
+  optional_add_ons: List[StrictStr]
+  eligible_for_updates: StrictBool = Field(description='If the price can be updated or not.')
+  currency: StrictStr
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'is_active', 'product_name',
+    'product_id', 'internal_description', 'billing_scheme', 'unit_amount_atom',
+    'transform_quantity_divide_by', 'price_tiers', 'price_type', 'recurring_details', 'tiers_mode',
+    'billing_interval', 'billing_interval_count', 'contract_term_multiple', 'contract_auto_renew',
+    'invoice_settings', 'is_licensed', 'is_exclusive', 'listed_exclusively_for_customers',
+    'can_only_be_purchased_with', 'optional_add_ons', 'eligible_for_updates', 'currency'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PriceExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in price_tiers (list)
-        _items = []
-        if self.price_tiers:
-            for _item in self.price_tiers:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['price_tiers'] = _items
-        # override the default output from pydantic by calling `to_dict()` of recurring_details
-        if self.recurring_details:
-            _dict['recurring_details'] = self.recurring_details.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of invoice_settings
-        if self.invoice_settings:
-            _dict['invoice_settings'] = self.invoice_settings.to_dict()
-        # set to None if internal_description (nullable) is None
-        # and model_fields_set contains the field
-        if self.internal_description is None and "internal_description" in self.model_fields_set:
-            _dict['internal_description'] = None
-
-        # set to None if unit_amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.unit_amount_atom is None and "unit_amount_atom" in self.model_fields_set:
-            _dict['unit_amount_atom'] = None
-
-        # set to None if recurring_details (nullable) is None
-        # and model_fields_set contains the field
-        if self.recurring_details is None and "recurring_details" in self.model_fields_set:
-            _dict['recurring_details'] = None
-
-        # set to None if tiers_mode (nullable) is None
-        # and model_fields_set contains the field
-        if self.tiers_mode is None and "tiers_mode" in self.model_fields_set:
-            _dict['tiers_mode'] = None
-
-        # set to None if billing_interval (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_interval is None and "billing_interval" in self.model_fields_set:
-            _dict['billing_interval'] = None
-
-        # set to None if billing_interval_count (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_interval_count is None and "billing_interval_count" in self.model_fields_set:
-            _dict['billing_interval_count'] = None
-
-        # set to None if contract_term_multiple (nullable) is None
-        # and model_fields_set contains the field
-        if self.contract_term_multiple is None and "contract_term_multiple" in self.model_fields_set:
-            _dict['contract_term_multiple'] = None
-
-        # set to None if contract_auto_renew (nullable) is None
-        # and model_fields_set contains the field
-        if self.contract_auto_renew is None and "contract_auto_renew" in self.model_fields_set:
-            _dict['contract_auto_renew'] = None
-
-        # set to None if invoice_settings (nullable) is None
-        # and model_fields_set contains the field
-        if self.invoice_settings is None and "invoice_settings" in self.model_fields_set:
-            _dict['invoice_settings'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PriceExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "is_active": obj.get("is_active"),
-            "product_id": obj.get("product_id"),
-            "internal_description": obj.get("internal_description"),
-            "billing_scheme": obj.get("billing_scheme"),
-            "unit_amount_atom": obj.get("unit_amount_atom"),
-            "transform_quantity_divide_by": obj.get("transform_quantity_divide_by"),
-            "price_tiers": [PriceTierExternal.from_dict(_item) for _item in obj.get("price_tiers")] if obj.get("price_tiers") is not None else None,
-            "price_type": obj.get("price_type"),
-            "recurring_details": RecurringDetails.from_dict(obj.get("recurring_details")) if obj.get("recurring_details") is not None else None,
-            "tiers_mode": obj.get("tiers_mode"),
-            "billing_interval": obj.get("billing_interval"),
-            "billing_interval_count": obj.get("billing_interval_count"),
-            "contract_term_multiple": obj.get("contract_term_multiple"),
-            "contract_auto_renew": obj.get("contract_auto_renew"),
-            "invoice_settings": InvoiceSettings.from_dict(obj.get("invoice_settings")) if obj.get("invoice_settings") is not None else None,
-            "is_licensed": obj.get("is_licensed"),
-            "is_exclusive": obj.get("is_exclusive") if obj.get("is_exclusive") is not None else False,
-            "listed_exclusively_for_customers": obj.get("listed_exclusively_for_customers"),
-            "can_only_be_purchased_with": obj.get("can_only_be_purchased_with"),
-            "optional_add_ons": obj.get("optional_add_ons"),
-            "eligible_for_updates": obj.get("eligible_for_updates"),
-            "currency": obj.get("currency")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in price_tiers (list)
+    _items = []
+    if self.price_tiers:
+      for _item in self.price_tiers:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['price_tiers'] = _items
+    # override the default output from pydantic by calling `to_dict()` of recurring_details
+    if self.recurring_details:
+      _dict['recurring_details'] = self.recurring_details.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of invoice_settings
+    if self.invoice_settings:
+      _dict['invoice_settings'] = self.invoice_settings.to_dict()
+    # set to None if internal_description (nullable) is None
+    # and model_fields_set contains the field
+    if self.internal_description is None and 'internal_description' in self.model_fields_set:
+      _dict['internal_description'] = None
+
+    # set to None if unit_amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.unit_amount_atom is None and 'unit_amount_atom' in self.model_fields_set:
+      _dict['unit_amount_atom'] = None
+
+    # set to None if recurring_details (nullable) is None
+    # and model_fields_set contains the field
+    if self.recurring_details is None and 'recurring_details' in self.model_fields_set:
+      _dict['recurring_details'] = None
+
+    # set to None if tiers_mode (nullable) is None
+    # and model_fields_set contains the field
+    if self.tiers_mode is None and 'tiers_mode' in self.model_fields_set:
+      _dict['tiers_mode'] = None
+
+    # set to None if billing_interval (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_interval is None and 'billing_interval' in self.model_fields_set:
+      _dict['billing_interval'] = None
+
+    # set to None if billing_interval_count (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_interval_count is None and 'billing_interval_count' in self.model_fields_set:
+      _dict['billing_interval_count'] = None
+
+    # set to None if contract_term_multiple (nullable) is None
+    # and model_fields_set contains the field
+    if self.contract_term_multiple is None and 'contract_term_multiple' in self.model_fields_set:
+      _dict['contract_term_multiple'] = None
+
+    # set to None if contract_auto_renew (nullable) is None
+    # and model_fields_set contains the field
+    if self.contract_auto_renew is None and 'contract_auto_renew' in self.model_fields_set:
+      _dict['contract_auto_renew'] = None
+
+    # set to None if invoice_settings (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_settings is None and 'invoice_settings' in self.model_fields_set:
+      _dict['invoice_settings'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PriceExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'is_active': obj.get('is_active'),
+        'product_name': obj.get('product_name'),
+        'product_id': obj.get('product_id'),
+        'internal_description': obj.get('internal_description'),
+        'billing_scheme': obj.get('billing_scheme'),
+        'unit_amount_atom': obj.get('unit_amount_atom'),
+        'transform_quantity_divide_by': obj.get('transform_quantity_divide_by'),
+        'price_tiers':
+          [PriceTierExternal.from_dict(_item) for _item in obj.get('price_tiers')]
+          if obj.get('price_tiers') is not None else None,
+        'price_type': obj.get('price_type'),
+        'recurring_details':
+          RecurringDetails.from_dict(obj.get('recurring_details'))
+          if obj.get('recurring_details') is not None else None,
+        'tiers_mode': obj.get('tiers_mode'),
+        'billing_interval': obj.get('billing_interval'),
+        'billing_interval_count': obj.get('billing_interval_count'),
+        'contract_term_multiple': obj.get('contract_term_multiple'),
+        'contract_auto_renew': obj.get('contract_auto_renew'),
+        'invoice_settings':
+          InvoiceSettings.from_dict(obj.get('invoice_settings'))
+          if obj.get('invoice_settings') is not None else None,
+        'is_licensed': obj.get('is_licensed'),
+        'is_exclusive': obj.get('is_exclusive') if obj.get('is_exclusive') is not None else False,
+        'listed_exclusively_for_customers': obj.get('listed_exclusively_for_customers'),
+        'can_only_be_purchased_with': obj.get('can_only_be_purchased_with'),
+        'optional_add_ons': obj.get('optional_add_ons'),
+        'eligible_for_updates': obj.get('eligible_for_updates'),
+        'currency': obj.get('currency')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/price_query_params.py` & `getopenpay-0.0.2/getopenpay/models/product_query_params.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,126 +7,132 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
-from getopenpay.models.price_type_enum import PriceTypeEnum
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class PriceQueryParams(BaseModel):
+class ProductQueryParams(BaseModel):
+  """
+    ProductQueryParams
     """
-    PriceQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    product_id: Optional[StrictStr] = None
-    is_active: Optional[StrictBool] = None
-    currency: Optional[StrictStr] = None
-    price_type: Optional[PriceTypeEnum] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "product_id", "is_active", "currency", "price_type"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PriceQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  is_active: Optional[StrictBool] = None
+  created_by: Optional[StrictStr] = None
+  name_contains: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand', 'is_active',
+    'created_by', 'name_contains'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ProductQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if product_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.product_id is None and "product_id" in self.model_fields_set:
-            _dict['product_id'] = None
-
-        # set to None if is_active (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_active is None and "is_active" in self.model_fields_set:
-            _dict['is_active'] = None
-
-        # set to None if price_type (nullable) is None
-        # and model_fields_set contains the field
-        if self.price_type is None and "price_type" in self.model_fields_set:
-            _dict['price_type'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PriceQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "product_id": obj.get("product_id"),
-            "is_active": obj.get("is_active"),
-            "currency": obj.get("currency"),
-            "price_type": obj.get("price_type")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    # set to None if is_active (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_active is None and 'is_active' in self.model_fields_set:
+      _dict['is_active'] = None
+
+    # set to None if created_by (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_by is None and 'created_by' in self.model_fields_set:
+      _dict['created_by'] = None
+
+    # set to None if name_contains (nullable) is None
+    # and model_fields_set contains the field
+    if self.name_contains is None and 'name_contains' in self.model_fields_set:
+      _dict['name_contains'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ProductQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'is_active': obj.get('is_active'),
+        'created_by': obj.get('created_by'),
+        'name_contains': obj.get('name_contains')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/price_tier_external.py` & `getopenpay-0.0.2/getopenpay/models/price_tier_external.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,102 +7,109 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class PriceTierExternal(BaseModel):
-    """
+  """
     PriceTierExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier for the object.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    units_upto: Optional[StrictInt] = None
-    unit_amount_atom: StrictInt
-    flat_amount_atom: StrictInt
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "units_upto", "unit_amount_atom", "flat_amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PriceTierExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier for the object.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  units_upto: Optional[StrictInt] = None
+  unit_amount_atom: StrictInt
+  flat_amount_atom: StrictInt
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'units_upto', 'unit_amount_atom',
+    'flat_amount_atom'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PriceTierExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if units_upto (nullable) is None
-        # and model_fields_set contains the field
-        if self.units_upto is None and "units_upto" in self.model_fields_set:
-            _dict['units_upto'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PriceTierExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "units_upto": obj.get("units_upto"),
-            "unit_amount_atom": obj.get("unit_amount_atom"),
-            "flat_amount_atom": obj.get("flat_amount_atom")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if units_upto (nullable) is None
+    # and model_fields_set contains the field
+    if self.units_upto is None and 'units_upto' in self.model_fields_set:
+      _dict['units_upto'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PriceTierExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'units_upto': obj.get('units_upto'),
+        'unit_amount_atom': obj.get('unit_amount_atom'),
+        'flat_amount_atom': obj.get('flat_amount_atom')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/price_tier_params.py` & `getopenpay-0.0.2/getopenpay/models/price_tier_params.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,98 +7,99 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictInt
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class PriceTierParams(BaseModel):
-    """
+  """
     PriceTierParams
-    """ # noqa: E501
-    units_from: StrictInt = Field(description="The starting unit for the price tier.")
-    units_upto: Optional[StrictInt] = None
-    unit_amount_atom: StrictInt = Field(description="The price for the unit in the smallest denomination.It is in atomic units (in USD this is cents).")
-    flat_amount_atom: Optional[StrictInt] = None
-    __properties: ClassVar[List[str]] = ["units_from", "units_upto", "unit_amount_atom", "flat_amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PriceTierParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  units_from: StrictInt = Field(description='The starting unit for the price tier.')
+  units_upto: Optional[StrictInt] = None
+  unit_amount_atom: StrictInt = Field(
+    description=
+    'The price for the unit in the smallest denomination.It is in atomic units (in USD this is cents).'
+  )
+  flat_amount_atom: Optional[StrictInt] = None
+  __properties: ClassVar[List[str]
+                         ] = ['units_from', 'units_upto', 'unit_amount_atom', 'flat_amount_atom']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PriceTierParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if units_upto (nullable) is None
-        # and model_fields_set contains the field
-        if self.units_upto is None and "units_upto" in self.model_fields_set:
-            _dict['units_upto'] = None
-
-        # set to None if flat_amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.flat_amount_atom is None and "flat_amount_atom" in self.model_fields_set:
-            _dict['flat_amount_atom'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PriceTierParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "units_from": obj.get("units_from"),
-            "units_upto": obj.get("units_upto"),
-            "unit_amount_atom": obj.get("unit_amount_atom"),
-            "flat_amount_atom": obj.get("flat_amount_atom")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if units_upto (nullable) is None
+    # and model_fields_set contains the field
+    if self.units_upto is None and 'units_upto' in self.model_fields_set:
+      _dict['units_upto'] = None
+
+    # set to None if flat_amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.flat_amount_atom is None and 'flat_amount_atom' in self.model_fields_set:
+      _dict['flat_amount_atom'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PriceTierParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'units_from': obj.get('units_from'),
+        'units_upto': obj.get('units_upto'),
+        'unit_amount_atom': obj.get('unit_amount_atom'),
+        'flat_amount_atom': obj.get('flat_amount_atom')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/price_tier_public.py` & `getopenpay-0.0.2/getopenpay/models/price_tier_public.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,91 +7,88 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictInt
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class PriceTierPublic(BaseModel):
-    """
+  """
     PriceTierPublic
-    """ # noqa: E501
-    units_upto: Optional[StrictInt] = None
-    unit_amount_atom: StrictInt = Field(description="Price per unit in the currency atom.")
-    flat_amount_atom: StrictInt = Field(description="Flat price in the currency atom.")
-    __properties: ClassVar[List[str]] = ["units_upto", "unit_amount_atom", "flat_amount_atom"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PriceTierPublic from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  units_upto: Optional[StrictInt] = None
+  unit_amount_atom: StrictInt = Field(description='Price per unit in the currency atom.')
+  flat_amount_atom: StrictInt = Field(description='Flat price in the currency atom.')
+  __properties: ClassVar[List[str]] = ['units_upto', 'unit_amount_atom', 'flat_amount_atom']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PriceTierPublic from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if units_upto (nullable) is None
-        # and model_fields_set contains the field
-        if self.units_upto is None and "units_upto" in self.model_fields_set:
-            _dict['units_upto'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PriceTierPublic from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "units_upto": obj.get("units_upto"),
-            "unit_amount_atom": obj.get("unit_amount_atom"),
-            "flat_amount_atom": obj.get("flat_amount_atom")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if units_upto (nullable) is None
+    # and model_fields_set contains the field
+    if self.units_upto is None and 'units_upto' in self.model_fields_set:
+      _dict['units_upto'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PriceTierPublic from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'units_upto': obj.get('units_upto'),
+        'unit_amount_atom': obj.get('unit_amount_atom'),
+        'flat_amount_atom': obj.get('flat_amount_atom')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/price_type_enum.py` & `getopenpay-0.0.2/getopenpay/models/pricing_tiers_enum.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,38 +7,33 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class PriceTypeEnum(str, Enum):
-    """
-    PriceTypeEnum
-    """
-
+class PricingTiersEnum(str, Enum):
+  """
+    PricingTiersEnum
     """
+  """
     allowed enum values
     """
-    ONE_TIME = 'one_time'
-    RECURRING = 'recurring'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PriceTypeEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
+  GRADUATED = 'graduated'
+  VOLUME = 'volume'
 
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PricingTiersEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/pricing_model.py` & `getopenpay-0.0.2/getopenpay/models/proration_enum.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,40 +7,34 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class PricingModel(str, Enum):
-    """
-    PricingModel
-    """
-
+class ProrationEnum(str, Enum):
+  """
+    ProrationEnum
     """
+  """
     allowed enum values
     """
-    STANDARD = 'standard'
-    PACKAGE = 'package'
-    GRADUATED = 'graduated'
-    VOLUME = 'volume'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PricingModel from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  CREATE_PRORATIONS = 'create_prorations'
+  NONE = 'none'
+  ALWAYS_INVOICE = 'always_invoice'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ProrationEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/pricing_tiers_enum.py` & `getopenpay-0.0.2/getopenpay/models/usage_type_enum.py`

 * *Files 26% similar despite different names*

```diff
@@ -7,38 +7,33 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class PricingTiersEnum(str, Enum):
-    """
-    PricingTiersEnum
-    """
-
+class UsageTypeEnum(str, Enum):
+  """
+    UsageTypeEnum
     """
+  """
     allowed enum values
     """
-    GRADUATED = 'graduated'
-    VOLUME = 'volume'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PricingTiersEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
+  METERED = 'metered'
+  LICENSED = 'licensed'
 
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UsageTypeEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/product_external.py` & `getopenpay-0.0.2/getopenpay/models/product_external.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,135 +7,146 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.object_name import ObjectName
 from getopenpay.models.price_external import PriceExternal
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class ProductExternal(BaseModel):
-    """
+  """
     ProductExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the product.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    name: StrictStr = Field(description="Name of product.")
-    description: Optional[StrictStr]
-    features: List[StrictStr]
-    default_price: Optional[StrictInt]
-    is_active: StrictBool = Field(description="Whether the product is currently available for purchase.")
-    prices: List[PriceExternal]
-    account_sku: Optional[StrictStr]
-    unit_label: Optional[StrictStr]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "name", "description", "features", "default_price", "is_active", "prices", "account_sku", "unit_label"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ProductExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier of the product.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  name: StrictStr = Field(description='Name of product.')
+  description: Optional[StrictStr]
+  features: List[StrictStr]
+  default_price: Optional[StrictInt]
+  is_active: StrictBool = Field(
+    description='Whether the product is currently available for purchase.'
+  )
+  prices: List[PriceExternal]
+  account_sku: Optional[StrictStr]
+  unit_label: Optional[StrictStr]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'name', 'description', 'features',
+    'default_price', 'is_active', 'prices', 'account_sku', 'unit_label'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ProductExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in prices (list)
-        _items = []
-        if self.prices:
-            for _item in self.prices:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['prices'] = _items
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        # set to None if default_price (nullable) is None
-        # and model_fields_set contains the field
-        if self.default_price is None and "default_price" in self.model_fields_set:
-            _dict['default_price'] = None
-
-        # set to None if account_sku (nullable) is None
-        # and model_fields_set contains the field
-        if self.account_sku is None and "account_sku" in self.model_fields_set:
-            _dict['account_sku'] = None
-
-        # set to None if unit_label (nullable) is None
-        # and model_fields_set contains the field
-        if self.unit_label is None and "unit_label" in self.model_fields_set:
-            _dict['unit_label'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ProductExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "features": obj.get("features"),
-            "default_price": obj.get("default_price"),
-            "is_active": obj.get("is_active"),
-            "prices": [PriceExternal.from_dict(_item) for _item in obj.get("prices")] if obj.get("prices") is not None else None,
-            "account_sku": obj.get("account_sku"),
-            "unit_label": obj.get("unit_label")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in prices (list)
+    _items = []
+    if self.prices:
+      for _item in self.prices:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['prices'] = _items
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    # set to None if default_price (nullable) is None
+    # and model_fields_set contains the field
+    if self.default_price is None and 'default_price' in self.model_fields_set:
+      _dict['default_price'] = None
+
+    # set to None if account_sku (nullable) is None
+    # and model_fields_set contains the field
+    if self.account_sku is None and 'account_sku' in self.model_fields_set:
+      _dict['account_sku'] = None
+
+    # set to None if unit_label (nullable) is None
+    # and model_fields_set contains the field
+    if self.unit_label is None and 'unit_label' in self.model_fields_set:
+      _dict['unit_label'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ProductExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'name': obj.get('name'),
+        'description': obj.get('description'),
+        'features': obj.get('features'),
+        'default_price': obj.get('default_price'),
+        'is_active': obj.get('is_active'),
+        'prices':
+          [PriceExternal.from_dict(_item) for _item in obj.get('prices')]
+          if obj.get('prices') is not None else None,
+        'account_sku': obj.get('account_sku'),
+        'unit_label': obj.get('unit_label')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/product_family_external.py` & `getopenpay-0.0.2/getopenpay/models/webhook_endpoint_external_no_secret.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,104 +7,112 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
+
+from getopenpay.models.event_type import EventType
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ProductFamilyExternal(BaseModel):
+class WebhookEndpointExternalNoSecret(BaseModel):
+  """
+    WebhookEndpointExternalNoSecret
     """
-    ProductFamilyExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique identifier of the product family.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    name: StrictStr = Field(description="Name of the product family.")
-    description: Optional[StrictStr]
-    products: List[StrictStr]
-    hierarchy: Optional[StrictStr] = Field(default='{}', description="A JSON object representing the hierarchy within the family.")
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "name", "description", "products", "hierarchy"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ProductFamilyExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  url: StrictStr
+  is_active: StrictBool
+  enabled_events: List[EventType]
+  description: Optional[StrictStr]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'url', 'is_active', 'enabled_events',
+    'description'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of WebhookEndpointExternalNoSecret from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ProductFamilyExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "products": obj.get("products"),
-            "hierarchy": obj.get("hierarchy") if obj.get("hierarchy") is not None else '{}'
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of WebhookEndpointExternalNoSecret from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'url': obj.get('url'),
+        'is_active': obj.get('is_active'),
+        'enabled_events': obj.get('enabled_events'),
+        'description': obj.get('description')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/product_family_query_params.py` & `getopenpay-0.0.2/getopenpay/models/payment_link_query_params.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,109 +7,110 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
+
 from getopenpay.models.date_time_filter import DateTimeFilter
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ProductFamilyQueryParams(BaseModel):
+class PaymentLinkQueryParams(BaseModel):
+  """
+    PaymentLinkQueryParams
     """
-    ProductFamilyQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    is_deleted: Optional[StrictBool] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "is_deleted"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ProductFamilyQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PaymentLinkQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if is_deleted (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_deleted is None and "is_deleted" in self.model_fields_set:
-            _dict['is_deleted'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ProductFamilyQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "is_deleted": obj.get("is_deleted")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PaymentLinkQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/product_query_params.py` & `getopenpay-0.0.2/getopenpay/models/event_external.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,123 +7,128 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from datetime import datetime
+from typing import Any, ClassVar, Dict, List, Optional, Union
 
+from getopenpay.models.event_type import EventType
+from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
-from getopenpay.models.date_time_filter import DateTimeFilter
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
-class ProductQueryParams(BaseModel):
+
+class EventExternal(BaseModel):
+  """
+    EventExternal
     """
-    ProductQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    is_active: Optional[StrictBool] = None
-    created_by: Optional[StrictStr] = None
-    name_contains: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "is_active", "created_by", "name_contains"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ProductQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  account_id: StrictStr
+  type: EventType
+  data: Union[str, Any]
+  data_previous: Optional[Union[str, Any]]
+  request_id: Optional[StrictStr]
+  request_idempotency_key: Optional[StrictStr]
+  pending_webhooks: StrictInt
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'account_id', 'type', 'data',
+    'data_previous', 'request_id', 'request_idempotency_key', 'pending_webhooks'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of EventExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if is_active (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_active is None and "is_active" in self.model_fields_set:
-            _dict['is_active'] = None
-
-        # set to None if created_by (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_by is None and "created_by" in self.model_fields_set:
-            _dict['created_by'] = None
-
-        # set to None if name_contains (nullable) is None
-        # and model_fields_set contains the field
-        if self.name_contains is None and "name_contains" in self.model_fields_set:
-            _dict['name_contains'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ProductQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "is_active": obj.get("is_active"),
-            "created_by": obj.get("created_by"),
-            "name_contains": obj.get("name_contains")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if data_previous (nullable) is None
+    # and model_fields_set contains the field
+    if self.data_previous is None and 'data_previous' in self.model_fields_set:
+      _dict['data_previous'] = None
+
+    # set to None if request_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.request_id is None and 'request_id' in self.model_fields_set:
+      _dict['request_id'] = None
+
+    # set to None if request_idempotency_key (nullable) is None
+    # and model_fields_set contains the field
+    if self.request_idempotency_key is None and 'request_idempotency_key' in self.model_fields_set:
+      _dict['request_idempotency_key'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of EventExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'account_id': obj.get('account_id'),
+        'type': obj.get('type'),
+        'data': obj.get('data'),
+        'data_previous': obj.get('data_previous'),
+        'request_id': obj.get('request_id'),
+        'request_idempotency_key': obj.get('request_idempotency_key'),
+        'pending_webhooks': obj.get('pending_webhooks')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/promo_code_query_params.py` & `getopenpay-0.0.2/getopenpay/models/update_customer_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,130 +7,157 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
-from getopenpay.models.date_time_filter import DateTimeFilter
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class PromoCodeQueryParams(BaseModel):
+class UpdateCustomerRequest(BaseModel):
+  """
+    UpdateCustomerRequest
     """
-    PromoCodeQueryParams
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    sort_key: Optional[StrictStr] = Field(default='created_at', description="Key name based on which data is sorted.")
-    sort_descending: Optional[StrictBool] = Field(default=False, description="Sort direction.")
-    created_at: Optional[DateTimeFilter] = None
-    expand: Optional[List[StrictStr]] = None
-    coupon_id: Optional[StrictStr] = None
-    customer_id: Optional[StrictStr] = None
-    is_active: Optional[StrictBool] = None
-    code: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "sort_key", "sort_descending", "created_at", "expand", "coupon_id", "customer_id", "is_active", "code"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PromoCodeQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  first_name: Optional[StrictStr] = None
+  last_name: Optional[StrictStr] = None
+  line1: Optional[StrictStr] = None
+  line2: Optional[StrictStr] = None
+  line3: Optional[StrictStr] = None
+  city: Optional[StrictStr] = None
+  state: Optional[StrictStr] = None
+  country: Optional[StrictStr] = None
+  zip_code: Optional[StrictStr] = None
+  coupon_id: Optional[StrictStr] = None
+  promotion_code_id: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'first_name', 'last_name', 'line1', 'line2', 'line3', 'city', 'state', 'country', 'zip_code',
+    'coupon_id', 'promotion_code_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdateCustomerRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of created_at
-        if self.created_at:
-            _dict['created_at'] = self.created_at.to_dict()
-        # set to None if created_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.created_at is None and "created_at" in self.model_fields_set:
-            _dict['created_at'] = None
-
-        # set to None if coupon_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.coupon_id is None and "coupon_id" in self.model_fields_set:
-            _dict['coupon_id'] = None
-
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if is_active (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_active is None and "is_active" in self.model_fields_set:
-            _dict['is_active'] = None
-
-        # set to None if code (nullable) is None
-        # and model_fields_set contains the field
-        if self.code is None and "code" in self.model_fields_set:
-            _dict['code'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PromoCodeQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "sort_key": obj.get("sort_key") if obj.get("sort_key") is not None else 'created_at',
-            "sort_descending": obj.get("sort_descending") if obj.get("sort_descending") is not None else False,
-            "created_at": DateTimeFilter.from_dict(obj.get("created_at")) if obj.get("created_at") is not None else None,
-            "expand": obj.get("expand"),
-            "coupon_id": obj.get("coupon_id"),
-            "customer_id": obj.get("customer_id"),
-            "is_active": obj.get("is_active"),
-            "code": obj.get("code")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if first_name (nullable) is None
+    # and model_fields_set contains the field
+    if self.first_name is None and 'first_name' in self.model_fields_set:
+      _dict['first_name'] = None
+
+    # set to None if last_name (nullable) is None
+    # and model_fields_set contains the field
+    if self.last_name is None and 'last_name' in self.model_fields_set:
+      _dict['last_name'] = None
+
+    # set to None if line1 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line1 is None and 'line1' in self.model_fields_set:
+      _dict['line1'] = None
+
+    # set to None if line2 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line2 is None and 'line2' in self.model_fields_set:
+      _dict['line2'] = None
+
+    # set to None if line3 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line3 is None and 'line3' in self.model_fields_set:
+      _dict['line3'] = None
+
+    # set to None if city (nullable) is None
+    # and model_fields_set contains the field
+    if self.city is None and 'city' in self.model_fields_set:
+      _dict['city'] = None
+
+    # set to None if state (nullable) is None
+    # and model_fields_set contains the field
+    if self.state is None and 'state' in self.model_fields_set:
+      _dict['state'] = None
+
+    # set to None if country (nullable) is None
+    # and model_fields_set contains the field
+    if self.country is None and 'country' in self.model_fields_set:
+      _dict['country'] = None
+
+    # set to None if zip_code (nullable) is None
+    # and model_fields_set contains the field
+    if self.zip_code is None and 'zip_code' in self.model_fields_set:
+      _dict['zip_code'] = None
+
+    # set to None if coupon_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.coupon_id is None and 'coupon_id' in self.model_fields_set:
+      _dict['coupon_id'] = None
+
+    # set to None if promotion_code_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.promotion_code_id is None and 'promotion_code_id' in self.model_fields_set:
+      _dict['promotion_code_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdateCustomerRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'first_name': obj.get('first_name'),
+        'last_name': obj.get('last_name'),
+        'line1': obj.get('line1'),
+        'line2': obj.get('line2'),
+        'line3': obj.get('line3'),
+        'city': obj.get('city'),
+        'state': obj.get('state'),
+        'country': obj.get('country'),
+        'zip_code': obj.get('zip_code'),
+        'coupon_id': obj.get('coupon_id'),
+        'promotion_code_id': obj.get('promotion_code_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/promo_restrictions.py` & `getopenpay-0.0.2/getopenpay/models/promo_restrictions.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,95 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
+
 from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class PromoRestrictions(BaseModel):
-    """
+  """
     PromoRestrictions
-    """ # noqa: E501
-    first_time_transaction: Optional[StrictBool] = None
-    minimum_amount_atom: Optional[StrictInt] = None
-    minimum_amount_currency: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["first_time_transaction", "minimum_amount_atom", "minimum_amount_currency"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PromoRestrictions from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  first_time_transaction: Optional[StrictBool] = None
+  minimum_amount_atom: Optional[StrictInt] = None
+  minimum_amount_currency: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = [
+    'first_time_transaction', 'minimum_amount_atom', 'minimum_amount_currency'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PromoRestrictions from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if first_time_transaction (nullable) is None
-        # and model_fields_set contains the field
-        if self.first_time_transaction is None and "first_time_transaction" in self.model_fields_set:
-            _dict['first_time_transaction'] = None
-
-        # set to None if minimum_amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.minimum_amount_atom is None and "minimum_amount_atom" in self.model_fields_set:
-            _dict['minimum_amount_atom'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PromoRestrictions from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "first_time_transaction": obj.get("first_time_transaction"),
-            "minimum_amount_atom": obj.get("minimum_amount_atom"),
-            "minimum_amount_currency": obj.get("minimum_amount_currency")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if first_time_transaction (nullable) is None
+    # and model_fields_set contains the field
+    if self.first_time_transaction is None and 'first_time_transaction' in self.model_fields_set:
+      _dict['first_time_transaction'] = None
+
+    # set to None if minimum_amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.minimum_amount_atom is None and 'minimum_amount_atom' in self.model_fields_set:
+      _dict['minimum_amount_atom'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PromoRestrictions from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'first_time_transaction': obj.get('first_time_transaction'),
+        'minimum_amount_atom': obj.get('minimum_amount_atom'),
+        'minimum_amount_currency': obj.get('minimum_amount_currency')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/promotion_code_external.py` & `getopenpay-0.0.2/getopenpay/models/promotion_code_external.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,136 +7,145 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.object_name import ObjectName
 from getopenpay.models.promo_restrictions import PromoRestrictions
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class PromotionCodeExternal(BaseModel):
-    """
+  """
     PromotionCodeExternal
-    """ # noqa: E501
-    id: StrictStr
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    code: StrictStr
-    is_active: StrictBool
-    coupon_id: StrictStr
-    customer_id: Optional[StrictStr]
-    expires_at: Optional[datetime]
-    max_redemptions: Optional[StrictInt]
-    times_redeemed: Optional[StrictInt]
-    restrictions: Optional[PromoRestrictions]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "code", "is_active", "coupon_id", "customer_id", "expires_at", "max_redemptions", "times_redeemed", "restrictions"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of PromotionCodeExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  code: StrictStr
+  is_active: StrictBool
+  coupon_id: StrictStr
+  customer_id: Optional[StrictStr]
+  expires_at: Optional[datetime]
+  max_redemptions: Optional[StrictInt]
+  times_redeemed: Optional[StrictInt]
+  restrictions: Optional[PromoRestrictions]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'code', 'is_active', 'coupon_id',
+    'customer_id', 'expires_at', 'max_redemptions', 'times_redeemed', 'restrictions'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of PromotionCodeExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of restrictions
-        if self.restrictions:
-            _dict['restrictions'] = self.restrictions.to_dict()
-        # set to None if customer_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.customer_id is None and "customer_id" in self.model_fields_set:
-            _dict['customer_id'] = None
-
-        # set to None if expires_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.expires_at is None and "expires_at" in self.model_fields_set:
-            _dict['expires_at'] = None
-
-        # set to None if max_redemptions (nullable) is None
-        # and model_fields_set contains the field
-        if self.max_redemptions is None and "max_redemptions" in self.model_fields_set:
-            _dict['max_redemptions'] = None
-
-        # set to None if times_redeemed (nullable) is None
-        # and model_fields_set contains the field
-        if self.times_redeemed is None and "times_redeemed" in self.model_fields_set:
-            _dict['times_redeemed'] = None
-
-        # set to None if restrictions (nullable) is None
-        # and model_fields_set contains the field
-        if self.restrictions is None and "restrictions" in self.model_fields_set:
-            _dict['restrictions'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of PromotionCodeExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "code": obj.get("code"),
-            "is_active": obj.get("is_active"),
-            "coupon_id": obj.get("coupon_id"),
-            "customer_id": obj.get("customer_id"),
-            "expires_at": obj.get("expires_at"),
-            "max_redemptions": obj.get("max_redemptions"),
-            "times_redeemed": obj.get("times_redeemed"),
-            "restrictions": PromoRestrictions.from_dict(obj.get("restrictions")) if obj.get("restrictions") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of restrictions
+    if self.restrictions:
+      _dict['restrictions'] = self.restrictions.to_dict()
+    # set to None if customer_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.customer_id is None and 'customer_id' in self.model_fields_set:
+      _dict['customer_id'] = None
+
+    # set to None if expires_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.expires_at is None and 'expires_at' in self.model_fields_set:
+      _dict['expires_at'] = None
+
+    # set to None if max_redemptions (nullable) is None
+    # and model_fields_set contains the field
+    if self.max_redemptions is None and 'max_redemptions' in self.model_fields_set:
+      _dict['max_redemptions'] = None
+
+    # set to None if times_redeemed (nullable) is None
+    # and model_fields_set contains the field
+    if self.times_redeemed is None and 'times_redeemed' in self.model_fields_set:
+      _dict['times_redeemed'] = None
+
+    # set to None if restrictions (nullable) is None
+    # and model_fields_set contains the field
+    if self.restrictions is None and 'restrictions' in self.model_fields_set:
+      _dict['restrictions'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of PromotionCodeExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'code': obj.get('code'),
+        'is_active': obj.get('is_active'),
+        'coupon_id': obj.get('coupon_id'),
+        'customer_id': obj.get('customer_id'),
+        'expires_at': obj.get('expires_at'),
+        'max_redemptions': obj.get('max_redemptions'),
+        'times_redeemed': obj.get('times_redeemed'),
+        'restrictions':
+          PromoRestrictions.from_dict(obj.get('restrictions'))
+          if obj.get('restrictions') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/proration_enum.py` & `getopenpay-0.0.2/getopenpay/models/usage_agg_method_enum.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,39 +7,35 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class ProrationEnum(str, Enum):
-    """
-    ProrationEnum
-    """
-
+class UsageAggMethodEnum(str, Enum):
+  """
+    UsageAggMethodEnum
     """
+  """
     allowed enum values
     """
-    CREATE_PRORATIONS = 'create_prorations'
-    NONE = 'none'
-    ALWAYS_INVOICE = 'always_invoice'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ProrationEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  SUM = 'sum'
+  LAST_DURING_PERIOD = 'last_during_period'
+  LAST_EVER = 'last_ever'
+  MAX = 'max'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UsageAggMethodEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/recurring_details.py` & `getopenpay-0.0.2/getopenpay/models/recurring_details.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,92 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictInt
+
 from getopenpay.models.usage_agg_method_enum import UsageAggMethodEnum
 from getopenpay.models.usage_type_enum import UsageTypeEnum
+from pydantic import BaseModel, StrictInt
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class RecurringDetails(BaseModel):
-    """
+  """
     RecurringDetails
-    """ # noqa: E501
-    usage_type: UsageTypeEnum
-    aggregate_usage: Optional[UsageAggMethodEnum] = None
-    trial_period_days: Optional[StrictInt] = 0
-    __properties: ClassVar[List[str]] = ["usage_type", "aggregate_usage", "trial_period_days"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of RecurringDetails from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  usage_type: UsageTypeEnum
+  aggregate_usage: Optional[UsageAggMethodEnum] = None
+  trial_period_days: Optional[StrictInt] = 0
+  __properties: ClassVar[List[str]] = ['usage_type', 'aggregate_usage', 'trial_period_days']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of RecurringDetails from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if aggregate_usage (nullable) is None
-        # and model_fields_set contains the field
-        if self.aggregate_usage is None and "aggregate_usage" in self.model_fields_set:
-            _dict['aggregate_usage'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of RecurringDetails from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "usage_type": obj.get("usage_type"),
-            "aggregate_usage": obj.get("aggregate_usage"),
-            "trial_period_days": obj.get("trial_period_days") if obj.get("trial_period_days") is not None else 0
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if aggregate_usage (nullable) is None
+    # and model_fields_set contains the field
+    if self.aggregate_usage is None and 'aggregate_usage' in self.model_fields_set:
+      _dict['aggregate_usage'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of RecurringDetails from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'usage_type': obj.get('usage_type'),
+        'aggregate_usage': obj.get('aggregate_usage'),
+        'trial_period_days':
+          obj.get('trial_period_days') if obj.get('trial_period_days') is not None else 0
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/refund_external.py` & `getopenpay-0.0.2/getopenpay/models/customer_payment_method_query_params.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,105 +7,117 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
-from getopenpay.models.object_name import ObjectName
-from getopenpay.models.refund_reason_enum import RefundReasonEnum
-from getopenpay.models.refund_status_enum import RefundStatusEnum
+
+from getopenpay.models.date_time_filter import DateTimeFilter
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class RefundExternal(BaseModel):
+class CustomerPaymentMethodQueryParams(BaseModel):
+  """
+    CustomerPaymentMethodQueryParams
     """
-    RefundExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the refund.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    amount_atom: StrictInt = Field(description="amount_atom that you want to refund.")
-    charge_id: StrictStr = Field(description="Unique Identifier of the charge.")
-    invoice_id: StrictStr = Field(description="Invoice id to which the refund is attached.")
-    payment_intent_id: StrictStr = Field(description="Unique Identifier of the payment_intent.")
-    reason: RefundReasonEnum
-    status: RefundStatusEnum
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "amount_atom", "charge_id", "invoice_id", "payment_intent_id", "reason", "status"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of RefundExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  sort_key: Optional[StrictStr] = Field(
+    default='created_at', description='Key name based on which data is sorted.'
+  )
+  sort_descending: Optional[StrictBool] = Field(default=False, description='Sort direction.')
+  created_at: Optional[DateTimeFilter] = None
+  expand: Optional[List[StrictStr]] = None
+  provider_type: Optional[StrictStr] = Field(
+    default=None,
+    description=
+    'Not to be confused with PaymentProcessor, this type is used in PaymentMethod which are methods that are visible to customer (i.e. customer has an option to pay with these different providers).'
+  )
+  __properties: ClassVar[List[str]] = [
+    'page_number', 'page_size', 'sort_key', 'sort_descending', 'created_at', 'expand',
+    'provider_type'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CustomerPaymentMethodQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of RefundExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "amount_atom": obj.get("amount_atom"),
-            "charge_id": obj.get("charge_id"),
-            "invoice_id": obj.get("invoice_id"),
-            "payment_intent_id": obj.get("payment_intent_id"),
-            "reason": obj.get("reason"),
-            "status": obj.get("status")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of created_at
+    if self.created_at:
+      _dict['created_at'] = self.created_at.to_dict()
+    # set to None if created_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.created_at is None and 'created_at' in self.model_fields_set:
+      _dict['created_at'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CustomerPaymentMethodQueryParams from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'sort_key': obj.get('sort_key') if obj.get('sort_key') is not None else 'created_at',
+        'sort_descending':
+          obj.get('sort_descending') if obj.get('sort_descending') is not None else False,
+        'created_at':
+          DateTimeFilter.from_dict(obj.get('created_at'))
+          if obj.get('created_at') is not None else None,
+        'expand': obj.get('expand'),
+        'provider_type': obj.get('provider_type')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/refund_reason_enum.py` & `getopenpay-0.0.2/getopenpay/models/refund_reason_enum.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,41 +7,36 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class RefundReasonEnum(str, Enum):
-    """
+  """
     RefundReasonEnum
     """
-
-    """
+  """
     allowed enum values
     """
-    MANUAL = 'manual'
-    DUPLICATE = 'duplicate'
-    FRAUDULENT = 'fraudulent'
-    REQUESTED_BY_CUSTOMER = 'requested_by_customer'
-    EXPIRED_UNCAPTURED_CHARGE = 'expired_uncaptured_charge'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of RefundReasonEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  MANUAL = 'manual'
+  DUPLICATE = 'duplicate'
+  FRAUDULENT = 'fraudulent'
+  REQUESTED_BY_CUSTOMER = 'requested_by_customer'
+  EXPIRED_UNCAPTURED_CHARGE = 'expired_uncaptured_charge'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of RefundReasonEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/refund_status_enum.py` & `getopenpay-0.0.2/getopenpay/models/refund_status_enum.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,41 +7,36 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class RefundStatusEnum(str, Enum):
-    """
+  """
     RefundStatusEnum
     """
-
-    """
+  """
     allowed enum values
     """
-    SUCCEEDED = 'succeeded'
-    FAILED = 'failed'
-    PENDING = 'pending'
-    REQUIRES_ACTION = 'requires_action'
-    CANCELED = 'canceled'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of RefundStatusEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  SUCCEEDED = 'succeeded'
+  FAILED = 'failed'
+  PENDING = 'pending'
+  REQUIRES_ACTION = 'requires_action'
+  CANCELED = 'canceled'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of RefundStatusEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/search_charge_request.py` & `getopenpay-0.0.2/getopenpay/models/update_invoice_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -7,87 +7,102 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.discounts import Discounts
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
-from typing_extensions import Annotated
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class SearchChargeRequest(BaseModel):
+class UpdateInvoiceRequest(BaseModel):
+  """
+    UpdateInvoiceRequest
     """
-    SearchChargeRequest
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    query: StrictStr = Field(description="The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     ")
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "query"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SearchChargeRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  payment_method_id: Optional[StrictStr] = None
+  description: Optional[StrictStr] = Field(
+    default='Manual creation of invoice', description='Description for newly created invoice'
+  )
+  discounts: Optional[Discounts] = None
+  __properties: ClassVar[List[str]] = ['payment_method_id', 'description', 'discounts']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdateInvoiceRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SearchChargeRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "query": obj.get("query")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of discounts
+    if self.discounts:
+      _dict['discounts'] = self.discounts.to_dict()
+    # set to None if payment_method_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.payment_method_id is None and 'payment_method_id' in self.model_fields_set:
+      _dict['payment_method_id'] = None
+
+    # set to None if discounts (nullable) is None
+    # and model_fields_set contains the field
+    if self.discounts is None and 'discounts' in self.model_fields_set:
+      _dict['discounts'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdateInvoiceRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'payment_method_id': obj.get('payment_method_id'),
+        'description':
+          obj.get('description')
+          if obj.get('description') is not None else 'Manual creation of invoice',
+        'discounts':
+          Discounts.from_dict(obj.get('discounts')) if obj.get('discounts') is not None else None
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/search_customer_request.py` & `getopenpay-0.0.2/getopenpay/models/search_price_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,87 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
+
+from pydantic import BaseModel, Field, StrictStr
 from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class SearchCustomerRequest(BaseModel):
+class SearchPriceRequest(BaseModel):
+  """
+    SearchPriceRequest
     """
-    SearchCustomerRequest
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    query: StrictStr = Field(description="The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     ")
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "query"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SearchCustomerRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  query: StrictStr = Field(
+    description=
+    "The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     "
+  )
+  __properties: ClassVar[List[str]] = ['page_number', 'page_size', 'query']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SearchPriceRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SearchCustomerRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "query": obj.get("query")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SearchPriceRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'query': obj.get('query')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/search_invoice_request.py` & `getopenpay-0.0.2/getopenpay/models/search_invoice_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,87 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
+
+from pydantic import BaseModel, Field, StrictStr
 from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class SearchInvoiceRequest(BaseModel):
-    """
+  """
     SearchInvoiceRequest
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    query: StrictStr = Field(description="The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     ")
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "query"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SearchInvoiceRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  query: StrictStr = Field(
+    description=
+    "The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     "
+  )
+  __properties: ClassVar[List[str]] = ['page_number', 'page_size', 'query']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SearchInvoiceRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SearchInvoiceRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "query": obj.get("query")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SearchInvoiceRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'query': obj.get('query')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/search_payment_intent_request.py` & `getopenpay-0.0.2/getopenpay/models/search_charge_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,87 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
+
+from pydantic import BaseModel, Field, StrictStr
 from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class SearchPaymentIntentRequest(BaseModel):
+class SearchChargeRequest(BaseModel):
+  """
+    SearchChargeRequest
     """
-    SearchPaymentIntentRequest
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    query: StrictStr = Field(description="The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     ")
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "query"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SearchPaymentIntentRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  query: StrictStr = Field(
+    description=
+    "The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     "
+  )
+  __properties: ClassVar[List[str]] = ['page_number', 'page_size', 'query']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SearchChargeRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SearchPaymentIntentRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "query": obj.get("query")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SearchChargeRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'query': obj.get('query')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/search_price_request.py` & `getopenpay-0.0.2/getopenpay/models/search_product_request.py`

 * *Files 25% similar despite different names*

```diff
@@ -7,87 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
+
+from pydantic import BaseModel, Field, StrictStr
 from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class SearchPriceRequest(BaseModel):
+class SearchProductRequest(BaseModel):
+  """
+    SearchProductRequest
     """
-    SearchPriceRequest
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    query: StrictStr = Field(description="The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     ")
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "query"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SearchPriceRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  query: StrictStr = Field(
+    description=
+    "The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     "
+  )
+  __properties: ClassVar[List[str]] = ['page_number', 'page_size', 'query']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SearchProductRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SearchPriceRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "query": obj.get("query")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SearchProductRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'query': obj.get('query')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/search_subscription_request.py` & `getopenpay-0.0.2/getopenpay/models/search_customer_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,87 +7,91 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
+
+from pydantic import BaseModel, Field, StrictStr
 from typing_extensions import Annotated
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class SearchSubscriptionRequest(BaseModel):
+class SearchCustomerRequest(BaseModel):
+  """
+    SearchCustomerRequest
     """
-    SearchSubscriptionRequest
-    """ # noqa: E501
-    page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(default=1, description="Page number")
-    page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(default=100, description="Page size")
-    query: StrictStr = Field(description="The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     ")
-    __properties: ClassVar[List[str]] = ["page_number", "page_size", "query"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SearchSubscriptionRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  page_number: Optional[Annotated[int, Field(strict=True, ge=1)]] = Field(
+    default=1, description='Page number'
+  )
+  page_size: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = Field(
+    default=100, description='Page size'
+  )
+  query: StrictStr = Field(
+    description=
+    "The search query string in limited Lucene Query Syntax. Query is case insensitive.     Limitations:        1. You can combine multiple query clauses in a search by either separating them with a space, or using the AND or OR keywords (case insensitive). By default, the API combines clauses with AND logic. AND and OR operators are mutually exclusive.       2. Nesting of Queries by ( ) is not supported.     Example searches.       1. search by exact field. example: `name:'field_name'`       2. search by wildcard. example: `name:'*sub_string_1*'`, `name:'prefix_string*'`       3. range search using [], both bounds are included in result. example: `amount:[100 TO *]`, `amount:[10 TO 100]`.     "
+  )
+  __properties: ClassVar[List[str]] = ['page_number', 'page_size', 'query']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SearchCustomerRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SearchSubscriptionRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "page_number": obj.get("page_number") if obj.get("page_number") is not None else 1,
-            "page_size": obj.get("page_size") if obj.get("page_size") is not None else 100,
-            "query": obj.get("query")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SearchCustomerRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'page_number': obj.get('page_number') if obj.get('page_number') is not None else 1,
+        'page_size': obj.get('page_size') if obj.get('page_size') is not None else 100,
+        'query': obj.get('query')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/selected_price_quantity.py` & `getopenpay-0.0.2/getopenpay/models/selected_price_quantity.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,84 +7,76 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List
 
+from pydantic import BaseModel, Field, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class SelectedPriceQuantity(BaseModel):
-    """
+  """
     SelectedPriceQuantity
-    """ # noqa: E501
-    price_id: StrictStr = Field(description="Unique Identifier of the price.")
-    quantity: StrictInt = Field(description="Quantity of the product selected for the subscription.")
-    __properties: ClassVar[List[str]] = ["price_id", "quantity"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SelectedPriceQuantity from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  price_id: StrictStr = Field(description='Unique Identifier of the price.')
+  quantity: StrictInt = Field(description='Quantity of the product selected for the subscription.')
+  __properties: ClassVar[List[str]] = ['price_id', 'quantity']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SelectedPriceQuantity from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SelectedPriceQuantity from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "price_id": obj.get("price_id"),
-            "quantity": obj.get("quantity")
-        })
-        return _obj
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SelectedPriceQuantity from a dict"""
+    if obj is None:
+      return None
 
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
 
+    _obj = cls.model_validate({'price_id': obj.get('price_id'), 'quantity': obj.get('quantity')})
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/subscription_cancel_feedback_enum.py` & `getopenpay-0.0.2/getopenpay/models/subscription_cancel_feedback_enum.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,44 +7,39 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class SubscriptionCancelFeedbackEnum(str, Enum):
-    """
+  """
     SubscriptionCancelFeedbackEnum
     """
-
-    """
+  """
     allowed enum values
     """
-    TOO_EXPENSIVE = 'too_expensive'
-    MISSING_FEATURES = 'missing_features'
-    SWITCHED_SERVICE = 'switched_service'
-    UNUSED = 'unused'
-    CUSTOMER_SERVICE = 'customer_service'
-    TOO_COMPLEX = 'too_complex'
-    LOW_QUALITY = 'low_quality'
-    OTHER = 'other'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SubscriptionCancelFeedbackEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  TOO_EXPENSIVE = 'too_expensive'
+  MISSING_FEATURES = 'missing_features'
+  SWITCHED_SERVICE = 'switched_service'
+  UNUSED = 'unused'
+  CUSTOMER_SERVICE = 'customer_service'
+  TOO_COMPLEX = 'too_complex'
+  LOW_QUALITY = 'low_quality'
+  OTHER = 'other'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SubscriptionCancelFeedbackEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/subscription_cancellation_details.py` & `getopenpay-0.0.2/getopenpay/models/subscription_cancellation_details.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,101 +7,99 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictStr
+
 from getopenpay.models.subscription_cancel_feedback_enum import SubscriptionCancelFeedbackEnum
+from pydantic import BaseModel, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class SubscriptionCancellationDetails(BaseModel):
-    """
+  """
     SubscriptionCancellationDetails
-    """ # noqa: E501
-    comment: Optional[StrictStr] = None
-    feedback: Optional[SubscriptionCancelFeedbackEnum] = None
-    reason: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["comment", "feedback", "reason"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SubscriptionCancellationDetails from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  comment: Optional[StrictStr] = None
+  feedback: Optional[SubscriptionCancelFeedbackEnum] = None
+  reason: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = ['comment', 'feedback', 'reason']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SubscriptionCancellationDetails from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if comment (nullable) is None
-        # and model_fields_set contains the field
-        if self.comment is None and "comment" in self.model_fields_set:
-            _dict['comment'] = None
-
-        # set to None if feedback (nullable) is None
-        # and model_fields_set contains the field
-        if self.feedback is None and "feedback" in self.model_fields_set:
-            _dict['feedback'] = None
-
-        # set to None if reason (nullable) is None
-        # and model_fields_set contains the field
-        if self.reason is None and "reason" in self.model_fields_set:
-            _dict['reason'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SubscriptionCancellationDetails from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "comment": obj.get("comment"),
-            "feedback": obj.get("feedback"),
-            "reason": obj.get("reason")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if comment (nullable) is None
+    # and model_fields_set contains the field
+    if self.comment is None and 'comment' in self.model_fields_set:
+      _dict['comment'] = None
+
+    # set to None if feedback (nullable) is None
+    # and model_fields_set contains the field
+    if self.feedback is None and 'feedback' in self.model_fields_set:
+      _dict['feedback'] = None
+
+    # set to None if reason (nullable) is None
+    # and model_fields_set contains the field
+    if self.reason is None and 'reason' in self.model_fields_set:
+      _dict['reason'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SubscriptionCancellationDetails from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'comment': obj.get('comment'),
+        'feedback': obj.get('feedback'),
+        'reason': obj.get('reason')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/subscription_external.py` & `getopenpay-0.0.2/getopenpay/models/subscription_external.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,233 +7,268 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from pydantic import Field
+
 from getopenpay.models.calendar_interval_enum import CalendarIntervalEnum
 from getopenpay.models.discount_external import DiscountExternal
 from getopenpay.models.object_name import ObjectName
 from getopenpay.models.subscription_cancellation_details import SubscriptionCancellationDetails
 from getopenpay.models.subscription_item_external import SubscriptionItemExternal
+from getopenpay.models.subscription_status_enum import SubscriptionStatusEnum
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class SubscriptionExternal(BaseModel):
-    """
+  """
     SubscriptionExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the subscription.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    name: StrictStr = Field(description="Name for this subscription.")
-    account_id: StrictStr = Field(description="Unique Identifier of the account.")
-    customer_id: StrictStr = Field(description="Unique Identifier of the customer.")
-    description: Optional[StrictStr]
-    status: StrictStr = Field(description="Current status of the subscription.")
-    initial_start: datetime = Field(description="Very beginning of the subscription, in 'ISO 8601' format.")
-    current_period_start: datetime = Field(description="Starting of the current billing period, in 'ISO 8601' format.")
-    current_period_end: datetime = Field(description="End of the current billing period, in 'ISO 8601' format.")
-    default_payment_method_id: StrictStr = Field(description="Unique Identifier of the payment_method.")
-    cancel_at_end: StrictBool = Field(description="Whether this subscription should cancel at the end of contract or billing cycle.")
-    pause_at_end: Optional[StrictBool] = None
-    pause_for_cycles: Optional[StrictInt] = None
-    billing_interval: Optional[CalendarIntervalEnum] = None
-    billing_interval_count: Optional[StrictInt] = None
-    contract_start: Optional[datetime] = None
-    contract_auto_renew: Optional[StrictBool] = None
-    subscription_items: List[SubscriptionItemExternal]
-    cancellation_details: Optional[SubscriptionCancellationDetails] = None
-    trial_start: Optional[datetime] = None
-    trial_end: Optional[datetime] = None
-    discount: Optional[DiscountExternal] = None
-    total_billing_cycles: Optional[StrictInt] = None
-    remaining_billing_cycles: Optional[StrictInt] = None
-    paused_at: Optional[datetime] = None
-    resumes_at: Optional[datetime] = None
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "name", "account_id", "customer_id", "description", "status", "initial_start", "current_period_start", "current_period_end", "default_payment_method_id", "cancel_at_end", "pause_at_end", "pause_for_cycles", "billing_interval", "billing_interval_count", "contract_start", "contract_auto_renew", "subscription_items", "cancellation_details", "trial_start", "trial_end", "discount", "total_billing_cycles", "remaining_billing_cycles", "paused_at", "resumes_at"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SubscriptionExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique Identifier of the subscription.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  name: StrictStr = Field(description='Name for this subscription.')
+  account_id: StrictStr = Field(description='Unique Identifier of the account.')
+  customer_id: StrictStr = Field(description='Unique Identifier of the customer.')
+  description: Optional[StrictStr]
+  status: SubscriptionStatusEnum
+  initial_start: datetime = Field(
+    description="Very beginning of the subscription, in 'ISO 8601' format."
+  )
+  current_period_start: datetime = Field(
+    description="Starting of the current billing period, in 'ISO 8601' format."
+  )
+  current_period_end: datetime = Field(
+    description="End of the current billing period, in 'ISO 8601' format."
+  )
+  default_payment_method_id: StrictStr = Field(
+    description='Unique Identifier of the payment_method.'
+  )
+  cancel_at_end: StrictBool = Field(
+    description='Whether this subscription should cancel at the end of contract or billing cycle.'
+  )
+  pause_at_end: Optional[StrictBool] = None
+  pause_for_cycles: Optional[StrictInt] = None
+  billing_interval: Optional[CalendarIntervalEnum] = None
+  billing_interval_count: Optional[StrictInt] = None
+  contract_start: Optional[datetime] = None
+  contract_auto_renew: Optional[StrictBool] = None
+  subscription_items: List[SubscriptionItemExternal]
+  cancellation_details: Optional[SubscriptionCancellationDetails] = None
+  cancelled_at: Optional[datetime]
+  trial_start: Optional[datetime] = None
+  trial_end: Optional[datetime] = None
+  discount: Optional[DiscountExternal] = None
+  total_billing_cycles: Optional[StrictInt] = None
+  remaining_billing_cycles: Optional[StrictInt] = None
+  paused_at: Optional[datetime] = None
+  resumes_at: Optional[datetime] = None
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'name', 'account_id', 'customer_id',
+    'description', 'status', 'initial_start', 'current_period_start', 'current_period_end',
+    'default_payment_method_id', 'cancel_at_end', 'pause_at_end', 'pause_for_cycles',
+    'billing_interval', 'billing_interval_count', 'contract_start', 'contract_auto_renew',
+    'subscription_items', 'cancellation_details', 'cancelled_at', 'trial_start', 'trial_end',
+    'discount', 'total_billing_cycles', 'remaining_billing_cycles', 'paused_at', 'resumes_at'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SubscriptionExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in subscription_items (list)
-        _items = []
-        if self.subscription_items:
-            for _item in self.subscription_items:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['subscription_items'] = _items
-        # override the default output from pydantic by calling `to_dict()` of cancellation_details
-        if self.cancellation_details:
-            _dict['cancellation_details'] = self.cancellation_details.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of discount
-        if self.discount:
-            _dict['discount'] = self.discount.to_dict()
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        # set to None if pause_at_end (nullable) is None
-        # and model_fields_set contains the field
-        if self.pause_at_end is None and "pause_at_end" in self.model_fields_set:
-            _dict['pause_at_end'] = None
-
-        # set to None if pause_for_cycles (nullable) is None
-        # and model_fields_set contains the field
-        if self.pause_for_cycles is None and "pause_for_cycles" in self.model_fields_set:
-            _dict['pause_for_cycles'] = None
-
-        # set to None if billing_interval (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_interval is None and "billing_interval" in self.model_fields_set:
-            _dict['billing_interval'] = None
-
-        # set to None if billing_interval_count (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_interval_count is None and "billing_interval_count" in self.model_fields_set:
-            _dict['billing_interval_count'] = None
-
-        # set to None if contract_start (nullable) is None
-        # and model_fields_set contains the field
-        if self.contract_start is None and "contract_start" in self.model_fields_set:
-            _dict['contract_start'] = None
-
-        # set to None if contract_auto_renew (nullable) is None
-        # and model_fields_set contains the field
-        if self.contract_auto_renew is None and "contract_auto_renew" in self.model_fields_set:
-            _dict['contract_auto_renew'] = None
-
-        # set to None if cancellation_details (nullable) is None
-        # and model_fields_set contains the field
-        if self.cancellation_details is None and "cancellation_details" in self.model_fields_set:
-            _dict['cancellation_details'] = None
-
-        # set to None if trial_start (nullable) is None
-        # and model_fields_set contains the field
-        if self.trial_start is None and "trial_start" in self.model_fields_set:
-            _dict['trial_start'] = None
-
-        # set to None if trial_end (nullable) is None
-        # and model_fields_set contains the field
-        if self.trial_end is None and "trial_end" in self.model_fields_set:
-            _dict['trial_end'] = None
-
-        # set to None if discount (nullable) is None
-        # and model_fields_set contains the field
-        if self.discount is None and "discount" in self.model_fields_set:
-            _dict['discount'] = None
-
-        # set to None if total_billing_cycles (nullable) is None
-        # and model_fields_set contains the field
-        if self.total_billing_cycles is None and "total_billing_cycles" in self.model_fields_set:
-            _dict['total_billing_cycles'] = None
-
-        # set to None if remaining_billing_cycles (nullable) is None
-        # and model_fields_set contains the field
-        if self.remaining_billing_cycles is None and "remaining_billing_cycles" in self.model_fields_set:
-            _dict['remaining_billing_cycles'] = None
-
-        # set to None if paused_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.paused_at is None and "paused_at" in self.model_fields_set:
-            _dict['paused_at'] = None
-
-        # set to None if resumes_at (nullable) is None
-        # and model_fields_set contains the field
-        if self.resumes_at is None and "resumes_at" in self.model_fields_set:
-            _dict['resumes_at'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SubscriptionExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "name": obj.get("name"),
-            "account_id": obj.get("account_id"),
-            "customer_id": obj.get("customer_id"),
-            "description": obj.get("description"),
-            "status": obj.get("status"),
-            "initial_start": obj.get("initial_start"),
-            "current_period_start": obj.get("current_period_start"),
-            "current_period_end": obj.get("current_period_end"),
-            "default_payment_method_id": obj.get("default_payment_method_id"),
-            "cancel_at_end": obj.get("cancel_at_end"),
-            "pause_at_end": obj.get("pause_at_end"),
-            "pause_for_cycles": obj.get("pause_for_cycles"),
-            "billing_interval": obj.get("billing_interval"),
-            "billing_interval_count": obj.get("billing_interval_count"),
-            "contract_start": obj.get("contract_start"),
-            "contract_auto_renew": obj.get("contract_auto_renew"),
-            "subscription_items": [SubscriptionItemExternal.from_dict(_item) for _item in obj.get("subscription_items")] if obj.get("subscription_items") is not None else None,
-            "cancellation_details": SubscriptionCancellationDetails.from_dict(obj.get("cancellation_details")) if obj.get("cancellation_details") is not None else None,
-            "trial_start": obj.get("trial_start"),
-            "trial_end": obj.get("trial_end"),
-            "discount": DiscountExternal.from_dict(obj.get("discount")) if obj.get("discount") is not None else None,
-            "total_billing_cycles": obj.get("total_billing_cycles"),
-            "remaining_billing_cycles": obj.get("remaining_billing_cycles"),
-            "paused_at": obj.get("paused_at"),
-            "resumes_at": obj.get("resumes_at")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in subscription_items (list)
+    _items = []
+    if self.subscription_items:
+      for _item in self.subscription_items:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['subscription_items'] = _items
+    # override the default output from pydantic by calling `to_dict()` of cancellation_details
+    if self.cancellation_details:
+      _dict['cancellation_details'] = self.cancellation_details.to_dict()
+    # override the default output from pydantic by calling `to_dict()` of discount
+    if self.discount:
+      _dict['discount'] = self.discount.to_dict()
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    # set to None if pause_at_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.pause_at_end is None and 'pause_at_end' in self.model_fields_set:
+      _dict['pause_at_end'] = None
+
+    # set to None if pause_for_cycles (nullable) is None
+    # and model_fields_set contains the field
+    if self.pause_for_cycles is None and 'pause_for_cycles' in self.model_fields_set:
+      _dict['pause_for_cycles'] = None
+
+    # set to None if billing_interval (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_interval is None and 'billing_interval' in self.model_fields_set:
+      _dict['billing_interval'] = None
+
+    # set to None if billing_interval_count (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_interval_count is None and 'billing_interval_count' in self.model_fields_set:
+      _dict['billing_interval_count'] = None
+
+    # set to None if contract_start (nullable) is None
+    # and model_fields_set contains the field
+    if self.contract_start is None and 'contract_start' in self.model_fields_set:
+      _dict['contract_start'] = None
+
+    # set to None if contract_auto_renew (nullable) is None
+    # and model_fields_set contains the field
+    if self.contract_auto_renew is None and 'contract_auto_renew' in self.model_fields_set:
+      _dict['contract_auto_renew'] = None
+
+    # set to None if cancellation_details (nullable) is None
+    # and model_fields_set contains the field
+    if self.cancellation_details is None and 'cancellation_details' in self.model_fields_set:
+      _dict['cancellation_details'] = None
+
+    # set to None if cancelled_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.cancelled_at is None and 'cancelled_at' in self.model_fields_set:
+      _dict['cancelled_at'] = None
+
+    # set to None if trial_start (nullable) is None
+    # and model_fields_set contains the field
+    if self.trial_start is None and 'trial_start' in self.model_fields_set:
+      _dict['trial_start'] = None
+
+    # set to None if trial_end (nullable) is None
+    # and model_fields_set contains the field
+    if self.trial_end is None and 'trial_end' in self.model_fields_set:
+      _dict['trial_end'] = None
+
+    # set to None if discount (nullable) is None
+    # and model_fields_set contains the field
+    if self.discount is None and 'discount' in self.model_fields_set:
+      _dict['discount'] = None
+
+    # set to None if total_billing_cycles (nullable) is None
+    # and model_fields_set contains the field
+    if self.total_billing_cycles is None and 'total_billing_cycles' in self.model_fields_set:
+      _dict['total_billing_cycles'] = None
+
+    # set to None if remaining_billing_cycles (nullable) is None
+    # and model_fields_set contains the field
+    if self.remaining_billing_cycles is None and 'remaining_billing_cycles' in self.model_fields_set:
+      _dict['remaining_billing_cycles'] = None
+
+    # set to None if paused_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.paused_at is None and 'paused_at' in self.model_fields_set:
+      _dict['paused_at'] = None
+
+    # set to None if resumes_at (nullable) is None
+    # and model_fields_set contains the field
+    if self.resumes_at is None and 'resumes_at' in self.model_fields_set:
+      _dict['resumes_at'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SubscriptionExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'name': obj.get('name'),
+        'account_id': obj.get('account_id'),
+        'customer_id': obj.get('customer_id'),
+        'description': obj.get('description'),
+        'status': obj.get('status'),
+        'initial_start': obj.get('initial_start'),
+        'current_period_start': obj.get('current_period_start'),
+        'current_period_end': obj.get('current_period_end'),
+        'default_payment_method_id': obj.get('default_payment_method_id'),
+        'cancel_at_end': obj.get('cancel_at_end'),
+        'pause_at_end': obj.get('pause_at_end'),
+        'pause_for_cycles': obj.get('pause_for_cycles'),
+        'billing_interval': obj.get('billing_interval'),
+        'billing_interval_count': obj.get('billing_interval_count'),
+        'contract_start': obj.get('contract_start'),
+        'contract_auto_renew': obj.get('contract_auto_renew'),
+        'subscription_items':
+          [SubscriptionItemExternal.from_dict(_item) for _item in obj.get('subscription_items')]
+          if obj.get('subscription_items') is not None else None,
+        'cancellation_details':
+          SubscriptionCancellationDetails.from_dict(obj.get('cancellation_details'))
+          if obj.get('cancellation_details') is not None else None,
+        'cancelled_at': obj.get('cancelled_at'),
+        'trial_start': obj.get('trial_start'),
+        'trial_end': obj.get('trial_end'),
+        'discount':
+          DiscountExternal.from_dict(obj.get('discount'))
+          if obj.get('discount') is not None else None,
+        'total_billing_cycles': obj.get('total_billing_cycles'),
+        'remaining_billing_cycles': obj.get('remaining_billing_cycles'),
+        'paused_at': obj.get('paused_at'),
+        'resumes_at': obj.get('resumes_at')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/subscription_item_query_params.py` & `getopenpay-0.0.2/getopenpay/models/subscription_item_query_params.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,82 +7,77 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List
 
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictStr
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class SubscriptionItemQueryParams(BaseModel):
-    """
+  """
     SubscriptionItemQueryParams
-    """ # noqa: E501
-    subscription_id: StrictStr = Field(description="The ID of the subscription whose items will be retrieved.")
-    __properties: ClassVar[List[str]] = ["subscription_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SubscriptionItemQueryParams from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  subscription_id: StrictStr = Field(
+    description='The ID of the subscription whose items will be retrieved.'
+  )
+  __properties: ClassVar[List[str]] = ['subscription_id']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SubscriptionItemQueryParams from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SubscriptionItemQueryParams from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "subscription_id": obj.get("subscription_id")
-        })
-        return _obj
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of SubscriptionItemQueryParams from a dict"""
+    if obj is None:
+      return None
 
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
 
+    _obj = cls.model_validate({'subscription_id': obj.get('subscription_id')})
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/subscription_pause_request.py` & `getopenpay-0.0.2/getopenpay/models/validation_error.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,82 +7,93 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List
 
+from getopenpay.models.validation_error_loc_inner import ValidationErrorLocInner
+from pydantic import BaseModel, StrictStr
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictInt
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class SubscriptionPauseRequest(BaseModel):
+class ValidationError(BaseModel):
+  """
+    ValidationError
     """
-    SubscriptionPauseRequest
-    """ # noqa: E501
-    number_of_billing_cycles_to_skip: StrictInt = Field(description="Number of billing cycles this subscription will be paused.")
-    __properties: ClassVar[List[str]] = ["number_of_billing_cycles_to_skip"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SubscriptionPauseRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  loc: List[ValidationErrorLocInner]
+  msg: StrictStr
+  type: StrictStr
+  __properties: ClassVar[List[str]] = ['loc', 'msg', 'type']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ValidationError from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SubscriptionPauseRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "number_of_billing_cycles_to_skip": obj.get("number_of_billing_cycles_to_skip")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in loc (list)
+    _items = []
+    if self.loc:
+      for _item in self.loc:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['loc'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ValidationError from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'loc':
+          [ValidationErrorLocInner.from_dict(_item) for _item in obj.get('loc')]
+          if obj.get('loc') is not None else None,
+        'msg': obj.get('msg'),
+        'type': obj.get('type')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/subscription_resume_request.py` & `getopenpay-0.0.2/getopenpay/models/delete_price_response.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,82 +7,84 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from pydantic import BaseModel, Field, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel
-from getopenpay.models.proration_enum import ProrationEnum
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class SubscriptionResumeRequest(BaseModel):
+class DeletePriceResponse(BaseModel):
+  """
+    DeletePriceResponse
     """
-    SubscriptionResumeRequest
-    """ # noqa: E501
-    proration_behavior: Optional[ProrationEnum] = None
-    __properties: ClassVar[List[str]] = ["proration_behavior"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SubscriptionResumeRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  message: Optional[StrictStr] = Field(
+    default='Price deleted Successfully.', description='Message describing result of API call.'
+  )
+  price_id: StrictStr = Field(description='Unique identifier of the price.')
+  __properties: ClassVar[List[str]] = ['message', 'price_id']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of DeletePriceResponse from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of SubscriptionResumeRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "proration_behavior": obj.get("proration_behavior")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of DeletePriceResponse from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'message':
+          obj.get('message') if obj.get('message') is not None else 'Price deleted Successfully.',
+        'price_id': obj.get('price_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/subscription_status_enum.py` & `getopenpay-0.0.2/getopenpay/models/subscription_status_enum.py`

 * *Files 19% similar despite different names*

```diff
@@ -7,41 +7,36 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
 class SubscriptionStatusEnum(str, Enum):
-    """
+  """
     SubscriptionStatusEnum
     """
-
-    """
+  """
     allowed enum values
     """
-    TRIALING = 'trialing'
-    ACTIVE = 'active'
-    PAUSED = 'paused'
-    PAST_DUE = 'past_due'
-    CANCELED = 'canceled'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of SubscriptionStatusEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  TRIALING = 'trialing'
+  ACTIVE = 'active'
+  PAUSED = 'paused'
+  PAST_DUE = 'past_due'
+  CANCELED = 'canceled'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of SubscriptionStatusEnum from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/tokenized_credit_card_input.py` & `getopenpay-0.0.2/getopenpay/models/complete_address.py`

 * *Files 22% similar despite different names*

```diff
@@ -7,136 +7,127 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
+
 from pydantic import BaseModel, StrictStr
-from pydantic import Field
-from getopenpay.models.credit_card_type import CreditCardType
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class TokenizedCreditCardInput(BaseModel):
+class CompleteAddress(BaseModel):
+  """
+    CompleteAddress
     """
-    TokenizedCreditCardInput
-    """ # noqa: E501
-    cde_external_id: StrictStr = Field(description="Card token.")
-    last_four: StrictStr = Field(description="Last four digits of credit card")
-    zip_code: StrictStr = Field(description="ZIP or postal code.")
-    line1: Optional[StrictStr] = None
-    line2: Optional[StrictStr] = None
-    line3: Optional[StrictStr] = None
-    city: Optional[StrictStr] = None
-    state: Optional[StrictStr] = None
-    country: Optional[StrictStr] = None
-    card_type: Optional[CreditCardType] = None
-    __properties: ClassVar[List[str]] = ["cde_external_id", "last_four", "zip_code", "line1", "line2", "line3", "city", "state", "country", "card_type"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of TokenizedCreditCardInput from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  line1: Optional[StrictStr] = None
+  line2: Optional[StrictStr] = None
+  line3: Optional[StrictStr] = None
+  city: Optional[StrictStr] = None
+  state: Optional[StrictStr] = None
+  zip_code: Optional[StrictStr] = None
+  country: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]
+                         ] = ['line1', 'line2', 'line3', 'city', 'state', 'zip_code', 'country']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CompleteAddress from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if line1 (nullable) is None
-        # and model_fields_set contains the field
-        if self.line1 is None and "line1" in self.model_fields_set:
-            _dict['line1'] = None
-
-        # set to None if line2 (nullable) is None
-        # and model_fields_set contains the field
-        if self.line2 is None and "line2" in self.model_fields_set:
-            _dict['line2'] = None
-
-        # set to None if line3 (nullable) is None
-        # and model_fields_set contains the field
-        if self.line3 is None and "line3" in self.model_fields_set:
-            _dict['line3'] = None
-
-        # set to None if city (nullable) is None
-        # and model_fields_set contains the field
-        if self.city is None and "city" in self.model_fields_set:
-            _dict['city'] = None
-
-        # set to None if state (nullable) is None
-        # and model_fields_set contains the field
-        if self.state is None and "state" in self.model_fields_set:
-            _dict['state'] = None
-
-        # set to None if country (nullable) is None
-        # and model_fields_set contains the field
-        if self.country is None and "country" in self.model_fields_set:
-            _dict['country'] = None
-
-        # set to None if card_type (nullable) is None
-        # and model_fields_set contains the field
-        if self.card_type is None and "card_type" in self.model_fields_set:
-            _dict['card_type'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of TokenizedCreditCardInput from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "cde_external_id": obj.get("cde_external_id"),
-            "last_four": obj.get("last_four"),
-            "zip_code": obj.get("zip_code"),
-            "line1": obj.get("line1"),
-            "line2": obj.get("line2"),
-            "line3": obj.get("line3"),
-            "city": obj.get("city"),
-            "state": obj.get("state"),
-            "country": obj.get("country"),
-            "card_type": obj.get("card_type")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if line1 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line1 is None and 'line1' in self.model_fields_set:
+      _dict['line1'] = None
+
+    # set to None if line2 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line2 is None and 'line2' in self.model_fields_set:
+      _dict['line2'] = None
+
+    # set to None if line3 (nullable) is None
+    # and model_fields_set contains the field
+    if self.line3 is None and 'line3' in self.model_fields_set:
+      _dict['line3'] = None
+
+    # set to None if city (nullable) is None
+    # and model_fields_set contains the field
+    if self.city is None and 'city' in self.model_fields_set:
+      _dict['city'] = None
+
+    # set to None if state (nullable) is None
+    # and model_fields_set contains the field
+    if self.state is None and 'state' in self.model_fields_set:
+      _dict['state'] = None
+
+    # set to None if zip_code (nullable) is None
+    # and model_fields_set contains the field
+    if self.zip_code is None and 'zip_code' in self.model_fields_set:
+      _dict['zip_code'] = None
+
+    # set to None if country (nullable) is None
+    # and model_fields_set contains the field
+    if self.country is None and 'country' in self.model_fields_set:
+      _dict['country'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CompleteAddress from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'line1': obj.get('line1'),
+        'line2': obj.get('line2'),
+        'line3': obj.get('line3'),
+        'city': obj.get('city'),
+        'state': obj.get('state'),
+        'zip_code': obj.get('zip_code'),
+        'country': obj.get('country')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/transition_eligibility_external.py` & `getopenpay-0.0.2/getopenpay/models/transition_eligibility_external.py`

 * *Files 22% similar despite different names*

```diff
@@ -7,119 +7,126 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
+
 from getopenpay.models.object_name import ObjectName
+from pydantic import BaseModel, Field, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class TransitionEligibilityExternal(BaseModel):
-    """
+  """
     TransitionEligibilityExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the transition eligibility.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: StrictBool = Field(description="Flag to indicate whether the transition rule has been deleted or not")
-    current_price_id: Optional[StrictStr]
-    target_price_id: Optional[StrictStr]
-    current_product_id: Optional[StrictStr]
-    target_product_id: Optional[StrictStr]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "current_price_id", "target_price_id", "current_product_id", "target_product_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of TransitionEligibilityExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique Identifier of the transition eligibility.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: StrictBool = Field(
+    description='Flag to indicate whether the transition rule has been deleted or not'
+  )
+  current_price_id: Optional[StrictStr]
+  target_price_id: Optional[StrictStr]
+  current_product_id: Optional[StrictStr]
+  target_product_id: Optional[StrictStr]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'current_price_id', 'target_price_id',
+    'current_product_id', 'target_product_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of TransitionEligibilityExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if current_price_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.current_price_id is None and "current_price_id" in self.model_fields_set:
-            _dict['current_price_id'] = None
-
-        # set to None if target_price_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.target_price_id is None and "target_price_id" in self.model_fields_set:
-            _dict['target_price_id'] = None
-
-        # set to None if current_product_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.current_product_id is None and "current_product_id" in self.model_fields_set:
-            _dict['current_product_id'] = None
-
-        # set to None if target_product_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.target_product_id is None and "target_product_id" in self.model_fields_set:
-            _dict['target_product_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of TransitionEligibilityExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted"),
-            "current_price_id": obj.get("current_price_id"),
-            "target_price_id": obj.get("target_price_id"),
-            "current_product_id": obj.get("current_product_id"),
-            "target_product_id": obj.get("target_product_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if current_price_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.current_price_id is None and 'current_price_id' in self.model_fields_set:
+      _dict['current_price_id'] = None
+
+    # set to None if target_price_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.target_price_id is None and 'target_price_id' in self.model_fields_set:
+      _dict['target_price_id'] = None
+
+    # set to None if current_product_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.current_product_id is None and 'current_product_id' in self.model_fields_set:
+      _dict['current_product_id'] = None
+
+    # set to None if target_product_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.target_product_id is None and 'target_product_id' in self.model_fields_set:
+      _dict['target_product_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of TransitionEligibilityExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted'),
+        'current_price_id': obj.get('current_price_id'),
+        'target_price_id': obj.get('target_price_id'),
+        'current_product_id': obj.get('current_product_id'),
+        'target_product_id': obj.get('target_product_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/update_coupon_request.py` & `getopenpay-0.0.2/getopenpay/models/update_coupon_request.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,93 +7,84 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
+
 from pydantic import BaseModel, StrictBool, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class UpdateCouponRequest(BaseModel):
-    """
+  """
     Coupons are largely immutable by design, discounts refer back to their coupons whenever they are applied to invoice
     """ # noqa: E501
-    name: Optional[StrictStr] = None
-    is_active: Optional[StrictBool] = None
-    __properties: ClassVar[List[str]] = ["name", "is_active"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of UpdateCouponRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+  name: Optional[StrictStr] = None
+  is_active: Optional[StrictBool] = None
+  __properties: ClassVar[List[str]] = ['name', 'is_active']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdateCouponRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if name (nullable) is None
-        # and model_fields_set contains the field
-        if self.name is None and "name" in self.model_fields_set:
-            _dict['name'] = None
-
-        # set to None if is_active (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_active is None and "is_active" in self.model_fields_set:
-            _dict['is_active'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of UpdateCouponRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "name": obj.get("name"),
-            "is_active": obj.get("is_active")
-        })
-        return _obj
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if name (nullable) is None
+    # and model_fields_set contains the field
+    if self.name is None and 'name' in self.model_fields_set:
+      _dict['name'] = None
+
+    # set to None if is_active (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_active is None and 'is_active' in self.model_fields_set:
+      _dict['is_active'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdateCouponRequest from a dict"""
+    if obj is None:
+      return None
 
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
 
+    _obj = cls.model_validate({'name': obj.get('name'), 'is_active': obj.get('is_active')})
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/update_price_request.py` & `getopenpay-0.0.2/getopenpay/models/update_price_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,194 +7,199 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional, Union
-from pydantic import BaseModel, StrictBool, StrictFloat, StrictInt, StrictStr
+
 from getopenpay.models.calendar_interval_enum import CalendarIntervalEnum
 from getopenpay.models.price_tier_params import PriceTierParams
 from getopenpay.models.price_type_enum import PriceTypeEnum
 from getopenpay.models.pricing_model import PricingModel
 from getopenpay.models.usage_agg_method_enum import UsageAggMethodEnum
 from getopenpay.models.usage_type_enum import UsageTypeEnum
+from pydantic import BaseModel, StrictBool, StrictFloat, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class UpdatePriceRequest(BaseModel):
-    """
+  """
     UpdatePriceRequest
-    """ # noqa: E501
-    is_active: Optional[StrictBool] = None
-    internal_description: Optional[StrictStr] = None
-    pricing_model: Optional[PricingModel] = None
-    unit_amount_atom: Optional[StrictInt] = None
-    transform_quantity_divide_by: Optional[Union[StrictFloat, StrictInt]] = None
-    price_tiers: Optional[List[PriceTierParams]] = None
-    price_type: Optional[PriceTypeEnum] = None
-    billing_interval: Optional[CalendarIntervalEnum] = None
-    billing_interval_count: Optional[StrictInt] = None
-    contract_term_multiple: Optional[StrictInt] = None
-    contract_auto_renew: Optional[StrictBool] = None
-    trial_period_days: Optional[StrictInt] = None
-    usage_type: Optional[UsageTypeEnum] = None
-    aggregate_usage: Optional[UsageAggMethodEnum] = None
-    default_net_d: Optional[StrictInt] = None
-    can_only_be_purchased_with: Optional[List[StrictStr]] = None
-    __properties: ClassVar[List[str]] = ["is_active", "internal_description", "pricing_model", "unit_amount_atom", "transform_quantity_divide_by", "price_tiers", "price_type", "billing_interval", "billing_interval_count", "contract_term_multiple", "contract_auto_renew", "trial_period_days", "usage_type", "aggregate_usage", "default_net_d", "can_only_be_purchased_with"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of UpdatePriceRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  is_active: Optional[StrictBool] = None
+  internal_description: Optional[StrictStr] = None
+  pricing_model: Optional[PricingModel] = None
+  unit_amount_atom: Optional[StrictInt] = None
+  transform_quantity_divide_by: Optional[Union[StrictFloat, StrictInt]] = None
+  price_tiers: Optional[List[PriceTierParams]] = None
+  price_type: Optional[PriceTypeEnum] = None
+  billing_interval: Optional[CalendarIntervalEnum] = None
+  billing_interval_count: Optional[StrictInt] = None
+  contract_term_multiple: Optional[StrictInt] = None
+  contract_auto_renew: Optional[StrictBool] = None
+  trial_period_days: Optional[StrictInt] = None
+  usage_type: Optional[UsageTypeEnum] = None
+  aggregate_usage: Optional[UsageAggMethodEnum] = None
+  default_net_d: Optional[StrictInt] = None
+  can_only_be_purchased_with: Optional[List[StrictStr]] = None
+  __properties: ClassVar[List[str]] = [
+    'is_active', 'internal_description', 'pricing_model', 'unit_amount_atom',
+    'transform_quantity_divide_by', 'price_tiers', 'price_type', 'billing_interval',
+    'billing_interval_count', 'contract_term_multiple', 'contract_auto_renew', 'trial_period_days',
+    'usage_type', 'aggregate_usage', 'default_net_d', 'can_only_be_purchased_with'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdatePriceRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in price_tiers (list)
-        _items = []
-        if self.price_tiers:
-            for _item in self.price_tiers:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['price_tiers'] = _items
-        # set to None if is_active (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_active is None and "is_active" in self.model_fields_set:
-            _dict['is_active'] = None
-
-        # set to None if internal_description (nullable) is None
-        # and model_fields_set contains the field
-        if self.internal_description is None and "internal_description" in self.model_fields_set:
-            _dict['internal_description'] = None
-
-        # set to None if pricing_model (nullable) is None
-        # and model_fields_set contains the field
-        if self.pricing_model is None and "pricing_model" in self.model_fields_set:
-            _dict['pricing_model'] = None
-
-        # set to None if unit_amount_atom (nullable) is None
-        # and model_fields_set contains the field
-        if self.unit_amount_atom is None and "unit_amount_atom" in self.model_fields_set:
-            _dict['unit_amount_atom'] = None
-
-        # set to None if transform_quantity_divide_by (nullable) is None
-        # and model_fields_set contains the field
-        if self.transform_quantity_divide_by is None and "transform_quantity_divide_by" in self.model_fields_set:
-            _dict['transform_quantity_divide_by'] = None
-
-        # set to None if price_type (nullable) is None
-        # and model_fields_set contains the field
-        if self.price_type is None and "price_type" in self.model_fields_set:
-            _dict['price_type'] = None
-
-        # set to None if billing_interval (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_interval is None and "billing_interval" in self.model_fields_set:
-            _dict['billing_interval'] = None
-
-        # set to None if billing_interval_count (nullable) is None
-        # and model_fields_set contains the field
-        if self.billing_interval_count is None and "billing_interval_count" in self.model_fields_set:
-            _dict['billing_interval_count'] = None
-
-        # set to None if contract_term_multiple (nullable) is None
-        # and model_fields_set contains the field
-        if self.contract_term_multiple is None and "contract_term_multiple" in self.model_fields_set:
-            _dict['contract_term_multiple'] = None
-
-        # set to None if contract_auto_renew (nullable) is None
-        # and model_fields_set contains the field
-        if self.contract_auto_renew is None and "contract_auto_renew" in self.model_fields_set:
-            _dict['contract_auto_renew'] = None
-
-        # set to None if trial_period_days (nullable) is None
-        # and model_fields_set contains the field
-        if self.trial_period_days is None and "trial_period_days" in self.model_fields_set:
-            _dict['trial_period_days'] = None
-
-        # set to None if usage_type (nullable) is None
-        # and model_fields_set contains the field
-        if self.usage_type is None and "usage_type" in self.model_fields_set:
-            _dict['usage_type'] = None
-
-        # set to None if aggregate_usage (nullable) is None
-        # and model_fields_set contains the field
-        if self.aggregate_usage is None and "aggregate_usage" in self.model_fields_set:
-            _dict['aggregate_usage'] = None
-
-        # set to None if default_net_d (nullable) is None
-        # and model_fields_set contains the field
-        if self.default_net_d is None and "default_net_d" in self.model_fields_set:
-            _dict['default_net_d'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of UpdatePriceRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "is_active": obj.get("is_active"),
-            "internal_description": obj.get("internal_description"),
-            "pricing_model": obj.get("pricing_model"),
-            "unit_amount_atom": obj.get("unit_amount_atom"),
-            "transform_quantity_divide_by": obj.get("transform_quantity_divide_by"),
-            "price_tiers": [PriceTierParams.from_dict(_item) for _item in obj.get("price_tiers")] if obj.get("price_tiers") is not None else None,
-            "price_type": obj.get("price_type"),
-            "billing_interval": obj.get("billing_interval"),
-            "billing_interval_count": obj.get("billing_interval_count"),
-            "contract_term_multiple": obj.get("contract_term_multiple"),
-            "contract_auto_renew": obj.get("contract_auto_renew"),
-            "trial_period_days": obj.get("trial_period_days"),
-            "usage_type": obj.get("usage_type"),
-            "aggregate_usage": obj.get("aggregate_usage"),
-            "default_net_d": obj.get("default_net_d"),
-            "can_only_be_purchased_with": obj.get("can_only_be_purchased_with")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in price_tiers (list)
+    _items = []
+    if self.price_tiers:
+      for _item in self.price_tiers:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['price_tiers'] = _items
+    # set to None if is_active (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_active is None and 'is_active' in self.model_fields_set:
+      _dict['is_active'] = None
+
+    # set to None if internal_description (nullable) is None
+    # and model_fields_set contains the field
+    if self.internal_description is None and 'internal_description' in self.model_fields_set:
+      _dict['internal_description'] = None
+
+    # set to None if pricing_model (nullable) is None
+    # and model_fields_set contains the field
+    if self.pricing_model is None and 'pricing_model' in self.model_fields_set:
+      _dict['pricing_model'] = None
+
+    # set to None if unit_amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.unit_amount_atom is None and 'unit_amount_atom' in self.model_fields_set:
+      _dict['unit_amount_atom'] = None
+
+    # set to None if transform_quantity_divide_by (nullable) is None
+    # and model_fields_set contains the field
+    if self.transform_quantity_divide_by is None and 'transform_quantity_divide_by' in self.model_fields_set:
+      _dict['transform_quantity_divide_by'] = None
+
+    # set to None if price_type (nullable) is None
+    # and model_fields_set contains the field
+    if self.price_type is None and 'price_type' in self.model_fields_set:
+      _dict['price_type'] = None
+
+    # set to None if billing_interval (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_interval is None and 'billing_interval' in self.model_fields_set:
+      _dict['billing_interval'] = None
+
+    # set to None if billing_interval_count (nullable) is None
+    # and model_fields_set contains the field
+    if self.billing_interval_count is None and 'billing_interval_count' in self.model_fields_set:
+      _dict['billing_interval_count'] = None
+
+    # set to None if contract_term_multiple (nullable) is None
+    # and model_fields_set contains the field
+    if self.contract_term_multiple is None and 'contract_term_multiple' in self.model_fields_set:
+      _dict['contract_term_multiple'] = None
+
+    # set to None if contract_auto_renew (nullable) is None
+    # and model_fields_set contains the field
+    if self.contract_auto_renew is None and 'contract_auto_renew' in self.model_fields_set:
+      _dict['contract_auto_renew'] = None
+
+    # set to None if trial_period_days (nullable) is None
+    # and model_fields_set contains the field
+    if self.trial_period_days is None and 'trial_period_days' in self.model_fields_set:
+      _dict['trial_period_days'] = None
+
+    # set to None if usage_type (nullable) is None
+    # and model_fields_set contains the field
+    if self.usage_type is None and 'usage_type' in self.model_fields_set:
+      _dict['usage_type'] = None
+
+    # set to None if aggregate_usage (nullable) is None
+    # and model_fields_set contains the field
+    if self.aggregate_usage is None and 'aggregate_usage' in self.model_fields_set:
+      _dict['aggregate_usage'] = None
+
+    # set to None if default_net_d (nullable) is None
+    # and model_fields_set contains the field
+    if self.default_net_d is None and 'default_net_d' in self.model_fields_set:
+      _dict['default_net_d'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdatePriceRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'is_active': obj.get('is_active'),
+        'internal_description': obj.get('internal_description'),
+        'pricing_model': obj.get('pricing_model'),
+        'unit_amount_atom': obj.get('unit_amount_atom'),
+        'transform_quantity_divide_by': obj.get('transform_quantity_divide_by'),
+        'price_tiers':
+          [PriceTierParams.from_dict(_item) for _item in obj.get('price_tiers')]
+          if obj.get('price_tiers') is not None else None,
+        'price_type': obj.get('price_type'),
+        'billing_interval': obj.get('billing_interval'),
+        'billing_interval_count': obj.get('billing_interval_count'),
+        'contract_term_multiple': obj.get('contract_term_multiple'),
+        'contract_auto_renew': obj.get('contract_auto_renew'),
+        'trial_period_days': obj.get('trial_period_days'),
+        'usage_type': obj.get('usage_type'),
+        'aggregate_usage': obj.get('aggregate_usage'),
+        'default_net_d': obj.get('default_net_d'),
+        'can_only_be_purchased_with': obj.get('can_only_be_purchased_with')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/update_product_family_request.py` & `getopenpay-0.0.2/getopenpay/models/update_product_family_request.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,102 +7,100 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
+
 from pydantic import BaseModel, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class UpdateProductFamilyRequest(BaseModel):
-    """
+  """
     UpdateProductFamilyRequest
-    """ # noqa: E501
-    name: Optional[StrictStr]
-    description: Optional[StrictStr] = None
-    products: List[StrictStr]
-    hierarchy: Optional[StrictStr] = None
-    __properties: ClassVar[List[str]] = ["name", "description", "products", "hierarchy"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of UpdateProductFamilyRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  name: Optional[StrictStr]
+  description: Optional[StrictStr] = None
+  products: List[StrictStr]
+  hierarchy: Optional[StrictStr] = None
+  __properties: ClassVar[List[str]] = ['name', 'description', 'products', 'hierarchy']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdateProductFamilyRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if name (nullable) is None
-        # and model_fields_set contains the field
-        if self.name is None and "name" in self.model_fields_set:
-            _dict['name'] = None
-
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        # set to None if hierarchy (nullable) is None
-        # and model_fields_set contains the field
-        if self.hierarchy is None and "hierarchy" in self.model_fields_set:
-            _dict['hierarchy'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of UpdateProductFamilyRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "products": obj.get("products"),
-            "hierarchy": obj.get("hierarchy")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if name (nullable) is None
+    # and model_fields_set contains the field
+    if self.name is None and 'name' in self.model_fields_set:
+      _dict['name'] = None
+
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    # set to None if hierarchy (nullable) is None
+    # and model_fields_set contains the field
+    if self.hierarchy is None and 'hierarchy' in self.model_fields_set:
+      _dict['hierarchy'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdateProductFamilyRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'name': obj.get('name'),
+        'description': obj.get('description'),
+        'products': obj.get('products'),
+        'hierarchy': obj.get('hierarchy')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/update_product_request.py` & `getopenpay-0.0.2/getopenpay/models/update_product_request.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,123 +7,123 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
-
 from typing import Any, ClassVar, Dict, List, Optional
+
 from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class UpdateProductRequest(BaseModel):
-    """
+  """
     UpdateProductRequest
-    """ # noqa: E501
-    name: Optional[StrictStr] = None
-    description: Optional[StrictStr] = None
-    account_sku: Optional[StrictStr] = None
-    features: Optional[List[StrictStr]] = None
-    unit_label: Optional[StrictStr] = None
-    is_active: Optional[StrictBool] = None
-    default_price_id: Optional[StrictInt] = None
-    __properties: ClassVar[List[str]] = ["name", "description", "account_sku", "features", "unit_label", "is_active", "default_price_id"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of UpdateProductRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  name: Optional[StrictStr] = None
+  description: Optional[StrictStr] = None
+  account_sku: Optional[StrictStr] = None
+  features: Optional[List[StrictStr]] = None
+  unit_label: Optional[StrictStr] = None
+  is_active: Optional[StrictBool] = None
+  default_price_id: Optional[StrictInt] = None
+  __properties: ClassVar[List[str]] = [
+    'name', 'description', 'account_sku', 'features', 'unit_label', 'is_active', 'default_price_id'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdateProductRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if name (nullable) is None
-        # and model_fields_set contains the field
-        if self.name is None and "name" in self.model_fields_set:
-            _dict['name'] = None
-
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        # set to None if account_sku (nullable) is None
-        # and model_fields_set contains the field
-        if self.account_sku is None and "account_sku" in self.model_fields_set:
-            _dict['account_sku'] = None
-
-        # set to None if unit_label (nullable) is None
-        # and model_fields_set contains the field
-        if self.unit_label is None and "unit_label" in self.model_fields_set:
-            _dict['unit_label'] = None
-
-        # set to None if is_active (nullable) is None
-        # and model_fields_set contains the field
-        if self.is_active is None and "is_active" in self.model_fields_set:
-            _dict['is_active'] = None
-
-        # set to None if default_price_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.default_price_id is None and "default_price_id" in self.model_fields_set:
-            _dict['default_price_id'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of UpdateProductRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "name": obj.get("name"),
-            "description": obj.get("description"),
-            "account_sku": obj.get("account_sku"),
-            "features": obj.get("features"),
-            "unit_label": obj.get("unit_label"),
-            "is_active": obj.get("is_active"),
-            "default_price_id": obj.get("default_price_id")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if name (nullable) is None
+    # and model_fields_set contains the field
+    if self.name is None and 'name' in self.model_fields_set:
+      _dict['name'] = None
+
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    # set to None if account_sku (nullable) is None
+    # and model_fields_set contains the field
+    if self.account_sku is None and 'account_sku' in self.model_fields_set:
+      _dict['account_sku'] = None
+
+    # set to None if unit_label (nullable) is None
+    # and model_fields_set contains the field
+    if self.unit_label is None and 'unit_label' in self.model_fields_set:
+      _dict['unit_label'] = None
+
+    # set to None if is_active (nullable) is None
+    # and model_fields_set contains the field
+    if self.is_active is None and 'is_active' in self.model_fields_set:
+      _dict['is_active'] = None
+
+    # set to None if default_price_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.default_price_id is None and 'default_price_id' in self.model_fields_set:
+      _dict['default_price_id'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdateProductRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'name': obj.get('name'),
+        'description': obj.get('description'),
+        'account_sku': obj.get('account_sku'),
+        'features': obj.get('features'),
+        'unit_label': obj.get('unit_label'),
+        'is_active': obj.get('is_active'),
+        'default_price_id': obj.get('default_price_id')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/update_promo_code_request.py` & `getopenpay-0.0.2/getopenpay/models/update_promo_code_request.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,82 +7,78 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List
 
+from pydantic import BaseModel, Field, StrictBool
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictBool
-from pydantic import Field
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
 class UpdatePromoCodeRequest(BaseModel):
-    """
+  """
     UpdatePromoCodeRequest
-    """ # noqa: E501
-    is_active: StrictBool = Field(description="Whether the promotion code is currently active. A promotion code can only be reactivated when the coupon is still valid and the promotion code is otherwise redeemable.")
-    __properties: ClassVar[List[str]] = ["is_active"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of UpdatePromoCodeRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
+    """
+
+  # noqa: E501
+  is_active: StrictBool = Field(
+    description=
+    'Whether the promotion code is currently active. A promotion code can only be reactivated when the coupon is still valid and the promotion code is otherwise redeemable.'
+  )
+  __properties: ClassVar[List[str]] = ['is_active']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of UpdatePromoCodeRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of UpdatePromoCodeRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "is_active": obj.get("is_active")
-        })
-        return _obj
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of UpdatePromoCodeRequest from a dict"""
+    if obj is None:
+      return None
 
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
 
+    _obj = cls.model_validate({'is_active': obj.get('is_active')})
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/update_subscription_item_request.py` & `getopenpay-0.0.2/getopenpay/models/create_credit_note_line.py`

 * *Files 22% similar despite different names*

```diff
@@ -7,103 +7,104 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.credit_note_line_type import CreditNoteLineType
+from pydantic import BaseModel, Field, StrictInt, StrictStr
 
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
-from getopenpay.models.proration_enum import ProrationEnum
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class UpdateSubscriptionItemRequest(BaseModel):
+class CreateCreditNoteLine(BaseModel):
+  """
+    CreateCreditNoteLine
     """
-    UpdateSubscriptionItemRequest
-    """ # noqa: E501
-    price_id: Optional[StrictStr] = None
-    quantity: Optional[StrictInt] = None
-    proration_behavior: Optional[ProrationEnum] = None
-    drop_at_end: Optional[StrictBool] = None
-    __properties: ClassVar[List[str]] = ["price_id", "quantity", "proration_behavior", "drop_at_end"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of UpdateSubscriptionItemRequest from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  amount_atom: StrictInt = Field(
+    description='The integer amount representing the gross amount being credited for this line item.'
+  )
+  currency: StrictStr
+  type: CreditNoteLineType
+  quantity: Optional[StrictInt] = 1
+  invoice_item_id: Optional[StrictStr] = None
+  unit_amount_atom: Optional[StrictInt] = None
+  __properties: ClassVar[List[str]] = [
+    'amount_atom', 'currency', 'type', 'quantity', 'invoice_item_id', 'unit_amount_atom'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CreateCreditNoteLine from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if price_id (nullable) is None
-        # and model_fields_set contains the field
-        if self.price_id is None and "price_id" in self.model_fields_set:
-            _dict['price_id'] = None
-
-        # set to None if quantity (nullable) is None
-        # and model_fields_set contains the field
-        if self.quantity is None and "quantity" in self.model_fields_set:
-            _dict['quantity'] = None
-
-        # set to None if drop_at_end (nullable) is None
-        # and model_fields_set contains the field
-        if self.drop_at_end is None and "drop_at_end" in self.model_fields_set:
-            _dict['drop_at_end'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of UpdateSubscriptionItemRequest from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "price_id": obj.get("price_id"),
-            "quantity": obj.get("quantity"),
-            "proration_behavior": obj.get("proration_behavior"),
-            "drop_at_end": obj.get("drop_at_end")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if invoice_item_id (nullable) is None
+    # and model_fields_set contains the field
+    if self.invoice_item_id is None and 'invoice_item_id' in self.model_fields_set:
+      _dict['invoice_item_id'] = None
+
+    # set to None if unit_amount_atom (nullable) is None
+    # and model_fields_set contains the field
+    if self.unit_amount_atom is None and 'unit_amount_atom' in self.model_fields_set:
+      _dict['unit_amount_atom'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of CreateCreditNoteLine from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'amount_atom': obj.get('amount_atom'),
+        'currency': obj.get('currency'),
+        'type': obj.get('type'),
+        'quantity': obj.get('quantity') if obj.get('quantity') is not None else 1,
+        'invoice_item_id': obj.get('invoice_item_id'),
+        'unit_amount_atom': obj.get('unit_amount_atom')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/update_subscription_response.py` & `getopenpay-0.0.2/getopenpay/models/delete_subscription_item_request.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,99 +7,85 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List, Optional
 
+from getopenpay.models.proration_enum import ProrationEnum
+from pydantic import BaseModel, Field, StrictBool
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel
-from getopenpay.models.invoice_external import InvoiceExternal
-from getopenpay.models.subscription_external import SubscriptionExternal
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
-class UpdateSubscriptionResponse(BaseModel):
+
+class DeleteSubscriptionItemRequest(BaseModel):
+  """
+    DeleteSubscriptionItemRequest
     """
-    UpdateSubscriptionResponse
-    """ # noqa: E501
-    subscriptions: List[SubscriptionExternal]
-    invoices: List[InvoiceExternal]
-    __properties: ClassVar[List[str]] = ["subscriptions", "invoices"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of UpdateSubscriptionResponse from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  drop_at_end: Optional[StrictBool] = Field(
+    default=True,
+    description='Whether or not this item will be dropped from subscription before next renewal'
+  )
+  proration_behavior: Optional[ProrationEnum] = None
+  __properties: ClassVar[List[str]] = ['drop_at_end', 'proration_behavior']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of DeleteSubscriptionItemRequest from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in subscriptions (list)
-        _items = []
-        if self.subscriptions:
-            for _item in self.subscriptions:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['subscriptions'] = _items
-        # override the default output from pydantic by calling `to_dict()` of each item in invoices (list)
-        _items = []
-        if self.invoices:
-            for _item in self.invoices:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['invoices'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of UpdateSubscriptionResponse from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "subscriptions": [SubscriptionExternal.from_dict(_item) for _item in obj.get("subscriptions")] if obj.get("subscriptions") is not None else None,
-            "invoices": [InvoiceExternal.from_dict(_item) for _item in obj.get("invoices")] if obj.get("invoices") is not None else None
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of DeleteSubscriptionItemRequest from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'drop_at_end': obj.get('drop_at_end') if obj.get('drop_at_end') is not None else True,
+        'proration_behavior': obj.get('proration_behavior')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/usage_agg_method_enum.py` & `getopenpay-0.0.2/getopenpay/models/checkout_mode.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,40 +7,34 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import re  # noqa: F401
 from enum import Enum
 
-
-
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
 
 
-class UsageAggMethodEnum(str, Enum):
-    """
-    UsageAggMethodEnum
-    """
-
+class CheckoutMode(str, Enum):
+  """
+    CheckoutMode
     """
+  """
     allowed enum values
     """
-    SUM = 'sum'
-    LAST_DURING_PERIOD = 'last_during_period'
-    LAST_EVER = 'last_ever'
-    MAX = 'max'
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of UsageAggMethodEnum from a JSON string"""
-        return cls(json.loads(json_str))
-
-
+  PAYMENT = 'payment'
+  SETUP = 'setup'
+  SUBSCRIPTION = 'subscription'
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of CheckoutMode from a JSON string"""
+    return cls(json.loads(json_str))
```

### Comparing `getopenpay-0.0.1/getopenpay/models/user_external.py` & `getopenpay-0.0.2/getopenpay/models/account_external.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,100 +7,113 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
-from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
+from typing import Any, ClassVar, Dict, List, Optional, Union
+
+from getopenpay.models.business_type import BusinessType
 from getopenpay.models.object_name import ObjectName
-from getopenpay.models.role_enum import RoleEnum
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class UserExternal(BaseModel):
+class AccountExternal(BaseModel):
+  """
+    AccountExternal
     """
-    UserExternal
-    """ # noqa: E501
-    id: StrictStr = Field(description="Unique Identifier of the user.")
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    email: StrictStr = Field(description="Email of the user.")
-    role: RoleEnum
-    account_id: StrictStr = Field(description="Unique Identifier of the account.")
-    is_active: StrictBool = Field(description="User status for the account.")
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "email", "role", "account_id", "is_active"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of UserExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier of the account.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  name: StrictStr = Field(description='The accounts name.')
+  business_type: BusinessType
+  country: StrictStr = Field(description='The accounts country.')
+  created_by_id: StrictInt = Field(
+    description='Unique identifier of the user who created the account.'
+  )
+  branding_settings: Union[str, Any] = Field(
+    description='The branding settings associated with this account.'
+  )
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'name', 'business_type', 'country',
+    'created_by_id', 'branding_settings'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of AccountExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of UserExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "email": obj.get("email"),
-            "role": obj.get("role"),
-            "account_id": obj.get("account_id"),
-            "is_active": obj.get("is_active")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of AccountExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'name': obj.get('name'),
+        'business_type': obj.get('business_type'),
+        'country': obj.get('country'),
+        'created_by_id': obj.get('created_by_id'),
+        'branding_settings': obj.get('branding_settings')
+      }
+    )
+    return _obj
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `getopenpay-0.0.1/getopenpay/models/validation_error.py` & `getopenpay-0.0.2/getopenpay/models/list_response_promotion_code_external.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,93 +7,95 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
+from typing import Any, ClassVar, Dict, List
 
+from getopenpay.models.promotion_code_external import PromotionCodeExternal
+from pydantic import BaseModel, StrictInt
 
-from typing import Any, ClassVar, Dict, List
-from pydantic import BaseModel, StrictStr
-from getopenpay.models.validation_error_loc_inner import ValidationErrorLocInner
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class ValidationError(BaseModel):
+class ListResponsePromotionCodeExternal(BaseModel):
+  """
+    ListResponsePromotionCodeExternal
     """
-    ValidationError
-    """ # noqa: E501
-    loc: List[ValidationErrorLocInner]
-    msg: StrictStr
-    type: StrictStr
-    __properties: ClassVar[List[str]] = ["loc", "msg", "type"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of ValidationError from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  data: List[PromotionCodeExternal]
+  total_objects: StrictInt
+  page_number: StrictInt
+  page_size: StrictInt
+  __properties: ClassVar[List[str]] = ['data', 'total_objects', 'page_number', 'page_size']
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ListResponsePromotionCodeExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of each item in loc (list)
-        _items = []
-        if self.loc:
-            for _item in self.loc:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict['loc'] = _items
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of ValidationError from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "loc": [ValidationErrorLocInner.from_dict(_item) for _item in obj.get("loc")] if obj.get("loc") is not None else None,
-            "msg": obj.get("msg"),
-            "type": obj.get("type")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # override the default output from pydantic by calling `to_dict()` of each item in data (list)
+    _items = []
+    if self.data:
+      for _item in self.data:
+        if _item:
+          _items.append(_item.to_dict())
+      _dict['data'] = _items
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ListResponsePromotionCodeExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'data':
+          [PromotionCodeExternal.from_dict(_item) for _item in obj.get('data')]
+          if obj.get('data') is not None else None,
+        'total_objects': obj.get('total_objects'),
+        'page_number': obj.get('page_number'),
+        'page_size': obj.get('page_size')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/models/validation_error_loc_inner.py` & `getopenpay-0.0.2/getopenpay/models/validation_error_loc_inner.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,137 +7,141 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
 import json
 import pprint
 import re  # noqa: F401
+from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union
 
-from typing import Optional
 from pydantic import BaseModel, StrictInt, StrictStr, ValidationError, field_validator
-from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
 from typing_extensions import Literal
-from pydantic import StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
+VALIDATIONERRORLOCINNER_ANY_OF_SCHEMAS = ['int', 'str']
 
-VALIDATIONERRORLOCINNER_ANY_OF_SCHEMAS = ["int", "str"]
 
 class ValidationErrorLocInner(BaseModel):
-    """
+  """
     ValidationErrorLocInner
     """
 
-    # data type: str
-    anyof_schema_1_validator: Optional[StrictStr] = None
-    # data type: int
-    anyof_schema_2_validator: Optional[StrictInt] = None
-    if TYPE_CHECKING:
-        actual_instance: Optional[Union[int, str]] = None
+  # data type: str
+  anyof_schema_1_validator: Optional[StrictStr] = None
+  # data type: int
+  anyof_schema_2_validator: Optional[StrictInt] = None
+  if TYPE_CHECKING:
+    actual_instance: Optional[Union[int, str]] = None
+  else:
+    actual_instance: Any = None
+  any_of_schemas: List[str] = Literal[VALIDATIONERRORLOCINNER_ANY_OF_SCHEMAS]
+
+  model_config = {'validate_assignment': True}
+
+  def __init__(self, *args, **kwargs) -> None:
+    if args:
+      if len(args) > 1:
+        raise ValueError(
+          'If a position argument is used, only 1 is allowed to set `actual_instance`'
+        )
+      if kwargs:
+        raise ValueError('If a position argument is used, keyword arguments cannot be used.')
+      super().__init__(actual_instance=args[0])
     else:
-        actual_instance: Any = None
-    any_of_schemas: List[str] = Literal[VALIDATIONERRORLOCINNER_ANY_OF_SCHEMAS]
+      super().__init__(**kwargs)
 
-    model_config = {
-        "validate_assignment": True
-    }
-
-    def __init__(self, *args, **kwargs) -> None:
-        if args:
-            if len(args) > 1:
-                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
-            if kwargs:
-                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
-            super().__init__(actual_instance=args[0])
-        else:
-            super().__init__(**kwargs)
-
-    @field_validator('actual_instance')
-    def actual_instance_must_validate_anyof(cls, v):
-        instance = ValidationErrorLocInner.model_construct()
-        error_messages = []
-        # validate data type: str
-        try:
-            instance.anyof_schema_1_validator = v
-            return v
-        except (ValidationError, ValueError) as e:
-            error_messages.append(str(e))
-        # validate data type: int
-        try:
-            instance.anyof_schema_2_validator = v
-            return v
-        except (ValidationError, ValueError) as e:
-            error_messages.append(str(e))
-        if error_messages:
-            # no match
-            raise ValueError("No match found when setting the actual_instance in ValidationErrorLocInner with anyOf schemas: int, str. Details: " + ", ".join(error_messages))
-        else:
-            return v
-
-    @classmethod
-    def from_dict(cls, obj: dict) -> Self:
-        return cls.from_json(json.dumps(obj))
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Returns the object represented by the json string"""
-        instance = cls.model_construct()
-        error_messages = []
-        # deserialize data into str
-        try:
-            # validation
-            instance.anyof_schema_1_validator = json.loads(json_str)
-            # assign value to actual_instance
-            instance.actual_instance = instance.anyof_schema_1_validator
-            return instance
-        except (ValidationError, ValueError) as e:
-            error_messages.append(str(e))
-        # deserialize data into int
-        try:
-            # validation
-            instance.anyof_schema_2_validator = json.loads(json_str)
-            # assign value to actual_instance
-            instance.actual_instance = instance.anyof_schema_2_validator
-            return instance
-        except (ValidationError, ValueError) as e:
-            error_messages.append(str(e))
-
-        if error_messages:
-            # no match
-            raise ValueError("No match found when deserializing the JSON string into ValidationErrorLocInner with anyOf schemas: int, str. Details: " + ", ".join(error_messages))
-        else:
-            return instance
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the actual instance"""
-        if self.actual_instance is None:
-            return "null"
-
-        to_json = getattr(self.actual_instance, "to_json", None)
-        if callable(to_json):
-            return self.actual_instance.to_json()
-        else:
-            return json.dumps(self.actual_instance)
-
-    def to_dict(self) -> Dict:
-        """Returns the dict representation of the actual instance"""
-        if self.actual_instance is None:
-            return "null"
-
-        to_json = getattr(self.actual_instance, "to_json", None)
-        if callable(to_json):
-            return self.actual_instance.to_dict()
-        else:
-            return json.dumps(self.actual_instance)
-
-    def to_str(self) -> str:
-        """Returns the string representation of the actual instance"""
-        return pprint.pformat(self.model_dump())
+  @field_validator('actual_instance')
+  def actual_instance_must_validate_anyof(cls, v):
+    instance = ValidationErrorLocInner.model_construct()
+    error_messages = []
+    # validate data type: str
+    try:
+      instance.anyof_schema_1_validator = v
+      return v
+    except (ValidationError, ValueError) as e:
+      error_messages.append(str(e))
+    # validate data type: int
+    try:
+      instance.anyof_schema_2_validator = v
+      return v
+    except (ValidationError, ValueError) as e:
+      error_messages.append(str(e))
+    if error_messages:
+      # no match
+      raise ValueError(
+        'No match found when setting the actual_instance in ValidationErrorLocInner with anyOf schemas: int, str. Details: '
+        + ', '.join(error_messages)
+      )
+    else:
+      return v
 
+  @classmethod
+  def from_dict(cls, obj: dict) -> Self:
+    return cls.from_json(json.dumps(obj))
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Returns the object represented by the json string"""
+    instance = cls.model_construct()
+    error_messages = []
+    # deserialize data into str
+    try:
+      # validation
+      instance.anyof_schema_1_validator = json.loads(json_str)
+      # assign value to actual_instance
+      instance.actual_instance = instance.anyof_schema_1_validator
+      return instance
+    except (ValidationError, ValueError) as e:
+      error_messages.append(str(e))
+    # deserialize data into int
+    try:
+      # validation
+      instance.anyof_schema_2_validator = json.loads(json_str)
+      # assign value to actual_instance
+      instance.actual_instance = instance.anyof_schema_2_validator
+      return instance
+    except (ValidationError, ValueError) as e:
+      error_messages.append(str(e))
+
+    if error_messages:
+      # no match
+      raise ValueError(
+        'No match found when deserializing the JSON string into ValidationErrorLocInner with anyOf schemas: int, str. Details: '
+        + ', '.join(error_messages)
+      )
+    else:
+      return instance
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the actual instance"""
+    if self.actual_instance is None:
+      return 'null'
+
+    to_json = getattr(self.actual_instance, 'to_json', None)
+    if callable(to_json):
+      return self.actual_instance.to_json()
+    else:
+      return json.dumps(self.actual_instance)
+
+  def to_dict(self) -> Dict:
+    """Returns the dict representation of the actual instance"""
+    if self.actual_instance is None:
+      return 'null'
+
+    to_json = getattr(self.actual_instance, 'to_json', None)
+    if callable(to_json):
+      return self.actual_instance.to_dict()
+    else:
+      return json.dumps(self.actual_instance)
 
+  def to_str(self) -> str:
+    """Returns the string representation of the actual instance"""
+    return pprint.pformat(self.model_dump())
```

### Comparing `getopenpay-0.0.1/getopenpay/models/webhook_endpoint_external.py` & `getopenpay-0.0.2/getopenpay/models/api_token_external.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,112 +7,116 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 from __future__ import annotations
+
+import json
 import pprint
 import re  # noqa: F401
-import json
-
 from datetime import datetime
 from typing import Any, ClassVar, Dict, List, Optional
-from pydantic import BaseModel, StrictBool, StrictStr
-from pydantic import Field
-from getopenpay.models.event_type import EventType
+
 from getopenpay.models.object_name import ObjectName
+from getopenpay.models.role_enum import RoleEnum
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
+
 try:
-    from typing import Self
+  from typing import Self
 except ImportError:
-    from typing_extensions import Self
+  from typing_extensions import Self
+
 
-class WebhookEndpointExternal(BaseModel):
+class ApiTokenExternal(BaseModel):
+  """
+    ApiTokenExternal
     """
-    WebhookEndpointExternal
-    """ # noqa: E501
-    id: StrictStr
-    object: Optional[ObjectName] = None
-    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
-    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
-    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
-    url: StrictStr
-    is_active: StrictBool
-    enabled_events: List[EventType]
-    description: Optional[StrictStr]
-    secret: Optional[StrictStr]
-    __properties: ClassVar[List[str]] = ["id", "object", "created_at", "updated_at", "is_deleted", "url", "is_active", "enabled_events", "description", "secret"]
-
-    model_config = {
-        "populate_by_name": True,
-        "validate_assignment": True
-    }
-
-
-    def to_str(self) -> str:
-        """Returns the string representation of the model using alias"""
-        return pprint.pformat(self.model_dump(by_alias=True))
-
-    def to_json(self) -> str:
-        """Returns the JSON representation of the model using alias"""
-        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
-        return json.dumps(self.to_dict())
-
-    @classmethod
-    def from_json(cls, json_str: str) -> Self:
-        """Create an instance of WebhookEndpointExternal from a JSON string"""
-        return cls.from_dict(json.loads(json_str))
 
-    def to_dict(self) -> Dict[str, Any]:
-        """Return the dictionary representation of the model using alias.
+  # noqa: E501
+  id: StrictStr = Field(description='Unique identifier of the api token.')
+  object: Optional[ObjectName] = None
+  created_at: datetime = Field(
+    description="DateTime at which the object was created, in 'ISO 8601' format."
+  )
+  updated_at: datetime = Field(
+    description="DateTime at which the object was updated, in 'ISO 8601' format."
+  )
+  is_deleted: Optional[StrictBool] = Field(
+    default=False, description='If true, indicates that this object has been deleted'
+  )
+  secret_token: StrictStr = Field(description='The secret token used for request authorization.')
+  publishable_token: StrictStr = Field(
+    description='The publishable token used for request authorization.'
+  )
+  user_id: StrictInt = Field(description='Unique identifier of the user.')
+  role: RoleEnum
+  description: Optional[StrictStr]
+  __properties: ClassVar[List[str]] = [
+    'id', 'object', 'created_at', 'updated_at', 'is_deleted', 'secret_token', 'publishable_token',
+    'user_id', 'role', 'description'
+  ]
+
+  model_config = {'populate_by_name': True, 'validate_assignment': True}
+
+  def to_str(self) -> str:
+    """Returns the string representation of the model using alias"""
+    return pprint.pformat(self.model_dump(by_alias=True))
+
+  def to_json(self) -> str:
+    """Returns the JSON representation of the model using alias"""
+    # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
+    return json.dumps(self.to_dict())
+
+  @classmethod
+  def from_json(cls, json_str: str) -> Self:
+    """Create an instance of ApiTokenExternal from a JSON string"""
+    return cls.from_dict(json.loads(json_str))
+
+  def to_dict(self) -> Dict[str, Any]:
+    """Return the dictionary representation of the model using alias.
 
         This has the following differences from calling pydantic's
         `self.model_dump(by_alias=True)`:
 
         * `None` is only added to the output dict for nullable fields that
           were set at model initialization. Other fields with value `None`
           are ignored.
         """
-        _dict = self.model_dump(
-            by_alias=True,
-            exclude={
-            },
-            exclude_none=True,
-        )
-        # set to None if description (nullable) is None
-        # and model_fields_set contains the field
-        if self.description is None and "description" in self.model_fields_set:
-            _dict['description'] = None
-
-        # set to None if secret (nullable) is None
-        # and model_fields_set contains the field
-        if self.secret is None and "secret" in self.model_fields_set:
-            _dict['secret'] = None
-
-        return _dict
-
-    @classmethod
-    def from_dict(cls, obj: Dict) -> Self:
-        """Create an instance of WebhookEndpointExternal from a dict"""
-        if obj is None:
-            return None
-
-        if not isinstance(obj, dict):
-            return cls.model_validate(obj)
-
-        _obj = cls.model_validate({
-            "id": obj.get("id"),
-            "object": obj.get("object"),
-            "created_at": obj.get("created_at"),
-            "updated_at": obj.get("updated_at"),
-            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
-            "url": obj.get("url"),
-            "is_active": obj.get("is_active"),
-            "enabled_events": obj.get("enabled_events"),
-            "description": obj.get("description"),
-            "secret": obj.get("secret")
-        })
-        return _obj
-
-
+    _dict = self.model_dump(
+      by_alias=True,
+      exclude={},
+      exclude_none=True,
+    )
+    # set to None if description (nullable) is None
+    # and model_fields_set contains the field
+    if self.description is None and 'description' in self.model_fields_set:
+      _dict['description'] = None
+
+    return _dict
+
+  @classmethod
+  def from_dict(cls, obj: Dict) -> Self:
+    """Create an instance of ApiTokenExternal from a dict"""
+    if obj is None:
+      return None
+
+    if not isinstance(obj, dict):
+      return cls.model_validate(obj)
+
+    _obj = cls.model_validate(
+      {
+        'id': obj.get('id'),
+        'object': obj.get('object'),
+        'created_at': obj.get('created_at'),
+        'updated_at': obj.get('updated_at'),
+        'is_deleted': obj.get('is_deleted') if obj.get('is_deleted') is not None else False,
+        'secret_token': obj.get('secret_token'),
+        'publishable_token': obj.get('publishable_token'),
+        'user_id': obj.get('user_id'),
+        'role': obj.get('role'),
+        'description': obj.get('description')
+      }
+    )
+    return _obj
```

### Comparing `getopenpay-0.0.1/getopenpay/rest.py` & `getopenpay-0.0.2/getopenpay/rest.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,225 +7,179 @@
 
     The version of the OpenAPI document: 1.0.0
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the class manually.
 """  # noqa: E501
 
-
 import io
 import json
 import re
 import ssl
 
 import urllib3
-
 from getopenpay.exceptions import ApiException, ApiValueError
 
 RESTResponseType = urllib3.HTTPResponse
 
+
 class RESTResponse(io.IOBase):
 
-    def __init__(self, resp) -> None:
-        self.response = resp
-        self.status = resp.status
-        self.reason = resp.reason
-        self.data = None
-
-    def read(self):
-        if self.data is None:
-            self.data = self.response.data
-        return self.data
-
-    def getheaders(self):
-        """Returns a dictionary of the response headers."""
-        return self.response.headers
-
-    def getheader(self, name, default=None):
-        """Returns a given response header."""
-        return self.response.headers.get(name, default)
+  def __init__(self, resp) -> None:
+    self.response = resp
+    self.status = resp.status
+    self.reason = resp.reason
+    self.data = None
+
+  def read(self):
+    if self.data is None:
+      self.data = self.response.data
+    return self.data
+
+  def getheaders(self):
+    """Returns a dictionary of the response headers."""
+    return self.response.headers
+
+  def getheader(self, name, default=None):
+    """Returns a given response header."""
+    return self.response.headers.get(name, default)
 
 
 class RESTClientObject:
 
-    def __init__(self, configuration) -> None:
-        # urllib3.PoolManager will pass all kw parameters to connectionpool
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
-        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501
-
-        # cert_reqs
-        if configuration.verify_ssl:
-            cert_reqs = ssl.CERT_REQUIRED
-        else:
-            cert_reqs = ssl.CERT_NONE
+  def __init__(self, configuration) -> None:
+    # urllib3.PoolManager will pass all kw parameters to connectionpool
+    # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
+    # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
+    # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501
+
+    # cert_reqs
+    if configuration.verify_ssl:
+      cert_reqs = ssl.CERT_REQUIRED
+    else:
+      cert_reqs = ssl.CERT_NONE
+
+    addition_pool_args = {}
+    if configuration.assert_hostname is not None:
+      addition_pool_args['assert_hostname'] = (configuration.assert_hostname)
+
+    if configuration.retries is not None:
+      addition_pool_args['retries'] = configuration.retries
+
+    if configuration.tls_server_name:
+      addition_pool_args['server_hostname'] = configuration.tls_server_name
+
+    if configuration.socket_options is not None:
+      addition_pool_args['socket_options'] = configuration.socket_options
+
+    # https pool manager
+    if configuration.proxy:
+      self.pool_manager = urllib3.ProxyManager(
+        cert_reqs=cert_reqs,
+        ca_certs=configuration.ssl_ca_cert,
+        cert_file=configuration.cert_file,
+        key_file=configuration.key_file,
+        proxy_url=configuration.proxy,
+        proxy_headers=configuration.proxy_headers,
+        **addition_pool_args
+      )
+    else:
+      self.pool_manager = urllib3.PoolManager(
+        cert_reqs=cert_reqs,
+        ca_certs=configuration.ssl_ca_cert,
+        cert_file=configuration.cert_file,
+        key_file=configuration.key_file,
+        **addition_pool_args
+      )
 
-        addition_pool_args = {}
-        if configuration.assert_hostname is not None:
-            addition_pool_args['assert_hostname'] = (
-                configuration.assert_hostname
-            )
-
-        if configuration.retries is not None:
-            addition_pool_args['retries'] = configuration.retries
-
-        if configuration.tls_server_name:
-            addition_pool_args['server_hostname'] = configuration.tls_server_name
-
-
-        if configuration.socket_options is not None:
-            addition_pool_args['socket_options'] = configuration.socket_options
-
-        # https pool manager
-        if configuration.proxy:
-            self.pool_manager = urllib3.ProxyManager(
-                cert_reqs=cert_reqs,
-                ca_certs=configuration.ssl_ca_cert,
-                cert_file=configuration.cert_file,
-                key_file=configuration.key_file,
-                proxy_url=configuration.proxy,
-                proxy_headers=configuration.proxy_headers,
-                **addition_pool_args
-            )
-        else:
-            self.pool_manager = urllib3.PoolManager(
-                cert_reqs=cert_reqs,
-                ca_certs=configuration.ssl_ca_cert,
-                cert_file=configuration.cert_file,
-                key_file=configuration.key_file,
-                **addition_pool_args
-            )
-
-    def request(
-        self,
-        method,
-        url,
-        headers=None,
-        body=None,
-        post_params=None,
-        _request_timeout=None
-    ):
-        """Perform requests.
+  def request(self, method, url, headers=None, body=None, post_params=None, _request_timeout=None):
+    """Perform requests.
 
         :param method: http request method
         :param url: http request url
         :param headers: http request headers
         :param body: request json body, for `application/json`
         :param post_params: request post parameters,
                             `application/x-www-form-urlencoded`
                             and `multipart/form-data`
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         """
-        method = method.upper()
-        assert method in [
-            'GET',
-            'HEAD',
-            'DELETE',
-            'POST',
-            'PUT',
-            'PATCH',
-            'OPTIONS'
-        ]
-
-        if post_params and body:
-            raise ApiValueError(
-                "body parameter cannot be used with post_params parameter."
-            )
-
-        post_params = post_params or {}
-        headers = headers or {}
-
-        timeout = None
-        if _request_timeout:
-            if isinstance(_request_timeout, (int, float)):
-                timeout = urllib3.Timeout(total=_request_timeout)
-            elif (
-                    isinstance(_request_timeout, tuple)
-                    and len(_request_timeout) == 2
-                ):
-                timeout = urllib3.Timeout(
-                    connect=_request_timeout[0],
-                    read=_request_timeout[1]
-                )
-
-        try:
-            # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
-            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
-
-                # no content type provided or payload is json
-                content_type = headers.get('Content-Type')
-                if (
-                    not content_type
-                    or re.search('json', content_type, re.IGNORECASE)
-                ):
-                    request_body = None
-                    if body is not None:
-                        request_body = json.dumps(body)
-                    r = self.pool_manager.request(
-                        method,
-                        url,
-                        body=request_body,
-                        timeout=timeout,
-                        headers=headers,
-                        preload_content=False
-                    )
-                elif content_type == 'application/x-www-form-urlencoded':
-                    r = self.pool_manager.request(
-                        method,
-                        url,
-                        fields=post_params,
-                        encode_multipart=False,
-                        timeout=timeout,
-                        headers=headers,
-                        preload_content=False
-                    )
-                elif content_type == 'multipart/form-data':
-                    # must del headers['Content-Type'], or the correct
-                    # Content-Type which generated by urllib3 will be
-                    # overwritten.
-                    del headers['Content-Type']
-                    r = self.pool_manager.request(
-                        method,
-                        url,
-                        fields=post_params,
-                        encode_multipart=True,
-                        timeout=timeout,
-                        headers=headers,
-                        preload_content=False
-                    )
-                # Pass a `string` parameter directly in the body to support
-                # other content types than Json when `body` argument is
-                # provided in serialized form
-                elif isinstance(body, str) or isinstance(body, bytes):
-                    request_body = body
-                    r = self.pool_manager.request(
-                        method,
-                        url,
-                        body=request_body,
-                        timeout=timeout,
-                        headers=headers,
-                        preload_content=False
-                    )
-                else:
-                    # Cannot generate the request from given parameters
-                    msg = """Cannot prepare a request message for provided
+    method = method.upper()
+    assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT', 'PATCH', 'OPTIONS']
+
+    if post_params and body:
+      raise ApiValueError('body parameter cannot be used with post_params parameter.')
+
+    post_params = post_params or {}
+    headers = headers or {}
+
+    timeout = None
+    if _request_timeout:
+      if isinstance(_request_timeout, (int, float)):
+        timeout = urllib3.Timeout(total=_request_timeout)
+      elif (isinstance(_request_timeout, tuple) and len(_request_timeout) == 2):
+        timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])
+
+    try:
+      # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
+      if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
+
+        # no content type provided or payload is json
+        content_type = headers.get('Content-Type')
+        if (not content_type or re.search('json', content_type, re.IGNORECASE)):
+          request_body = None
+          if body is not None:
+            request_body = json.dumps(body)
+          r = self.pool_manager.request(
+            method, url, body=request_body, timeout=timeout, headers=headers, preload_content=False
+          )
+        elif content_type == 'application/x-www-form-urlencoded':
+          r = self.pool_manager.request(
+            method,
+            url,
+            fields=post_params,
+            encode_multipart=False,
+            timeout=timeout,
+            headers=headers,
+            preload_content=False
+          )
+        elif content_type == 'multipart/form-data':
+          # must del headers['Content-Type'], or the correct
+          # Content-Type which generated by urllib3 will be
+          # overwritten.
+          del headers['Content-Type']
+          r = self.pool_manager.request(
+            method,
+            url,
+            fields=post_params,
+            encode_multipart=True,
+            timeout=timeout,
+            headers=headers,
+            preload_content=False
+          )
+        # Pass a `string` parameter directly in the body to support
+        # other content types than Json when `body` argument is
+        # provided in serialized form
+        elif isinstance(body, str) or isinstance(body, bytes):
+          request_body = body
+          r = self.pool_manager.request(
+            method, url, body=request_body, timeout=timeout, headers=headers, preload_content=False
+          )
+        else:
+          # Cannot generate the request from given parameters
+          msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
-                    raise ApiException(status=0, reason=msg)
-            # For `GET`, `HEAD`
-            else:
-                r = self.pool_manager.request(
-                    method,
-                    url,
-                    fields={},
-                    timeout=timeout,
-                    headers=headers,
-                    preload_content=False
-                )
-        except urllib3.exceptions.SSLError as e:
-            msg = "\n".join([type(e).__name__, str(e)])
-            raise ApiException(status=0, reason=msg)
+          raise ApiException(status=0, reason=msg)
+      # For `GET`, `HEAD`
+      else:
+        r = self.pool_manager.request(
+          method, url, fields={}, timeout=timeout, headers=headers, preload_content=False
+        )
+    except urllib3.exceptions.SSLError as e:
+      msg = '\n'.join([type(e).__name__, str(e)])
+      raise ApiException(status=0, reason=msg)
 
-        return RESTResponse(r)
+    return RESTResponse(r)
```

### Comparing `getopenpay-0.0.1/getopenpay.egg-info/SOURCES.txt` & `getopenpay-0.0.2/getopenpay.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -42,14 +42,15 @@
 getopenpay/models/billing_reason_enum.py
 getopenpay/models/billing_scheme_enum.py
 getopenpay/models/business_type.py
 getopenpay/models/calendar_interval_enum.py
 getopenpay/models/charge_external.py
 getopenpay/models/charge_query_params.py
 getopenpay/models/charge_status_enum.py
+getopenpay/models/chart_mogul_integration_public.py
 getopenpay/models/checkout_mode.py
 getopenpay/models/checkout_session_external.py
 getopenpay/models/checkout_session_line_item_external.py
 getopenpay/models/checkout_session_query_params.py
 getopenpay/models/checkout_session_status.py
 getopenpay/models/collection_method_enum.py
 getopenpay/models/complete_address.py
```

### Comparing `getopenpay-0.0.1/setup.py` & `getopenpay-0.0.2/setup.py`

 * *Files 8% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 # To install the library, run the following
 #
 # python setup.py install
 #
 # prerequisite: setuptools
 # http://pypi.python.org/pypi/setuptools
 NAME = 'getopenpay'
-VERSION = '0.0.1'
+VERSION = '0.0.2'
 PYTHON_REQUIRES = '>=3.7'
 REQUIRES = [
   'urllib3 >= 1.25.3, < 2.1.0',
   'python-dateutil',
   'pydantic >= 2',
   'typing-extensions >= 4.7.1',
 ]
```

