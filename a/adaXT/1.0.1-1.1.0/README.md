# Comparing `tmp/adaXT-1.0.1.tar.gz` & `tmp/adaxt-1.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "adaXT-1.0.1.tar", last modified: Sat Feb 17 12:12:56 2024, max compression
+gzip compressed data, was "adaxt-1.1.0.tar", last modified: Wed May 22 06:17:49 2024, max compression
```

## Comparing `adaXT-1.0.1.tar` & `adaxt-1.1.0.tar`

### file list

```diff
@@ -1,33 +1,46 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-17 12:12:56.564957 adaXT-1.0.1/
--rw-r--r--   0 runner    (1001) docker     (127)    35149 2024-02-17 12:12:43.000000 adaXT-1.0.1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (127)     1171 2024-02-17 12:12:56.564957 adaXT-1.0.1/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)      387 2024-02-17 12:12:43.000000 adaXT-1.0.1/README.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-17 12:12:56.564957 adaXT-1.0.1/adaXT.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)     1171 2024-02-17 12:12:56.000000 adaXT-1.0.1/adaXT.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)      715 2024-02-17 12:12:56.000000 adaXT-1.0.1/adaXT.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-02-17 12:12:56.000000 adaXT-1.0.1/adaXT.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)       74 2024-02-17 12:12:56.000000 adaXT-1.0.1/adaXT.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)        6 2024-02-17 12:12:56.000000 adaXT-1.0.1/adaXT.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (127)      293 2024-02-17 12:12:43.000000 adaXT-1.0.1/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (127)       38 2024-02-17 12:12:56.564957 adaXT-1.0.1/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (127)     2321 2024-02-17 12:12:43.000000 adaXT-1.0.1/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-17 12:12:56.552957 adaXT-1.0.1/src/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-17 12:12:56.556957 adaXT-1.0.1/src/adaXT/
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-02-17 12:12:43.000000 adaXT-1.0.1/src/adaXT/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-17 12:12:56.556957 adaXT-1.0.1/src/adaXT/criteria/
--rw-r--r--   0 runner    (1001) docker     (127)       86 2024-02-17 12:12:43.000000 adaXT-1.0.1/src/adaXT/criteria/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)   915070 2024-02-17 12:12:54.000000 adaXT-1.0.1/src/adaXT/criteria/crit_helpers.cpp
--rw-r--r--   0 runner    (1001) docker     (127)  1375030 2024-02-17 12:12:55.000000 adaXT-1.0.1/src/adaXT/criteria/criteria.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1343 2024-02-17 12:12:43.000000 adaXT-1.0.1/src/adaXT/criteria/criteria.pyi
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-17 12:12:56.560957 adaXT-1.0.1/src/adaXT/decision_tree/
--rw-r--r--   0 runner    (1001) docker     (127)  1329520 2024-02-17 12:12:55.000000 adaXT-1.0.1/src/adaXT/decision_tree/DecisionTree.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5372 2024-02-17 12:12:43.000000 adaXT-1.0.1/src/adaXT/decision_tree/DecisionTree.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     9101 2024-02-17 12:12:43.000000 adaXT-1.0.1/src/adaXT/decision_tree/DepthTreeBuilder.py
--rw-r--r--   0 runner    (1001) docker     (127)   338777 2024-02-17 12:12:55.000000 adaXT-1.0.1/src/adaXT/decision_tree/Nodes.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2628 2024-02-17 12:12:43.000000 adaXT-1.0.1/src/adaXT/decision_tree/Nodes.pyi
--rw-r--r--   0 runner    (1001) docker     (127)      121 2024-02-17 12:12:43.000000 adaXT-1.0.1/src/adaXT/decision_tree/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)  1194721 2024-02-17 12:12:56.000000 adaXT-1.0.1/src/adaXT/decision_tree/splitter.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3994 2024-02-17 12:12:43.000000 adaXT-1.0.1/src/adaXT/decision_tree/tree_utils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-17 12:12:56.564957 adaXT-1.0.1/tests/
--rw-r--r--   0 runner    (1001) docker     (127)    10671 2024-02-17 12:12:43.000000 adaXT-1.0.1/tests/test_decision_tree.py
--rw-r--r--   0 runner    (1001) docker     (127)    13929 2024-02-17 12:12:43.000000 adaXT-1.0.1/tests/test_tree_features.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.397146 adaxt-1.1.0/
+-rw-r--r--   0 runner    (1001) docker     (127)     1500 2024-05-22 06:17:40.000000 adaxt-1.1.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (127)     3495 2024-05-22 06:17:49.397146 adaxt-1.1.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     2732 2024-05-22 06:17:40.000000 adaxt-1.1.0/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.397146 adaxt-1.1.0/adaXT.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)     3495 2024-05-22 06:17:49.000000 adaxt-1.1.0/adaXT.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     1057 2024-05-22 06:17:49.000000 adaxt-1.1.0/adaXT.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-22 06:17:49.000000 adaxt-1.1.0/adaXT.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       74 2024-05-22 06:17:49.000000 adaxt-1.1.0/adaXT.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        6 2024-05-22 06:17:49.000000 adaxt-1.1.0/adaXT.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      252 2024-05-22 06:17:40.000000 adaxt-1.1.0/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-22 06:17:49.397146 adaxt-1.1.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)     3544 2024-05-22 06:17:40.000000 adaxt-1.1.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.381146 adaxt-1.1.0/src/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.385146 adaxt-1.1.0/src/adaXT/
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)  1178999 2024-05-22 06:17:45.000000 adaxt-1.1.0/src/adaXT/base_model.cpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.389146 adaxt-1.1.0/src/adaXT/criteria/
+-rw-r--r--   0 runner    (1001) docker     (127)       86 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/criteria/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)   915686 2024-05-22 06:17:46.000000 adaxt-1.1.0/src/adaXT/criteria/crit_helpers.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)  1350995 2024-05-22 06:17:46.000000 adaxt-1.1.0/src/adaXT/criteria/criteria.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2206 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/criteria/criteria.pyi
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.389146 adaxt-1.1.0/src/adaXT/decision_tree/
+-rw-r--r--   0 runner    (1001) docker     (127)      122 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/decision_tree/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)   758886 2024-05-22 06:17:46.000000 adaxt-1.1.0/src/adaXT/decision_tree/decision_tree.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     6557 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/decision_tree/decision_tree.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)   362120 2024-05-22 06:17:46.000000 adaxt-1.1.0/src/adaXT/decision_tree/nodes.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2628 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/decision_tree/nodes.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)  1180258 2024-05-22 06:17:47.000000 adaxt-1.1.0/src/adaXT/decision_tree/splitter.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1265 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/decision_tree/splitter.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     4290 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/decision_tree/tree_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.393146 adaxt-1.1.0/src/adaXT/leaf_builder/
+-rw-r--r--   0 runner    (1001) docker     (127)      138 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/leaf_builder/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)  1334529 2024-05-22 06:17:48.000000 adaxt-1.1.0/src/adaXT/leaf_builder/leaf_builder.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      204 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/leaf_builder/leaf_builder.pyi
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.393146 adaxt-1.1.0/src/adaXT/predict/
+-rw-r--r--   0 runner    (1001) docker     (127)      138 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/predict/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)  1376252 2024-05-22 06:17:48.000000 adaxt-1.1.0/src/adaXT/predict/predict.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      440 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/predict/predict.pyi
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.385146 adaxt-1.1.0/src/adaXT/random_forest/
+-rw-r--r--   0 runner    (1001) docker     (127)       40 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/random_forest/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14860 2024-05-22 06:17:40.000000 adaxt-1.1.0/src/adaXT/random_forest/random_forest.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-22 06:17:49.397146 adaxt-1.1.0/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)    10954 2024-05-22 06:17:40.000000 adaxt-1.1.0/tests/test_decision_tree.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7687 2024-05-22 06:17:40.000000 adaxt-1.1.0/tests/test_random_forest.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15606 2024-05-22 06:17:40.000000 adaxt-1.1.0/tests/test_tree_features.py
```

### Comparing `adaXT-1.0.1/adaXT.egg-info/SOURCES.txt` & `adaxt-1.1.0/adaXT.egg-info/SOURCES.txt`

 * *Files 25% similar despite different names*

```diff
@@ -1,24 +1,34 @@
 LICENSE
 README.md
 pyproject.toml
 setup.py
 ./src/adaXT/__init__.py
 ./src/adaXT/criteria/__init__.py
 ./src/adaXT/criteria/criteria.pyi
-./src/adaXT/decision_tree/DecisionTree.pyi
-./src/adaXT/decision_tree/DepthTreeBuilder.py
-./src/adaXT/decision_tree/Nodes.pyi
 ./src/adaXT/decision_tree/__init__.py
+./src/adaXT/decision_tree/decision_tree.pyi
+./src/adaXT/decision_tree/nodes.pyi
+./src/adaXT/decision_tree/splitter.pyi
 ./src/adaXT/decision_tree/tree_utils.py
+./src/adaXT/leaf_builder/__init__.py
+./src/adaXT/leaf_builder/leaf_builder.pyi
+./src/adaXT/predict/__init__.py
+./src/adaXT/predict/predict.pyi
+./src/adaXT/random_forest/__init__.py
+./src/adaXT/random_forest/random_forest.py
 adaXT.egg-info/PKG-INFO
 adaXT.egg-info/SOURCES.txt
 adaXT.egg-info/dependency_links.txt
 adaXT.egg-info/requires.txt
 adaXT.egg-info/top_level.txt
+src/adaXT/base_model.cpp
 src/adaXT/criteria/crit_helpers.cpp
 src/adaXT/criteria/criteria.cpp
-src/adaXT/decision_tree/DecisionTree.cpp
-src/adaXT/decision_tree/Nodes.cpp
+src/adaXT/decision_tree/decision_tree.cpp
+src/adaXT/decision_tree/nodes.cpp
 src/adaXT/decision_tree/splitter.cpp
+src/adaXT/leaf_builder/leaf_builder.cpp
+src/adaXT/predict/predict.cpp
 tests/test_decision_tree.py
+tests/test_random_forest.py
 tests/test_tree_features.py
```

### Comparing `adaXT-1.0.1/src/adaXT/criteria/crit_helpers.cpp` & `adaxt-1.1.0/src/adaXT/criteria/crit_helpers.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,17 +1,23 @@
-/* Generated by Cython 3.0.8 */
+/* Generated by Cython 3.0.10 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
+        "define_macros": [
+            [
+                "NPY_NO_DEPRECATED_API",
+                "NPY_1_7_API_VERSION"
+            ]
+        ],
         "extra_compile_args": [
             "-O3"
         ],
         "include_dirs": [
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include"
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include"
         ],
         "language": "c++",
         "name": "adaXT.criteria.crit_helpers",
         "sources": [
             "src/adaXT/criteria/crit_helpers.pyx"
         ]
     },
@@ -39,18 +45,18 @@
     #error Cython requires Python 2.7+ or Python 3.3+.
 #else
 #if defined(CYTHON_LIMITED_API) && CYTHON_LIMITED_API
 #define __PYX_EXTRA_ABI_MODULE_NAME "limited"
 #else
 #define __PYX_EXTRA_ABI_MODULE_NAME ""
 #endif
-#define CYTHON_ABI "3_0_8" __PYX_EXTRA_ABI_MODULE_NAME
+#define CYTHON_ABI "3_0_10" __PYX_EXTRA_ABI_MODULE_NAME
 #define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
 #define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
-#define CYTHON_HEX_VERSION 0x030008F0
+#define CYTHON_HEX_VERSION 0x03000AF0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -134,14 +140,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(PYPY_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
@@ -195,14 +203,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(CYTHON_LIMITED_API)
   #ifdef Py_LIMITED_API
     #undef __PYX_LIMITED_VERSION_HEX
     #define __PYX_LIMITED_VERSION_HEX Py_LIMITED_API
   #endif
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
@@ -256,60 +266,83 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(Py_GIL_DISABLED) || defined(Py_NOGIL)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_TYPE_SPECS
+    #define CYTHON_USE_TYPE_SPECS 0
+  #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #ifndef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #endif
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #ifndef CYTHON_METH_FASTCALL
+    #define CYTHON_METH_FASTCALL 1
+  #endif
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT 1
   #endif
+  #ifndef CYTHON_USE_MODULE_STATE
+    #define CYTHON_USE_MODULE_STATE 0
+  #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE 1
   #endif
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 0
+  #endif
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
@@ -392,14 +425,17 @@
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK 1
   #endif
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
   #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 1
+  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if !defined(CYTHON_VECTORCALL)
 #define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
 #endif
@@ -751,16 +787,21 @@
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
   typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
   typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
-  #define __Pyx_PyCFunctionFast _PyCFunctionFast
-  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #if PY_VERSION_HEX >= 0x030d00A4
+  #  define __Pyx_PyCFunctionFast PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords PyCFunctionFastWithKeywords
+  #else
+  #  define __Pyx_PyCFunctionFast _PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #endif
 #endif
 #if CYTHON_METH_FASTCALL
   #define __Pyx_METH_FASTCALL METH_FASTCALL
   #define __Pyx_PyCFunction_FastCall __Pyx_PyCFunctionFast
   #define __Pyx_PyCFunction_FastCallWithKeywords __Pyx_PyCFunctionFastWithKeywords
 #else
   #define __Pyx_METH_FASTCALL METH_VARARGS
@@ -1104,15 +1145,15 @@
   #define __Pyx_PyList_SET_ITEM(o, i, v) PyList_SetItem(o, i, v)
   #define __Pyx_PyTuple_GET_SIZE(o) PyTuple_Size(o)
   #define __Pyx_PyList_GET_SIZE(o) PyList_Size(o)
   #define __Pyx_PySet_GET_SIZE(o) PySet_Size(o)
   #define __Pyx_PyBytes_GET_SIZE(o) PyBytes_Size(o)
   #define __Pyx_PyByteArray_GET_SIZE(o) PyByteArray_Size(o)
 #endif
-#if PY_VERSION_HEX >= 0x030d00A1
+#if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
   #define __Pyx_PyImport_AddModuleRef(name) PyImport_AddModuleRef(name)
 #else
   static CYTHON_INLINE PyObject *__Pyx_PyImport_AddModuleRef(const char *name) {
       PyObject *module = PyImport_AddModule(name);
       Py_XINCREF(module);
       return module;
   }
@@ -1191,15 +1232,15 @@
 #if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
 #define __Pyx_truncl trunc
 #else
 #define __Pyx_truncl truncl
 #endif
 
 #define __PYX_MARK_ERR_POS(f_index, lineno) \
-    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
+    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__;  (void)__pyx_clineno; }
 #define __PYX_ERR(f_index, lineno, Ln_error) \
     { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
 
 #ifdef CYTHON_EXTERN_C
     #undef __PYX_EXTERN_C
     #define __PYX_EXTERN_C CYTHON_EXTERN_C
 #elif defined(__PYX_EXTERN_C)
@@ -1293,32 +1334,15 @@
 #define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
 #define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
 #define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
 #define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
 #define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const wchar_t *u)
-{
-    const wchar_t *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#else
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
-    const Py_UNICODE *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#endif
 #define __Pyx_PyUnicode_FromOrdinal(o)       PyUnicode_FromOrdinal((int)o)
-#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
-#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
@@ -17137,37 +17161,37 @@
   __pyx_v_length = (__pyx_v_indices.shape[0]);
 
   /* "adaXT/criteria/crit_helpers.pyx":26
  *         int length = indices.shape[0]
  * 
  *     for i in range(length):             # <<<<<<<<<<<<<<
  *         sum += lst[indices[i]]
- *     return sum / (<double> length)
+ *     return sum / (< double > length)
  */
   __pyx_t_1 = __pyx_v_length;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
     /* "adaXT/criteria/crit_helpers.pyx":27
  * 
  *     for i in range(length):
  *         sum += lst[indices[i]]             # <<<<<<<<<<<<<<
- *     return sum / (<double> length)
+ *     return sum / (< double > length)
  * 
  */
     __pyx_t_4 = __pyx_v_i;
     __pyx_t_5 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_4 * __pyx_v_indices.strides[0]) )));
     __pyx_v_sum = (__pyx_v_sum + (*((double *) ( /* dim=0 */ (__pyx_v_lst.data + __pyx_t_5 * __pyx_v_lst.strides[0]) ))));
   }
 
   /* "adaXT/criteria/crit_helpers.pyx":28
  *     for i in range(length):
  *         sum += lst[indices[i]]
- *     return sum / (<double> length)             # <<<<<<<<<<<<<<
+ *     return sum / (< double > length)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = (__pyx_v_sum / ((double)__pyx_v_length));
   goto __pyx_L0;
 
   /* "adaXT/criteria/crit_helpers.pyx":3
```

### Comparing `adaXT-1.0.1/src/adaXT/criteria/criteria.cpp` & `adaxt-1.1.0/src/adaXT/criteria/criteria.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,24 @@
-/* Generated by Cython 3.0.8 */
+/* Generated by Cython 3.0.10 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
+        "define_macros": [
+            [
+                "NPY_NO_DEPRECATED_API",
+                "NPY_1_7_API_VERSION"
+            ]
+        ],
         "depends": [],
         "extra_compile_args": [
             "-O3"
         ],
         "include_dirs": [
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include"
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include"
         ],
         "language": "c++",
         "name": "adaXT.criteria.criteria",
         "sources": [
             "src/adaXT/criteria/criteria.pyx"
         ]
     },
@@ -40,18 +46,18 @@
     #error Cython requires Python 2.7+ or Python 3.3+.
 #else
 #if defined(CYTHON_LIMITED_API) && CYTHON_LIMITED_API
 #define __PYX_EXTRA_ABI_MODULE_NAME "limited"
 #else
 #define __PYX_EXTRA_ABI_MODULE_NAME ""
 #endif
-#define CYTHON_ABI "3_0_8" __PYX_EXTRA_ABI_MODULE_NAME
+#define CYTHON_ABI "3_0_10" __PYX_EXTRA_ABI_MODULE_NAME
 #define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
 #define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
-#define CYTHON_HEX_VERSION 0x030008F0
+#define CYTHON_HEX_VERSION 0x03000AF0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -135,14 +141,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(PYPY_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
@@ -196,14 +204,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(CYTHON_LIMITED_API)
   #ifdef Py_LIMITED_API
     #undef __PYX_LIMITED_VERSION_HEX
     #define __PYX_LIMITED_VERSION_HEX Py_LIMITED_API
   #endif
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
@@ -257,60 +267,83 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(Py_GIL_DISABLED) || defined(Py_NOGIL)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_TYPE_SPECS
+    #define CYTHON_USE_TYPE_SPECS 0
+  #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #ifndef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #endif
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #ifndef CYTHON_METH_FASTCALL
+    #define CYTHON_METH_FASTCALL 1
+  #endif
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT 1
   #endif
+  #ifndef CYTHON_USE_MODULE_STATE
+    #define CYTHON_USE_MODULE_STATE 0
+  #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE 1
   #endif
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 0
+  #endif
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
@@ -393,14 +426,17 @@
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK 1
   #endif
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
   #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 1
+  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if !defined(CYTHON_VECTORCALL)
 #define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
 #endif
@@ -752,16 +788,21 @@
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
   typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
   typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
-  #define __Pyx_PyCFunctionFast _PyCFunctionFast
-  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #if PY_VERSION_HEX >= 0x030d00A4
+  #  define __Pyx_PyCFunctionFast PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords PyCFunctionFastWithKeywords
+  #else
+  #  define __Pyx_PyCFunctionFast _PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #endif
 #endif
 #if CYTHON_METH_FASTCALL
   #define __Pyx_METH_FASTCALL METH_FASTCALL
   #define __Pyx_PyCFunction_FastCall __Pyx_PyCFunctionFast
   #define __Pyx_PyCFunction_FastCallWithKeywords __Pyx_PyCFunctionFastWithKeywords
 #else
   #define __Pyx_METH_FASTCALL METH_VARARGS
@@ -1105,15 +1146,15 @@
   #define __Pyx_PyList_SET_ITEM(o, i, v) PyList_SetItem(o, i, v)
   #define __Pyx_PyTuple_GET_SIZE(o) PyTuple_Size(o)
   #define __Pyx_PyList_GET_SIZE(o) PyList_Size(o)
   #define __Pyx_PySet_GET_SIZE(o) PySet_Size(o)
   #define __Pyx_PyBytes_GET_SIZE(o) PyBytes_Size(o)
   #define __Pyx_PyByteArray_GET_SIZE(o) PyByteArray_Size(o)
 #endif
-#if PY_VERSION_HEX >= 0x030d00A1
+#if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
   #define __Pyx_PyImport_AddModuleRef(name) PyImport_AddModuleRef(name)
 #else
   static CYTHON_INLINE PyObject *__Pyx_PyImport_AddModuleRef(const char *name) {
       PyObject *module = PyImport_AddModule(name);
       Py_XINCREF(module);
       return module;
   }
@@ -1192,15 +1233,15 @@
 #if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
 #define __Pyx_truncl trunc
 #else
 #define __Pyx_truncl truncl
 #endif
 
 #define __PYX_MARK_ERR_POS(f_index, lineno) \
-    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
+    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__;  (void)__pyx_clineno; }
 #define __PYX_ERR(f_index, lineno, Ln_error) \
     { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
 
 #ifdef CYTHON_EXTERN_C
     #undef __PYX_EXTERN_C
     #define __PYX_EXTERN_C CYTHON_EXTERN_C
 #elif defined(__PYX_EXTERN_C)
@@ -1295,32 +1336,15 @@
 #define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
 #define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
 #define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
 #define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
 #define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const wchar_t *u)
-{
-    const wchar_t *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#else
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
-    const Py_UNICODE *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#endif
 #define __Pyx_PyUnicode_FromOrdinal(o)       PyUnicode_FromOrdinal((int)o)
-#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
-#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
@@ -1640,50 +1664,23 @@
 struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy;
 struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error;
 struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression;
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
-struct __pyx_ctuple_double__and_double__and_double__and_double;
-typedef struct __pyx_ctuple_double__and_double__and_double__and_double __pyx_ctuple_double__and_double__and_double__and_double;
-struct __pyx_opt_args_5adaXT_8criteria_8criteria_13Squared_error__squared_error;
 struct __pyx_ctuple_double__and_double;
 typedef struct __pyx_ctuple_double__and_double __pyx_ctuple_double__and_double;
 
-/* "adaXT/criteria/criteria.pxd":7
- *         double[::1] sample_weight
- *     cpdef double impurity(self, int[:] indices)
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature)             # <<<<<<<<<<<<<<
- */
-struct __pyx_ctuple_double__and_double__and_double__and_double {
-  double f0;
-  double f1;
-  double f2;
-  double f3;
-};
-
-/* "adaXT/criteria/criteria.pyx":480
- *         return (crit, left_imp, right_imp, mean_thresh)
+/* "adaXT/criteria/criteria.pxd":27
  * 
- *     cdef double _squared_error(self, int[:] indices, int left_or_right = -1):             # <<<<<<<<<<<<<<
- *         """
- *         Function used to calculate the squared error of y[indices]
- */
-struct __pyx_opt_args_5adaXT_8criteria_8criteria_13Squared_error__squared_error {
-  int __pyx_n;
-  int left_or_right;
-};
-
-/* "adaXT/criteria/criteria.pyx":529
- * 
- *     # Custom mean function, such that we don't have to loop through twice.
- *     cdef (double, double) custom_mean(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         cdef:
- *             double sumX, sumY
+ *     cpdef double impurity(self, int[::1] indices)
+ *     cdef (double, double) evaluate_split(self, int[::1] indices, int split_idx, int feature)             # <<<<<<<<<<<<<<
+ *     """
+ *         Function to evaluate how good a split is
  */
 struct __pyx_ctuple_double__and_double {
   double f0;
   double f1;
 };
 
 /* "adaXT/criteria/criteria.pxd":1
@@ -1693,81 +1690,75 @@
  */
 struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria {
   PyObject_HEAD
   struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *__pyx_vtab;
   __Pyx_memviewslice x;
   __Pyx_memviewslice y;
   __Pyx_memviewslice sample_weight;
+  int old_obs;
+  int old_split;
+  int old_feature;
 };
 
 
-/* "adaXT/criteria/criteria.pyx":72
- *         return (crit, left_imp, right_imp, mean_thresh)
+/* "adaXT/criteria/criteria.pyx":69
+ *         return (crit, mean_thresh)
  * 
  * cdef class Gini_index(Criteria):             # <<<<<<<<<<<<<<
  *     cdef:
  *         double[::1] class_labels
  */
 struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index {
   struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria __pyx_base;
   __Pyx_memviewslice class_labels;
-  double *n_in_class_left;
-  double *n_in_class_right;
+  double *weight_in_class_left;
+  double *weight_in_class_right;
   double weight_left;
   double weight_right;
   int num_classes;
-  int old_obs;
-  int old_split;
-  int old_feature;
+  int first_call;
 };
 
 
-/* "adaXT/criteria/criteria.pyx":232
- *         return (crit, left_imp, right_imp, mean_thresh)
+/* "adaXT/criteria/criteria.pyx":222
+ * 
  * 
  * cdef class Entropy(Criteria):             # <<<<<<<<<<<<<<
  *     cdef:
  *         double[::1] class_labels
  */
 struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy {
   struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria __pyx_base;
   __Pyx_memviewslice class_labels;
-  double *n_in_class_left;
-  double *n_in_class_right;
+  double *weight_in_class_left;
+  double *weight_in_class_right;
   double weight_left;
   double weight_right;
   int num_classes;
-  int old_obs;
-  int old_split;
-  int old_feature;
+  int first_call;
 };
 
 
-/* "adaXT/criteria/criteria.pyx":393
- *         return (crit, left_imp, right_imp, mean_thresh)
+/* "adaXT/criteria/criteria.pyx":382
+ * 
  * 
  * cdef class Squared_error(Criteria):             # <<<<<<<<<<<<<<
  *     cdef:
- *         double old_left_square_sum
+ *         double left_sum
  */
 struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error {
   struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria __pyx_base;
-  double old_left_square_sum;
-  double old_left_sum;
-  double old_right_square_sum;
-  double old_right_sum;
+  double left_sum;
+  double right_sum;
   double weight_left;
   double weight_right;
-  int old_obs;
-  int old_split;
-  int old_feature;
 };
 
 
-/* "adaXT/criteria/criteria.pyx":526
+/* "adaXT/criteria/criteria.pyx":470
  *         return square_err
  * 
  * cdef class Linear_regression(Criteria):             # <<<<<<<<<<<<<<
  * 
  *     # Custom mean function, such that we don't have to loop through twice.
  */
 struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression {
@@ -1848,83 +1839,79 @@
   PyObject *from_object;
   PyObject *(*to_object_func)(char *);
   int (*to_dtype_func)(char *, PyObject *);
 };
 
 
 
-/* "adaXT/criteria/criteria.pyx":8
+/* "adaXT/criteria/criteria.pyx":9
  * from .crit_helpers cimport weighted_mean
  * 
  * cdef class Criteria:             # <<<<<<<<<<<<<<
+ * 
  *     def __cinit__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):
- *         self.x = x
  */
 
 struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria {
+  double (*proxy_improvement)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int);
+  double (*update_proxy)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int);
   double (*impurity)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int __pyx_skip_dispatch);
-  __pyx_ctuple_double__and_double__and_double__and_double (*evaluate_split)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int, int);
+  __pyx_ctuple_double__and_double (*evaluate_split)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int, int);
 };
 static struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *__pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria;
 
 
-/* "adaXT/criteria/criteria.pyx":72
- *         return (crit, left_imp, right_imp, mean_thresh)
+/* "adaXT/criteria/criteria.pyx":69
+ *         return (crit, mean_thresh)
  * 
  * cdef class Gini_index(Criteria):             # <<<<<<<<<<<<<<
  *     cdef:
  *         double[::1] class_labels
  */
 
 struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index {
   struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria __pyx_base;
-  void (*reset_n_in_class)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, double *);
-  double (*_gini)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, __Pyx_memviewslice, double *, int);
-  double (*update_left)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, __Pyx_memviewslice, int);
-  double (*update_right)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, __Pyx_memviewslice, int);
+  void (*reset_weight_list)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, double *);
+  double (*_gini)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, __Pyx_memviewslice, double *);
 };
 static struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *__pyx_vtabptr_5adaXT_8criteria_8criteria_Gini_index;
 
 
-/* "adaXT/criteria/criteria.pyx":232
- *         return (crit, left_imp, right_imp, mean_thresh)
+/* "adaXT/criteria/criteria.pyx":222
+ * 
  * 
  * cdef class Entropy(Criteria):             # <<<<<<<<<<<<<<
  *     cdef:
  *         double[::1] class_labels
  */
 
 struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy {
   struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria __pyx_base;
-  void (*reset_n_in_class)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, double *);
-  double (*_entropy)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, __Pyx_memviewslice, double *, int);
-  double (*update_left)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, __Pyx_memviewslice, int);
-  double (*update_right)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, __Pyx_memviewslice, int);
+  void (*reset_weight_list)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, double *);
+  double (*_entropy)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, __Pyx_memviewslice, double *);
 };
 static struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *__pyx_vtabptr_5adaXT_8criteria_8criteria_Entropy;
 
 
-/* "adaXT/criteria/criteria.pyx":393
- *         return (crit, left_imp, right_imp, mean_thresh)
+/* "adaXT/criteria/criteria.pyx":382
+ * 
  * 
  * cdef class Squared_error(Criteria):             # <<<<<<<<<<<<<<
  *     cdef:
- *         double old_left_square_sum
+ *         double left_sum
  */
 
 struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Squared_error {
   struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria __pyx_base;
-  double (*update_left)(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *, __Pyx_memviewslice, int);
-  double (*update_right)(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *, __Pyx_memviewslice, int);
-  double (*_squared_error)(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *, __Pyx_memviewslice, struct __pyx_opt_args_5adaXT_8criteria_8criteria_13Squared_error__squared_error *__pyx_optional_args);
+  double (*_squared_error)(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *, __Pyx_memviewslice);
 };
 static struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Squared_error *__pyx_vtabptr_5adaXT_8criteria_8criteria_Squared_error;
 
 
-/* "adaXT/criteria/criteria.pyx":526
+/* "adaXT/criteria/criteria.pyx":470
  *         return square_err
  * 
  * cdef class Linear_regression(Criteria):             # <<<<<<<<<<<<<<
  * 
  *     # Custom mean function, such that we don't have to loop through twice.
  */
 
@@ -2853,18 +2840,15 @@
 /* ObjectToMemviewSlice.proto */
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(PyObject *, int writable_flag);
 
 /* ObjectToMemviewSlice.proto */
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_double(PyObject *, int writable_flag);
 
 /* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_int(PyObject *, int writable_flag);
-
-/* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_double(PyObject *, int writable_flag);
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_int(PyObject *, int writable_flag);
 
 /* MemviewDtypeToObject.proto */
 static CYTHON_INLINE PyObject *__pyx_memview_get_int(const char *itemp);
 static CYTHON_INLINE int __pyx_memview_set_int(const char *itemp, PyObject *obj);
 
 /* MemviewDtypeToObject.proto */
 static CYTHON_INLINE PyObject *__pyx_memview_get_double(const char *itemp);
@@ -2934,15 +2918,15 @@
 #endif
 
 /* CheckBinaryVersion.proto */
 static unsigned long __Pyx_get_runtime_version(void);
 static int __Pyx_check_binary_version(unsigned long ct_version, unsigned long rt_version, int allow_newer);
 
 /* FunctionImport.proto */
-static int __Pyx_ImportFunction_3_0_8(PyObject *module, const char *funcname, void (**f)(void), const char *sig);
+static int __Pyx_ImportFunction_3_0_10(PyObject *module, const char *funcname, void (**f)(void), const char *sig);
 
 /* InitStrings.proto */
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
 
 /* #### Code section: module_declarations ### */
 static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *__pyx_v_self); /* proto*/
 static char *__pyx_memoryview_get_item_pointer(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index); /* proto*/
@@ -2952,33 +2936,32 @@
 static PyObject *__pyx_memoryview_setitem_indexed(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryview_convert_item_to_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp); /* proto*/
 static PyObject *__pyx_memoryview_assign_item_from_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryview__get_base(struct __pyx_memoryview_obj *__pyx_v_self); /* proto*/
 static PyObject *__pyx_memoryviewslice_convert_item_to_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp); /* proto*/
 static PyObject *__pyx_memoryviewslice_assign_item_from_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryviewslice__get_base(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_8Criteria_update_proxy(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_8Criteria_proxy_improvement(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx); /* proto*/
 static double __pyx_f_5adaXT_8criteria_8criteria_8Criteria_impurity(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_indices, int __pyx_skip_dispatch); /* proto*/
-static __pyx_ctuple_double__and_double__and_double__and_double __pyx_f_5adaXT_8criteria_8criteria_8Criteria_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature); /* proto*/
+static __pyx_ctuple_double__and_double __pyx_f_5adaXT_8criteria_8criteria_8Criteria_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature); /* proto*/
+static void __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_reset_weight_list(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, double *__pyx_v_class_occurences); /* proto*/
 static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_skip_dispatch); /* proto*/
-static void __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_reset_n_in_class(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, double *__pyx_v_class_occurences); /* proto*/
-static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index__gini(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, double *__pyx_v_class_occurences, int __pyx_v_left_or_right); /* proto*/
-static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_update_left(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split); /* proto*/
-static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_update_right(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split); /* proto*/
-static __pyx_ctuple_double__and_double__and_double__and_double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index__gini(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, double *__pyx_v_class_occurences); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_update_proxy(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_proxy_improvement(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx); /* proto*/
 static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_skip_dispatch); /* proto*/
-static void __pyx_f_5adaXT_8criteria_8criteria_7Entropy_reset_n_in_class(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, double *__pyx_v_class_occurences); /* proto*/
-static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy__entropy(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, double *__pyx_v_class_occurences, int __pyx_v_left_or_right); /* proto*/
-static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_update_left(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split); /* proto*/
-static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_update_right(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split); /* proto*/
-static __pyx_ctuple_double__and_double__and_double__and_double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature); /* proto*/
-static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_update_left(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split); /* proto*/
-static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_update_right(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split); /* proto*/
+static void __pyx_f_5adaXT_8criteria_8criteria_7Entropy_reset_weight_list(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, double *__pyx_v_class_occurences); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy__entropy(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, double *__pyx_v_class_occurences); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_proxy_improvement(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_update_proxy(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_update_proxy(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_proxy_improvement(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx); /* proto*/
 static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_skip_dispatch); /* proto*/
-static __pyx_ctuple_double__and_double__and_double__and_double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature); /* proto*/
-static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error__squared_error(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, struct __pyx_opt_args_5adaXT_8criteria_8criteria_13Squared_error__squared_error *__pyx_optional_args); /* proto*/
+static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error__squared_error(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices); /* proto*/
 static __pyx_ctuple_double__and_double __pyx_f_5adaXT_8criteria_8criteria_17Linear_regression_custom_mean(struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices); /* proto*/
 static __pyx_ctuple_double__and_double __pyx_f_5adaXT_8criteria_8criteria_17Linear_regression_theta(struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices); /* proto*/
 static double __pyx_f_5adaXT_8criteria_8criteria_17Linear_regression_impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_skip_dispatch); /* proto*/
 
 /* Module declarations from "libc.math" */
 
 /* Module declarations from "libc.string" */
@@ -3251,18 +3234,17 @@
 static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_10Gini_index_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_10Gini_index_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static int __pyx_pf_5adaXT_8criteria_8criteria_7Entropy___init__(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_x, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_y, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_sample_weight); /* proto */
 static void __pyx_pf_5adaXT_8criteria_8criteria_7Entropy_2__del__(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_7Entropy_4impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices); /* proto */
 static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_7Entropy_6__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_7Entropy_8__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
-static int __pyx_pf_5adaXT_8criteria_8criteria_13Squared_error___init__(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_x, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_y, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_sample_weight); /* proto */
-static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_2impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices); /* proto */
-static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_4__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_6__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
+static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices); /* proto */
+static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_17Linear_regression_impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices); /* proto */
 static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_17Linear_regression_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_17Linear_regression_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_tp_new_5adaXT_8criteria_8criteria_Criteria(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_5adaXT_8criteria_8criteria_Gini_index(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_5adaXT_8criteria_8criteria_Entropy(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_5adaXT_8criteria_8criteria_Squared_error(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
@@ -3347,15 +3329,15 @@
   PyObject *__pyx_n_s_Entropy___reduce_cython;
   PyObject *__pyx_n_s_Entropy___setstate_cython;
   PyObject *__pyx_n_s_Entropy_impurity;
   PyObject *__pyx_n_s_Gini_index;
   PyObject *__pyx_n_s_Gini_index___reduce_cython;
   PyObject *__pyx_n_s_Gini_index___setstate_cython;
   PyObject *__pyx_n_s_Gini_index_impurity;
-  PyObject *__pyx_kp_s_Impurity_must_be_implemented;
+  PyObject *__pyx_kp_u_Impurity_must_be_implemented;
   PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
   PyObject *__pyx_n_s_IndexError;
   PyObject *__pyx_kp_s_Index_out_of_bounds_axis_d;
   PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
   PyObject *__pyx_kp_u_Invalid_mode_expected_c_or_fortr;
   PyObject *__pyx_kp_u_Invalid_shape_in_axis;
   PyObject *__pyx_n_s_Linear_regression;
@@ -3596,15 +3578,15 @@
   Py_CLEAR(clear_module_state->__pyx_n_s_Entropy___reduce_cython);
   Py_CLEAR(clear_module_state->__pyx_n_s_Entropy___setstate_cython);
   Py_CLEAR(clear_module_state->__pyx_n_s_Entropy_impurity);
   Py_CLEAR(clear_module_state->__pyx_n_s_Gini_index);
   Py_CLEAR(clear_module_state->__pyx_n_s_Gini_index___reduce_cython);
   Py_CLEAR(clear_module_state->__pyx_n_s_Gini_index___setstate_cython);
   Py_CLEAR(clear_module_state->__pyx_n_s_Gini_index_impurity);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Impurity_must_be_implemented);
+  Py_CLEAR(clear_module_state->__pyx_kp_u_Impurity_must_be_implemented);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
   Py_CLEAR(clear_module_state->__pyx_n_s_IndexError);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_shape_in_axis);
   Py_CLEAR(clear_module_state->__pyx_n_s_Linear_regression);
@@ -3823,15 +3805,15 @@
   Py_VISIT(traverse_module_state->__pyx_n_s_Entropy___reduce_cython);
   Py_VISIT(traverse_module_state->__pyx_n_s_Entropy___setstate_cython);
   Py_VISIT(traverse_module_state->__pyx_n_s_Entropy_impurity);
   Py_VISIT(traverse_module_state->__pyx_n_s_Gini_index);
   Py_VISIT(traverse_module_state->__pyx_n_s_Gini_index___reduce_cython);
   Py_VISIT(traverse_module_state->__pyx_n_s_Gini_index___setstate_cython);
   Py_VISIT(traverse_module_state->__pyx_n_s_Gini_index_impurity);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Impurity_must_be_implemented);
+  Py_VISIT(traverse_module_state->__pyx_kp_u_Impurity_must_be_implemented);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
   Py_VISIT(traverse_module_state->__pyx_n_s_IndexError);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_shape_in_axis);
   Py_VISIT(traverse_module_state->__pyx_n_s_Linear_regression);
@@ -4068,15 +4050,15 @@
 #define __pyx_n_s_Entropy___reduce_cython __pyx_mstate_global->__pyx_n_s_Entropy___reduce_cython
 #define __pyx_n_s_Entropy___setstate_cython __pyx_mstate_global->__pyx_n_s_Entropy___setstate_cython
 #define __pyx_n_s_Entropy_impurity __pyx_mstate_global->__pyx_n_s_Entropy_impurity
 #define __pyx_n_s_Gini_index __pyx_mstate_global->__pyx_n_s_Gini_index
 #define __pyx_n_s_Gini_index___reduce_cython __pyx_mstate_global->__pyx_n_s_Gini_index___reduce_cython
 #define __pyx_n_s_Gini_index___setstate_cython __pyx_mstate_global->__pyx_n_s_Gini_index___setstate_cython
 #define __pyx_n_s_Gini_index_impurity __pyx_mstate_global->__pyx_n_s_Gini_index_impurity
-#define __pyx_kp_s_Impurity_must_be_implemented __pyx_mstate_global->__pyx_kp_s_Impurity_must_be_implemented
+#define __pyx_kp_u_Impurity_must_be_implemented __pyx_mstate_global->__pyx_kp_u_Impurity_must_be_implemented
 #define __pyx_kp_s_Incompatible_checksums_0x_x_vs_0 __pyx_mstate_global->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0
 #define __pyx_n_s_IndexError __pyx_mstate_global->__pyx_n_s_IndexError
 #define __pyx_kp_s_Index_out_of_bounds_axis_d __pyx_mstate_global->__pyx_kp_s_Index_out_of_bounds_axis_d
 #define __pyx_kp_s_Indirect_dimensions_not_supporte __pyx_mstate_global->__pyx_kp_s_Indirect_dimensions_not_supporte
 #define __pyx_kp_u_Invalid_mode_expected_c_or_fortr __pyx_mstate_global->__pyx_kp_u_Invalid_mode_expected_c_or_fortr
 #define __pyx_kp_u_Invalid_shape_in_axis __pyx_mstate_global->__pyx_kp_u_Invalid_shape_in_axis
 #define __pyx_n_s_Linear_regression __pyx_mstate_global->__pyx_n_s_Linear_regression
@@ -17860,17 +17842,17 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":9
- * 
+/* "adaXT/criteria/criteria.pyx":11
  * cdef class Criteria:
+ * 
  *     def __cinit__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):             # <<<<<<<<<<<<<<
  *         self.x = x
  *         self.y = y
  */
 
 /* Python wrapper */
 static int __pyx_pw_5adaXT_8criteria_8criteria_8Criteria_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
@@ -17910,55 +17892,55 @@
       kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_x)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 9, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 11, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_y)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 9, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 11, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 1); __PYX_ERR(1, 9, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 1); __PYX_ERR(1, 11, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_sample_weight)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[2]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 9, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 11, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 2); __PYX_ERR(1, 9, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 2); __PYX_ERR(1, 11, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__cinit__") < 0)) __PYX_ERR(1, 9, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__cinit__") < 0)) __PYX_ERR(1, 11, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 3)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
       values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
       values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
     }
-    __pyx_v_x = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_x.memview)) __PYX_ERR(1, 9, __pyx_L3_error)
-    __pyx_v_y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_y.memview)) __PYX_ERR(1, 9, __pyx_L3_error)
-    __pyx_v_sample_weight = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[2], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sample_weight.memview)) __PYX_ERR(1, 9, __pyx_L3_error)
+    __pyx_v_x = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_x.memview)) __PYX_ERR(1, 11, __pyx_L3_error)
+    __pyx_v_y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_y.memview)) __PYX_ERR(1, 11, __pyx_L3_error)
+    __pyx_v_sample_weight = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[2], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sample_weight.memview)) __PYX_ERR(1, 11, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, __pyx_nargs); __PYX_ERR(1, 9, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, __pyx_nargs); __PYX_ERR(1, 11, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
@@ -17986,64 +17968,447 @@
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_5adaXT_8criteria_8criteria_8Criteria___cinit__(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, __Pyx_memviewslice __pyx_v_x, __Pyx_memviewslice __pyx_v_y, __Pyx_memviewslice __pyx_v_sample_weight) {
   int __pyx_r;
 
-  /* "adaXT/criteria/criteria.pyx":10
- * cdef class Criteria:
+  /* "adaXT/criteria/criteria.pyx":12
+ * 
  *     def __cinit__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):
  *         self.x = x             # <<<<<<<<<<<<<<
  *         self.y = y
  *         self.sample_weight = sample_weight
  */
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->x, 0);
   __PYX_INC_MEMVIEW(&__pyx_v_x, 1);
   __pyx_v_self->x = __pyx_v_x;
 
-  /* "adaXT/criteria/criteria.pyx":11
+  /* "adaXT/criteria/criteria.pyx":13
  *     def __cinit__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):
  *         self.x = x
  *         self.y = y             # <<<<<<<<<<<<<<
  *         self.sample_weight = sample_weight
- * 
+ *         self.old_obs = -1
  */
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->y, 0);
   __PYX_INC_MEMVIEW(&__pyx_v_y, 1);
   __pyx_v_self->y = __pyx_v_y;
 
-  /* "adaXT/criteria/criteria.pyx":12
+  /* "adaXT/criteria/criteria.pyx":14
  *         self.x = x
  *         self.y = y
  *         self.sample_weight = sample_weight             # <<<<<<<<<<<<<<
- * 
- *     cpdef double impurity(self, int[:] indices):
+ *         self.old_obs = -1
+ *         self.old_feature = -1
  */
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->sample_weight, 0);
   __PYX_INC_MEMVIEW(&__pyx_v_sample_weight, 1);
   __pyx_v_self->sample_weight = __pyx_v_sample_weight;
 
-  /* "adaXT/criteria/criteria.pyx":9
+  /* "adaXT/criteria/criteria.pyx":15
+ *         self.y = y
+ *         self.sample_weight = sample_weight
+ *         self.old_obs = -1             # <<<<<<<<<<<<<<
+ *         self.old_feature = -1
+ * 
+ */
+  __pyx_v_self->old_obs = -1;
+
+  /* "adaXT/criteria/criteria.pyx":16
+ *         self.sample_weight = sample_weight
+ *         self.old_obs = -1
+ *         self.old_feature = -1             # <<<<<<<<<<<<<<
  * 
+ *     cdef double update_proxy(self, int[::1] indices, int split_idx):
+ */
+  __pyx_v_self->old_feature = -1;
+
+  /* "adaXT/criteria/criteria.pyx":11
  * cdef class Criteria:
+ * 
  *     def __cinit__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):             # <<<<<<<<<<<<<<
  *         self.x = x
  *         self.y = y
  */
 
   /* function exit code */
   __pyx_r = 0;
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":14
- *         self.sample_weight = sample_weight
+/* "adaXT/criteria/criteria.pyx":18
+ *         self.old_feature = -1
+ * 
+ *     cdef double update_proxy(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
+ *         return self.proxy_improvement(indices, split_idx)
+ * 
+ */
+
+static double __pyx_f_5adaXT_8criteria_8criteria_8Criteria_update_proxy(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx) {
+  double __pyx_r;
+  double __pyx_t_1;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+
+  /* "adaXT/criteria/criteria.pyx":19
+ * 
+ *     cdef double update_proxy(self, int[::1] indices, int split_idx):
+ *         return self.proxy_improvement(indices, split_idx)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):
+ */
+  __pyx_t_1 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->__pyx_vtab)->proxy_improvement(__pyx_v_self, __pyx_v_indices, __pyx_v_split_idx); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 19, __pyx_L1_error)
+  __pyx_r = __pyx_t_1;
+  goto __pyx_L0;
+
+  /* "adaXT/criteria/criteria.pyx":18
+ *         self.old_feature = -1
+ * 
+ *     cdef double update_proxy(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
+ *         return self.proxy_improvement(indices, split_idx)
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_AddTraceback("adaXT.criteria.criteria.Criteria.update_proxy", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  return __pyx_r;
+}
+
+/* "adaXT/criteria/criteria.pyx":21
+ *         return self.proxy_improvement(indices, split_idx)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             double left_imp = 0.0
+ */
+
+static double __pyx_f_5adaXT_8criteria_8criteria_8Criteria_proxy_improvement(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx) {
+  double __pyx_v_left_imp;
+  double __pyx_v_right_imp;
+  double __pyx_v_crit;
+  __Pyx_memviewslice __pyx_v_left_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_right_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_v_n_left;
+  int __pyx_v_n_right;
+  double __pyx_r;
+  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_t_2;
+  int __pyx_t_3;
+  double __pyx_t_4;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+
+  /* "adaXT/criteria/criteria.pyx":23
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):
+ *         cdef:
+ *             double left_imp = 0.0             # <<<<<<<<<<<<<<
+ *             double right_imp = 0.0
+ *             double crit = 0.0
+ */
+  __pyx_v_left_imp = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":24
+ *         cdef:
+ *             double left_imp = 0.0
+ *             double right_imp = 0.0             # <<<<<<<<<<<<<<
+ *             double crit = 0.0
+ *             int[::1] left_indices = indices[:split_idx]
+ */
+  __pyx_v_right_imp = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":25
+ *             double left_imp = 0.0
+ *             double right_imp = 0.0
+ *             double crit = 0.0             # <<<<<<<<<<<<<<
+ *             int[::1] left_indices = indices[:split_idx]
+ *             int[::1] right_indices = indices[split_idx:]
+ */
+  __pyx_v_crit = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":26
+ *             double right_imp = 0.0
+ *             double crit = 0.0
+ *             int[::1] left_indices = indices[:split_idx]             # <<<<<<<<<<<<<<
+ *             int[::1] right_indices = indices[split_idx:]
+ *             int n_left = left_indices.shape[0]
+ */
+  __pyx_t_1.data = __pyx_v_indices.data;
+  __pyx_t_1.memview = __pyx_v_indices.memview;
+  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_t_2 = -1;
+  if (unlikely(__pyx_memoryview_slice_memviewslice(
+    &__pyx_t_1,
+    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
+    0,
+    0,
+    &__pyx_t_2,
+    0,
+    __pyx_v_split_idx,
+    0,
+    0,
+    1,
+    0,
+    1) < 0))
+{
+    __PYX_ERR(1, 26, __pyx_L1_error)
+}
+
+__pyx_v_left_indices = __pyx_t_1;
+  __pyx_t_1.memview = NULL;
+  __pyx_t_1.data = NULL;
+
+  /* "adaXT/criteria/criteria.pyx":27
+ *             double crit = 0.0
+ *             int[::1] left_indices = indices[:split_idx]
+ *             int[::1] right_indices = indices[split_idx:]             # <<<<<<<<<<<<<<
+ *             int n_left = left_indices.shape[0]
+ *             int n_right = right_indices.shape[0]
+ */
+  __pyx_t_1.data = __pyx_v_indices.data;
+  __pyx_t_1.memview = __pyx_v_indices.memview;
+  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_t_2 = -1;
+  if (unlikely(__pyx_memoryview_slice_memviewslice(
+    &__pyx_t_1,
+    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
+    0,
+    0,
+    &__pyx_t_2,
+    __pyx_v_split_idx,
+    0,
+    0,
+    1,
+    0,
+    0,
+    1) < 0))
+{
+    __PYX_ERR(1, 27, __pyx_L1_error)
+}
+
+__pyx_v_right_indices = __pyx_t_1;
+  __pyx_t_1.memview = NULL;
+  __pyx_t_1.data = NULL;
+
+  /* "adaXT/criteria/criteria.pyx":28
+ *             int[::1] left_indices = indices[:split_idx]
+ *             int[::1] right_indices = indices[split_idx:]
+ *             int n_left = left_indices.shape[0]             # <<<<<<<<<<<<<<
+ *             int n_right = right_indices.shape[0]
+ * 
+ */
+  __pyx_v_n_left = (__pyx_v_left_indices.shape[0]);
+
+  /* "adaXT/criteria/criteria.pyx":29
+ *             int[::1] right_indices = indices[split_idx:]
+ *             int n_left = left_indices.shape[0]
+ *             int n_right = right_indices.shape[0]             # <<<<<<<<<<<<<<
+ * 
+ *         left_indices = indices[:split_idx]
+ */
+  __pyx_v_n_right = (__pyx_v_right_indices.shape[0]);
+
+  /* "adaXT/criteria/criteria.pyx":31
+ *             int n_right = right_indices.shape[0]
+ * 
+ *         left_indices = indices[:split_idx]             # <<<<<<<<<<<<<<
+ *         right_indices = indices[split_idx:]
+ *         n_left = left_indices.shape[0]
+ */
+  __pyx_t_1.data = __pyx_v_indices.data;
+  __pyx_t_1.memview = __pyx_v_indices.memview;
+  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_t_2 = -1;
+  if (unlikely(__pyx_memoryview_slice_memviewslice(
+    &__pyx_t_1,
+    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
+    0,
+    0,
+    &__pyx_t_2,
+    0,
+    __pyx_v_split_idx,
+    0,
+    0,
+    1,
+    0,
+    1) < 0))
+{
+    __PYX_ERR(1, 31, __pyx_L1_error)
+}
+
+__PYX_XCLEAR_MEMVIEW(&__pyx_v_left_indices, 1);
+  __pyx_v_left_indices = __pyx_t_1;
+  __pyx_t_1.memview = NULL;
+  __pyx_t_1.data = NULL;
+
+  /* "adaXT/criteria/criteria.pyx":32
+ * 
+ *         left_indices = indices[:split_idx]
+ *         right_indices = indices[split_idx:]             # <<<<<<<<<<<<<<
+ *         n_left = left_indices.shape[0]
+ *         n_right = right_indices.shape[0]
+ */
+  __pyx_t_1.data = __pyx_v_indices.data;
+  __pyx_t_1.memview = __pyx_v_indices.memview;
+  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_t_2 = -1;
+  if (unlikely(__pyx_memoryview_slice_memviewslice(
+    &__pyx_t_1,
+    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
+    0,
+    0,
+    &__pyx_t_2,
+    __pyx_v_split_idx,
+    0,
+    0,
+    1,
+    0,
+    0,
+    1) < 0))
+{
+    __PYX_ERR(1, 32, __pyx_L1_error)
+}
+
+__PYX_XCLEAR_MEMVIEW(&__pyx_v_right_indices, 1);
+  __pyx_v_right_indices = __pyx_t_1;
+  __pyx_t_1.memview = NULL;
+  __pyx_t_1.data = NULL;
+
+  /* "adaXT/criteria/criteria.pyx":33
+ *         left_indices = indices[:split_idx]
+ *         right_indices = indices[split_idx:]
+ *         n_left = left_indices.shape[0]             # <<<<<<<<<<<<<<
+ *         n_right = right_indices.shape[0]
+ * 
+ */
+  __pyx_v_n_left = (__pyx_v_left_indices.shape[0]);
+
+  /* "adaXT/criteria/criteria.pyx":34
+ *         right_indices = indices[split_idx:]
+ *         n_left = left_indices.shape[0]
+ *         n_right = right_indices.shape[0]             # <<<<<<<<<<<<<<
+ * 
+ *         # calculate criteria value on the left dataset
+ */
+  __pyx_v_n_right = (__pyx_v_right_indices.shape[0]);
+
+  /* "adaXT/criteria/criteria.pyx":37
+ * 
+ *         # calculate criteria value on the left dataset
+ *         if n_left != 0.0:             # <<<<<<<<<<<<<<
+ *             left_imp = self.impurity(left_indices)
+ *         crit = left_imp * (<double > n_left)
+ */
+  __pyx_t_3 = (__pyx_v_n_left != 0.0);
+  if (__pyx_t_3) {
+
+    /* "adaXT/criteria/criteria.pyx":38
+ *         # calculate criteria value on the left dataset
+ *         if n_left != 0.0:
+ *             left_imp = self.impurity(left_indices)             # <<<<<<<<<<<<<<
+ *         crit = left_imp * (<double > n_left)
+ * 
+ */
+    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->__pyx_vtab)->impurity(__pyx_v_self, __pyx_v_left_indices, 0); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 38, __pyx_L1_error)
+    __pyx_v_left_imp = __pyx_t_4;
+
+    /* "adaXT/criteria/criteria.pyx":37
+ * 
+ *         # calculate criteria value on the left dataset
+ *         if n_left != 0.0:             # <<<<<<<<<<<<<<
+ *             left_imp = self.impurity(left_indices)
+ *         crit = left_imp * (<double > n_left)
+ */
+  }
+
+  /* "adaXT/criteria/criteria.pyx":39
+ *         if n_left != 0.0:
+ *             left_imp = self.impurity(left_indices)
+ *         crit = left_imp * (<double > n_left)             # <<<<<<<<<<<<<<
+ * 
+ *         # calculate criteria value on the right dataset
+ */
+  __pyx_v_crit = (__pyx_v_left_imp * ((double)__pyx_v_n_left));
+
+  /* "adaXT/criteria/criteria.pyx":42
+ * 
+ *         # calculate criteria value on the right dataset
+ *         if n_right != 0.0:             # <<<<<<<<<<<<<<
+ *             right_imp = self.impurity(right_indices)
+ *         crit += (right_imp) * (<double> n_right)
+ */
+  __pyx_t_3 = (__pyx_v_n_right != 0.0);
+  if (__pyx_t_3) {
+
+    /* "adaXT/criteria/criteria.pyx":43
+ *         # calculate criteria value on the right dataset
+ *         if n_right != 0.0:
+ *             right_imp = self.impurity(right_indices)             # <<<<<<<<<<<<<<
+ *         crit += (right_imp) * (<double> n_right)
+ * 
+ */
+    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->__pyx_vtab)->impurity(__pyx_v_self, __pyx_v_right_indices, 0); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 43, __pyx_L1_error)
+    __pyx_v_right_imp = __pyx_t_4;
+
+    /* "adaXT/criteria/criteria.pyx":42
+ * 
+ *         # calculate criteria value on the right dataset
+ *         if n_right != 0.0:             # <<<<<<<<<<<<<<
+ *             right_imp = self.impurity(right_indices)
+ *         crit += (right_imp) * (<double> n_right)
+ */
+  }
+
+  /* "adaXT/criteria/criteria.pyx":44
+ *         if n_right != 0.0:
+ *             right_imp = self.impurity(right_indices)
+ *         crit += (right_imp) * (<double> n_right)             # <<<<<<<<<<<<<<
+ * 
+ *         return crit
+ */
+  __pyx_v_crit = (__pyx_v_crit + (__pyx_v_right_imp * ((double)__pyx_v_n_right)));
+
+  /* "adaXT/criteria/criteria.pyx":46
+ *         crit += (right_imp) * (<double> n_right)
+ * 
+ *         return crit             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef double impurity(self, int[::1] indices):
+ */
+  __pyx_r = __pyx_v_crit;
+  goto __pyx_L0;
+
+  /* "adaXT/criteria/criteria.pyx":21
+ *         return self.proxy_improvement(indices, split_idx)
+ * 
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             double left_imp = 0.0
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __Pyx_AddTraceback("adaXT.criteria.criteria.Criteria.proxy_improvement", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
+  __pyx_L0:;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_left_indices, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_right_indices, 1);
+  return __pyx_r;
+}
+
+/* "adaXT/criteria/criteria.pyx":48
+ *         return crit
+ * 
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         raise Exception("Impurity must be implemented!")
  * 
  */
 
 static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_8Criteria_3impurity(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
@@ -18070,18 +18435,18 @@
   /* Check if overridden in Python */
   else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || __Pyx_PyType_HasFeature(Py_TYPE(((PyObject *)__pyx_v_self)), (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
     #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
     if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
       PY_UINT64_T __pyx_typedict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
       #endif
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 14, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 48, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_8criteria_8criteria_8Criteria_3impurity)) {
-        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 14, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 48, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
         __pyx_t_6 = 0;
         #if CYTHON_UNPACK_METHODS
         if (unlikely(PyMethod_Check(__pyx_t_4))) {
           __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
@@ -18095,19 +18460,19 @@
         }
         #endif
         {
           PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_t_3};
           __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
           __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 14, __pyx_L1_error)
+          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 48, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_2);
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
         }
-        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 14, __pyx_L1_error)
+        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
         __pyx_r = __pyx_t_7;
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         goto __pyx_L0;
       }
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
       __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
@@ -18118,31 +18483,31 @@
       #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     }
     #endif
   }
 
-  /* "adaXT/criteria/criteria.pyx":15
+  /* "adaXT/criteria/criteria.pyx":49
  * 
- *     cpdef double impurity(self, int[:] indices):
+ *     cpdef double impurity(self, int[::1] indices):
  *         raise Exception("Impurity must be implemented!")             # <<<<<<<<<<<<<<
  * 
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):
+ *     cdef (double, double) evaluate_split(self, int[::1] indices, int split_idx, int feature):
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 15, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])), __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 49, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(1, 15, __pyx_L1_error)
+  __PYX_ERR(1, 49, __pyx_L1_error)
 
-  /* "adaXT/criteria/criteria.pyx":14
- *         self.sample_weight = sample_weight
+  /* "adaXT/criteria/criteria.pyx":48
+ *         return crit
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         raise Exception("Impurity must be implemented!")
  * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
@@ -18206,31 +18571,31 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 14, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 14, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 48, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_ds_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 14, __pyx_L3_error)
+    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 48, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 14, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 48, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -18261,16 +18626,16 @@
   double __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("impurity", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_8Criteria_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 14, __pyx_L1_error)
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 14, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_8Criteria_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 48, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 48, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -18279,388 +18644,168 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":17
+/* "adaXT/criteria/criteria.pyx":51
  *         raise Exception("Impurity must be implemented!")
  * 
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
- *         """
- *         Function to evaluate how good a split is
+ *     cdef (double, double) evaluate_split(self, int[::1] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             double mean_thresh
  */
 
-static __pyx_ctuple_double__and_double__and_double__and_double __pyx_f_5adaXT_8criteria_8criteria_8Criteria_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature) {
+static __pyx_ctuple_double__and_double __pyx_f_5adaXT_8criteria_8criteria_8Criteria_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature) {
   double __pyx_v_mean_thresh;
-  double __pyx_v_left_imp;
-  double __pyx_v_right_imp;
+  int __pyx_v_n_obs;
   double __pyx_v_crit;
-  int __pyx_v_n_indices;
-  __Pyx_memviewslice __pyx_v_features = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_left_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_v_right_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_v_n_left;
-  int __pyx_v_n_right;
-  __pyx_ctuple_double__and_double__and_double__and_double __pyx_r;
-  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __Pyx_memviewslice __pyx_t_2 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_t_3;
-  int __pyx_t_4;
-  double __pyx_t_5;
+  __pyx_ctuple_double__and_double __pyx_r;
+  int __pyx_t_1;
+  int __pyx_t_2;
+  double __pyx_t_3;
+  Py_ssize_t __pyx_t_4;
+  Py_ssize_t __pyx_t_5;
   Py_ssize_t __pyx_t_6;
   Py_ssize_t __pyx_t_7;
   Py_ssize_t __pyx_t_8;
   Py_ssize_t __pyx_t_9;
-  Py_ssize_t __pyx_t_10;
-  Py_ssize_t __pyx_t_11;
-  __pyx_ctuple_double__and_double__and_double__and_double __pyx_t_12;
+  __pyx_ctuple_double__and_double __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "adaXT/criteria/criteria.pyx":43
+  /* "adaXT/criteria/criteria.pyx":54
  *         cdef:
  *             double mean_thresh
- *             double left_imp = 0.0             # <<<<<<<<<<<<<<
- *             double right_imp = 0.0
- *             double crit = 0.0
- */
-  __pyx_v_left_imp = 0.0;
-
-  /* "adaXT/criteria/criteria.pyx":44
- *             double mean_thresh
- *             double left_imp = 0.0
- *             double right_imp = 0.0             # <<<<<<<<<<<<<<
- *             double crit = 0.0
- *             int n_indices = indices.shape[0]  # total in node
- */
-  __pyx_v_right_imp = 0.0;
-
-  /* "adaXT/criteria/criteria.pyx":45
- *             double left_imp = 0.0
- *             double right_imp = 0.0
- *             double crit = 0.0             # <<<<<<<<<<<<<<
- *             int n_indices = indices.shape[0]  # total in node
- *             double[:, ::1] features = self.x
- */
-  __pyx_v_crit = 0.0;
-
-  /* "adaXT/criteria/criteria.pyx":46
- *             double right_imp = 0.0
- *             double crit = 0.0
- *             int n_indices = indices.shape[0]  # total in node             # <<<<<<<<<<<<<<
- *             double[:, ::1] features = self.x
- *             int[:] left_indices = indices[:split_idx]
- */
-  __pyx_v_n_indices = (__pyx_v_indices.shape[0]);
-
-  /* "adaXT/criteria/criteria.pyx":47
- *             double crit = 0.0
- *             int n_indices = indices.shape[0]  # total in node
- *             double[:, ::1] features = self.x             # <<<<<<<<<<<<<<
- *             int[:] left_indices = indices[:split_idx]
- *             int[:] right_indices = indices[split_idx:]
- */
-  __pyx_t_1 = __pyx_v_self->x;
-  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
-  __pyx_v_features = __pyx_t_1;
-  __pyx_t_1.memview = NULL;
-  __pyx_t_1.data = NULL;
-
-  /* "adaXT/criteria/criteria.pyx":48
- *             int n_indices = indices.shape[0]  # total in node
- *             double[:, ::1] features = self.x
- *             int[:] left_indices = indices[:split_idx]             # <<<<<<<<<<<<<<
- *             int[:] right_indices = indices[split_idx:]
- *             int n_left = left_indices.shape[0]
- */
-  __pyx_t_2.data = __pyx_v_indices.data;
-  __pyx_t_2.memview = __pyx_v_indices.memview;
-  __PYX_INC_MEMVIEW(&__pyx_t_2, 1);
-  __pyx_t_3 = -1;
-  if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_2,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_3,
-    0,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 48, __pyx_L1_error)
-}
-
-__pyx_v_left_indices = __pyx_t_2;
-  __pyx_t_2.memview = NULL;
-  __pyx_t_2.data = NULL;
-
-  /* "adaXT/criteria/criteria.pyx":49
- *             double[:, ::1] features = self.x
- *             int[:] left_indices = indices[:split_idx]
- *             int[:] right_indices = indices[split_idx:]             # <<<<<<<<<<<<<<
- *             int n_left = left_indices.shape[0]
- *             int n_right = right_indices.shape[0]
- */
-  __pyx_t_2.data = __pyx_v_indices.data;
-  __pyx_t_2.memview = __pyx_v_indices.memview;
-  __PYX_INC_MEMVIEW(&__pyx_t_2, 1);
-  __pyx_t_3 = -1;
-  if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_2,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_3,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 49, __pyx_L1_error)
-}
-
-__pyx_v_right_indices = __pyx_t_2;
-  __pyx_t_2.memview = NULL;
-  __pyx_t_2.data = NULL;
-
-  /* "adaXT/criteria/criteria.pyx":50
- *             int[:] left_indices = indices[:split_idx]
- *             int[:] right_indices = indices[split_idx:]
- *             int n_left = left_indices.shape[0]             # <<<<<<<<<<<<<<
- *             int n_right = right_indices.shape[0]
- * 
- */
-  __pyx_v_n_left = (__pyx_v_left_indices.shape[0]);
-
-  /* "adaXT/criteria/criteria.pyx":51
- *             int[:] right_indices = indices[split_idx:]
- *             int n_left = left_indices.shape[0]
- *             int n_right = right_indices.shape[0]             # <<<<<<<<<<<<<<
+ *             int n_obs = indices.shape[0]  # total in node             # <<<<<<<<<<<<<<
  * 
- *         left_indices = indices[:split_idx]
- */
-  __pyx_v_n_right = (__pyx_v_right_indices.shape[0]);
-
-  /* "adaXT/criteria/criteria.pyx":53
- *             int n_right = right_indices.shape[0]
- * 
- *         left_indices = indices[:split_idx]             # <<<<<<<<<<<<<<
- *         right_indices = indices[split_idx:]
- *         n_left = left_indices.shape[0]
+ *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
  */
-  __pyx_t_2.data = __pyx_v_indices.data;
-  __pyx_t_2.memview = __pyx_v_indices.memview;
-  __PYX_INC_MEMVIEW(&__pyx_t_2, 1);
-  __pyx_t_3 = -1;
-  if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_2,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_3,
-    0,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 53, __pyx_L1_error)
-}
-
-__PYX_XCLEAR_MEMVIEW(&__pyx_v_left_indices, 1);
-  __pyx_v_left_indices = __pyx_t_2;
-  __pyx_t_2.memview = NULL;
-  __pyx_t_2.data = NULL;
+  __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":54
+  /* "adaXT/criteria/criteria.pyx":56
+ *             int n_obs = indices.shape[0]  # total in node
  * 
- *         left_indices = indices[:split_idx]
- *         right_indices = indices[split_idx:]             # <<<<<<<<<<<<<<
- *         n_left = left_indices.shape[0]
- *         n_right = right_indices.shape[0]
- */
-  __pyx_t_2.data = __pyx_v_indices.data;
-  __pyx_t_2.memview = __pyx_v_indices.memview;
-  __PYX_INC_MEMVIEW(&__pyx_t_2, 1);
-  __pyx_t_3 = -1;
-  if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_2,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_3,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 54, __pyx_L1_error)
-}
-
-__PYX_XCLEAR_MEMVIEW(&__pyx_v_right_indices, 1);
-  __pyx_v_right_indices = __pyx_t_2;
-  __pyx_t_2.memview = NULL;
-  __pyx_t_2.data = NULL;
-
-  /* "adaXT/criteria/criteria.pyx":55
- *         left_indices = indices[:split_idx]
- *         right_indices = indices[split_idx:]
- *         n_left = left_indices.shape[0]             # <<<<<<<<<<<<<<
- *         n_right = right_indices.shape[0]
+ *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting             # <<<<<<<<<<<<<<
+ *             crit = self.update_proxy(indices, split_idx)
  * 
  */
-  __pyx_v_n_left = (__pyx_v_left_indices.shape[0]);
+  __pyx_t_2 = (__pyx_v_n_obs == __pyx_v_self->old_obs);
+  if (__pyx_t_2) {
+  } else {
+    __pyx_t_1 = __pyx_t_2;
+    goto __pyx_L4_bool_binop_done;
+  }
+  __pyx_t_2 = (__pyx_v_feature == __pyx_v_self->old_feature);
+  __pyx_t_1 = __pyx_t_2;
+  __pyx_L4_bool_binop_done:;
+  if (__pyx_t_1) {
 
-  /* "adaXT/criteria/criteria.pyx":56
- *         right_indices = indices[split_idx:]
- *         n_left = left_indices.shape[0]
- *         n_right = right_indices.shape[0]             # <<<<<<<<<<<<<<
+    /* "adaXT/criteria/criteria.pyx":57
  * 
- *         # calculate criteria value on the left dataset
- */
-  __pyx_v_n_right = (__pyx_v_right_indices.shape[0]);
-
-  /* "adaXT/criteria/criteria.pyx":59
+ *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
+ *             crit = self.update_proxy(indices, split_idx)             # <<<<<<<<<<<<<<
  * 
- *         # calculate criteria value on the left dataset
- *         if n_left != 0.0:             # <<<<<<<<<<<<<<
- *             left_imp = self.impurity(left_indices)
- *         crit = left_imp * (<double > n_left)/(<double> n_indices)
+ *         else:
  */
-  __pyx_t_4 = (__pyx_v_n_left != 0.0);
-  if (__pyx_t_4) {
+    __pyx_t_3 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->__pyx_vtab)->update_proxy(__pyx_v_self, __pyx_v_indices, __pyx_v_split_idx); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 57, __pyx_L1_error)
+    __pyx_v_crit = __pyx_t_3;
 
-    /* "adaXT/criteria/criteria.pyx":60
- *         # calculate criteria value on the left dataset
- *         if n_left != 0.0:
- *             left_imp = self.impurity(left_indices)             # <<<<<<<<<<<<<<
- *         crit = left_imp * (<double > n_left)/(<double> n_indices)
+    /* "adaXT/criteria/criteria.pyx":56
+ *             int n_obs = indices.shape[0]  # total in node
  * 
- */
-    __pyx_t_5 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->__pyx_vtab)->impurity(__pyx_v_self, __pyx_v_left_indices, 0); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 60, __pyx_L1_error)
-    __pyx_v_left_imp = __pyx_t_5;
-
-    /* "adaXT/criteria/criteria.pyx":59
+ *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting             # <<<<<<<<<<<<<<
+ *             crit = self.update_proxy(indices, split_idx)
  * 
- *         # calculate criteria value on the left dataset
- *         if n_left != 0.0:             # <<<<<<<<<<<<<<
- *             left_imp = self.impurity(left_indices)
- *         crit = left_imp * (<double > n_left)/(<double> n_indices)
  */
+    goto __pyx_L3;
   }
 
-  /* "adaXT/criteria/criteria.pyx":61
- *         if n_left != 0.0:
- *             left_imp = self.impurity(left_indices)
- *         crit = left_imp * (<double > n_left)/(<double> n_indices)             # <<<<<<<<<<<<<<
+  /* "adaXT/criteria/criteria.pyx":60
  * 
- *         # calculate criteria value on the right dataset
- */
-  __pyx_v_crit = ((__pyx_v_left_imp * ((double)__pyx_v_n_left)) / ((double)__pyx_v_n_indices));
-
-  /* "adaXT/criteria/criteria.pyx":64
- * 
- *         # calculate criteria value on the right dataset
- *         if n_right != 0.0:             # <<<<<<<<<<<<<<
- *             right_imp = self.impurity(right_indices)
- *         crit += (right_imp) * (<double> n_right)/(<double> n_indices)
+ *         else:
+ *             crit = self.proxy_improvement(indices, split_idx)             # <<<<<<<<<<<<<<
+ *             self.old_feature = feature
+ *             self.old_obs = n_obs
  */
-  __pyx_t_4 = (__pyx_v_n_right != 0.0);
-  if (__pyx_t_4) {
+  /*else*/ {
+    __pyx_t_3 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->__pyx_vtab)->proxy_improvement(__pyx_v_self, __pyx_v_indices, __pyx_v_split_idx); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 60, __pyx_L1_error)
+    __pyx_v_crit = __pyx_t_3;
 
-    /* "adaXT/criteria/criteria.pyx":65
- *         # calculate criteria value on the right dataset
- *         if n_right != 0.0:
- *             right_imp = self.impurity(right_indices)             # <<<<<<<<<<<<<<
- *         crit += (right_imp) * (<double> n_right)/(<double> n_indices)
+    /* "adaXT/criteria/criteria.pyx":61
+ *         else:
+ *             crit = self.proxy_improvement(indices, split_idx)
+ *             self.old_feature = feature             # <<<<<<<<<<<<<<
+ *             self.old_obs = n_obs
  * 
  */
-    __pyx_t_5 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->__pyx_vtab)->impurity(__pyx_v_self, __pyx_v_right_indices, 0); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 65, __pyx_L1_error)
-    __pyx_v_right_imp = __pyx_t_5;
+    __pyx_v_self->old_feature = __pyx_v_feature;
 
-    /* "adaXT/criteria/criteria.pyx":64
+    /* "adaXT/criteria/criteria.pyx":62
+ *             crit = self.proxy_improvement(indices, split_idx)
+ *             self.old_feature = feature
+ *             self.old_obs = n_obs             # <<<<<<<<<<<<<<
  * 
- *         # calculate criteria value on the right dataset
- *         if n_right != 0.0:             # <<<<<<<<<<<<<<
- *             right_imp = self.impurity(right_indices)
- *         crit += (right_imp) * (<double> n_right)/(<double> n_indices)
+ *         self.old_split = split_idx
  */
+    __pyx_v_self->old_obs = __pyx_v_n_obs;
   }
+  __pyx_L3:;
 
-  /* "adaXT/criteria/criteria.pyx":66
- *         if n_right != 0.0:
- *             right_imp = self.impurity(right_indices)
- *         crit += (right_imp) * (<double> n_right)/(<double> n_indices)             # <<<<<<<<<<<<<<
+  /* "adaXT/criteria/criteria.pyx":64
+ *             self.old_obs = n_obs
+ * 
+ *         self.old_split = split_idx             # <<<<<<<<<<<<<<
+ *         mean_thresh = (self.x[indices[split_idx-1]][feature] + self.x[indices[split_idx]][feature]) / 2.0
  * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0
  */
-  __pyx_v_crit = (__pyx_v_crit + ((__pyx_v_right_imp * ((double)__pyx_v_n_right)) / ((double)__pyx_v_n_indices)));
+  __pyx_v_self->old_split = __pyx_v_split_idx;
 
-  /* "adaXT/criteria/criteria.pyx":68
- *         crit += (right_imp) * (<double> n_right)/(<double> n_indices)
+  /* "adaXT/criteria/criteria.pyx":65
  * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0             # <<<<<<<<<<<<<<
+ *         self.old_split = split_idx
+ *         mean_thresh = (self.x[indices[split_idx-1]][feature] + self.x[indices[split_idx]][feature]) / 2.0             # <<<<<<<<<<<<<<
  * 
- *         return (crit, left_imp, right_imp, mean_thresh)
+ *         return (crit, mean_thresh)
  */
-  __pyx_t_6 = (__pyx_v_split_idx - 1);
-  __pyx_t_7 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_6 * __pyx_v_indices.strides[0]) )));
-  __pyx_t_8 = __pyx_v_feature;
-  __pyx_t_9 = __pyx_v_split_idx;
-  __pyx_t_10 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_9 * __pyx_v_indices.strides[0]) )));
-  __pyx_t_11 = __pyx_v_feature;
-  __pyx_v_mean_thresh = (((*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_features.data + __pyx_t_7 * __pyx_v_features.strides[0]) )) + __pyx_t_8)) ))) + (*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_features.data + __pyx_t_10 * __pyx_v_features.strides[0]) )) + __pyx_t_11)) )))) / 2.0);
+  __pyx_t_4 = (__pyx_v_split_idx - 1);
+  __pyx_t_5 = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_4)) )));
+  __pyx_t_6 = __pyx_v_feature;
+  __pyx_t_7 = __pyx_v_split_idx;
+  __pyx_t_8 = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_7)) )));
+  __pyx_t_9 = __pyx_v_feature;
+  __pyx_v_mean_thresh = (((*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_self->x.data + __pyx_t_5 * __pyx_v_self->x.strides[0]) )) + __pyx_t_6)) ))) + (*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_self->x.data + __pyx_t_8 * __pyx_v_self->x.strides[0]) )) + __pyx_t_9)) )))) / 2.0);
 
-  /* "adaXT/criteria/criteria.pyx":70
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0
+  /* "adaXT/criteria/criteria.pyx":67
+ *         mean_thresh = (self.x[indices[split_idx-1]][feature] + self.x[indices[split_idx]][feature]) / 2.0
  * 
- *         return (crit, left_imp, right_imp, mean_thresh)             # <<<<<<<<<<<<<<
+ *         return (crit, mean_thresh)             # <<<<<<<<<<<<<<
  * 
  * cdef class Gini_index(Criteria):
  */
-  __pyx_t_12.f0 = __pyx_v_crit;
-  __pyx_t_12.f1 = __pyx_v_left_imp;
-  __pyx_t_12.f2 = __pyx_v_right_imp;
-  __pyx_t_12.f3 = __pyx_v_mean_thresh;
-  __pyx_r = __pyx_t_12;
+  __pyx_t_10.f0 = __pyx_v_crit;
+  __pyx_t_10.f1 = __pyx_v_mean_thresh;
+  __pyx_r = __pyx_t_10;
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":17
+  /* "adaXT/criteria/criteria.pyx":51
  *         raise Exception("Impurity must be implemented!")
  * 
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
- *         """
- *         Function to evaluate how good a split is
+ *     cdef (double, double) evaluate_split(self, int[::1] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             double mean_thresh
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_2, 1);
   __Pyx_AddTraceback("adaXT.criteria.criteria.Criteria.evaluate_split", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_features, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_left_indices, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_right_indices, 1);
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
@@ -18870,19 +19015,19 @@
   __Pyx_AddTraceback("adaXT.criteria.criteria.Criteria.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":84
- *         int old_feature
+/* "adaXT/criteria/criteria.pyx":79
+ *         bint first_call
  * 
  *     def __init__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):             # <<<<<<<<<<<<<<
- *         self.old_obs = -1
+ *         self.first_call = True
  * 
  */
 
 /* Python wrapper */
 static int __pyx_pw_5adaXT_8criteria_8criteria_10Gini_index_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_pw_5adaXT_8criteria_8criteria_10Gini_index_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   CYTHON_UNUSED __Pyx_memviewslice __pyx_v_x = { 0, 0, { 0 }, { 0 }, { 0 } };
@@ -18920,55 +19065,55 @@
       kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_x)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 84, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 79, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_y)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 84, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 79, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 1); __PYX_ERR(1, 84, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 1); __PYX_ERR(1, 79, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_sample_weight)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[2]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 84, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 79, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 2); __PYX_ERR(1, 84, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 2); __PYX_ERR(1, 79, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(1, 84, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(1, 79, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 3)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
       values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
       values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
     }
-    __pyx_v_x = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_x.memview)) __PYX_ERR(1, 84, __pyx_L3_error)
-    __pyx_v_y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_y.memview)) __PYX_ERR(1, 84, __pyx_L3_error)
-    __pyx_v_sample_weight = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[2], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sample_weight.memview)) __PYX_ERR(1, 84, __pyx_L3_error)
+    __pyx_v_x = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_x.memview)) __PYX_ERR(1, 79, __pyx_L3_error)
+    __pyx_v_y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_y.memview)) __PYX_ERR(1, 79, __pyx_L3_error)
+    __pyx_v_sample_weight = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[2], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sample_weight.memview)) __PYX_ERR(1, 79, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, __pyx_nargs); __PYX_ERR(1, 84, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, __pyx_nargs); __PYX_ERR(1, 79, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
@@ -18996,42 +19141,42 @@
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_5adaXT_8criteria_8criteria_10Gini_index___init__(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_x, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_y, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_sample_weight) {
   int __pyx_r;
 
-  /* "adaXT/criteria/criteria.pyx":85
+  /* "adaXT/criteria/criteria.pyx":80
  * 
  *     def __init__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):
- *         self.old_obs = -1             # <<<<<<<<<<<<<<
+ *         self.first_call = True             # <<<<<<<<<<<<<<
  * 
- *     def __del__(self):  # Called by garbage collector.
+ *     def __del__(self):
  */
-  __pyx_v_self->old_obs = -1;
+  __pyx_v_self->first_call = 1;
 
-  /* "adaXT/criteria/criteria.pyx":84
- *         int old_feature
+  /* "adaXT/criteria/criteria.pyx":79
+ *         bint first_call
  * 
  *     def __init__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):             # <<<<<<<<<<<<<<
- *         self.old_obs = -1
+ *         self.first_call = True
  * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":87
- *         self.old_obs = -1
+/* "adaXT/criteria/criteria.pyx":82
+ *         self.first_call = True
  * 
- *     def __del__(self):  # Called by garbage collector.             # <<<<<<<<<<<<<<
- *         free(self.n_in_class_left)
- *         free(self.n_in_class_right)
+ *     def __del__(self):             # <<<<<<<<<<<<<<
+ *         free(self.weight_in_class_left)
+ *         free(self.weight_in_class_right)
  */
 
 /* Python wrapper */
 static void __pyx_pw_5adaXT_8criteria_8criteria_10Gini_index_3__del__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_pw_5adaXT_8criteria_8criteria_10Gini_index_3__del__(PyObject *__pyx_v_self) {
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   __Pyx_RefNannyDeclarations
@@ -19041,49 +19186,79 @@
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_pf_5adaXT_8criteria_8criteria_10Gini_index_2__del__(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self) {
 
-  /* "adaXT/criteria/criteria.pyx":88
+  /* "adaXT/criteria/criteria.pyx":83
  * 
- *     def __del__(self):  # Called by garbage collector.
- *         free(self.n_in_class_left)             # <<<<<<<<<<<<<<
- *         free(self.n_in_class_right)
+ *     def __del__(self):
+ *         free(self.weight_in_class_left)             # <<<<<<<<<<<<<<
+ *         free(self.weight_in_class_right)
  * 
  */
-  free(__pyx_v_self->n_in_class_left);
+  free(__pyx_v_self->weight_in_class_left);
 
-  /* "adaXT/criteria/criteria.pyx":89
- *     def __del__(self):  # Called by garbage collector.
- *         free(self.n_in_class_left)
- *         free(self.n_in_class_right)             # <<<<<<<<<<<<<<
+  /* "adaXT/criteria/criteria.pyx":84
+ *     def __del__(self):
+ *         free(self.weight_in_class_left)
+ *         free(self.weight_in_class_right)             # <<<<<<<<<<<<<<
  * 
- *     cpdef double impurity(self, int[:] indices):
+ *     cdef void reset_weight_list(self, double* class_occurences):
  */
-  free(__pyx_v_self->n_in_class_right);
+  free(__pyx_v_self->weight_in_class_right);
 
-  /* "adaXT/criteria/criteria.pyx":87
- *         self.old_obs = -1
+  /* "adaXT/criteria/criteria.pyx":82
+ *         self.first_call = True
  * 
- *     def __del__(self):  # Called by garbage collector.             # <<<<<<<<<<<<<<
- *         free(self.n_in_class_left)
- *         free(self.n_in_class_right)
+ *     def __del__(self):             # <<<<<<<<<<<<<<
+ *         free(self.weight_in_class_left)
+ *         free(self.weight_in_class_right)
+ */
+
+  /* function exit code */
+}
+
+/* "adaXT/criteria/criteria.pyx":86
+ *         free(self.weight_in_class_right)
+ * 
+ *     cdef void reset_weight_list(self, double* class_occurences):             # <<<<<<<<<<<<<<
+ *         # Use memset to set the entire malloc to 0
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
+ */
+
+static void __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_reset_weight_list(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, double *__pyx_v_class_occurences) {
+
+  /* "adaXT/criteria/criteria.pyx":88
+ *     cdef void reset_weight_list(self, double* class_occurences):
+ *         # Use memset to set the entire malloc to 0
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef double impurity(self, int[::1] indices):
+ */
+  (void)(memset(__pyx_v_class_occurences, 0, (__pyx_v_self->num_classes * (sizeof(double)))));
+
+  /* "adaXT/criteria/criteria.pyx":86
+ *         free(self.weight_in_class_right)
+ * 
+ *     cdef void reset_weight_list(self, double* class_occurences):             # <<<<<<<<<<<<<<
+ *         # Use memset to set the entire malloc to 0
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
  */
 
   /* function exit code */
 }
 
-/* "adaXT/criteria/criteria.pyx":91
- *         free(self.n_in_class_right)
+/* "adaXT/criteria/criteria.pyx":90
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
  */
 
 static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_10Gini_index_5impurity(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
@@ -19109,18 +19284,18 @@
   /* Check if overridden in Python */
   else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || __Pyx_PyType_HasFeature(Py_TYPE(((PyObject *)__pyx_v_self)), (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
     #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
     if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
       PY_UINT64_T __pyx_typedict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
       #endif
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 91, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 90, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_8criteria_8criteria_10Gini_index_5impurity)) {
-        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 91, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 90, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
         __pyx_t_6 = 0;
         #if CYTHON_UNPACK_METHODS
         if (unlikely(PyMethod_Check(__pyx_t_4))) {
           __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
@@ -19134,19 +19309,19 @@
         }
         #endif
         {
           PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_t_3};
           __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
           __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 91, __pyx_L1_error)
+          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 90, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_2);
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
         }
-        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 91, __pyx_L1_error)
+        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 90, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
         __pyx_r = __pyx_t_7;
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         goto __pyx_L0;
       }
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
       __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
@@ -19157,111 +19332,138 @@
       #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     }
     #endif
   }
 
-  /* "adaXT/criteria/criteria.pyx":92
+  /* "adaXT/criteria/criteria.pyx":91
  * 
- *     cpdef double impurity(self, int[:] indices):
- *         self.class_labels = np.unique(self.y.base[indices])             # <<<<<<<<<<<<<<
- *         self.num_classes = self.class_labels.shape[0]
- *         self.n_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
+ *     cpdef double impurity(self, int[::1] indices):
+ *         if self.first_call:             # <<<<<<<<<<<<<<
+ *             self.class_labels = np.unique(self.y.base[indices])
+ *             self.num_classes = self.class_labels.shape[0]
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_self->__pyx_base.y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_base); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  __pyx_t_6 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_4))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-      __Pyx_INCREF(__pyx_t_2);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_4, function);
-      __pyx_t_6 = 1;
+  if (__pyx_v_self->first_call) {
+
+    /* "adaXT/criteria/criteria.pyx":92
+ *     cpdef double impurity(self, int[::1] indices):
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])             # <<<<<<<<<<<<<<
+ *             self.num_classes = self.class_labels.shape[0]
+ * 
+ */
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 92, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 92, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_self->__pyx_base.y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 92, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_base); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 92, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 92, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 92, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = NULL;
+    __pyx_t_6 = 0;
+    #if CYTHON_UNPACK_METHODS
+    if (unlikely(PyMethod_Check(__pyx_t_4))) {
+      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
+      if (likely(__pyx_t_2)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_2);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_4, function);
+        __pyx_t_6 = 1;
+      }
     }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_2, __pyx_t_5};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 92, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  }
-  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(1, 92, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->class_labels, 0);
-  __pyx_v_self->class_labels = __pyx_t_8;
-  __pyx_t_8.memview = NULL;
-  __pyx_t_8.data = NULL;
+    #endif
+    {
+      PyObject *__pyx_callargs[2] = {__pyx_t_2, __pyx_t_5};
+      __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
+      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 92, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    }
+    __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(1, 92, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->class_labels, 0);
+    __pyx_v_self->class_labels = __pyx_t_8;
+    __pyx_t_8.memview = NULL;
+    __pyx_t_8.data = NULL;
+
+    /* "adaXT/criteria/criteria.pyx":93
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
+ *             self.num_classes = self.class_labels.shape[0]             # <<<<<<<<<<<<<<
+ * 
+ *             self.weight_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)
+ */
+    __pyx_v_self->num_classes = (__pyx_v_self->class_labels.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":93
- *     cpdef double impurity(self, int[:] indices):
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]             # <<<<<<<<<<<<<<
- *         self.n_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
- *         self.n_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)
+    /* "adaXT/criteria/criteria.pyx":95
+ *             self.num_classes = self.class_labels.shape[0]
+ * 
+ *             self.weight_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)             # <<<<<<<<<<<<<<
+ *             self.weight_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
+ * 
  */
-  __pyx_v_self->num_classes = (__pyx_v_self->class_labels.shape[0]);
+    __pyx_v_self->weight_in_class_right = ((double *)malloc(((sizeof(double)) * __pyx_v_self->num_classes)));
 
-  /* "adaXT/criteria/criteria.pyx":94
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
- *         self.n_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)             # <<<<<<<<<<<<<<
- *         self.n_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)
+    /* "adaXT/criteria/criteria.pyx":96
  * 
+ *             self.weight_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)
+ *             self.weight_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)             # <<<<<<<<<<<<<<
+ * 
+ *             self.first_call = False
  */
-  __pyx_v_self->n_in_class_left = ((double *)malloc(((sizeof(double)) * __pyx_v_self->num_classes)));
+    __pyx_v_self->weight_in_class_left = ((double *)malloc(((sizeof(double)) * __pyx_v_self->num_classes)));
 
-  /* "adaXT/criteria/criteria.pyx":95
- *         self.num_classes = self.class_labels.shape[0]
- *         self.n_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
- *         self.n_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)             # <<<<<<<<<<<<<<
+    /* "adaXT/criteria/criteria.pyx":98
+ *             self.weight_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
+ * 
+ *             self.first_call = False             # <<<<<<<<<<<<<<
  * 
- *         # n_in_class_left can be use as the int pointer as it will be cleared before and after this use
+ *         return self._gini(indices, self.weight_in_class_left)
  */
-  __pyx_v_self->n_in_class_right = ((double *)malloc(((sizeof(double)) * __pyx_v_self->num_classes)));
+    __pyx_v_self->first_call = 0;
+
+    /* "adaXT/criteria/criteria.pyx":91
+ * 
+ *     cpdef double impurity(self, int[::1] indices):
+ *         if self.first_call:             # <<<<<<<<<<<<<<
+ *             self.class_labels = np.unique(self.y.base[indices])
+ *             self.num_classes = self.class_labels.shape[0]
+ */
+  }
 
-  /* "adaXT/criteria/criteria.pyx":98
+  /* "adaXT/criteria/criteria.pyx":100
+ *             self.first_call = False
  * 
- *         # n_in_class_left can be use as the int pointer as it will be cleared before and after this use
- *         return self._gini(indices, self.n_in_class_left, 1)             # <<<<<<<<<<<<<<
+ *         return self._gini(indices, self.weight_in_class_left)             # <<<<<<<<<<<<<<
  * 
- *     cdef void reset_n_in_class(self, double* class_occurences):
+ *     cdef double _gini(self, int[::1] indices, double* class_occurences):
  */
-  __pyx_t_7 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->_gini(__pyx_v_self, __pyx_v_indices, __pyx_v_self->n_in_class_left, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 98, __pyx_L1_error)
+  __pyx_t_7 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->_gini(__pyx_v_self, __pyx_v_indices, __pyx_v_self->weight_in_class_left); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 100, __pyx_L1_error)
   __pyx_r = __pyx_t_7;
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":91
- *         free(self.n_in_class_right)
+  /* "adaXT/criteria/criteria.pyx":90
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -19324,31 +19526,31 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 91, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 90, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 91, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 90, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_ds_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 91, __pyx_L3_error)
+    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 90, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 91, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 90, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -19379,16 +19581,16 @@
   double __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("impurity", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 91, __pyx_L1_error)
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 91, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 90, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -19397,70 +19599,23 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":100
- *         return self._gini(indices, self.n_in_class_left, 1)
- * 
- *     cdef void reset_n_in_class(self, double* class_occurences):             # <<<<<<<<<<<<<<
- *         cdef int i
- *         for i in range(self.num_classes):
- */
-
-static void __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_reset_n_in_class(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, double *__pyx_v_class_occurences) {
-  int __pyx_v_i;
-  int __pyx_t_1;
-  int __pyx_t_2;
-  int __pyx_t_3;
-
-  /* "adaXT/criteria/criteria.pyx":102
- *     cdef void reset_n_in_class(self, double* class_occurences):
- *         cdef int i
- *         for i in range(self.num_classes):             # <<<<<<<<<<<<<<
- *             class_occurences[i] = 0.0
- * 
- */
-  __pyx_t_1 = __pyx_v_self->num_classes;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
-
-    /* "adaXT/criteria/criteria.pyx":103
- *         cdef int i
- *         for i in range(self.num_classes):
- *             class_occurences[i] = 0.0             # <<<<<<<<<<<<<<
- * 
- *     cdef double _gini(self, int[:] indices, double* class_occurences, int left_or_right):
- */
-    (__pyx_v_class_occurences[__pyx_v_i]) = 0.0;
-  }
-
-  /* "adaXT/criteria/criteria.pyx":100
- *         return self._gini(indices, self.n_in_class_left, 1)
- * 
- *     cdef void reset_n_in_class(self, double* class_occurences):             # <<<<<<<<<<<<<<
- *         cdef int i
- *         for i in range(self.num_classes):
- */
-
-  /* function exit code */
-}
-
-/* "adaXT/criteria/criteria.pyx":105
- *             class_occurences[i] = 0.0
+/* "adaXT/criteria/criteria.pyx":102
+ *         return self._gini(indices, self.weight_in_class_left)
  * 
- *     cdef double _gini(self, int[:] indices, double* class_occurences, int left_or_right):             # <<<<<<<<<<<<<<
+ *     cdef double _gini(self, int[::1] indices, double* class_occurences):             # <<<<<<<<<<<<<<
  *         """
  *         Function that calculates the gini index of a dataset
  */
 
-static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index__gini(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, double *__pyx_v_class_occurences, int __pyx_v_left_or_right) {
+static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index__gini(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, double *__pyx_v_class_occurences) {
   double __pyx_v_sum;
   int __pyx_v_n_obs;
   double __pyx_v_obs_weight;
   double __pyx_v_proportion_cls;
   double __pyx_v_weight;
   int __pyx_v_i;
   int __pyx_v_j;
@@ -19479,248 +19634,217 @@
   Py_ssize_t __pyx_t_9;
   int __pyx_t_10;
   int __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "adaXT/criteria/criteria.pyx":123
+  /* "adaXT/criteria/criteria.pyx":120
  *             The value of the gini index
  *         """
- *         self.reset_n_in_class(class_occurences)  # Reset the counter such that no previous values influence the new ones             # <<<<<<<<<<<<<<
+ *         self.reset_weight_list(class_occurences)  # Reset the counter such that no previous values influence the new ones             # <<<<<<<<<<<<<<
  * 
  *         cdef:
  */
-  ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->reset_n_in_class(__pyx_v_self, __pyx_v_class_occurences); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 123, __pyx_L1_error)
+  ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->reset_weight_list(__pyx_v_self, __pyx_v_class_occurences); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 120, __pyx_L1_error)
 
-  /* "adaXT/criteria/criteria.pyx":126
+  /* "adaXT/criteria/criteria.pyx":123
  * 
  *         cdef:
  *             double sum = 0.0             # <<<<<<<<<<<<<<
  *             int n_obs = indices.shape[0]
  *             double obs_weight = 0.0
  */
   __pyx_v_sum = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":127
+  /* "adaXT/criteria/criteria.pyx":124
  *         cdef:
  *             double sum = 0.0
  *             int n_obs = indices.shape[0]             # <<<<<<<<<<<<<<
  *             double obs_weight = 0.0
  *             double proportion_cls, weight
  */
   __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":128
+  /* "adaXT/criteria/criteria.pyx":125
  *             double sum = 0.0
  *             int n_obs = indices.shape[0]
  *             double obs_weight = 0.0             # <<<<<<<<<<<<<<
  *             double proportion_cls, weight
  *             int i, j, p
  */
   __pyx_v_obs_weight = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":131
+  /* "adaXT/criteria/criteria.pyx":128
  *             double proportion_cls, weight
  *             int i, j, p
  *             double[:] y = self.y             # <<<<<<<<<<<<<<
  *             double[:] class_labels = self.class_labels
  * 
  */
   __pyx_t_1 = __pyx_v_self->__pyx_base.y;
   __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
   __pyx_v_y = __pyx_t_1;
   __pyx_t_1.memview = NULL;
   __pyx_t_1.data = NULL;
 
-  /* "adaXT/criteria/criteria.pyx":132
+  /* "adaXT/criteria/criteria.pyx":129
  *             int i, j, p
  *             double[:] y = self.y
  *             double[:] class_labels = self.class_labels             # <<<<<<<<<<<<<<
  * 
  *         for i in range(n_obs):  # loop over all indices
  */
   __pyx_t_1 = __pyx_v_self->class_labels;
   __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
   __pyx_v_class_labels = __pyx_t_1;
   __pyx_t_1.memview = NULL;
   __pyx_t_1.data = NULL;
 
-  /* "adaXT/criteria/criteria.pyx":134
+  /* "adaXT/criteria/criteria.pyx":131
  *             double[:] class_labels = self.class_labels
  * 
  *         for i in range(n_obs):  # loop over all indices             # <<<<<<<<<<<<<<
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter
  *                 p = indices[i]
  */
   __pyx_t_2 = __pyx_v_n_obs;
   __pyx_t_3 = __pyx_t_2;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "adaXT/criteria/criteria.pyx":135
+    /* "adaXT/criteria/criteria.pyx":132
  * 
  *         for i in range(n_obs):  # loop over all indices
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter             # <<<<<<<<<<<<<<
  *                 p = indices[i]
  *                 if y[p] == class_labels[j]:
  */
     __pyx_t_5 = __pyx_v_self->num_classes;
     __pyx_t_6 = __pyx_t_5;
     for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
       __pyx_v_j = __pyx_t_7;
 
-      /* "adaXT/criteria/criteria.pyx":136
+      /* "adaXT/criteria/criteria.pyx":133
  *         for i in range(n_obs):  # loop over all indices
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter
  *                 p = indices[i]             # <<<<<<<<<<<<<<
  *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]
  */
       __pyx_t_8 = __pyx_v_i;
-      __pyx_v_p = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_8 * __pyx_v_indices.strides[0]) )));
+      __pyx_v_p = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_8)) )));
 
-      /* "adaXT/criteria/criteria.pyx":137
+      /* "adaXT/criteria/criteria.pyx":134
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter
  *                 p = indices[i]
  *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
  *                     class_occurences[j] += weight
  */
       __pyx_t_8 = __pyx_v_p;
       __pyx_t_9 = __pyx_v_j;
       __pyx_t_10 = ((*((double *) ( /* dim=0 */ (__pyx_v_y.data + __pyx_t_8 * __pyx_v_y.strides[0]) ))) == (*((double *) ( /* dim=0 */ (__pyx_v_class_labels.data + __pyx_t_9 * __pyx_v_class_labels.strides[0]) ))));
       if (__pyx_t_10) {
 
-        /* "adaXT/criteria/criteria.pyx":138
+        /* "adaXT/criteria/criteria.pyx":135
  *                 p = indices[i]
  *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]             # <<<<<<<<<<<<<<
  *                     class_occurences[j] += weight
  *                     obs_weight += weight
  */
         __pyx_t_9 = __pyx_v_p;
         __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_9)) )));
 
-        /* "adaXT/criteria/criteria.pyx":139
+        /* "adaXT/criteria/criteria.pyx":136
  *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]
  *                     class_occurences[j] += weight             # <<<<<<<<<<<<<<
  *                     obs_weight += weight
- * 
+ *                     break
  */
         __pyx_t_11 = __pyx_v_j;
         (__pyx_v_class_occurences[__pyx_t_11]) = ((__pyx_v_class_occurences[__pyx_t_11]) + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":140
+        /* "adaXT/criteria/criteria.pyx":137
  *                     weight = self.sample_weight[p]
  *                     class_occurences[j] += weight
  *                     obs_weight += weight             # <<<<<<<<<<<<<<
+ *                     break
  * 
- *         # Loop over all classes and calculate gini_index
  */
         __pyx_v_obs_weight = (__pyx_v_obs_weight + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":137
+        /* "adaXT/criteria/criteria.pyx":138
+ *                     class_occurences[j] += weight
+ *                     obs_weight += weight
+ *                     break             # <<<<<<<<<<<<<<
+ * 
+ *         # Loop over all classes and calculate gini_index
+ */
+        goto __pyx_L6_break;
+
+        /* "adaXT/criteria/criteria.pyx":134
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter
  *                 p = indices[i]
  *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
  *                     class_occurences[j] += weight
  */
       }
     }
+    __pyx_L6_break:;
   }
 
-  /* "adaXT/criteria/criteria.pyx":143
+  /* "adaXT/criteria/criteria.pyx":141
  * 
  *         # Loop over all classes and calculate gini_index
  *         for i in range(self.num_classes):             # <<<<<<<<<<<<<<
  *             proportion_cls = (class_occurences[i]) / obs_weight
  *             sum += proportion_cls * proportion_cls
  */
   __pyx_t_2 = __pyx_v_self->num_classes;
   __pyx_t_3 = __pyx_t_2;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "adaXT/criteria/criteria.pyx":144
+    /* "adaXT/criteria/criteria.pyx":142
  *         # Loop over all classes and calculate gini_index
  *         for i in range(self.num_classes):
  *             proportion_cls = (class_occurences[i]) / obs_weight             # <<<<<<<<<<<<<<
  *             sum += proportion_cls * proportion_cls
  * 
  */
     __pyx_v_proportion_cls = ((__pyx_v_class_occurences[__pyx_v_i]) / __pyx_v_obs_weight);
 
-    /* "adaXT/criteria/criteria.pyx":145
+    /* "adaXT/criteria/criteria.pyx":143
  *         for i in range(self.num_classes):
  *             proportion_cls = (class_occurences[i]) / obs_weight
  *             sum += proportion_cls * proportion_cls             # <<<<<<<<<<<<<<
  * 
- *         # update left or right weight
+ *         return 1.0 - sum
  */
     __pyx_v_sum = (__pyx_v_sum + (__pyx_v_proportion_cls * __pyx_v_proportion_cls));
   }
 
-  /* "adaXT/criteria/criteria.pyx":148
- * 
- *         # update left or right weight
- *         if left_or_right == 1:             # <<<<<<<<<<<<<<
- *             self.weight_left = obs_weight
- *         else:
- */
-  __pyx_t_10 = (__pyx_v_left_or_right == 1);
-  if (__pyx_t_10) {
-
-    /* "adaXT/criteria/criteria.pyx":149
- *         # update left or right weight
- *         if left_or_right == 1:
- *             self.weight_left = obs_weight             # <<<<<<<<<<<<<<
- *         else:
- *             self.weight_right = obs_weight
- */
-    __pyx_v_self->weight_left = __pyx_v_obs_weight;
-
-    /* "adaXT/criteria/criteria.pyx":148
- * 
- *         # update left or right weight
- *         if left_or_right == 1:             # <<<<<<<<<<<<<<
- *             self.weight_left = obs_weight
- *         else:
- */
-    goto __pyx_L10;
-  }
-
-  /* "adaXT/criteria/criteria.pyx":151
- *             self.weight_left = obs_weight
- *         else:
- *             self.weight_right = obs_weight             # <<<<<<<<<<<<<<
- *         return 1.0 - sum
+  /* "adaXT/criteria/criteria.pyx":145
+ *             sum += proportion_cls * proportion_cls
  * 
- */
-  /*else*/ {
-    __pyx_v_self->weight_right = __pyx_v_obs_weight;
-  }
-  __pyx_L10:;
-
-  /* "adaXT/criteria/criteria.pyx":152
- *         else:
- *             self.weight_right = obs_weight
  *         return 1.0 - sum             # <<<<<<<<<<<<<<
  * 
- *     cdef double update_left(self, int[:] indices, int new_split):
+ *     cdef double update_proxy(self, int[::1] indices, int new_split):
  */
   __pyx_r = (1.0 - __pyx_v_sum);
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":105
- *             class_occurences[i] = 0.0
+  /* "adaXT/criteria/criteria.pyx":102
+ *         return self._gini(indices, self.weight_in_class_left)
  * 
- *     cdef double _gini(self, int[:] indices, double* class_occurences, int left_or_right):             # <<<<<<<<<<<<<<
+ *     cdef double _gini(self, int[::1] indices, double* class_occurences):             # <<<<<<<<<<<<<<
  *         """
  *         Function that calculates the gini index of a dataset
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
@@ -19728,727 +19852,651 @@
   __pyx_r = 0;
   __pyx_L0:;
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_y, 1);
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_class_labels, 1);
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":154
+/* "adaXT/criteria/criteria.pyx":147
  *         return 1.0 - sum
  * 
- *     cdef double update_left(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
+ *     cdef double update_proxy(self, int[::1] indices, int new_split):             # <<<<<<<<<<<<<<
  *         # All new values in node from before
  *         cdef:
  */
 
-static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_update_left(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split) {
+static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_update_proxy(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split) {
   int __pyx_v_i;
   int __pyx_v_j;
   int __pyx_v_p;
   int __pyx_v_start_idx;
-  double __pyx_v_proportion_cls;
+  double __pyx_v_proportion_cls_left;
+  double __pyx_v_proportion_cls_right;
   double __pyx_v_weight;
-  double __pyx_v_sum;
+  double __pyx_v_sum_left;
+  double __pyx_v_sum_right;
   double __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   Py_ssize_t __pyx_t_7;
   Py_ssize_t __pyx_t_8;
   int __pyx_t_9;
   int __pyx_t_10;
 
-  /* "adaXT/criteria/criteria.pyx":158
+  /* "adaXT/criteria/criteria.pyx":151
  *         cdef:
  *             int i, j, p
  *             int start_idx = self.old_split             # <<<<<<<<<<<<<<
- *             double proportion_cls, weight
- *             double sum = 0.0
+ *             double proportion_cls_left, proportion_cls_right, weight
+ *             double sum_left = 0.0
  */
-  __pyx_t_1 = __pyx_v_self->old_split;
+  __pyx_t_1 = __pyx_v_self->__pyx_base.old_split;
   __pyx_v_start_idx = __pyx_t_1;
 
-  /* "adaXT/criteria/criteria.pyx":160
+  /* "adaXT/criteria/criteria.pyx":153
  *             int start_idx = self.old_split
- *             double proportion_cls, weight
- *             double sum = 0.0             # <<<<<<<<<<<<<<
+ *             double proportion_cls_left, proportion_cls_right, weight
+ *             double sum_left = 0.0             # <<<<<<<<<<<<<<
+ *             double sum_right = 0.0
+ * 
+ */
+  __pyx_v_sum_left = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":154
+ *             double proportion_cls_left, proportion_cls_right, weight
+ *             double sum_left = 0.0
+ *             double sum_right = 0.0             # <<<<<<<<<<<<<<
  * 
  *         for i in range(start_idx, new_split):  # loop over indices to be updated
  */
-  __pyx_v_sum = 0.0;
+  __pyx_v_sum_right = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":162
- *             double sum = 0.0
+  /* "adaXT/criteria/criteria.pyx":156
+ *             double sum_right = 0.0
  * 
  *         for i in range(start_idx, new_split):  # loop over indices to be updated             # <<<<<<<<<<<<<<
  *             for j in range(self.num_classes):
  *                 p = indices[i]
  */
   __pyx_t_1 = __pyx_v_new_split;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = __pyx_v_start_idx; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "adaXT/criteria/criteria.pyx":163
+    /* "adaXT/criteria/criteria.pyx":157
  * 
  *         for i in range(start_idx, new_split):  # loop over indices to be updated
  *             for j in range(self.num_classes):             # <<<<<<<<<<<<<<
  *                 p = indices[i]
  *                 if self.y[p] == self.class_labels[j]:
  */
     __pyx_t_4 = __pyx_v_self->num_classes;
     __pyx_t_5 = __pyx_t_4;
     for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
       __pyx_v_j = __pyx_t_6;
 
-      /* "adaXT/criteria/criteria.pyx":164
+      /* "adaXT/criteria/criteria.pyx":158
  *         for i in range(start_idx, new_split):  # loop over indices to be updated
  *             for j in range(self.num_classes):
  *                 p = indices[i]             # <<<<<<<<<<<<<<
  *                 if self.y[p] == self.class_labels[j]:
  *                     weight = self.sample_weight[p]
  */
       __pyx_t_7 = __pyx_v_i;
-      __pyx_v_p = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_7 * __pyx_v_indices.strides[0]) )));
+      __pyx_v_p = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_7)) )));
 
-      /* "adaXT/criteria/criteria.pyx":165
+      /* "adaXT/criteria/criteria.pyx":159
  *             for j in range(self.num_classes):
  *                 p = indices[i]
  *                 if self.y[p] == self.class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_left[j] += weight
+ *                     self.weight_in_class_left[j] += weight
  */
       __pyx_t_7 = __pyx_v_p;
       __pyx_t_8 = __pyx_v_j;
       __pyx_t_9 = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_7)) ))) == (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->class_labels.data) + __pyx_t_8)) ))));
       if (__pyx_t_9) {
 
-        /* "adaXT/criteria/criteria.pyx":166
+        /* "adaXT/criteria/criteria.pyx":160
  *                 p = indices[i]
  *                 if self.y[p] == self.class_labels[j]:
  *                     weight = self.sample_weight[p]             # <<<<<<<<<<<<<<
- *                     self.n_in_class_left[j] += weight
+ *                     self.weight_in_class_left[j] += weight
  *                     self.weight_left += weight
  */
         __pyx_t_8 = __pyx_v_p;
         __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_8)) )));
 
-        /* "adaXT/criteria/criteria.pyx":167
+        /* "adaXT/criteria/criteria.pyx":161
  *                 if self.y[p] == self.class_labels[j]:
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_left[j] += weight             # <<<<<<<<<<<<<<
+ *                     self.weight_in_class_left[j] += weight             # <<<<<<<<<<<<<<
  *                     self.weight_left += weight
- *                     break
+ *                     self.weight_in_class_right[j] -= weight
  */
         __pyx_t_10 = __pyx_v_j;
-        (__pyx_v_self->n_in_class_left[__pyx_t_10]) = ((__pyx_v_self->n_in_class_left[__pyx_t_10]) + __pyx_v_weight);
+        (__pyx_v_self->weight_in_class_left[__pyx_t_10]) = ((__pyx_v_self->weight_in_class_left[__pyx_t_10]) + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":168
+        /* "adaXT/criteria/criteria.pyx":162
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_left[j] += weight
+ *                     self.weight_in_class_left[j] += weight
  *                     self.weight_left += weight             # <<<<<<<<<<<<<<
- *                     break
- * 
+ *                     self.weight_in_class_right[j] -= weight
+ *                     self.weight_right -= weight
  */
         __pyx_v_self->weight_left = (__pyx_v_self->weight_left + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":169
- *                     self.n_in_class_left[j] += weight
+        /* "adaXT/criteria/criteria.pyx":163
+ *                     self.weight_in_class_left[j] += weight
+ *                     self.weight_left += weight
+ *                     self.weight_in_class_right[j] -= weight             # <<<<<<<<<<<<<<
+ *                     self.weight_right -= weight
+ *                     break
+ */
+        __pyx_t_10 = __pyx_v_j;
+        (__pyx_v_self->weight_in_class_right[__pyx_t_10]) = ((__pyx_v_self->weight_in_class_right[__pyx_t_10]) - __pyx_v_weight);
+
+        /* "adaXT/criteria/criteria.pyx":164
  *                     self.weight_left += weight
+ *                     self.weight_in_class_right[j] -= weight
+ *                     self.weight_right -= weight             # <<<<<<<<<<<<<<
+ *                     break
+ * 
+ */
+        __pyx_v_self->weight_right = (__pyx_v_self->weight_right - __pyx_v_weight);
+
+        /* "adaXT/criteria/criteria.pyx":165
+ *                     self.weight_in_class_right[j] -= weight
+ *                     self.weight_right -= weight
  *                     break             # <<<<<<<<<<<<<<
  * 
  *         # Loop over all classes and calculate gini_index
  */
         goto __pyx_L6_break;
 
-        /* "adaXT/criteria/criteria.pyx":165
+        /* "adaXT/criteria/criteria.pyx":159
  *             for j in range(self.num_classes):
  *                 p = indices[i]
  *                 if self.y[p] == self.class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_left[j] += weight
+ *                     self.weight_in_class_left[j] += weight
  */
       }
     }
     __pyx_L6_break:;
   }
 
-  /* "adaXT/criteria/criteria.pyx":172
+  /* "adaXT/criteria/criteria.pyx":168
  * 
  *         # Loop over all classes and calculate gini_index
  *         for i in range(self.num_classes):             # <<<<<<<<<<<<<<
- *             proportion_cls = (self.n_in_class_left[i]) / self.weight_left
- *             sum += proportion_cls * proportion_cls
+ *             proportion_cls_left = (self.weight_in_class_left[i]) / self.weight_left
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right
  */
   __pyx_t_1 = __pyx_v_self->num_classes;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "adaXT/criteria/criteria.pyx":173
+    /* "adaXT/criteria/criteria.pyx":169
  *         # Loop over all classes and calculate gini_index
  *         for i in range(self.num_classes):
- *             proportion_cls = (self.n_in_class_left[i]) / self.weight_left             # <<<<<<<<<<<<<<
- *             sum += proportion_cls * proportion_cls
- * 
+ *             proportion_cls_left = (self.weight_in_class_left[i]) / self.weight_left             # <<<<<<<<<<<<<<
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right
+ *             sum_left += proportion_cls_left * proportion_cls_left
  */
-    __pyx_v_proportion_cls = ((__pyx_v_self->n_in_class_left[__pyx_v_i]) / __pyx_v_self->weight_left);
+    __pyx_v_proportion_cls_left = ((__pyx_v_self->weight_in_class_left[__pyx_v_i]) / __pyx_v_self->weight_left);
 
-    /* "adaXT/criteria/criteria.pyx":174
+    /* "adaXT/criteria/criteria.pyx":170
  *         for i in range(self.num_classes):
- *             proportion_cls = (self.n_in_class_left[i]) / self.weight_left
- *             sum += proportion_cls * proportion_cls             # <<<<<<<<<<<<<<
+ *             proportion_cls_left = (self.weight_in_class_left[i]) / self.weight_left
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right             # <<<<<<<<<<<<<<
+ *             sum_left += proportion_cls_left * proportion_cls_left
+ *             sum_right += proportion_cls_right * proportion_cls_right
+ */
+    __pyx_v_proportion_cls_right = ((__pyx_v_self->weight_in_class_right[__pyx_v_i]) / __pyx_v_self->weight_right);
+
+    /* "adaXT/criteria/criteria.pyx":171
+ *             proportion_cls_left = (self.weight_in_class_left[i]) / self.weight_left
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right
+ *             sum_left += proportion_cls_left * proportion_cls_left             # <<<<<<<<<<<<<<
+ *             sum_right += proportion_cls_right * proportion_cls_right
  * 
- *         return 1.0 - sum
  */
-    __pyx_v_sum = (__pyx_v_sum + (__pyx_v_proportion_cls * __pyx_v_proportion_cls));
+    __pyx_v_sum_left = (__pyx_v_sum_left + (__pyx_v_proportion_cls_left * __pyx_v_proportion_cls_left));
+
+    /* "adaXT/criteria/criteria.pyx":172
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right
+ *             sum_left += proportion_cls_left * proportion_cls_left
+ *             sum_right += proportion_cls_right * proportion_cls_right             # <<<<<<<<<<<<<<
+ * 
+ *         # No need to divide by the total weight, as the proxy proxy_improvement is always compared to itself
+ */
+    __pyx_v_sum_right = (__pyx_v_sum_right + (__pyx_v_proportion_cls_right * __pyx_v_proportion_cls_right));
   }
 
-  /* "adaXT/criteria/criteria.pyx":176
- *             sum += proportion_cls * proportion_cls
+  /* "adaXT/criteria/criteria.pyx":175
  * 
- *         return 1.0 - sum             # <<<<<<<<<<<<<<
+ *         # No need to divide by the total weight, as the proxy proxy_improvement is always compared to itself
+ *         return (1.0 - sum_left)*self.weight_left + (1.0 - sum_right)*self.weight_right             # <<<<<<<<<<<<<<
  * 
- *     cdef double update_right(self, int[:] indices, int new_split):
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):
  */
-  __pyx_r = (1.0 - __pyx_v_sum);
+  __pyx_r = (((1.0 - __pyx_v_sum_left) * __pyx_v_self->weight_left) + ((1.0 - __pyx_v_sum_right) * __pyx_v_self->weight_right));
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":154
+  /* "adaXT/criteria/criteria.pyx":147
  *         return 1.0 - sum
  * 
- *     cdef double update_left(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
+ *     cdef double update_proxy(self, int[::1] indices, int new_split):             # <<<<<<<<<<<<<<
  *         # All new values in node from before
  *         cdef:
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":178
- *         return 1.0 - sum
+/* "adaXT/criteria/criteria.pyx":177
+ *         return (1.0 - sum_left)*self.weight_left + (1.0 - sum_right)*self.weight_right
  * 
- *     cdef double update_right(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
- *         # All new values in node from before
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
  *         cdef:
+ *             int n_obs = indices.shape[0]
  */
 
-static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_update_right(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split) {
+static double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_proxy_improvement(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx) {
+  int __pyx_v_n_obs;
+  double __pyx_v_sum_left;
+  double __pyx_v_sum_right;
+  double __pyx_v_proportion_cls_left;
+  double __pyx_v_proportion_cls_right;
+  double __pyx_v_weight;
   int __pyx_v_i;
   int __pyx_v_j;
   int __pyx_v_p;
-  int __pyx_v_start_idx;
-  int __pyx_v_n_obs;
-  double __pyx_v_proportion_cls;
-  double __pyx_v_weight;
-  double __pyx_v_sum;
+  __Pyx_memviewslice __pyx_v_y = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_class_labels = { 0, 0, { 0 }, { 0 }, { 0 } };
   double __pyx_r;
-  int __pyx_t_1;
+  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
+  int __pyx_t_7;
   Py_ssize_t __pyx_t_8;
-  int __pyx_t_9;
+  Py_ssize_t __pyx_t_9;
   int __pyx_t_10;
+  int __pyx_t_11;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
 
-  /* "adaXT/criteria/criteria.pyx":182
+  /* "adaXT/criteria/criteria.pyx":179
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):
  *         cdef:
+ *             int n_obs = indices.shape[0]             # <<<<<<<<<<<<<<
+ *             double sum_left = 0.0
+ *             double sum_right = 0.0
+ */
+  __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
+
+  /* "adaXT/criteria/criteria.pyx":180
+ *         cdef:
+ *             int n_obs = indices.shape[0]
+ *             double sum_left = 0.0             # <<<<<<<<<<<<<<
+ *             double sum_right = 0.0
+ *             double proportion_cls_left, proportion_cls_right, weight
+ */
+  __pyx_v_sum_left = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":181
+ *             int n_obs = indices.shape[0]
+ *             double sum_left = 0.0
+ *             double sum_right = 0.0             # <<<<<<<<<<<<<<
+ *             double proportion_cls_left, proportion_cls_right, weight
  *             int i, j, p
- *             int start_idx = self.old_split             # <<<<<<<<<<<<<<
- *             int n_obs = indices.shape[0] - new_split
- *             double proportion_cls, weight
  */
-  __pyx_t_1 = __pyx_v_self->old_split;
-  __pyx_v_start_idx = __pyx_t_1;
+  __pyx_v_sum_right = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":183
+  /* "adaXT/criteria/criteria.pyx":184
+ *             double proportion_cls_left, proportion_cls_right, weight
  *             int i, j, p
- *             int start_idx = self.old_split
- *             int n_obs = indices.shape[0] - new_split             # <<<<<<<<<<<<<<
- *             double proportion_cls, weight
- *             double sum = 0.0
+ *             double[:] y = self.y             # <<<<<<<<<<<<<<
+ *             double[:] class_labels = self.class_labels
+ * 
  */
-  __pyx_v_n_obs = ((__pyx_v_indices.shape[0]) - __pyx_v_new_split);
+  __pyx_t_1 = __pyx_v_self->__pyx_base.y;
+  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_v_y = __pyx_t_1;
+  __pyx_t_1.memview = NULL;
+  __pyx_t_1.data = NULL;
 
   /* "adaXT/criteria/criteria.pyx":185
- *             int n_obs = indices.shape[0] - new_split
- *             double proportion_cls, weight
- *             double sum = 0.0             # <<<<<<<<<<<<<<
+ *             int i, j, p
+ *             double[:] y = self.y
+ *             double[:] class_labels = self.class_labels             # <<<<<<<<<<<<<<
  * 
- *         for i in range(start_idx, new_split):  # loop over indices to be updated
+ *         # Reset weights as we are in a new node
  */
-  __pyx_v_sum = 0.0;
+  __pyx_t_1 = __pyx_v_self->class_labels;
+  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_v_class_labels = __pyx_t_1;
+  __pyx_t_1.memview = NULL;
+  __pyx_t_1.data = NULL;
 
-  /* "adaXT/criteria/criteria.pyx":187
- *             double sum = 0.0
+  /* "adaXT/criteria/criteria.pyx":188
  * 
- *         for i in range(start_idx, new_split):  # loop over indices to be updated             # <<<<<<<<<<<<<<
+ *         # Reset weights as we are in a new node
+ *         self.reset_weight_list(self.weight_in_class_left)             # <<<<<<<<<<<<<<
+ *         self.reset_weight_list(self.weight_in_class_right)
+ *         self.weight_left = 0.0
+ */
+  ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->reset_weight_list(__pyx_v_self, __pyx_v_self->weight_in_class_left); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 188, __pyx_L1_error)
+
+  /* "adaXT/criteria/criteria.pyx":189
+ *         # Reset weights as we are in a new node
+ *         self.reset_weight_list(self.weight_in_class_left)
+ *         self.reset_weight_list(self.weight_in_class_right)             # <<<<<<<<<<<<<<
+ *         self.weight_left = 0.0
+ *         self.weight_right = 0.0
+ */
+  ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->reset_weight_list(__pyx_v_self, __pyx_v_self->weight_in_class_right); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 189, __pyx_L1_error)
+
+  /* "adaXT/criteria/criteria.pyx":190
+ *         self.reset_weight_list(self.weight_in_class_left)
+ *         self.reset_weight_list(self.weight_in_class_right)
+ *         self.weight_left = 0.0             # <<<<<<<<<<<<<<
+ *         self.weight_right = 0.0
+ * 
+ */
+  __pyx_v_self->weight_left = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":191
+ *         self.reset_weight_list(self.weight_in_class_right)
+ *         self.weight_left = 0.0
+ *         self.weight_right = 0.0             # <<<<<<<<<<<<<<
+ * 
+ *         for i in range(split_idx):
+ */
+  __pyx_v_self->weight_right = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":193
+ *         self.weight_right = 0.0
+ * 
+ *         for i in range(split_idx):             # <<<<<<<<<<<<<<
  *             for j in range(self.num_classes):
  *                 p = indices[i]
  */
-  __pyx_t_1 = __pyx_v_new_split;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = __pyx_v_start_idx; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_2 = __pyx_v_split_idx;
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
 
-    /* "adaXT/criteria/criteria.pyx":188
+    /* "adaXT/criteria/criteria.pyx":194
  * 
- *         for i in range(start_idx, new_split):  # loop over indices to be updated
+ *         for i in range(split_idx):
  *             for j in range(self.num_classes):             # <<<<<<<<<<<<<<
  *                 p = indices[i]
- *                 if self.y[p] == self.class_labels[j]:
+ *                 if y[p] == class_labels[j]:
  */
-    __pyx_t_4 = __pyx_v_self->num_classes;
-    __pyx_t_5 = __pyx_t_4;
-    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
-      __pyx_v_j = __pyx_t_6;
+    __pyx_t_5 = __pyx_v_self->num_classes;
+    __pyx_t_6 = __pyx_t_5;
+    for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+      __pyx_v_j = __pyx_t_7;
 
-      /* "adaXT/criteria/criteria.pyx":189
- *         for i in range(start_idx, new_split):  # loop over indices to be updated
+      /* "adaXT/criteria/criteria.pyx":195
+ *         for i in range(split_idx):
  *             for j in range(self.num_classes):
  *                 p = indices[i]             # <<<<<<<<<<<<<<
- *                 if self.y[p] == self.class_labels[j]:
+ *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]
  */
-      __pyx_t_7 = __pyx_v_i;
-      __pyx_v_p = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_7 * __pyx_v_indices.strides[0]) )));
+      __pyx_t_8 = __pyx_v_i;
+      __pyx_v_p = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_8)) )));
 
-      /* "adaXT/criteria/criteria.pyx":190
+      /* "adaXT/criteria/criteria.pyx":196
  *             for j in range(self.num_classes):
  *                 p = indices[i]
- *                 if self.y[p] == self.class_labels[j]:             # <<<<<<<<<<<<<<
+ *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_right[j] -= weight
+ *                     self.weight_in_class_left[j] += weight
  */
-      __pyx_t_7 = __pyx_v_p;
-      __pyx_t_8 = __pyx_v_j;
-      __pyx_t_9 = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_7)) ))) == (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->class_labels.data) + __pyx_t_8)) ))));
-      if (__pyx_t_9) {
+      __pyx_t_8 = __pyx_v_p;
+      __pyx_t_9 = __pyx_v_j;
+      __pyx_t_10 = ((*((double *) ( /* dim=0 */ (__pyx_v_y.data + __pyx_t_8 * __pyx_v_y.strides[0]) ))) == (*((double *) ( /* dim=0 */ (__pyx_v_class_labels.data + __pyx_t_9 * __pyx_v_class_labels.strides[0]) ))));
+      if (__pyx_t_10) {
 
-        /* "adaXT/criteria/criteria.pyx":191
+        /* "adaXT/criteria/criteria.pyx":197
  *                 p = indices[i]
- *                 if self.y[p] == self.class_labels[j]:
+ *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]             # <<<<<<<<<<<<<<
- *                     self.n_in_class_right[j] -= weight
- *                     self.weight_right -= weight
+ *                     self.weight_in_class_left[j] += weight
+ *                     self.weight_left += weight
  */
-        __pyx_t_8 = __pyx_v_p;
-        __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_8)) )));
+        __pyx_t_9 = __pyx_v_p;
+        __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_9)) )));
 
-        /* "adaXT/criteria/criteria.pyx":192
- *                 if self.y[p] == self.class_labels[j]:
+        /* "adaXT/criteria/criteria.pyx":198
+ *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_right[j] -= weight             # <<<<<<<<<<<<<<
- *                     self.weight_right -= weight
+ *                     self.weight_in_class_left[j] += weight             # <<<<<<<<<<<<<<
+ *                     self.weight_left += weight
  *                     break
  */
-        __pyx_t_10 = __pyx_v_j;
-        (__pyx_v_self->n_in_class_right[__pyx_t_10]) = ((__pyx_v_self->n_in_class_right[__pyx_t_10]) - __pyx_v_weight);
+        __pyx_t_11 = __pyx_v_j;
+        (__pyx_v_self->weight_in_class_left[__pyx_t_11]) = ((__pyx_v_self->weight_in_class_left[__pyx_t_11]) + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":193
+        /* "adaXT/criteria/criteria.pyx":199
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_right[j] -= weight
- *                     self.weight_right -= weight             # <<<<<<<<<<<<<<
+ *                     self.weight_in_class_left[j] += weight
+ *                     self.weight_left += weight             # <<<<<<<<<<<<<<
  *                     break
  * 
  */
-        __pyx_v_self->weight_right = (__pyx_v_self->weight_right - __pyx_v_weight);
+        __pyx_v_self->weight_left = (__pyx_v_self->weight_left + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":194
- *                     self.n_in_class_right[j] -= weight
- *                     self.weight_right -= weight
+        /* "adaXT/criteria/criteria.pyx":200
+ *                     self.weight_in_class_left[j] += weight
+ *                     self.weight_left += weight
  *                     break             # <<<<<<<<<<<<<<
  * 
- *         # Loop over all classes and calculate gini_index
+ *         for i in range(split_idx, n_obs):
  */
         goto __pyx_L6_break;
 
-        /* "adaXT/criteria/criteria.pyx":190
+        /* "adaXT/criteria/criteria.pyx":196
  *             for j in range(self.num_classes):
  *                 p = indices[i]
- *                 if self.y[p] == self.class_labels[j]:             # <<<<<<<<<<<<<<
+ *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_right[j] -= weight
+ *                     self.weight_in_class_left[j] += weight
  */
       }
     }
     __pyx_L6_break:;
   }
 
-  /* "adaXT/criteria/criteria.pyx":197
- * 
- *         # Loop over all classes and calculate gini_index
- *         for i in range(self.num_classes):             # <<<<<<<<<<<<<<
- *             proportion_cls = (self.n_in_class_right[i]) / (<double> n_obs)
- *             sum += proportion_cls * proportion_cls
- */
-  __pyx_t_1 = __pyx_v_self->num_classes;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
-
-    /* "adaXT/criteria/criteria.pyx":198
- *         # Loop over all classes and calculate gini_index
- *         for i in range(self.num_classes):
- *             proportion_cls = (self.n_in_class_right[i]) / (<double> n_obs)             # <<<<<<<<<<<<<<
- *             sum += proportion_cls * proportion_cls
- * 
- */
-    __pyx_v_proportion_cls = ((__pyx_v_self->n_in_class_right[__pyx_v_i]) / ((double)__pyx_v_n_obs));
-
-    /* "adaXT/criteria/criteria.pyx":199
- *         for i in range(self.num_classes):
- *             proportion_cls = (self.n_in_class_right[i]) / (<double> n_obs)
- *             sum += proportion_cls * proportion_cls             # <<<<<<<<<<<<<<
- * 
- *         return 1.0 - sum
- */
-    __pyx_v_sum = (__pyx_v_sum + (__pyx_v_proportion_cls * __pyx_v_proportion_cls));
-  }
-
-  /* "adaXT/criteria/criteria.pyx":201
- *             sum += proportion_cls * proportion_cls
- * 
- *         return 1.0 - sum             # <<<<<<<<<<<<<<
- * 
- *     # Override the default evaluate_split
- */
-  __pyx_r = (1.0 - __pyx_v_sum);
-  goto __pyx_L0;
-
-  /* "adaXT/criteria/criteria.pyx":178
- *         return 1.0 - sum
+  /* "adaXT/criteria/criteria.pyx":202
+ *                     break
  * 
- *     cdef double update_right(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
- *         # All new values in node from before
- *         cdef:
+ *         for i in range(split_idx, n_obs):             # <<<<<<<<<<<<<<
+ *             for j in range(self.num_classes):
+ *                 p = indices[i]
  */
+  __pyx_t_2 = __pyx_v_n_obs;
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = __pyx_v_split_idx; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
 
-  /* function exit code */
-  __pyx_L0:;
-  return __pyx_r;
-}
-
-/* "adaXT/criteria/criteria.pyx":204
+    /* "adaXT/criteria/criteria.pyx":203
  * 
- *     # Override the default evaluate_split
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
- *         cdef:
- *             int n_obs = indices.shape[0]
- */
-
-static __pyx_ctuple_double__and_double__and_double__and_double __pyx_f_5adaXT_8criteria_8criteria_10Gini_index_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature) {
-  int __pyx_v_n_obs;
-  int __pyx_v_n_left;
-  int __pyx_v_n_right;
-  double __pyx_v_mean_thresh;
-  double __pyx_v_left_imp;
-  double __pyx_v_right_imp;
-  double __pyx_v_crit;
-  __Pyx_memviewslice __pyx_v_features = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __pyx_ctuple_double__and_double__and_double__and_double __pyx_r;
-  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_t_2;
-  int __pyx_t_3;
-  double __pyx_t_4;
-  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
-  Py_ssize_t __pyx_t_8;
-  Py_ssize_t __pyx_t_9;
-  Py_ssize_t __pyx_t_10;
-  Py_ssize_t __pyx_t_11;
-  Py_ssize_t __pyx_t_12;
-  __pyx_ctuple_double__and_double__and_double__and_double __pyx_t_13;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-
-  /* "adaXT/criteria/criteria.pyx":206
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):
- *         cdef:
- *             int n_obs = indices.shape[0]             # <<<<<<<<<<<<<<
- *             int n_left = split_idx
- *             int n_right = n_obs - n_left
+ *         for i in range(split_idx, n_obs):
+ *             for j in range(self.num_classes):             # <<<<<<<<<<<<<<
+ *                 p = indices[i]
+ *                 if y[p] == class_labels[j]:
  */
-  __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
+    __pyx_t_5 = __pyx_v_self->num_classes;
+    __pyx_t_6 = __pyx_t_5;
+    for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+      __pyx_v_j = __pyx_t_7;
 
-  /* "adaXT/criteria/criteria.pyx":207
- *         cdef:
- *             int n_obs = indices.shape[0]
- *             int n_left = split_idx             # <<<<<<<<<<<<<<
- *             int n_right = n_obs - n_left
- *             double mean_thresh
+      /* "adaXT/criteria/criteria.pyx":204
+ *         for i in range(split_idx, n_obs):
+ *             for j in range(self.num_classes):
+ *                 p = indices[i]             # <<<<<<<<<<<<<<
+ *                 if y[p] == class_labels[j]:
+ *                     weight = self.sample_weight[p]
  */
-  __pyx_v_n_left = __pyx_v_split_idx;
+      __pyx_t_9 = __pyx_v_i;
+      __pyx_v_p = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_9)) )));
 
-  /* "adaXT/criteria/criteria.pyx":208
- *             int n_obs = indices.shape[0]
- *             int n_left = split_idx
- *             int n_right = n_obs - n_left             # <<<<<<<<<<<<<<
- *             double mean_thresh
- *             double left_imp = 0.0
+      /* "adaXT/criteria/criteria.pyx":205
+ *             for j in range(self.num_classes):
+ *                 p = indices[i]
+ *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
+ *                     weight = self.sample_weight[p]
+ *                     self.weight_in_class_right[j] += weight
  */
-  __pyx_v_n_right = (__pyx_v_n_obs - __pyx_v_n_left);
+      __pyx_t_9 = __pyx_v_p;
+      __pyx_t_8 = __pyx_v_j;
+      __pyx_t_10 = ((*((double *) ( /* dim=0 */ (__pyx_v_y.data + __pyx_t_9 * __pyx_v_y.strides[0]) ))) == (*((double *) ( /* dim=0 */ (__pyx_v_class_labels.data + __pyx_t_8 * __pyx_v_class_labels.strides[0]) ))));
+      if (__pyx_t_10) {
 
-  /* "adaXT/criteria/criteria.pyx":210
- *             int n_right = n_obs - n_left
- *             double mean_thresh
- *             double left_imp = 0.0             # <<<<<<<<<<<<<<
- *             double right_imp = 0.0
- *             double crit = 0.0
+        /* "adaXT/criteria/criteria.pyx":206
+ *                 p = indices[i]
+ *                 if y[p] == class_labels[j]:
+ *                     weight = self.sample_weight[p]             # <<<<<<<<<<<<<<
+ *                     self.weight_in_class_right[j] += weight
+ *                     self.weight_right += weight
  */
-  __pyx_v_left_imp = 0.0;
+        __pyx_t_8 = __pyx_v_p;
+        __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_8)) )));
 
-  /* "adaXT/criteria/criteria.pyx":211
- *             double mean_thresh
- *             double left_imp = 0.0
- *             double right_imp = 0.0             # <<<<<<<<<<<<<<
- *             double crit = 0.0
- *             double[:, ::1] features = self.x
+        /* "adaXT/criteria/criteria.pyx":207
+ *                 if y[p] == class_labels[j]:
+ *                     weight = self.sample_weight[p]
+ *                     self.weight_in_class_right[j] += weight             # <<<<<<<<<<<<<<
+ *                     self.weight_right += weight
+ *                     break
  */
-  __pyx_v_right_imp = 0.0;
+        __pyx_t_11 = __pyx_v_j;
+        (__pyx_v_self->weight_in_class_right[__pyx_t_11]) = ((__pyx_v_self->weight_in_class_right[__pyx_t_11]) + __pyx_v_weight);
 
-  /* "adaXT/criteria/criteria.pyx":212
- *             double left_imp = 0.0
- *             double right_imp = 0.0
- *             double crit = 0.0             # <<<<<<<<<<<<<<
- *             double[:, ::1] features = self.x
+        /* "adaXT/criteria/criteria.pyx":208
+ *                     weight = self.sample_weight[p]
+ *                     self.weight_in_class_right[j] += weight
+ *                     self.weight_right += weight             # <<<<<<<<<<<<<<
+ *                     break
  * 
  */
-  __pyx_v_crit = 0.0;
+        __pyx_v_self->weight_right = (__pyx_v_self->weight_right + __pyx_v_weight);
 
-  /* "adaXT/criteria/criteria.pyx":213
- *             double right_imp = 0.0
- *             double crit = 0.0
- *             double[:, ::1] features = self.x             # <<<<<<<<<<<<<<
+        /* "adaXT/criteria/criteria.pyx":209
+ *                     self.weight_in_class_right[j] += weight
+ *                     self.weight_right += weight
+ *                     break             # <<<<<<<<<<<<<<
  * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
+ *         # Loop over all classes and calculate gini_index
  */
-  __pyx_t_1 = __pyx_v_self->__pyx_base.x;
-  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
-  __pyx_v_features = __pyx_t_1;
-  __pyx_t_1.memview = NULL;
-  __pyx_t_1.data = NULL;
+        goto __pyx_L11_break;
 
-  /* "adaXT/criteria/criteria.pyx":215
- *             double[:, ::1] features = self.x
- * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting             # <<<<<<<<<<<<<<
- *             left_imp = self.update_left(indices, split_idx)
- *             right_imp = self.update_right(indices, split_idx)
+        /* "adaXT/criteria/criteria.pyx":205
+ *             for j in range(self.num_classes):
+ *                 p = indices[i]
+ *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
+ *                     weight = self.sample_weight[p]
+ *                     self.weight_in_class_right[j] += weight
  */
-  __pyx_t_3 = (__pyx_v_n_obs == __pyx_v_self->old_obs);
-  if (__pyx_t_3) {
-  } else {
-    __pyx_t_2 = __pyx_t_3;
-    goto __pyx_L4_bool_binop_done;
+      }
+    }
+    __pyx_L11_break:;
   }
-  __pyx_t_3 = (__pyx_v_feature == __pyx_v_self->old_feature);
-  __pyx_t_2 = __pyx_t_3;
-  __pyx_L4_bool_binop_done:;
-  if (__pyx_t_2) {
 
-    /* "adaXT/criteria/criteria.pyx":216
- * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
- *             left_imp = self.update_left(indices, split_idx)             # <<<<<<<<<<<<<<
- *             right_imp = self.update_right(indices, split_idx)
+  /* "adaXT/criteria/criteria.pyx":212
  * 
+ *         # Loop over all classes and calculate gini_index
+ *         for i in range(self.num_classes):             # <<<<<<<<<<<<<<
+ *             proportion_cls_left = (self.weight_in_class_left[i]) / self.weight_left
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right
  */
-    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->update_left(__pyx_v_self, __pyx_v_indices, __pyx_v_split_idx); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 216, __pyx_L1_error)
-    __pyx_v_left_imp = __pyx_t_4;
+  __pyx_t_2 = __pyx_v_self->num_classes;
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
 
-    /* "adaXT/criteria/criteria.pyx":217
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
- *             left_imp = self.update_left(indices, split_idx)
- *             right_imp = self.update_right(indices, split_idx)             # <<<<<<<<<<<<<<
- * 
- *         else:
+    /* "adaXT/criteria/criteria.pyx":213
+ *         # Loop over all classes and calculate gini_index
+ *         for i in range(self.num_classes):
+ *             proportion_cls_left = (self.weight_in_class_left[i]) / self.weight_left             # <<<<<<<<<<<<<<
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right
+ *             sum_left += proportion_cls_left * proportion_cls_left
  */
-    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->update_right(__pyx_v_self, __pyx_v_indices, __pyx_v_split_idx); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 217, __pyx_L1_error)
-    __pyx_v_right_imp = __pyx_t_4;
+    __pyx_v_proportion_cls_left = ((__pyx_v_self->weight_in_class_left[__pyx_v_i]) / __pyx_v_self->weight_left);
 
-    /* "adaXT/criteria/criteria.pyx":215
- *             double[:, ::1] features = self.x
- * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting             # <<<<<<<<<<<<<<
- *             left_imp = self.update_left(indices, split_idx)
- *             right_imp = self.update_right(indices, split_idx)
+    /* "adaXT/criteria/criteria.pyx":214
+ *         for i in range(self.num_classes):
+ *             proportion_cls_left = (self.weight_in_class_left[i]) / self.weight_left
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right             # <<<<<<<<<<<<<<
+ *             sum_left += proportion_cls_left * proportion_cls_left
+ *             sum_right += proportion_cls_right * proportion_cls_right
  */
-    goto __pyx_L3;
-  }
+    __pyx_v_proportion_cls_right = ((__pyx_v_self->weight_in_class_right[__pyx_v_i]) / __pyx_v_self->weight_right);
 
-  /* "adaXT/criteria/criteria.pyx":220
- * 
- *         else:
- *             left_imp = self._gini(indices[:split_idx], self.n_in_class_left, 1)             # <<<<<<<<<<<<<<
- *             right_imp = self._gini(indices[split_idx:], self.n_in_class_right, 0)
+    /* "adaXT/criteria/criteria.pyx":215
+ *             proportion_cls_left = (self.weight_in_class_left[i]) / self.weight_left
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right
+ *             sum_left += proportion_cls_left * proportion_cls_left             # <<<<<<<<<<<<<<
+ *             sum_right += proportion_cls_right * proportion_cls_right
  * 
  */
-  /*else*/ {
-    __pyx_t_5.data = __pyx_v_indices.data;
-    __pyx_t_5.memview = __pyx_v_indices.memview;
-    __PYX_INC_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_6 = -1;
-    if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_5,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_6,
-    0,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 220, __pyx_L1_error)
-}
+    __pyx_v_sum_left = (__pyx_v_sum_left + (__pyx_v_proportion_cls_left * __pyx_v_proportion_cls_left));
 
-__pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->_gini(__pyx_v_self, __pyx_t_5, __pyx_v_self->n_in_class_left, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 220, __pyx_L1_error)
-    __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_5.memview = NULL; __pyx_t_5.data = NULL;
-    __pyx_v_left_imp = __pyx_t_4;
-
-    /* "adaXT/criteria/criteria.pyx":221
- *         else:
- *             left_imp = self._gini(indices[:split_idx], self.n_in_class_left, 1)
- *             right_imp = self._gini(indices[split_idx:], self.n_in_class_right, 0)             # <<<<<<<<<<<<<<
+    /* "adaXT/criteria/criteria.pyx":216
+ *             proportion_cls_right = (self.weight_in_class_right[i]) / self.weight_right
+ *             sum_left += proportion_cls_left * proportion_cls_left
+ *             sum_right += proportion_cls_right * proportion_cls_right             # <<<<<<<<<<<<<<
  * 
- *         self.old_feature = feature
+ *         # No need to divide by the total weight, as the proxy proxy_improvement is always compared to itself
  */
-    __pyx_t_5.data = __pyx_v_indices.data;
-    __pyx_t_5.memview = __pyx_v_indices.memview;
-    __PYX_INC_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_6 = -1;
-    if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_5,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_6,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 221, __pyx_L1_error)
-}
-
-__pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Gini_index *)__pyx_v_self->__pyx_base.__pyx_vtab)->_gini(__pyx_v_self, __pyx_t_5, __pyx_v_self->n_in_class_right, 0); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 221, __pyx_L1_error)
-    __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_5.memview = NULL; __pyx_t_5.data = NULL;
-    __pyx_v_right_imp = __pyx_t_4;
+    __pyx_v_sum_right = (__pyx_v_sum_right + (__pyx_v_proportion_cls_right * __pyx_v_proportion_cls_right));
   }
-  __pyx_L3:;
-
-  /* "adaXT/criteria/criteria.pyx":223
- *             right_imp = self._gini(indices[split_idx:], self.n_in_class_right, 0)
- * 
- *         self.old_feature = feature             # <<<<<<<<<<<<<<
- *         self.old_obs = n_obs
- *         self.old_split = split_idx
- */
-  __pyx_v_self->old_feature = __pyx_v_feature;
-
-  /* "adaXT/criteria/criteria.pyx":224
- * 
- *         self.old_feature = feature
- *         self.old_obs = n_obs             # <<<<<<<<<<<<<<
- *         self.old_split = split_idx
- *         crit = left_imp * n_left / n_obs
- */
-  __pyx_v_self->old_obs = __pyx_v_n_obs;
-
-  /* "adaXT/criteria/criteria.pyx":225
- *         self.old_feature = feature
- *         self.old_obs = n_obs
- *         self.old_split = split_idx             # <<<<<<<<<<<<<<
- *         crit = left_imp * n_left / n_obs
- *         crit += right_imp * n_right / n_obs
- */
-  __pyx_v_self->old_split = __pyx_v_split_idx;
-
-  /* "adaXT/criteria/criteria.pyx":226
- *         self.old_obs = n_obs
- *         self.old_split = split_idx
- *         crit = left_imp * n_left / n_obs             # <<<<<<<<<<<<<<
- *         crit += right_imp * n_right / n_obs
- * 
- */
-  __pyx_v_crit = ((__pyx_v_left_imp * __pyx_v_n_left) / ((double)__pyx_v_n_obs));
-
-  /* "adaXT/criteria/criteria.pyx":227
- *         self.old_split = split_idx
- *         crit = left_imp * n_left / n_obs
- *         crit += right_imp * n_right / n_obs             # <<<<<<<<<<<<<<
- * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0
- */
-  __pyx_v_crit = (__pyx_v_crit + ((__pyx_v_right_imp * __pyx_v_n_right) / ((double)__pyx_v_n_obs)));
 
-  /* "adaXT/criteria/criteria.pyx":229
- *         crit += right_imp * n_right / n_obs
+  /* "adaXT/criteria/criteria.pyx":219
  * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0             # <<<<<<<<<<<<<<
- *         return (crit, left_imp, right_imp, mean_thresh)
+ *         # No need to divide by the total weight, as the proxy proxy_improvement is always compared to itself
+ *         return (1.0 - sum_left)*self.weight_left + (1.0 - sum_right)*self.weight_right             # <<<<<<<<<<<<<<
  * 
- */
-  __pyx_t_7 = (__pyx_v_split_idx - 1);
-  __pyx_t_8 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_7 * __pyx_v_indices.strides[0]) )));
-  __pyx_t_9 = __pyx_v_feature;
-  __pyx_t_10 = __pyx_v_split_idx;
-  __pyx_t_11 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_10 * __pyx_v_indices.strides[0]) )));
-  __pyx_t_12 = __pyx_v_feature;
-  __pyx_v_mean_thresh = (((*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_features.data + __pyx_t_8 * __pyx_v_features.strides[0]) )) + __pyx_t_9)) ))) + (*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_features.data + __pyx_t_11 * __pyx_v_features.strides[0]) )) + __pyx_t_12)) )))) / 2.0);
-
-  /* "adaXT/criteria/criteria.pyx":230
- * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0
- *         return (crit, left_imp, right_imp, mean_thresh)             # <<<<<<<<<<<<<<
  * 
- * cdef class Entropy(Criteria):
  */
-  __pyx_t_13.f0 = __pyx_v_crit;
-  __pyx_t_13.f1 = __pyx_v_left_imp;
-  __pyx_t_13.f2 = __pyx_v_right_imp;
-  __pyx_t_13.f3 = __pyx_v_mean_thresh;
-  __pyx_r = __pyx_t_13;
+  __pyx_r = (((1.0 - __pyx_v_sum_left) * __pyx_v_self->weight_left) + ((1.0 - __pyx_v_sum_right) * __pyx_v_self->weight_right));
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":204
+  /* "adaXT/criteria/criteria.pyx":177
+ *         return (1.0 - sum_left)*self.weight_left + (1.0 - sum_right)*self.weight_right
  * 
- *     # Override the default evaluate_split
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
  *         cdef:
  *             int n_obs = indices.shape[0]
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-  __Pyx_AddTraceback("adaXT.criteria.criteria.Gini_index.evaluate_split", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_pretend_to_initialize(&__pyx_r);
+  __Pyx_AddTraceback("adaXT.criteria.criteria.Gini_index.proxy_improvement", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
   __pyx_L0:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_features, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_y, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_class_labels, 1);
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
@@ -20658,19 +20706,19 @@
   __Pyx_AddTraceback("adaXT.criteria.criteria.Gini_index.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":244
- *         int old_feature
+/* "adaXT/criteria/criteria.pyx":232
+ *         bint first_call
  * 
  *     def __init__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):             # <<<<<<<<<<<<<<
- *         self.old_obs = -1
+ *         self.first_call = True
  * 
  */
 
 /* Python wrapper */
 static int __pyx_pw_5adaXT_8criteria_8criteria_7Entropy_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
 static int __pyx_pw_5adaXT_8criteria_8criteria_7Entropy_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   CYTHON_UNUSED __Pyx_memviewslice __pyx_v_x = { 0, 0, { 0 }, { 0 }, { 0 } };
@@ -20708,55 +20756,55 @@
       kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_x)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 244, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 232, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_y)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 244, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 232, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 1); __PYX_ERR(1, 244, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 1); __PYX_ERR(1, 232, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_sample_weight)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[2]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 244, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 232, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 2); __PYX_ERR(1, 244, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 2); __PYX_ERR(1, 232, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(1, 244, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(1, 232, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 3)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
       values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
       values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
     }
-    __pyx_v_x = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_x.memview)) __PYX_ERR(1, 244, __pyx_L3_error)
-    __pyx_v_y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_y.memview)) __PYX_ERR(1, 244, __pyx_L3_error)
-    __pyx_v_sample_weight = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[2], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sample_weight.memview)) __PYX_ERR(1, 244, __pyx_L3_error)
+    __pyx_v_x = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_x.memview)) __PYX_ERR(1, 232, __pyx_L3_error)
+    __pyx_v_y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_y.memview)) __PYX_ERR(1, 232, __pyx_L3_error)
+    __pyx_v_sample_weight = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[2], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sample_weight.memview)) __PYX_ERR(1, 232, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, __pyx_nargs); __PYX_ERR(1, 244, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, __pyx_nargs); __PYX_ERR(1, 232, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
@@ -20784,42 +20832,42 @@
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 static int __pyx_pf_5adaXT_8criteria_8criteria_7Entropy___init__(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_x, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_y, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_sample_weight) {
   int __pyx_r;
 
-  /* "adaXT/criteria/criteria.pyx":245
+  /* "adaXT/criteria/criteria.pyx":233
  * 
  *     def __init__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):
- *         self.old_obs = -1             # <<<<<<<<<<<<<<
+ *         self.first_call = True             # <<<<<<<<<<<<<<
  * 
  *     def __del__(self):  # Called by garbage collector.
  */
-  __pyx_v_self->old_obs = -1;
+  __pyx_v_self->first_call = 1;
 
-  /* "adaXT/criteria/criteria.pyx":244
- *         int old_feature
+  /* "adaXT/criteria/criteria.pyx":232
+ *         bint first_call
  * 
  *     def __init__(self, double[:, ::1] x, double[::1] y, double[::1] sample_weight):             # <<<<<<<<<<<<<<
- *         self.old_obs = -1
+ *         self.first_call = True
  * 
  */
 
   /* function exit code */
   __pyx_r = 0;
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":247
- *         self.old_obs = -1
+/* "adaXT/criteria/criteria.pyx":235
+ *         self.first_call = True
  * 
  *     def __del__(self):  # Called by garbage collector.             # <<<<<<<<<<<<<<
- *         free(self.n_in_class_left)
- *         free(self.n_in_class_right)
+ *         free(self.weight_in_class_left)
+ *         free(self.weight_in_class_right)
  */
 
 /* Python wrapper */
 static void __pyx_pw_5adaXT_8criteria_8criteria_7Entropy_3__del__(PyObject *__pyx_v_self); /*proto*/
 static void __pyx_pw_5adaXT_8criteria_8criteria_7Entropy_3__del__(PyObject *__pyx_v_self) {
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   __Pyx_RefNannyDeclarations
@@ -20829,49 +20877,49 @@
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
 static void __pyx_pf_5adaXT_8criteria_8criteria_7Entropy_2__del__(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self) {
 
-  /* "adaXT/criteria/criteria.pyx":248
+  /* "adaXT/criteria/criteria.pyx":236
  * 
  *     def __del__(self):  # Called by garbage collector.
- *         free(self.n_in_class_left)             # <<<<<<<<<<<<<<
- *         free(self.n_in_class_right)
+ *         free(self.weight_in_class_left)             # <<<<<<<<<<<<<<
+ *         free(self.weight_in_class_right)
  * 
  */
-  free(__pyx_v_self->n_in_class_left);
+  free(__pyx_v_self->weight_in_class_left);
 
-  /* "adaXT/criteria/criteria.pyx":249
+  /* "adaXT/criteria/criteria.pyx":237
  *     def __del__(self):  # Called by garbage collector.
- *         free(self.n_in_class_left)
- *         free(self.n_in_class_right)             # <<<<<<<<<<<<<<
+ *         free(self.weight_in_class_left)
+ *         free(self.weight_in_class_right)             # <<<<<<<<<<<<<<
  * 
- *     cpdef double impurity(self, int[:] indices):
+ *     cpdef double impurity(self, int[::1] indices):
  */
-  free(__pyx_v_self->n_in_class_right);
+  free(__pyx_v_self->weight_in_class_right);
 
-  /* "adaXT/criteria/criteria.pyx":247
- *         self.old_obs = -1
+  /* "adaXT/criteria/criteria.pyx":235
+ *         self.first_call = True
  * 
  *     def __del__(self):  # Called by garbage collector.             # <<<<<<<<<<<<<<
- *         free(self.n_in_class_left)
- *         free(self.n_in_class_right)
+ *         free(self.weight_in_class_left)
+ *         free(self.weight_in_class_right)
  */
 
   /* function exit code */
 }
 
-/* "adaXT/criteria/criteria.pyx":251
- *         free(self.n_in_class_right)
+/* "adaXT/criteria/criteria.pyx":239
+ *         free(self.weight_in_class_right)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
  */
 
 static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_7Entropy_5impurity(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
@@ -20897,18 +20945,18 @@
   /* Check if overridden in Python */
   else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || __Pyx_PyType_HasFeature(Py_TYPE(((PyObject *)__pyx_v_self)), (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
     #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
     if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
       PY_UINT64_T __pyx_typedict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
       #endif
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 251, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 239, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_8criteria_8criteria_7Entropy_5impurity)) {
-        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 251, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 239, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
         __pyx_t_6 = 0;
         #if CYTHON_UNPACK_METHODS
         if (unlikely(PyMethod_Check(__pyx_t_4))) {
           __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
@@ -20922,19 +20970,19 @@
         }
         #endif
         {
           PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_t_3};
           __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
           __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 251, __pyx_L1_error)
+          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 239, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_2);
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
         }
-        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 251, __pyx_L1_error)
+        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 239, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
         __pyx_r = __pyx_t_7;
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         goto __pyx_L0;
       }
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
       __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
@@ -20945,111 +20993,138 @@
       #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     }
     #endif
   }
 
-  /* "adaXT/criteria/criteria.pyx":252
+  /* "adaXT/criteria/criteria.pyx":240
  * 
- *     cpdef double impurity(self, int[:] indices):
- *         self.class_labels = np.unique(self.y.base[indices])             # <<<<<<<<<<<<<<
- *         self.num_classes = self.class_labels.shape[0]
- *         self.n_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
+ *     cpdef double impurity(self, int[::1] indices):
+ *         if self.first_call:             # <<<<<<<<<<<<<<
+ *             self.class_labels = np.unique(self.y.base[indices])
+ *             self.num_classes = self.class_labels.shape[0]
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 252, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 252, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_self->__pyx_base.y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 252, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_base); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 252, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 252, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 252, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = NULL;
-  __pyx_t_6 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_4))) {
-    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
-    if (likely(__pyx_t_2)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-      __Pyx_INCREF(__pyx_t_2);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_4, function);
-      __pyx_t_6 = 1;
+  if (__pyx_v_self->first_call) {
+
+    /* "adaXT/criteria/criteria.pyx":241
+ *     cpdef double impurity(self, int[::1] indices):
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])             # <<<<<<<<<<<<<<
+ *             self.num_classes = self.class_labels.shape[0]
+ * 
+ */
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 241, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 241, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_self->__pyx_base.y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 241, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_base); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 241, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 241, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 241, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = NULL;
+    __pyx_t_6 = 0;
+    #if CYTHON_UNPACK_METHODS
+    if (unlikely(PyMethod_Check(__pyx_t_4))) {
+      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
+      if (likely(__pyx_t_2)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_2);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_4, function);
+        __pyx_t_6 = 1;
+      }
     }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_2, __pyx_t_5};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 252, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  }
-  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(1, 252, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->class_labels, 0);
-  __pyx_v_self->class_labels = __pyx_t_8;
-  __pyx_t_8.memview = NULL;
-  __pyx_t_8.data = NULL;
-
-  /* "adaXT/criteria/criteria.pyx":253
- *     cpdef double impurity(self, int[:] indices):
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]             # <<<<<<<<<<<<<<
- *         self.n_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
- *         self.n_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)
+    #endif
+    {
+      PyObject *__pyx_callargs[2] = {__pyx_t_2, __pyx_t_5};
+      __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
+      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 241, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    }
+    __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(1, 241, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->class_labels, 0);
+    __pyx_v_self->class_labels = __pyx_t_8;
+    __pyx_t_8.memview = NULL;
+    __pyx_t_8.data = NULL;
+
+    /* "adaXT/criteria/criteria.pyx":242
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
+ *             self.num_classes = self.class_labels.shape[0]             # <<<<<<<<<<<<<<
+ * 
+ *             self.weight_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)
  */
-  __pyx_v_self->num_classes = (__pyx_v_self->class_labels.shape[0]);
+    __pyx_v_self->num_classes = (__pyx_v_self->class_labels.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":254
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
- *         self.n_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)             # <<<<<<<<<<<<<<
- *         self.n_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)
- *         # n_in_class_left can be use as the int pointer as it will be cleared before and after this use
- */
-  __pyx_v_self->n_in_class_left = ((double *)malloc(((sizeof(double)) * __pyx_v_self->num_classes)));
-
-  /* "adaXT/criteria/criteria.pyx":255
- *         self.num_classes = self.class_labels.shape[0]
- *         self.n_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
- *         self.n_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)             # <<<<<<<<<<<<<<
- *         # n_in_class_left can be use as the int pointer as it will be cleared before and after this use
- *         return self._entropy(indices, self.n_in_class_left, 1)
- */
-  __pyx_v_self->n_in_class_right = ((double *)malloc(((sizeof(double)) * __pyx_v_self->num_classes)));
-
-  /* "adaXT/criteria/criteria.pyx":257
- *         self.n_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)
- *         # n_in_class_left can be use as the int pointer as it will be cleared before and after this use
- *         return self._entropy(indices, self.n_in_class_left, 1)             # <<<<<<<<<<<<<<
+    /* "adaXT/criteria/criteria.pyx":244
+ *             self.num_classes = self.class_labels.shape[0]
+ * 
+ *             self.weight_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)             # <<<<<<<<<<<<<<
+ *             self.weight_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
+ * 
+ */
+    __pyx_v_self->weight_in_class_right = ((double *)malloc(((sizeof(double)) * __pyx_v_self->num_classes)));
+
+    /* "adaXT/criteria/criteria.pyx":245
+ * 
+ *             self.weight_in_class_right = <double *> malloc(sizeof(double) * self.num_classes)
+ *             self.weight_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)             # <<<<<<<<<<<<<<
+ * 
+ *             self.first_call = False
+ */
+    __pyx_v_self->weight_in_class_left = ((double *)malloc(((sizeof(double)) * __pyx_v_self->num_classes)));
+
+    /* "adaXT/criteria/criteria.pyx":247
+ *             self.weight_in_class_left = <double *> malloc(sizeof(double) * self.num_classes)
+ * 
+ *             self.first_call = False             # <<<<<<<<<<<<<<
+ * 
+ *         # weight_in_class_left can be use as the int pointer as it will be cleared before and after this use
+ */
+    __pyx_v_self->first_call = 0;
+
+    /* "adaXT/criteria/criteria.pyx":240
  * 
- *     cdef void reset_n_in_class(self, double* class_occurences):
+ *     cpdef double impurity(self, int[::1] indices):
+ *         if self.first_call:             # <<<<<<<<<<<<<<
+ *             self.class_labels = np.unique(self.y.base[indices])
+ *             self.num_classes = self.class_labels.shape[0]
  */
-  __pyx_t_7 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->_entropy(__pyx_v_self, __pyx_v_indices, __pyx_v_self->n_in_class_left, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 257, __pyx_L1_error)
+  }
+
+  /* "adaXT/criteria/criteria.pyx":250
+ * 
+ *         # weight_in_class_left can be use as the int pointer as it will be cleared before and after this use
+ *         return self._entropy(indices, self.weight_in_class_left)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef void reset_weight_list(self, double* class_occurences):
+ */
+  __pyx_t_7 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->_entropy(__pyx_v_self, __pyx_v_indices, __pyx_v_self->weight_in_class_left); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 250, __pyx_L1_error)
   __pyx_r = __pyx_t_7;
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":251
- *         free(self.n_in_class_right)
+  /* "adaXT/criteria/criteria.pyx":239
+ *         free(self.weight_in_class_right)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -21112,31 +21187,31 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 251, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 239, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 251, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 239, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_ds_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 251, __pyx_L3_error)
+    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 239, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 251, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 239, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -21167,16 +21242,16 @@
   double __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("impurity", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_7Entropy_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 251, __pyx_L1_error)
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 251, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_7Entropy_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 239, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 239, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -21185,70 +21260,53 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":259
- *         return self._entropy(indices, self.n_in_class_left, 1)
+/* "adaXT/criteria/criteria.pyx":252
+ *         return self._entropy(indices, self.weight_in_class_left)
  * 
- *     cdef void reset_n_in_class(self, double* class_occurences):             # <<<<<<<<<<<<<<
- *         cdef int i
- *         for i in range(self.num_classes):
+ *     cdef void reset_weight_list(self, double* class_occurences):             # <<<<<<<<<<<<<<
+ *         # Use memset to set the entire malloc to 0
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
  */
 
-static void __pyx_f_5adaXT_8criteria_8criteria_7Entropy_reset_n_in_class(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, double *__pyx_v_class_occurences) {
-  int __pyx_v_i;
-  int __pyx_t_1;
-  int __pyx_t_2;
-  int __pyx_t_3;
-
-  /* "adaXT/criteria/criteria.pyx":261
- *     cdef void reset_n_in_class(self, double* class_occurences):
- *         cdef int i
- *         for i in range(self.num_classes):             # <<<<<<<<<<<<<<
- *             class_occurences[i] = 0.0
- * 
- */
-  __pyx_t_1 = __pyx_v_self->num_classes;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+static void __pyx_f_5adaXT_8criteria_8criteria_7Entropy_reset_weight_list(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, double *__pyx_v_class_occurences) {
 
-    /* "adaXT/criteria/criteria.pyx":262
- *         cdef int i
- *         for i in range(self.num_classes):
- *             class_occurences[i] = 0.0             # <<<<<<<<<<<<<<
+  /* "adaXT/criteria/criteria.pyx":254
+ *     cdef void reset_weight_list(self, double* class_occurences):
+ *         # Use memset to set the entire malloc to 0
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))             # <<<<<<<<<<<<<<
  * 
- *     cdef double _entropy(self, int[:] indices, double* class_occurences, int left_or_right):
+ *     cdef double _entropy(self, int[:] indices, double* class_occurences):
  */
-    (__pyx_v_class_occurences[__pyx_v_i]) = 0.0;
-  }
+  (void)(memset(__pyx_v_class_occurences, 0, (__pyx_v_self->num_classes * (sizeof(double)))));
 
-  /* "adaXT/criteria/criteria.pyx":259
- *         return self._entropy(indices, self.n_in_class_left, 1)
+  /* "adaXT/criteria/criteria.pyx":252
+ *         return self._entropy(indices, self.weight_in_class_left)
  * 
- *     cdef void reset_n_in_class(self, double* class_occurences):             # <<<<<<<<<<<<<<
- *         cdef int i
- *         for i in range(self.num_classes):
+ *     cdef void reset_weight_list(self, double* class_occurences):             # <<<<<<<<<<<<<<
+ *         # Use memset to set the entire malloc to 0
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
  */
 
   /* function exit code */
 }
 
-/* "adaXT/criteria/criteria.pyx":264
- *             class_occurences[i] = 0.0
+/* "adaXT/criteria/criteria.pyx":256
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
  * 
- *     cdef double _entropy(self, int[:] indices, double* class_occurences, int left_or_right):             # <<<<<<<<<<<<<<
+ *     cdef double _entropy(self, int[:] indices, double* class_occurences):             # <<<<<<<<<<<<<<
  *         """
  *         Function that calculates the entropy index of a dataset
  */
 
-static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy__entropy(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, double *__pyx_v_class_occurences, int __pyx_v_left_or_right) {
+static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy__entropy(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, double *__pyx_v_class_occurences) {
   double __pyx_v_sum;
   double __pyx_v_obs_weight;
   int __pyx_v_n_obs;
   double __pyx_v_pp;
   double __pyx_v_weight;
   int __pyx_v_i;
   int __pyx_v_j;
@@ -21267,277 +21325,246 @@
   Py_ssize_t __pyx_t_9;
   int __pyx_t_10;
   int __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "adaXT/criteria/criteria.pyx":282
+  /* "adaXT/criteria/criteria.pyx":274
  *             The value of the entropy index
  *         """
- *         self.reset_n_in_class(class_occurences)  # Reset the counter such that no previous values influence the new ones             # <<<<<<<<<<<<<<
+ *         self.reset_weight_list(class_occurences)  # Reset the counter such that no previous values influence the new ones             # <<<<<<<<<<<<<<
  * 
  *         cdef:
  */
-  ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->reset_n_in_class(__pyx_v_self, __pyx_v_class_occurences); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 282, __pyx_L1_error)
+  ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->reset_weight_list(__pyx_v_self, __pyx_v_class_occurences); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 274, __pyx_L1_error)
 
-  /* "adaXT/criteria/criteria.pyx":285
+  /* "adaXT/criteria/criteria.pyx":277
  * 
  *         cdef:
  *             double sum = 0.0             # <<<<<<<<<<<<<<
  *             double obs_weight = 0.0
  *             int n_obs = indices.shape[0]
  */
   __pyx_v_sum = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":286
+  /* "adaXT/criteria/criteria.pyx":278
  *         cdef:
  *             double sum = 0.0
  *             double obs_weight = 0.0             # <<<<<<<<<<<<<<
  *             int n_obs = indices.shape[0]
  *             double pp, weight
  */
   __pyx_v_obs_weight = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":287
+  /* "adaXT/criteria/criteria.pyx":279
  *             double sum = 0.0
  *             double obs_weight = 0.0
  *             int n_obs = indices.shape[0]             # <<<<<<<<<<<<<<
  *             double pp, weight
  *             int i, j, p
  */
   __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":290
+  /* "adaXT/criteria/criteria.pyx":282
  *             double pp, weight
  *             int i, j, p
  *             double[:] y = self.y             # <<<<<<<<<<<<<<
  *             double[:] class_labels = self.class_labels
  * 
  */
   __pyx_t_1 = __pyx_v_self->__pyx_base.y;
   __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
   __pyx_v_y = __pyx_t_1;
   __pyx_t_1.memview = NULL;
   __pyx_t_1.data = NULL;
 
-  /* "adaXT/criteria/criteria.pyx":291
+  /* "adaXT/criteria/criteria.pyx":283
  *             int i, j, p
  *             double[:] y = self.y
  *             double[:] class_labels = self.class_labels             # <<<<<<<<<<<<<<
  * 
  *         for i in range(n_obs):  # loop over all indices
  */
   __pyx_t_1 = __pyx_v_self->class_labels;
   __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
   __pyx_v_class_labels = __pyx_t_1;
   __pyx_t_1.memview = NULL;
   __pyx_t_1.data = NULL;
 
-  /* "adaXT/criteria/criteria.pyx":293
+  /* "adaXT/criteria/criteria.pyx":285
  *             double[:] class_labels = self.class_labels
  * 
  *         for i in range(n_obs):  # loop over all indices             # <<<<<<<<<<<<<<
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter
  *                 p = indices[i]
  */
   __pyx_t_2 = __pyx_v_n_obs;
   __pyx_t_3 = __pyx_t_2;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "adaXT/criteria/criteria.pyx":294
+    /* "adaXT/criteria/criteria.pyx":286
  * 
  *         for i in range(n_obs):  # loop over all indices
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter             # <<<<<<<<<<<<<<
  *                 p = indices[i]
  *                 if y[p] == class_labels[j]:
  */
     __pyx_t_5 = __pyx_v_self->num_classes;
     __pyx_t_6 = __pyx_t_5;
     for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
       __pyx_v_j = __pyx_t_7;
 
-      /* "adaXT/criteria/criteria.pyx":295
+      /* "adaXT/criteria/criteria.pyx":287
  *         for i in range(n_obs):  # loop over all indices
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter
  *                 p = indices[i]             # <<<<<<<<<<<<<<
  *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]
  */
       __pyx_t_8 = __pyx_v_i;
       __pyx_v_p = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_8 * __pyx_v_indices.strides[0]) )));
 
-      /* "adaXT/criteria/criteria.pyx":296
+      /* "adaXT/criteria/criteria.pyx":288
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter
  *                 p = indices[i]
  *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
  *                     obs_weight += weight
  */
       __pyx_t_8 = __pyx_v_p;
       __pyx_t_9 = __pyx_v_j;
       __pyx_t_10 = ((*((double *) ( /* dim=0 */ (__pyx_v_y.data + __pyx_t_8 * __pyx_v_y.strides[0]) ))) == (*((double *) ( /* dim=0 */ (__pyx_v_class_labels.data + __pyx_t_9 * __pyx_v_class_labels.strides[0]) ))));
       if (__pyx_t_10) {
 
-        /* "adaXT/criteria/criteria.pyx":297
+        /* "adaXT/criteria/criteria.pyx":289
  *                 p = indices[i]
  *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]             # <<<<<<<<<<<<<<
  *                     obs_weight += weight
  *                     class_occurences[j] += weight
  */
         __pyx_t_9 = __pyx_v_p;
         __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_9)) )));
 
-        /* "adaXT/criteria/criteria.pyx":298
+        /* "adaXT/criteria/criteria.pyx":290
  *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]
  *                     obs_weight += weight             # <<<<<<<<<<<<<<
  *                     class_occurences[j] += weight
- * 
+ *                     break
  */
         __pyx_v_obs_weight = (__pyx_v_obs_weight + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":299
+        /* "adaXT/criteria/criteria.pyx":291
  *                     weight = self.sample_weight[p]
  *                     obs_weight += weight
  *                     class_occurences[j] += weight             # <<<<<<<<<<<<<<
+ *                     break
  * 
- *         # Loop over all classes and calculate entropy
  */
         __pyx_t_11 = __pyx_v_j;
         (__pyx_v_class_occurences[__pyx_t_11]) = ((__pyx_v_class_occurences[__pyx_t_11]) + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":296
+        /* "adaXT/criteria/criteria.pyx":292
+ *                     obs_weight += weight
+ *                     class_occurences[j] += weight
+ *                     break             # <<<<<<<<<<<<<<
+ * 
+ *         # Loop over all classes and calculate entropy
+ */
+        goto __pyx_L6_break;
+
+        /* "adaXT/criteria/criteria.pyx":288
  *             for j in range(self.num_classes):  # Find the element we are currently on and increase it's counter
  *                 p = indices[i]
  *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
  *                     obs_weight += weight
  */
       }
     }
+    __pyx_L6_break:;
   }
 
-  /* "adaXT/criteria/criteria.pyx":302
+  /* "adaXT/criteria/criteria.pyx":295
  * 
  *         # Loop over all classes and calculate entropy
  *         for i in range(self.num_classes):             # <<<<<<<<<<<<<<
  *             if class_occurences[i] == 0:  # To make sure we dont take log(0)
  *                 continue
  */
   __pyx_t_2 = __pyx_v_self->num_classes;
   __pyx_t_3 = __pyx_t_2;
   for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
     __pyx_v_i = __pyx_t_4;
 
-    /* "adaXT/criteria/criteria.pyx":303
+    /* "adaXT/criteria/criteria.pyx":296
  *         # Loop over all classes and calculate entropy
  *         for i in range(self.num_classes):
  *             if class_occurences[i] == 0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
  *                 continue
  *             pp = (class_occurences[i])/(obs_weight)
  */
     __pyx_t_10 = ((__pyx_v_class_occurences[__pyx_v_i]) == 0.0);
     if (__pyx_t_10) {
 
-      /* "adaXT/criteria/criteria.pyx":304
+      /* "adaXT/criteria/criteria.pyx":297
  *         for i in range(self.num_classes):
  *             if class_occurences[i] == 0:  # To make sure we dont take log(0)
  *                 continue             # <<<<<<<<<<<<<<
  *             pp = (class_occurences[i])/(obs_weight)
- *             sum += - (pp) * log2(pp)
+ *             sum -= (pp) * log2(pp)
  */
       goto __pyx_L8_continue;
 
-      /* "adaXT/criteria/criteria.pyx":303
+      /* "adaXT/criteria/criteria.pyx":296
  *         # Loop over all classes and calculate entropy
  *         for i in range(self.num_classes):
  *             if class_occurences[i] == 0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
  *                 continue
  *             pp = (class_occurences[i])/(obs_weight)
  */
     }
 
-    /* "adaXT/criteria/criteria.pyx":305
+    /* "adaXT/criteria/criteria.pyx":298
  *             if class_occurences[i] == 0:  # To make sure we dont take log(0)
  *                 continue
  *             pp = (class_occurences[i])/(obs_weight)             # <<<<<<<<<<<<<<
- *             sum += - (pp) * log2(pp)
+ *             sum -= (pp) * log2(pp)
  * 
  */
     __pyx_v_pp = ((__pyx_v_class_occurences[__pyx_v_i]) / __pyx_v_obs_weight);
 
-    /* "adaXT/criteria/criteria.pyx":306
+    /* "adaXT/criteria/criteria.pyx":299
  *                 continue
  *             pp = (class_occurences[i])/(obs_weight)
- *             sum += - (pp) * log2(pp)             # <<<<<<<<<<<<<<
+ *             sum -= (pp) * log2(pp)             # <<<<<<<<<<<<<<
  * 
- *         # Save total weight
+ *         return sum
  */
-    __pyx_v_sum = (__pyx_v_sum + ((-__pyx_v_pp) * log2(__pyx_v_pp)));
+    __pyx_v_sum = (__pyx_v_sum - (__pyx_v_pp * log2(__pyx_v_pp)));
     __pyx_L8_continue:;
   }
 
-  /* "adaXT/criteria/criteria.pyx":309
- * 
- *         # Save total weight
- *         if left_or_right == 1:             # <<<<<<<<<<<<<<
- *             self.weight_left = obs_weight
- *         else:
- */
-  __pyx_t_10 = (__pyx_v_left_or_right == 1);
-  if (__pyx_t_10) {
-
-    /* "adaXT/criteria/criteria.pyx":310
- *         # Save total weight
- *         if left_or_right == 1:
- *             self.weight_left = obs_weight             # <<<<<<<<<<<<<<
- *         else:
- *             self.weight_right = obs_weight
- */
-    __pyx_v_self->weight_left = __pyx_v_obs_weight;
-
-    /* "adaXT/criteria/criteria.pyx":309
- * 
- *         # Save total weight
- *         if left_or_right == 1:             # <<<<<<<<<<<<<<
- *             self.weight_left = obs_weight
- *         else:
- */
-    goto __pyx_L11;
-  }
-
-  /* "adaXT/criteria/criteria.pyx":312
- *             self.weight_left = obs_weight
- *         else:
- *             self.weight_right = obs_weight             # <<<<<<<<<<<<<<
- *         return sum
+  /* "adaXT/criteria/criteria.pyx":301
+ *             sum -= (pp) * log2(pp)
  * 
- */
-  /*else*/ {
-    __pyx_v_self->weight_right = __pyx_v_obs_weight;
-  }
-  __pyx_L11:;
-
-  /* "adaXT/criteria/criteria.pyx":313
- *         else:
- *             self.weight_right = obs_weight
  *         return sum             # <<<<<<<<<<<<<<
  * 
- *     cdef double update_left(self, int[:] indices, int new_split):
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):
  */
   __pyx_r = __pyx_v_sum;
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":264
- *             class_occurences[i] = 0.0
+  /* "adaXT/criteria/criteria.pyx":256
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
  * 
- *     cdef double _entropy(self, int[:] indices, double* class_occurences, int left_or_right):             # <<<<<<<<<<<<<<
+ *     cdef double _entropy(self, int[:] indices, double* class_occurences):             # <<<<<<<<<<<<<<
  *         """
  *         Function that calculates the entropy index of a dataset
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
@@ -21545,775 +21572,725 @@
   __pyx_r = 0;
   __pyx_L0:;
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_y, 1);
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_class_labels, 1);
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":315
+/* "adaXT/criteria/criteria.pyx":303
  *         return sum
  * 
- *     cdef double update_left(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
- *         # All new values in node from before
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
  *         cdef:
+ *             double sum_left = 0.0
  */
 
-static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_update_left(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split) {
+static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_proxy_improvement(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx) {
+  double __pyx_v_sum_left;
+  double __pyx_v_sum_right;
+  int __pyx_v_n_obs;
+  double __pyx_v_weight;
   int __pyx_v_i;
   int __pyx_v_j;
   int __pyx_v_p;
-  int __pyx_v_start_idx;
+  __Pyx_memviewslice __pyx_v_y = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_class_labels = { 0, 0, { 0 }, { 0 }, { 0 } };
   double __pyx_v_pp;
-  double __pyx_v_weight;
-  double __pyx_v_sum;
   double __pyx_r;
-  int __pyx_t_1;
+  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
+  int __pyx_t_7;
   Py_ssize_t __pyx_t_8;
-  int __pyx_t_9;
+  Py_ssize_t __pyx_t_9;
   int __pyx_t_10;
+  int __pyx_t_11;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
 
-  /* "adaXT/criteria/criteria.pyx":319
+  /* "adaXT/criteria/criteria.pyx":305
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):
  *         cdef:
+ *             double sum_left = 0.0             # <<<<<<<<<<<<<<
+ *             double sum_right = 0.0
+ *             int n_obs = indices.shape[0]
+ */
+  __pyx_v_sum_left = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":306
+ *         cdef:
+ *             double sum_left = 0.0
+ *             double sum_right = 0.0             # <<<<<<<<<<<<<<
+ *             int n_obs = indices.shape[0]
+ *             double weight
+ */
+  __pyx_v_sum_right = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":307
+ *             double sum_left = 0.0
+ *             double sum_right = 0.0
+ *             int n_obs = indices.shape[0]             # <<<<<<<<<<<<<<
+ *             double weight
  *             int i, j, p
- *             int start_idx = self.old_split             # <<<<<<<<<<<<<<
- *             double pp, weight
- *             double sum = 0.0
  */
-  __pyx_t_1 = __pyx_v_self->old_split;
-  __pyx_v_start_idx = __pyx_t_1;
+  __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":321
- *             int start_idx = self.old_split
- *             double pp, weight
- *             double sum = 0.0             # <<<<<<<<<<<<<<
+  /* "adaXT/criteria/criteria.pyx":310
+ *             double weight
+ *             int i, j, p
+ *             double[:] y = self.y             # <<<<<<<<<<<<<<
+ *             double[:] class_labels = self.class_labels
  * 
- *         for i in range(start_idx, new_split):  # loop over indices to be updated
  */
-  __pyx_v_sum = 0.0;
+  __pyx_t_1 = __pyx_v_self->__pyx_base.y;
+  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_v_y = __pyx_t_1;
+  __pyx_t_1.memview = NULL;
+  __pyx_t_1.data = NULL;
 
-  /* "adaXT/criteria/criteria.pyx":323
- *             double sum = 0.0
+  /* "adaXT/criteria/criteria.pyx":311
+ *             int i, j, p
+ *             double[:] y = self.y
+ *             double[:] class_labels = self.class_labels             # <<<<<<<<<<<<<<
  * 
- *         for i in range(start_idx, new_split):  # loop over indices to be updated             # <<<<<<<<<<<<<<
+ *         # Reset weights as we are in a new node
+ */
+  __pyx_t_1 = __pyx_v_self->class_labels;
+  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_v_class_labels = __pyx_t_1;
+  __pyx_t_1.memview = NULL;
+  __pyx_t_1.data = NULL;
+
+  /* "adaXT/criteria/criteria.pyx":314
+ * 
+ *         # Reset weights as we are in a new node
+ *         self.reset_weight_list(self.weight_in_class_left)             # <<<<<<<<<<<<<<
+ *         self.reset_weight_list(self.weight_in_class_right)
+ *         self.weight_left = 0.0
+ */
+  ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->reset_weight_list(__pyx_v_self, __pyx_v_self->weight_in_class_left); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 314, __pyx_L1_error)
+
+  /* "adaXT/criteria/criteria.pyx":315
+ *         # Reset weights as we are in a new node
+ *         self.reset_weight_list(self.weight_in_class_left)
+ *         self.reset_weight_list(self.weight_in_class_right)             # <<<<<<<<<<<<<<
+ *         self.weight_left = 0.0
+ *         self.weight_right = 0.0
+ */
+  ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->reset_weight_list(__pyx_v_self, __pyx_v_self->weight_in_class_right); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 315, __pyx_L1_error)
+
+  /* "adaXT/criteria/criteria.pyx":316
+ *         self.reset_weight_list(self.weight_in_class_left)
+ *         self.reset_weight_list(self.weight_in_class_right)
+ *         self.weight_left = 0.0             # <<<<<<<<<<<<<<
+ *         self.weight_right = 0.0
+ * 
+ */
+  __pyx_v_self->weight_left = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":317
+ *         self.reset_weight_list(self.weight_in_class_right)
+ *         self.weight_left = 0.0
+ *         self.weight_right = 0.0             # <<<<<<<<<<<<<<
+ * 
+ *         for i in range(split_idx):
+ */
+  __pyx_v_self->weight_right = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":319
+ *         self.weight_right = 0.0
+ * 
+ *         for i in range(split_idx):             # <<<<<<<<<<<<<<
  *             for j in range(self.num_classes):
  *                 p = indices[i]
  */
-  __pyx_t_1 = __pyx_v_new_split;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = __pyx_v_start_idx; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_2 = __pyx_v_split_idx;
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
 
-    /* "adaXT/criteria/criteria.pyx":324
+    /* "adaXT/criteria/criteria.pyx":320
  * 
- *         for i in range(start_idx, new_split):  # loop over indices to be updated
+ *         for i in range(split_idx):
  *             for j in range(self.num_classes):             # <<<<<<<<<<<<<<
  *                 p = indices[i]
- *                 if self.y[p] == self.class_labels[j]:
+ *                 if y[p] == class_labels[j]:
  */
-    __pyx_t_4 = __pyx_v_self->num_classes;
-    __pyx_t_5 = __pyx_t_4;
-    for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
-      __pyx_v_j = __pyx_t_6;
+    __pyx_t_5 = __pyx_v_self->num_classes;
+    __pyx_t_6 = __pyx_t_5;
+    for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+      __pyx_v_j = __pyx_t_7;
 
-      /* "adaXT/criteria/criteria.pyx":325
- *         for i in range(start_idx, new_split):  # loop over indices to be updated
+      /* "adaXT/criteria/criteria.pyx":321
+ *         for i in range(split_idx):
  *             for j in range(self.num_classes):
  *                 p = indices[i]             # <<<<<<<<<<<<<<
- *                 if self.y[p] == self.class_labels[j]:
+ *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]
  */
-      __pyx_t_7 = __pyx_v_i;
-      __pyx_v_p = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_7 * __pyx_v_indices.strides[0]) )));
+      __pyx_t_8 = __pyx_v_i;
+      __pyx_v_p = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_8)) )));
 
-      /* "adaXT/criteria/criteria.pyx":326
+      /* "adaXT/criteria/criteria.pyx":322
  *             for j in range(self.num_classes):
  *                 p = indices[i]
- *                 if self.y[p] == self.class_labels[j]:             # <<<<<<<<<<<<<<
+ *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_left[j] += weight
+ *                     self.weight_in_class_left[j] += weight
  */
-      __pyx_t_7 = __pyx_v_p;
-      __pyx_t_8 = __pyx_v_j;
-      __pyx_t_9 = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_7)) ))) == (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->class_labels.data) + __pyx_t_8)) ))));
-      if (__pyx_t_9) {
+      __pyx_t_8 = __pyx_v_p;
+      __pyx_t_9 = __pyx_v_j;
+      __pyx_t_10 = ((*((double *) ( /* dim=0 */ (__pyx_v_y.data + __pyx_t_8 * __pyx_v_y.strides[0]) ))) == (*((double *) ( /* dim=0 */ (__pyx_v_class_labels.data + __pyx_t_9 * __pyx_v_class_labels.strides[0]) ))));
+      if (__pyx_t_10) {
 
-        /* "adaXT/criteria/criteria.pyx":327
+        /* "adaXT/criteria/criteria.pyx":323
  *                 p = indices[i]
- *                 if self.y[p] == self.class_labels[j]:
+ *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]             # <<<<<<<<<<<<<<
- *                     self.n_in_class_left[j] += weight
+ *                     self.weight_in_class_left[j] += weight
  *                     self.weight_left += weight
  */
-        __pyx_t_8 = __pyx_v_p;
-        __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_8)) )));
+        __pyx_t_9 = __pyx_v_p;
+        __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_9)) )));
 
-        /* "adaXT/criteria/criteria.pyx":328
- *                 if self.y[p] == self.class_labels[j]:
+        /* "adaXT/criteria/criteria.pyx":324
+ *                 if y[p] == class_labels[j]:
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_left[j] += weight             # <<<<<<<<<<<<<<
+ *                     self.weight_in_class_left[j] += weight             # <<<<<<<<<<<<<<
  *                     self.weight_left += weight
  *                     break
  */
-        __pyx_t_10 = __pyx_v_j;
-        (__pyx_v_self->n_in_class_left[__pyx_t_10]) = ((__pyx_v_self->n_in_class_left[__pyx_t_10]) + __pyx_v_weight);
+        __pyx_t_11 = __pyx_v_j;
+        (__pyx_v_self->weight_in_class_left[__pyx_t_11]) = ((__pyx_v_self->weight_in_class_left[__pyx_t_11]) + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":329
+        /* "adaXT/criteria/criteria.pyx":325
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_left[j] += weight
+ *                     self.weight_in_class_left[j] += weight
  *                     self.weight_left += weight             # <<<<<<<<<<<<<<
  *                     break
  * 
  */
         __pyx_v_self->weight_left = (__pyx_v_self->weight_left + __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":330
- *                     self.n_in_class_left[j] += weight
+        /* "adaXT/criteria/criteria.pyx":326
+ *                     self.weight_in_class_left[j] += weight
  *                     self.weight_left += weight
  *                     break             # <<<<<<<<<<<<<<
  * 
- *         # Loop over all classes and calculate entropy
+ *         for i in range(split_idx, n_obs):
  */
         goto __pyx_L6_break;
 
-        /* "adaXT/criteria/criteria.pyx":326
+        /* "adaXT/criteria/criteria.pyx":322
  *             for j in range(self.num_classes):
  *                 p = indices[i]
- *                 if self.y[p] == self.class_labels[j]:             # <<<<<<<<<<<<<<
+ *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_left[j] += weight
+ *                     self.weight_in_class_left[j] += weight
  */
       }
     }
     __pyx_L6_break:;
   }
 
-  /* "adaXT/criteria/criteria.pyx":333
+  /* "adaXT/criteria/criteria.pyx":328
+ *                     break
+ * 
+ *         for i in range(split_idx, n_obs):             # <<<<<<<<<<<<<<
+ *             for j in range(self.num_classes):
+ *                 p = indices[i]
+ */
+  __pyx_t_2 = __pyx_v_n_obs;
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = __pyx_v_split_idx; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
+
+    /* "adaXT/criteria/criteria.pyx":329
+ * 
+ *         for i in range(split_idx, n_obs):
+ *             for j in range(self.num_classes):             # <<<<<<<<<<<<<<
+ *                 p = indices[i]
+ *                 if y[p] == class_labels[j]:
+ */
+    __pyx_t_5 = __pyx_v_self->num_classes;
+    __pyx_t_6 = __pyx_t_5;
+    for (__pyx_t_7 = 0; __pyx_t_7 < __pyx_t_6; __pyx_t_7+=1) {
+      __pyx_v_j = __pyx_t_7;
+
+      /* "adaXT/criteria/criteria.pyx":330
+ *         for i in range(split_idx, n_obs):
+ *             for j in range(self.num_classes):
+ *                 p = indices[i]             # <<<<<<<<<<<<<<
+ *                 if y[p] == class_labels[j]:
+ *                     weight = self.sample_weight[p]
+ */
+      __pyx_t_9 = __pyx_v_i;
+      __pyx_v_p = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_9)) )));
+
+      /* "adaXT/criteria/criteria.pyx":331
+ *             for j in range(self.num_classes):
+ *                 p = indices[i]
+ *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
+ *                     weight = self.sample_weight[p]
+ *                     self.weight_in_class_right[j] += weight
+ */
+      __pyx_t_9 = __pyx_v_p;
+      __pyx_t_8 = __pyx_v_j;
+      __pyx_t_10 = ((*((double *) ( /* dim=0 */ (__pyx_v_y.data + __pyx_t_9 * __pyx_v_y.strides[0]) ))) == (*((double *) ( /* dim=0 */ (__pyx_v_class_labels.data + __pyx_t_8 * __pyx_v_class_labels.strides[0]) ))));
+      if (__pyx_t_10) {
+
+        /* "adaXT/criteria/criteria.pyx":332
+ *                 p = indices[i]
+ *                 if y[p] == class_labels[j]:
+ *                     weight = self.sample_weight[p]             # <<<<<<<<<<<<<<
+ *                     self.weight_in_class_right[j] += weight
+ *                     self.weight_right += weight
+ */
+        __pyx_t_8 = __pyx_v_p;
+        __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_8)) )));
+
+        /* "adaXT/criteria/criteria.pyx":333
+ *                 if y[p] == class_labels[j]:
+ *                     weight = self.sample_weight[p]
+ *                     self.weight_in_class_right[j] += weight             # <<<<<<<<<<<<<<
+ *                     self.weight_right += weight
+ *                     break
+ */
+        __pyx_t_11 = __pyx_v_j;
+        (__pyx_v_self->weight_in_class_right[__pyx_t_11]) = ((__pyx_v_self->weight_in_class_right[__pyx_t_11]) + __pyx_v_weight);
+
+        /* "adaXT/criteria/criteria.pyx":334
+ *                     weight = self.sample_weight[p]
+ *                     self.weight_in_class_right[j] += weight
+ *                     self.weight_right += weight             # <<<<<<<<<<<<<<
+ *                     break
+ * 
+ */
+        __pyx_v_self->weight_right = (__pyx_v_self->weight_right + __pyx_v_weight);
+
+        /* "adaXT/criteria/criteria.pyx":335
+ *                     self.weight_in_class_right[j] += weight
+ *                     self.weight_right += weight
+ *                     break             # <<<<<<<<<<<<<<
+ * 
+ *         # Loop over all classes and calculate entropy
+ */
+        goto __pyx_L11_break;
+
+        /* "adaXT/criteria/criteria.pyx":331
+ *             for j in range(self.num_classes):
+ *                 p = indices[i]
+ *                 if y[p] == class_labels[j]:             # <<<<<<<<<<<<<<
+ *                     weight = self.sample_weight[p]
+ *                     self.weight_in_class_right[j] += weight
+ */
+      }
+    }
+    __pyx_L11_break:;
+  }
+
+  /* "adaXT/criteria/criteria.pyx":338
  * 
  *         # Loop over all classes and calculate entropy
  *         for i in range(self.num_classes):             # <<<<<<<<<<<<<<
- *             if self.n_in_class_left[i] == 0:  # To make sure we dont take log(0)
- *                 continue
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)
  */
-  __pyx_t_1 = __pyx_v_self->num_classes;
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
+  __pyx_t_2 = __pyx_v_self->num_classes;
+  __pyx_t_3 = __pyx_t_2;
+  for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
+    __pyx_v_i = __pyx_t_4;
 
-    /* "adaXT/criteria/criteria.pyx":334
+    /* "adaXT/criteria/criteria.pyx":339
  *         # Loop over all classes and calculate entropy
  *         for i in range(self.num_classes):
- *             if self.n_in_class_left[i] == 0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
- *                 continue
- *             pp = (self.n_in_class_left[i])/(self.weight_left)
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)
+ *                 sum_left -= (pp) * log2(pp)
  */
-    __pyx_t_9 = ((__pyx_v_self->n_in_class_left[__pyx_v_i]) == 0.0);
-    if (__pyx_t_9) {
+    __pyx_t_10 = ((__pyx_v_self->weight_in_class_left[__pyx_v_i]) != 0.0);
+    if (__pyx_t_10) {
 
-      /* "adaXT/criteria/criteria.pyx":335
+      /* "adaXT/criteria/criteria.pyx":340
  *         for i in range(self.num_classes):
- *             if self.n_in_class_left[i] == 0:  # To make sure we dont take log(0)
- *                 continue             # <<<<<<<<<<<<<<
- *             pp = (self.n_in_class_left[i])/(self.weight_left)
- *             sum -= (pp) * log2(pp)
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)             # <<<<<<<<<<<<<<
+ *                 sum_left -= (pp) * log2(pp)
+ * 
  */
-      goto __pyx_L8_continue;
+      __pyx_v_pp = ((__pyx_v_self->weight_in_class_left[__pyx_v_i]) / __pyx_v_self->weight_left);
+
+      /* "adaXT/criteria/criteria.pyx":341
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)
+ *                 sum_left -= (pp) * log2(pp)             # <<<<<<<<<<<<<<
+ * 
+ *             if self.weight_in_class_right[i] != 0.0:
+ */
+      __pyx_v_sum_left = (__pyx_v_sum_left - (__pyx_v_pp * log2(__pyx_v_pp)));
 
-      /* "adaXT/criteria/criteria.pyx":334
+      /* "adaXT/criteria/criteria.pyx":339
  *         # Loop over all classes and calculate entropy
  *         for i in range(self.num_classes):
- *             if self.n_in_class_left[i] == 0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
- *                 continue
- *             pp = (self.n_in_class_left[i])/(self.weight_left)
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)
+ *                 sum_left -= (pp) * log2(pp)
  */
     }
 
-    /* "adaXT/criteria/criteria.pyx":336
- *             if self.n_in_class_left[i] == 0:  # To make sure we dont take log(0)
- *                 continue
- *             pp = (self.n_in_class_left[i])/(self.weight_left)             # <<<<<<<<<<<<<<
- *             sum -= (pp) * log2(pp)
- *         return sum
+    /* "adaXT/criteria/criteria.pyx":343
+ *                 sum_left -= (pp) * log2(pp)
+ * 
+ *             if self.weight_in_class_right[i] != 0.0:             # <<<<<<<<<<<<<<
+ *                 pp = (self.weight_in_class_right[i])/(self.weight_right)
+ *                 sum_right -= (pp) * log2(pp)
  */
-    __pyx_v_pp = ((__pyx_v_self->n_in_class_left[__pyx_v_i]) / __pyx_v_self->weight_left);
+    __pyx_t_10 = ((__pyx_v_self->weight_in_class_right[__pyx_v_i]) != 0.0);
+    if (__pyx_t_10) {
 
-    /* "adaXT/criteria/criteria.pyx":337
- *                 continue
- *             pp = (self.n_in_class_left[i])/(self.weight_left)
- *             sum -= (pp) * log2(pp)             # <<<<<<<<<<<<<<
- *         return sum
+      /* "adaXT/criteria/criteria.pyx":344
+ * 
+ *             if self.weight_in_class_right[i] != 0.0:
+ *                 pp = (self.weight_in_class_right[i])/(self.weight_right)             # <<<<<<<<<<<<<<
+ *                 sum_right -= (pp) * log2(pp)
  * 
  */
-    __pyx_v_sum = (__pyx_v_sum - (__pyx_v_pp * log2(__pyx_v_pp)));
-    __pyx_L8_continue:;
+      __pyx_v_pp = ((__pyx_v_self->weight_in_class_right[__pyx_v_i]) / __pyx_v_self->weight_right);
+
+      /* "adaXT/criteria/criteria.pyx":345
+ *             if self.weight_in_class_right[i] != 0.0:
+ *                 pp = (self.weight_in_class_right[i])/(self.weight_right)
+ *                 sum_right -= (pp) * log2(pp)             # <<<<<<<<<<<<<<
+ * 
+ *         return sum_left*self.weight_left + sum_right*self.weight_right
+ */
+      __pyx_v_sum_right = (__pyx_v_sum_right - (__pyx_v_pp * log2(__pyx_v_pp)));
+
+      /* "adaXT/criteria/criteria.pyx":343
+ *                 sum_left -= (pp) * log2(pp)
+ * 
+ *             if self.weight_in_class_right[i] != 0.0:             # <<<<<<<<<<<<<<
+ *                 pp = (self.weight_in_class_right[i])/(self.weight_right)
+ *                 sum_right -= (pp) * log2(pp)
+ */
+    }
   }
 
-  /* "adaXT/criteria/criteria.pyx":338
- *             pp = (self.n_in_class_left[i])/(self.weight_left)
- *             sum -= (pp) * log2(pp)
- *         return sum             # <<<<<<<<<<<<<<
+  /* "adaXT/criteria/criteria.pyx":347
+ *                 sum_right -= (pp) * log2(pp)
+ * 
+ *         return sum_left*self.weight_left + sum_right*self.weight_right             # <<<<<<<<<<<<<<
  * 
- *     cdef double update_right(self, int[:] indices, int new_split):
+ *     cdef double update_proxy(self, int[::1] indices, int new_split):
  */
-  __pyx_r = __pyx_v_sum;
+  __pyx_r = ((__pyx_v_sum_left * __pyx_v_self->weight_left) + (__pyx_v_sum_right * __pyx_v_self->weight_right));
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":315
+  /* "adaXT/criteria/criteria.pyx":303
  *         return sum
  * 
- *     cdef double update_left(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
- *         # All new values in node from before
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
  *         cdef:
+ *             double sum_left = 0.0
  */
 
   /* function exit code */
+  __pyx_L1_error:;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __Pyx_AddTraceback("adaXT.criteria.criteria.Entropy.proxy_improvement", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
   __pyx_L0:;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_y, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_class_labels, 1);
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":340
- *         return sum
+/* "adaXT/criteria/criteria.pyx":349
+ *         return sum_left*self.weight_left + sum_right*self.weight_right
  * 
- *     cdef double update_right(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
+ *     cdef double update_proxy(self, int[::1] indices, int new_split):             # <<<<<<<<<<<<<<
  *         # All new values in node from before
  *         cdef:
  */
 
-static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_update_right(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split) {
+static double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_update_proxy(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split) {
   int __pyx_v_i;
   int __pyx_v_j;
   int __pyx_v_p;
   int __pyx_v_start_idx;
-  double __pyx_v_pp;
   double __pyx_v_weight;
-  double __pyx_v_sum;
+  double __pyx_v_sum_left;
+  double __pyx_v_sum_right;
+  double __pyx_v_pp;
   double __pyx_r;
   int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   int __pyx_t_6;
   Py_ssize_t __pyx_t_7;
   Py_ssize_t __pyx_t_8;
   int __pyx_t_9;
   int __pyx_t_10;
 
-  /* "adaXT/criteria/criteria.pyx":344
+  /* "adaXT/criteria/criteria.pyx":353
  *         cdef:
  *             int i, j, p
  *             int start_idx = self.old_split             # <<<<<<<<<<<<<<
- *             double pp, weight
- *             double sum = 0.0
+ *             double weight
+ *             double sum_left = 0.0
  */
-  __pyx_t_1 = __pyx_v_self->old_split;
+  __pyx_t_1 = __pyx_v_self->__pyx_base.old_split;
   __pyx_v_start_idx = __pyx_t_1;
 
-  /* "adaXT/criteria/criteria.pyx":346
+  /* "adaXT/criteria/criteria.pyx":355
  *             int start_idx = self.old_split
- *             double pp, weight
- *             double sum = 0.0             # <<<<<<<<<<<<<<
+ *             double weight
+ *             double sum_left = 0.0             # <<<<<<<<<<<<<<
+ *             double sum_right = 0.0
+ * 
+ */
+  __pyx_v_sum_left = 0.0;
+
+  /* "adaXT/criteria/criteria.pyx":356
+ *             double weight
+ *             double sum_left = 0.0
+ *             double sum_right = 0.0             # <<<<<<<<<<<<<<
  * 
  *         for i in range(start_idx, new_split):  # loop over indices to be updated
  */
-  __pyx_v_sum = 0.0;
+  __pyx_v_sum_right = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":348
- *             double sum = 0.0
+  /* "adaXT/criteria/criteria.pyx":358
+ *             double sum_right = 0.0
  * 
  *         for i in range(start_idx, new_split):  # loop over indices to be updated             # <<<<<<<<<<<<<<
  *             for j in range(self.num_classes):
  *                 p = indices[i]
  */
   __pyx_t_1 = __pyx_v_new_split;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = __pyx_v_start_idx; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "adaXT/criteria/criteria.pyx":349
+    /* "adaXT/criteria/criteria.pyx":359
  * 
  *         for i in range(start_idx, new_split):  # loop over indices to be updated
  *             for j in range(self.num_classes):             # <<<<<<<<<<<<<<
  *                 p = indices[i]
  *                 if self.y[p] == self.class_labels[j]:
  */
     __pyx_t_4 = __pyx_v_self->num_classes;
     __pyx_t_5 = __pyx_t_4;
     for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
       __pyx_v_j = __pyx_t_6;
 
-      /* "adaXT/criteria/criteria.pyx":350
+      /* "adaXT/criteria/criteria.pyx":360
  *         for i in range(start_idx, new_split):  # loop over indices to be updated
  *             for j in range(self.num_classes):
  *                 p = indices[i]             # <<<<<<<<<<<<<<
  *                 if self.y[p] == self.class_labels[j]:
  *                     weight = self.sample_weight[p]
  */
       __pyx_t_7 = __pyx_v_i;
-      __pyx_v_p = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_7 * __pyx_v_indices.strides[0]) )));
+      __pyx_v_p = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_7)) )));
 
-      /* "adaXT/criteria/criteria.pyx":351
+      /* "adaXT/criteria/criteria.pyx":361
  *             for j in range(self.num_classes):
  *                 p = indices[i]
  *                 if self.y[p] == self.class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_right[j] -= weight
+ *                     self.weight_in_class_left[j] += weight
  */
       __pyx_t_7 = __pyx_v_p;
       __pyx_t_8 = __pyx_v_j;
       __pyx_t_9 = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_7)) ))) == (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->class_labels.data) + __pyx_t_8)) ))));
       if (__pyx_t_9) {
 
-        /* "adaXT/criteria/criteria.pyx":352
+        /* "adaXT/criteria/criteria.pyx":362
  *                 p = indices[i]
  *                 if self.y[p] == self.class_labels[j]:
  *                     weight = self.sample_weight[p]             # <<<<<<<<<<<<<<
- *                     self.n_in_class_right[j] -= weight
- *                     self.weight_right -= weight
+ *                     self.weight_in_class_left[j] += weight
+ *                     self.weight_left += weight
  */
         __pyx_t_8 = __pyx_v_p;
         __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_8)) )));
 
-        /* "adaXT/criteria/criteria.pyx":353
+        /* "adaXT/criteria/criteria.pyx":363
  *                 if self.y[p] == self.class_labels[j]:
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_right[j] -= weight             # <<<<<<<<<<<<<<
+ *                     self.weight_in_class_left[j] += weight             # <<<<<<<<<<<<<<
+ *                     self.weight_left += weight
+ *                     self.weight_in_class_right[j] -= weight
+ */
+        __pyx_t_10 = __pyx_v_j;
+        (__pyx_v_self->weight_in_class_left[__pyx_t_10]) = ((__pyx_v_self->weight_in_class_left[__pyx_t_10]) + __pyx_v_weight);
+
+        /* "adaXT/criteria/criteria.pyx":364
+ *                     weight = self.sample_weight[p]
+ *                     self.weight_in_class_left[j] += weight
+ *                     self.weight_left += weight             # <<<<<<<<<<<<<<
+ *                     self.weight_in_class_right[j] -= weight
+ *                     self.weight_right -= weight
+ */
+        __pyx_v_self->weight_left = (__pyx_v_self->weight_left + __pyx_v_weight);
+
+        /* "adaXT/criteria/criteria.pyx":365
+ *                     self.weight_in_class_left[j] += weight
+ *                     self.weight_left += weight
+ *                     self.weight_in_class_right[j] -= weight             # <<<<<<<<<<<<<<
  *                     self.weight_right -= weight
  *                     break
  */
         __pyx_t_10 = __pyx_v_j;
-        (__pyx_v_self->n_in_class_right[__pyx_t_10]) = ((__pyx_v_self->n_in_class_right[__pyx_t_10]) - __pyx_v_weight);
+        (__pyx_v_self->weight_in_class_right[__pyx_t_10]) = ((__pyx_v_self->weight_in_class_right[__pyx_t_10]) - __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":354
- *                     weight = self.sample_weight[p]
- *                     self.n_in_class_right[j] -= weight
+        /* "adaXT/criteria/criteria.pyx":366
+ *                     self.weight_left += weight
+ *                     self.weight_in_class_right[j] -= weight
  *                     self.weight_right -= weight             # <<<<<<<<<<<<<<
  *                     break
  * 
  */
         __pyx_v_self->weight_right = (__pyx_v_self->weight_right - __pyx_v_weight);
 
-        /* "adaXT/criteria/criteria.pyx":355
- *                     self.n_in_class_right[j] -= weight
+        /* "adaXT/criteria/criteria.pyx":367
+ *                     self.weight_in_class_right[j] -= weight
  *                     self.weight_right -= weight
  *                     break             # <<<<<<<<<<<<<<
  * 
  *         # Loop over all classes and calculate entropy
  */
         goto __pyx_L6_break;
 
-        /* "adaXT/criteria/criteria.pyx":351
+        /* "adaXT/criteria/criteria.pyx":361
  *             for j in range(self.num_classes):
  *                 p = indices[i]
  *                 if self.y[p] == self.class_labels[j]:             # <<<<<<<<<<<<<<
  *                     weight = self.sample_weight[p]
- *                     self.n_in_class_right[j] -= weight
+ *                     self.weight_in_class_left[j] += weight
  */
       }
     }
     __pyx_L6_break:;
   }
 
-  /* "adaXT/criteria/criteria.pyx":358
+  /* "adaXT/criteria/criteria.pyx":370
  * 
  *         # Loop over all classes and calculate entropy
  *         for i in range(self.num_classes):             # <<<<<<<<<<<<<<
- *             if self.n_in_class_right[i] == 0.0:  # To make sure we dont take log(0)
- *                 continue
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)
  */
   __pyx_t_1 = __pyx_v_self->num_classes;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "adaXT/criteria/criteria.pyx":359
+    /* "adaXT/criteria/criteria.pyx":371
  *         # Loop over all classes and calculate entropy
  *         for i in range(self.num_classes):
- *             if self.n_in_class_right[i] == 0.0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
- *                 continue
- *             pp = (self.n_in_class_right[i])/(self.weight_right)
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)
+ *                 sum_left -= (pp) * log2(pp)
  */
-    __pyx_t_9 = ((__pyx_v_self->n_in_class_right[__pyx_v_i]) == 0.0);
+    __pyx_t_9 = ((__pyx_v_self->weight_in_class_left[__pyx_v_i]) != 0.0);
     if (__pyx_t_9) {
 
-      /* "adaXT/criteria/criteria.pyx":360
- *         for i in range(self.num_classes):
- *             if self.n_in_class_right[i] == 0.0:  # To make sure we dont take log(0)
- *                 continue             # <<<<<<<<<<<<<<
- *             pp = (self.n_in_class_right[i])/(self.weight_right)
- *             sum += - (pp) * log2(pp)
- */
-      goto __pyx_L8_continue;
-
-      /* "adaXT/criteria/criteria.pyx":359
- *         # Loop over all classes and calculate entropy
+      /* "adaXT/criteria/criteria.pyx":372
  *         for i in range(self.num_classes):
- *             if self.n_in_class_right[i] == 0.0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
- *                 continue
- *             pp = (self.n_in_class_right[i])/(self.weight_right)
- */
-    }
-
-    /* "adaXT/criteria/criteria.pyx":361
- *             if self.n_in_class_right[i] == 0.0:  # To make sure we dont take log(0)
- *                 continue
- *             pp = (self.n_in_class_right[i])/(self.weight_right)             # <<<<<<<<<<<<<<
- *             sum += - (pp) * log2(pp)
- *         return sum
- */
-    __pyx_v_pp = ((__pyx_v_self->n_in_class_right[__pyx_v_i]) / __pyx_v_self->weight_right);
-
-    /* "adaXT/criteria/criteria.pyx":362
- *                 continue
- *             pp = (self.n_in_class_right[i])/(self.weight_right)
- *             sum += - (pp) * log2(pp)             # <<<<<<<<<<<<<<
- *         return sum
- * 
- */
-    __pyx_v_sum = (__pyx_v_sum + ((-__pyx_v_pp) * log2(__pyx_v_pp)));
-    __pyx_L8_continue:;
-  }
-
-  /* "adaXT/criteria/criteria.pyx":363
- *             pp = (self.n_in_class_right[i])/(self.weight_right)
- *             sum += - (pp) * log2(pp)
- *         return sum             # <<<<<<<<<<<<<<
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)             # <<<<<<<<<<<<<<
+ *                 sum_left -= (pp) * log2(pp)
  * 
- *     # Override the default evaluate_split
- */
-  __pyx_r = __pyx_v_sum;
-  goto __pyx_L0;
-
-  /* "adaXT/criteria/criteria.pyx":340
- *         return sum
- * 
- *     cdef double update_right(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
- *         # All new values in node from before
- *         cdef:
- */
-
-  /* function exit code */
-  __pyx_L0:;
-  return __pyx_r;
-}
-
-/* "adaXT/criteria/criteria.pyx":366
- * 
- *     # Override the default evaluate_split
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
- *         cdef:
- *             int n_obs = indices.shape[0]
- */
-
-static __pyx_ctuple_double__and_double__and_double__and_double __pyx_f_5adaXT_8criteria_8criteria_7Entropy_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature) {
-  int __pyx_v_n_obs;
-  int __pyx_v_n_left;
-  int __pyx_v_n_right;
-  double __pyx_v_mean_thresh;
-  double __pyx_v_left_imp;
-  double __pyx_v_right_imp;
-  double __pyx_v_crit;
-  __Pyx_memviewslice __pyx_v_features = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __pyx_ctuple_double__and_double__and_double__and_double __pyx_r;
-  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_t_2;
-  int __pyx_t_3;
-  double __pyx_t_4;
-  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
-  Py_ssize_t __pyx_t_8;
-  Py_ssize_t __pyx_t_9;
-  Py_ssize_t __pyx_t_10;
-  Py_ssize_t __pyx_t_11;
-  Py_ssize_t __pyx_t_12;
-  __pyx_ctuple_double__and_double__and_double__and_double __pyx_t_13;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-
-  /* "adaXT/criteria/criteria.pyx":368
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):
- *         cdef:
- *             int n_obs = indices.shape[0]             # <<<<<<<<<<<<<<
- *             int n_left = split_idx
- *             int n_right = n_obs - n_left
- */
-  __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
-
-  /* "adaXT/criteria/criteria.pyx":369
- *         cdef:
- *             int n_obs = indices.shape[0]
- *             int n_left = split_idx             # <<<<<<<<<<<<<<
- *             int n_right = n_obs - n_left
- *             double mean_thresh
- */
-  __pyx_v_n_left = __pyx_v_split_idx;
-
-  /* "adaXT/criteria/criteria.pyx":370
- *             int n_obs = indices.shape[0]
- *             int n_left = split_idx
- *             int n_right = n_obs - n_left             # <<<<<<<<<<<<<<
- *             double mean_thresh
- *             double left_imp = 0.0
- */
-  __pyx_v_n_right = (__pyx_v_n_obs - __pyx_v_n_left);
-
-  /* "adaXT/criteria/criteria.pyx":372
- *             int n_right = n_obs - n_left
- *             double mean_thresh
- *             double left_imp = 0.0             # <<<<<<<<<<<<<<
- *             double right_imp = 0.0
- *             double crit = 0.0
- */
-  __pyx_v_left_imp = 0.0;
-
-  /* "adaXT/criteria/criteria.pyx":373
- *             double mean_thresh
- *             double left_imp = 0.0
- *             double right_imp = 0.0             # <<<<<<<<<<<<<<
- *             double crit = 0.0
- *             double[:, ::1] features = self.x
  */
-  __pyx_v_right_imp = 0.0;
+      __pyx_v_pp = ((__pyx_v_self->weight_in_class_left[__pyx_v_i]) / __pyx_v_self->weight_left);
 
-  /* "adaXT/criteria/criteria.pyx":374
- *             double left_imp = 0.0
- *             double right_imp = 0.0
- *             double crit = 0.0             # <<<<<<<<<<<<<<
- *             double[:, ::1] features = self.x
+      /* "adaXT/criteria/criteria.pyx":373
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)
+ *                 sum_left -= (pp) * log2(pp)             # <<<<<<<<<<<<<<
  * 
+ *             if self.weight_in_class_right[i] != 0.0:
  */
-  __pyx_v_crit = 0.0;
+      __pyx_v_sum_left = (__pyx_v_sum_left - (__pyx_v_pp * log2(__pyx_v_pp)));
 
-  /* "adaXT/criteria/criteria.pyx":375
- *             double right_imp = 0.0
- *             double crit = 0.0
- *             double[:, ::1] features = self.x             # <<<<<<<<<<<<<<
- * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
+      /* "adaXT/criteria/criteria.pyx":371
+ *         # Loop over all classes and calculate entropy
+ *         for i in range(self.num_classes):
+ *             if self.weight_in_class_left[i] != 0.0:  # To make sure we dont take log(0)             # <<<<<<<<<<<<<<
+ *                 pp = (self.weight_in_class_left[i])/(self.weight_left)
+ *                 sum_left -= (pp) * log2(pp)
  */
-  __pyx_t_1 = __pyx_v_self->__pyx_base.x;
-  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
-  __pyx_v_features = __pyx_t_1;
-  __pyx_t_1.memview = NULL;
-  __pyx_t_1.data = NULL;
+    }
 
-  /* "adaXT/criteria/criteria.pyx":377
- *             double[:, ::1] features = self.x
+    /* "adaXT/criteria/criteria.pyx":375
+ *                 sum_left -= (pp) * log2(pp)
  * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting             # <<<<<<<<<<<<<<
- *             left_imp = self.update_left(indices, split_idx)
- *             right_imp = self.update_right(indices, split_idx)
+ *             if self.weight_in_class_right[i] != 0.0:             # <<<<<<<<<<<<<<
+ *                 pp = (self.weight_in_class_right[i])/(self.weight_right)
+ *                 sum_right -= (pp) * log2(pp)
  */
-  __pyx_t_3 = (__pyx_v_n_obs == __pyx_v_self->old_obs);
-  if (__pyx_t_3) {
-  } else {
-    __pyx_t_2 = __pyx_t_3;
-    goto __pyx_L4_bool_binop_done;
-  }
-  __pyx_t_3 = (__pyx_v_feature == __pyx_v_self->old_feature);
-  __pyx_t_2 = __pyx_t_3;
-  __pyx_L4_bool_binop_done:;
-  if (__pyx_t_2) {
+    __pyx_t_9 = ((__pyx_v_self->weight_in_class_right[__pyx_v_i]) != 0.0);
+    if (__pyx_t_9) {
 
-    /* "adaXT/criteria/criteria.pyx":378
+      /* "adaXT/criteria/criteria.pyx":376
  * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
- *             left_imp = self.update_left(indices, split_idx)             # <<<<<<<<<<<<<<
- *             right_imp = self.update_right(indices, split_idx)
- *         else:
- */
-    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->update_left(__pyx_v_self, __pyx_v_indices, __pyx_v_split_idx); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 378, __pyx_L1_error)
-    __pyx_v_left_imp = __pyx_t_4;
-
-    /* "adaXT/criteria/criteria.pyx":379
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
- *             left_imp = self.update_left(indices, split_idx)
- *             right_imp = self.update_right(indices, split_idx)             # <<<<<<<<<<<<<<
- *         else:
- *             left_imp = self._entropy(indices[:split_idx], self.n_in_class_left, 1)
- */
-    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->update_right(__pyx_v_self, __pyx_v_indices, __pyx_v_split_idx); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 379, __pyx_L1_error)
-    __pyx_v_right_imp = __pyx_t_4;
-
-    /* "adaXT/criteria/criteria.pyx":377
- *             double[:, ::1] features = self.x
+ *             if self.weight_in_class_right[i] != 0.0:
+ *                 pp = (self.weight_in_class_right[i])/(self.weight_right)             # <<<<<<<<<<<<<<
+ *                 sum_right -= (pp) * log2(pp)
  * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting             # <<<<<<<<<<<<<<
- *             left_imp = self.update_left(indices, split_idx)
- *             right_imp = self.update_right(indices, split_idx)
  */
-    goto __pyx_L3;
-  }
+      __pyx_v_pp = ((__pyx_v_self->weight_in_class_right[__pyx_v_i]) / __pyx_v_self->weight_right);
 
-  /* "adaXT/criteria/criteria.pyx":381
- *             right_imp = self.update_right(indices, split_idx)
- *         else:
- *             left_imp = self._entropy(indices[:split_idx], self.n_in_class_left, 1)             # <<<<<<<<<<<<<<
- *             right_imp = self._entropy(indices[split_idx:], self.n_in_class_right, 0)
+      /* "adaXT/criteria/criteria.pyx":377
+ *             if self.weight_in_class_right[i] != 0.0:
+ *                 pp = (self.weight_in_class_right[i])/(self.weight_right)
+ *                 sum_right -= (pp) * log2(pp)             # <<<<<<<<<<<<<<
  * 
+ *         return sum_left*self.weight_left + sum_right*self.weight_right
  */
-  /*else*/ {
-    __pyx_t_5.data = __pyx_v_indices.data;
-    __pyx_t_5.memview = __pyx_v_indices.memview;
-    __PYX_INC_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_6 = -1;
-    if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_5,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_6,
-    0,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 381, __pyx_L1_error)
-}
-
-__pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->_entropy(__pyx_v_self, __pyx_t_5, __pyx_v_self->n_in_class_left, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 381, __pyx_L1_error)
-    __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_5.memview = NULL; __pyx_t_5.data = NULL;
-    __pyx_v_left_imp = __pyx_t_4;
+      __pyx_v_sum_right = (__pyx_v_sum_right - (__pyx_v_pp * log2(__pyx_v_pp)));
 
-    /* "adaXT/criteria/criteria.pyx":382
- *         else:
- *             left_imp = self._entropy(indices[:split_idx], self.n_in_class_left, 1)
- *             right_imp = self._entropy(indices[split_idx:], self.n_in_class_right, 0)             # <<<<<<<<<<<<<<
+      /* "adaXT/criteria/criteria.pyx":375
+ *                 sum_left -= (pp) * log2(pp)
  * 
- *         self.old_feature = feature
+ *             if self.weight_in_class_right[i] != 0.0:             # <<<<<<<<<<<<<<
+ *                 pp = (self.weight_in_class_right[i])/(self.weight_right)
+ *                 sum_right -= (pp) * log2(pp)
  */
-    __pyx_t_5.data = __pyx_v_indices.data;
-    __pyx_t_5.memview = __pyx_v_indices.memview;
-    __PYX_INC_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_6 = -1;
-    if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_5,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_6,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 382, __pyx_L1_error)
-}
-
-__pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Entropy *)__pyx_v_self->__pyx_base.__pyx_vtab)->_entropy(__pyx_v_self, __pyx_t_5, __pyx_v_self->n_in_class_right, 0); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 382, __pyx_L1_error)
-    __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_5.memview = NULL; __pyx_t_5.data = NULL;
-    __pyx_v_right_imp = __pyx_t_4;
+    }
   }
-  __pyx_L3:;
-
-  /* "adaXT/criteria/criteria.pyx":384
- *             right_imp = self._entropy(indices[split_idx:], self.n_in_class_right, 0)
- * 
- *         self.old_feature = feature             # <<<<<<<<<<<<<<
- *         self.old_obs = n_obs
- *         self.old_split = split_idx
- */
-  __pyx_v_self->old_feature = __pyx_v_feature;
-
-  /* "adaXT/criteria/criteria.pyx":385
- * 
- *         self.old_feature = feature
- *         self.old_obs = n_obs             # <<<<<<<<<<<<<<
- *         self.old_split = split_idx
- *         crit = left_imp * n_left / n_obs
- */
-  __pyx_v_self->old_obs = __pyx_v_n_obs;
-
-  /* "adaXT/criteria/criteria.pyx":386
- *         self.old_feature = feature
- *         self.old_obs = n_obs
- *         self.old_split = split_idx             # <<<<<<<<<<<<<<
- *         crit = left_imp * n_left / n_obs
- *         crit += right_imp * n_right / n_obs
- */
-  __pyx_v_self->old_split = __pyx_v_split_idx;
-
-  /* "adaXT/criteria/criteria.pyx":387
- *         self.old_obs = n_obs
- *         self.old_split = split_idx
- *         crit = left_imp * n_left / n_obs             # <<<<<<<<<<<<<<
- *         crit += right_imp * n_right / n_obs
- * 
- */
-  __pyx_v_crit = ((__pyx_v_left_imp * __pyx_v_n_left) / ((double)__pyx_v_n_obs));
 
-  /* "adaXT/criteria/criteria.pyx":388
- *         self.old_split = split_idx
- *         crit = left_imp * n_left / n_obs
- *         crit += right_imp * n_right / n_obs             # <<<<<<<<<<<<<<
- * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0
- */
-  __pyx_v_crit = (__pyx_v_crit + ((__pyx_v_right_imp * __pyx_v_n_right) / ((double)__pyx_v_n_obs)));
-
-  /* "adaXT/criteria/criteria.pyx":390
- *         crit += right_imp * n_right / n_obs
+  /* "adaXT/criteria/criteria.pyx":379
+ *                 sum_right -= (pp) * log2(pp)
  * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0             # <<<<<<<<<<<<<<
- *         return (crit, left_imp, right_imp, mean_thresh)
- * 
- */
-  __pyx_t_7 = (__pyx_v_split_idx - 1);
-  __pyx_t_8 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_7 * __pyx_v_indices.strides[0]) )));
-  __pyx_t_9 = __pyx_v_feature;
-  __pyx_t_10 = __pyx_v_split_idx;
-  __pyx_t_11 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_10 * __pyx_v_indices.strides[0]) )));
-  __pyx_t_12 = __pyx_v_feature;
-  __pyx_v_mean_thresh = (((*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_features.data + __pyx_t_8 * __pyx_v_features.strides[0]) )) + __pyx_t_9)) ))) + (*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_features.data + __pyx_t_11 * __pyx_v_features.strides[0]) )) + __pyx_t_12)) )))) / 2.0);
-
-  /* "adaXT/criteria/criteria.pyx":391
+ *         return sum_left*self.weight_left + sum_right*self.weight_right             # <<<<<<<<<<<<<<
  * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0
- *         return (crit, left_imp, right_imp, mean_thresh)             # <<<<<<<<<<<<<<
  * 
- * cdef class Squared_error(Criteria):
  */
-  __pyx_t_13.f0 = __pyx_v_crit;
-  __pyx_t_13.f1 = __pyx_v_left_imp;
-  __pyx_t_13.f2 = __pyx_v_right_imp;
-  __pyx_t_13.f3 = __pyx_v_mean_thresh;
-  __pyx_r = __pyx_t_13;
+  __pyx_r = ((__pyx_v_sum_left * __pyx_v_self->weight_left) + (__pyx_v_sum_right * __pyx_v_self->weight_right));
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":366
+  /* "adaXT/criteria/criteria.pyx":349
+ *         return sum_left*self.weight_left + sum_right*self.weight_right
  * 
- *     # Override the default evaluate_split
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
+ *     cdef double update_proxy(self, int[::1] indices, int new_split):             # <<<<<<<<<<<<<<
+ *         # All new values in node from before
  *         cdef:
- *             int n_obs = indices.shape[0]
  */
 
   /* function exit code */
-  __pyx_L1_error:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-  __Pyx_AddTraceback("adaXT.criteria.criteria.Entropy.evaluate_split", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_features, 1);
   return __pyx_r;
 }
 
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
@@ -22523,503 +22500,354 @@
   __Pyx_AddTraceback("adaXT.criteria.criteria.Entropy.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":405
- *         int old_feature
- * 
- *     def __init__(self, double[:, ::1] x, double[:] y, double[::1] sample_weight):             # <<<<<<<<<<<<<<
- *         self.old_obs = -1
- * 
- */
-
-/* Python wrapper */
-static int __pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static int __pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
-  CYTHON_UNUSED __Pyx_memviewslice __pyx_v_x = { 0, 0, { 0 }, { 0 }, { 0 } };
-  CYTHON_UNUSED __Pyx_memviewslice __pyx_v_y = { 0, 0, { 0 }, { 0 }, { 0 } };
-  CYTHON_UNUSED __Pyx_memviewslice __pyx_v_sample_weight = { 0, 0, { 0 }, { 0 }, { 0 } };
-  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
-  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[3] = {0,0,0};
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  int __pyx_r;
-  __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
-  #if CYTHON_ASSUME_SAFE_MACROS
-  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
-  #else
-  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return -1;
-  #endif
-  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
-  {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_y,&__pyx_n_s_sample_weight,0};
-    if (__pyx_kwds) {
-      Py_ssize_t kw_args;
-      switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
-        CYTHON_FALLTHROUGH;
-        case  0: break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
-      switch (__pyx_nargs) {
-        case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_x)) != 0)) {
-          (void)__Pyx_Arg_NewRef_VARARGS(values[0]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 405, __pyx_L3_error)
-        else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_y)) != 0)) {
-          (void)__Pyx_Arg_NewRef_VARARGS(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 405, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 1); __PYX_ERR(1, 405, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_sample_weight)) != 0)) {
-          (void)__Pyx_Arg_NewRef_VARARGS(values[2]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 405, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 2); __PYX_ERR(1, 405, __pyx_L3_error)
-        }
-      }
-      if (unlikely(kw_args > 0)) {
-        const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(1, 405, __pyx_L3_error)
-      }
-    } else if (unlikely(__pyx_nargs != 3)) {
-      goto __pyx_L5_argtuple_error;
-    } else {
-      values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
-      values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
-      values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
-    }
-    __pyx_v_x = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_x.memview)) __PYX_ERR(1, 405, __pyx_L3_error)
-    __pyx_v_y = __Pyx_PyObject_to_MemoryviewSlice_ds_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_y.memview)) __PYX_ERR(1, 405, __pyx_L3_error)
-    __pyx_v_sample_weight = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[2], PyBUF_WRITABLE); if (unlikely(!__pyx_v_sample_weight.memview)) __PYX_ERR(1, 405, __pyx_L3_error)
-  }
-  goto __pyx_L6_skip;
-  __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, __pyx_nargs); __PYX_ERR(1, 405, __pyx_L3_error)
-  __pyx_L6_skip:;
-  goto __pyx_L4_argument_unpacking_done;
-  __pyx_L3_error:;
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
-    }
-  }
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_x, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_y, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_sample_weight, 1);
-  __Pyx_AddTraceback("adaXT.criteria.criteria.Squared_error.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_RefNannyFinishContext();
-  return -1;
-  __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_8criteria_8criteria_13Squared_error___init__(((struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self), __pyx_v_x, __pyx_v_y, __pyx_v_sample_weight);
-
-  /* function exit code */
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_x, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_y, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_sample_weight, 1);
-  {
-    Py_ssize_t __pyx_temp;
-    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
-    }
-  }
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-static int __pyx_pf_5adaXT_8criteria_8criteria_13Squared_error___init__(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_x, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_y, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_sample_weight) {
-  int __pyx_r;
-
-  /* "adaXT/criteria/criteria.pyx":406
- * 
- *     def __init__(self, double[:, ::1] x, double[:] y, double[::1] sample_weight):
- *         self.old_obs = -1             # <<<<<<<<<<<<<<
- * 
- *     cdef double update_left(self, int[:] indices, int new_split):
- */
-  __pyx_v_self->old_obs = -1;
-
-  /* "adaXT/criteria/criteria.pyx":405
- *         int old_feature
- * 
- *     def __init__(self, double[:, ::1] x, double[:] y, double[::1] sample_weight):             # <<<<<<<<<<<<<<
- *         self.old_obs = -1
- * 
- */
-
-  /* function exit code */
-  __pyx_r = 0;
-  return __pyx_r;
-}
-
-/* "adaXT/criteria/criteria.pyx":408
- *         self.old_obs = -1
+/* "adaXT/criteria/criteria.pyx":388
+ *         double weight_left, weight_right
  * 
- *     cdef double update_left(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
- *         # All new values in node from before
+ *     cdef double update_proxy(self, int[::1] indices, int new_split):             # <<<<<<<<<<<<<<
  *         cdef:
+ *             int i, idx
  */
 
-static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_update_left(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split) {
+static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_update_proxy(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split) {
   int __pyx_v_i;
-  int __pyx_v_start_idx;
-  int __pyx_v_p;
-  double __pyx_v_tmp;
-  double __pyx_v_square_sum;
-  double __pyx_v_cur_sum;
-  double __pyx_v_new_mu;
+  int __pyx_v_idx;
+  double __pyx_v_y_val;
+  double __pyx_v_weight;
   double __pyx_r;
-  double __pyx_t_1;
+  int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
-  int __pyx_t_4;
-  Py_ssize_t __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
+  Py_ssize_t __pyx_t_4;
 
-  /* "adaXT/criteria/criteria.pyx":414
- *             double tmp, square_sum, cur_sum, new_mu
- * 
- *         square_sum = self.old_left_square_sum             # <<<<<<<<<<<<<<
- *         cur_sum = self.old_left_sum
- *         start_idx = self.old_split
+  /* "adaXT/criteria/criteria.pyx":392
+ *             int i, idx
+ *             double y_val, weight
+ *         for i in range(self.old_split, new_split):             # <<<<<<<<<<<<<<
+ *             idx = indices[i]
+ *             weight = self.sample_weight[idx]
  */
-  __pyx_t_1 = __pyx_v_self->old_left_square_sum;
-  __pyx_v_square_sum = __pyx_t_1;
+  __pyx_t_1 = __pyx_v_new_split;
+  __pyx_t_2 = __pyx_t_1;
+  for (__pyx_t_3 = __pyx_v_self->__pyx_base.old_split; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
+    __pyx_v_i = __pyx_t_3;
 
-  /* "adaXT/criteria/criteria.pyx":415
- * 
- *         square_sum = self.old_left_square_sum
- *         cur_sum = self.old_left_sum             # <<<<<<<<<<<<<<
- *         start_idx = self.old_split
- *         for i in range(start_idx, new_split):
- */
-  __pyx_t_1 = __pyx_v_self->old_left_sum;
-  __pyx_v_cur_sum = __pyx_t_1;
-
-  /* "adaXT/criteria/criteria.pyx":416
- *         square_sum = self.old_left_square_sum
- *         cur_sum = self.old_left_sum
- *         start_idx = self.old_split             # <<<<<<<<<<<<<<
- *         for i in range(start_idx, new_split):
- *             p = indices[i]
+    /* "adaXT/criteria/criteria.pyx":393
+ *             double y_val, weight
+ *         for i in range(self.old_split, new_split):
+ *             idx = indices[i]             # <<<<<<<<<<<<<<
+ *             weight = self.sample_weight[idx]
+ *             y_val = self.y[idx]*weight
  */
-  __pyx_t_2 = __pyx_v_self->old_split;
-  __pyx_v_start_idx = __pyx_t_2;
+    __pyx_t_4 = __pyx_v_i;
+    __pyx_v_idx = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_4)) )));
 
-  /* "adaXT/criteria/criteria.pyx":417
- *         cur_sum = self.old_left_sum
- *         start_idx = self.old_split
- *         for i in range(start_idx, new_split):             # <<<<<<<<<<<<<<
- *             p = indices[i]
- *             tmp = self.y[p] * self.sample_weight[p]
+    /* "adaXT/criteria/criteria.pyx":394
+ *         for i in range(self.old_split, new_split):
+ *             idx = indices[i]
+ *             weight = self.sample_weight[idx]             # <<<<<<<<<<<<<<
+ *             y_val = self.y[idx]*weight
+ *             self.left_sum += y_val
  */
-  __pyx_t_2 = __pyx_v_new_split;
-  __pyx_t_3 = __pyx_t_2;
-  for (__pyx_t_4 = __pyx_v_start_idx; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-    __pyx_v_i = __pyx_t_4;
+    __pyx_t_4 = __pyx_v_idx;
+    __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_4)) )));
 
-    /* "adaXT/criteria/criteria.pyx":418
- *         start_idx = self.old_split
- *         for i in range(start_idx, new_split):
- *             p = indices[i]             # <<<<<<<<<<<<<<
- *             tmp = self.y[p] * self.sample_weight[p]
- *             square_sum += tmp * tmp
+    /* "adaXT/criteria/criteria.pyx":395
+ *             idx = indices[i]
+ *             weight = self.sample_weight[idx]
+ *             y_val = self.y[idx]*weight             # <<<<<<<<<<<<<<
+ *             self.left_sum += y_val
+ *             self.right_sum -= y_val
  */
-    __pyx_t_5 = __pyx_v_i;
-    __pyx_v_p = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_5 * __pyx_v_indices.strides[0]) )));
+    __pyx_t_4 = __pyx_v_idx;
+    __pyx_v_y_val = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_4)) ))) * __pyx_v_weight);
 
-    /* "adaXT/criteria/criteria.pyx":419
- *         for i in range(start_idx, new_split):
- *             p = indices[i]
- *             tmp = self.y[p] * self.sample_weight[p]             # <<<<<<<<<<<<<<
- *             square_sum += tmp * tmp
- *             cur_sum += tmp
+    /* "adaXT/criteria/criteria.pyx":396
+ *             weight = self.sample_weight[idx]
+ *             y_val = self.y[idx]*weight
+ *             self.left_sum += y_val             # <<<<<<<<<<<<<<
+ *             self.right_sum -= y_val
+ *             self.weight_left += weight
  */
-    __pyx_t_5 = __pyx_v_p;
-    __pyx_t_6 = __pyx_v_p;
-    __pyx_v_tmp = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_5)) ))) * (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_6)) ))));
+    __pyx_v_self->left_sum = (__pyx_v_self->left_sum + __pyx_v_y_val);
 
-    /* "adaXT/criteria/criteria.pyx":420
- *             p = indices[i]
- *             tmp = self.y[p] * self.sample_weight[p]
- *             square_sum += tmp * tmp             # <<<<<<<<<<<<<<
- *             cur_sum += tmp
- *             self.weight_left += self.sample_weight[p]
+    /* "adaXT/criteria/criteria.pyx":397
+ *             y_val = self.y[idx]*weight
+ *             self.left_sum += y_val
+ *             self.right_sum -= y_val             # <<<<<<<<<<<<<<
+ *             self.weight_left += weight
+ *             self.weight_right -= weight
  */
-    __pyx_v_square_sum = (__pyx_v_square_sum + (__pyx_v_tmp * __pyx_v_tmp));
+    __pyx_v_self->right_sum = (__pyx_v_self->right_sum - __pyx_v_y_val);
 
-    /* "adaXT/criteria/criteria.pyx":421
- *             tmp = self.y[p] * self.sample_weight[p]
- *             square_sum += tmp * tmp
- *             cur_sum += tmp             # <<<<<<<<<<<<<<
- *             self.weight_left += self.sample_weight[p]
+    /* "adaXT/criteria/criteria.pyx":398
+ *             self.left_sum += y_val
+ *             self.right_sum -= y_val
+ *             self.weight_left += weight             # <<<<<<<<<<<<<<
+ *             self.weight_right -= weight
  * 
  */
-    __pyx_v_cur_sum = (__pyx_v_cur_sum + __pyx_v_tmp);
+    __pyx_v_self->weight_left = (__pyx_v_self->weight_left + __pyx_v_weight);
 
-    /* "adaXT/criteria/criteria.pyx":422
- *             square_sum += tmp * tmp
- *             cur_sum += tmp
- *             self.weight_left += self.sample_weight[p]             # <<<<<<<<<<<<<<
+    /* "adaXT/criteria/criteria.pyx":399
+ *             self.right_sum -= y_val
+ *             self.weight_left += weight
+ *             self.weight_right -= weight             # <<<<<<<<<<<<<<
  * 
- *         self.old_left_square_sum = square_sum
+ *         return -((self.left_sum*self.left_sum) / self.weight_left +
  */
-    __pyx_t_6 = __pyx_v_p;
-    __pyx_v_self->weight_left = (__pyx_v_self->weight_left + (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_6)) ))));
+    __pyx_v_self->weight_right = (__pyx_v_self->weight_right - __pyx_v_weight);
   }
 
-  /* "adaXT/criteria/criteria.pyx":424
- *             self.weight_left += self.sample_weight[p]
+  /* "adaXT/criteria/criteria.pyx":401
+ *             self.weight_right -= weight
  * 
- *         self.old_left_square_sum = square_sum             # <<<<<<<<<<<<<<
- *         self.old_left_sum = cur_sum
- *         new_mu = cur_sum / self.weight_left
- */
-  __pyx_v_self->old_left_square_sum = __pyx_v_square_sum;
-
-  /* "adaXT/criteria/criteria.pyx":425
- * 
- *         self.old_left_square_sum = square_sum
- *         self.old_left_sum = cur_sum             # <<<<<<<<<<<<<<
- *         new_mu = cur_sum / self.weight_left
- *         return (square_sum/self.weight_left - new_mu*new_mu)
- */
-  __pyx_v_self->old_left_sum = __pyx_v_cur_sum;
-
-  /* "adaXT/criteria/criteria.pyx":426
- *         self.old_left_square_sum = square_sum
- *         self.old_left_sum = cur_sum
- *         new_mu = cur_sum / self.weight_left             # <<<<<<<<<<<<<<
- *         return (square_sum/self.weight_left - new_mu*new_mu)
+ *         return -((self.left_sum*self.left_sum) / self.weight_left +             # <<<<<<<<<<<<<<
+ *                  (self.right_sum*self.right_sum) / self.weight_right)
  * 
  */
-  __pyx_v_new_mu = (__pyx_v_cur_sum / __pyx_v_self->weight_left);
-
-  /* "adaXT/criteria/criteria.pyx":427
- *         self.old_left_sum = cur_sum
- *         new_mu = cur_sum / self.weight_left
- *         return (square_sum/self.weight_left - new_mu*new_mu)             # <<<<<<<<<<<<<<
- * 
- *     cdef double update_right(self, int[:] indices, int new_split):
- */
-  __pyx_r = ((__pyx_v_square_sum / __pyx_v_self->weight_left) - (__pyx_v_new_mu * __pyx_v_new_mu));
+  __pyx_r = (-(((__pyx_v_self->left_sum * __pyx_v_self->left_sum) / __pyx_v_self->weight_left) + ((__pyx_v_self->right_sum * __pyx_v_self->right_sum) / __pyx_v_self->weight_right)));
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":408
- *         self.old_obs = -1
+  /* "adaXT/criteria/criteria.pyx":388
+ *         double weight_left, weight_right
  * 
- *     cdef double update_left(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
- *         # All new values in node from before
+ *     cdef double update_proxy(self, int[::1] indices, int new_split):             # <<<<<<<<<<<<<<
  *         cdef:
+ *             int i, idx
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":429
- *         return (square_sum/self.weight_left - new_mu*new_mu)
+/* "adaXT/criteria/criteria.pyx":404
+ *                  (self.right_sum*self.right_sum) / self.weight_right)
  * 
- *     cdef double update_right(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
  *         cdef:
- *             int i, start_idx, p
+ *             int i, idx
  */
 
-static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_update_right(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_new_split) {
+static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_proxy_improvement(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx) {
   int __pyx_v_i;
-  int __pyx_v_start_idx;
-  int __pyx_v_p;
-  double __pyx_v_tmp;
-  double __pyx_v_square_sum;
-  double __pyx_v_cur_sum;
-  double __pyx_v_new_mu;
+  int __pyx_v_idx;
+  int __pyx_v_n_obs;
+  double __pyx_v_y_val;
+  double __pyx_v_weight;
   double __pyx_r;
-  double __pyx_t_1;
+  int __pyx_t_1;
   int __pyx_t_2;
   int __pyx_t_3;
-  int __pyx_t_4;
-  Py_ssize_t __pyx_t_5;
-  Py_ssize_t __pyx_t_6;
+  Py_ssize_t __pyx_t_4;
 
-  /* "adaXT/criteria/criteria.pyx":434
- *             double tmp, square_sum, cur_sum, new_mu
+  /* "adaXT/criteria/criteria.pyx":407
+ *         cdef:
+ *             int i, idx
+ *             int n_obs = indices.shape[0]             # <<<<<<<<<<<<<<
+ *             double y_val, weight
  * 
- *         square_sum = self.old_right_square_sum             # <<<<<<<<<<<<<<
- *         cur_sum = self.old_right_sum
- *         start_idx = self.old_split
  */
-  __pyx_t_1 = __pyx_v_self->old_right_square_sum;
-  __pyx_v_square_sum = __pyx_t_1;
+  __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":435
+  /* "adaXT/criteria/criteria.pyx":410
+ *             double y_val, weight
  * 
- *         square_sum = self.old_right_square_sum
- *         cur_sum = self.old_right_sum             # <<<<<<<<<<<<<<
- *         start_idx = self.old_split
- *         for i in range(start_idx, new_split):
- */
-  __pyx_t_1 = __pyx_v_self->old_right_sum;
-  __pyx_v_cur_sum = __pyx_t_1;
-
-  /* "adaXT/criteria/criteria.pyx":436
- *         square_sum = self.old_right_square_sum
- *         cur_sum = self.old_right_sum
- *         start_idx = self.old_split             # <<<<<<<<<<<<<<
- *         for i in range(start_idx, new_split):
- *             p = indices[i]
+ *         self.left_sum = 0.0             # <<<<<<<<<<<<<<
+ *         self.right_sum = 0.0
+ *         self.weight_left = 0.0
  */
-  __pyx_t_2 = __pyx_v_self->old_split;
-  __pyx_v_start_idx = __pyx_t_2;
+  __pyx_v_self->left_sum = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":437
- *         cur_sum = self.old_right_sum
- *         start_idx = self.old_split
- *         for i in range(start_idx, new_split):             # <<<<<<<<<<<<<<
- *             p = indices[i]
- *             tmp = self.y[p] * self.sample_weight[p]
+  /* "adaXT/criteria/criteria.pyx":411
+ * 
+ *         self.left_sum = 0.0
+ *         self.right_sum = 0.0             # <<<<<<<<<<<<<<
+ *         self.weight_left = 0.0
+ *         self.weight_right = 0.0
  */
-  __pyx_t_2 = __pyx_v_new_split;
-  __pyx_t_3 = __pyx_t_2;
-  for (__pyx_t_4 = __pyx_v_start_idx; __pyx_t_4 < __pyx_t_3; __pyx_t_4+=1) {
-    __pyx_v_i = __pyx_t_4;
+  __pyx_v_self->right_sum = 0.0;
 
-    /* "adaXT/criteria/criteria.pyx":438
- *         start_idx = self.old_split
- *         for i in range(start_idx, new_split):
- *             p = indices[i]             # <<<<<<<<<<<<<<
- *             tmp = self.y[p] * self.sample_weight[p]
- *             square_sum -= tmp * tmp
+  /* "adaXT/criteria/criteria.pyx":412
+ *         self.left_sum = 0.0
+ *         self.right_sum = 0.0
+ *         self.weight_left = 0.0             # <<<<<<<<<<<<<<
+ *         self.weight_right = 0.0
+ * 
  */
-    __pyx_t_5 = __pyx_v_i;
-    __pyx_v_p = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_5 * __pyx_v_indices.strides[0]) )));
+  __pyx_v_self->weight_left = 0.0;
 
-    /* "adaXT/criteria/criteria.pyx":439
- *         for i in range(start_idx, new_split):
- *             p = indices[i]
- *             tmp = self.y[p] * self.sample_weight[p]             # <<<<<<<<<<<<<<
- *             square_sum -= tmp * tmp
- *             cur_sum -= tmp
+  /* "adaXT/criteria/criteria.pyx":413
+ *         self.right_sum = 0.0
+ *         self.weight_left = 0.0
+ *         self.weight_right = 0.0             # <<<<<<<<<<<<<<
+ * 
+ *         for i in range(split_idx):
  */
-    __pyx_t_5 = __pyx_v_p;
-    __pyx_t_6 = __pyx_v_p;
-    __pyx_v_tmp = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_5)) ))) * (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_6)) ))));
+  __pyx_v_self->weight_right = 0.0;
 
-    /* "adaXT/criteria/criteria.pyx":440
- *             p = indices[i]
- *             tmp = self.y[p] * self.sample_weight[p]
- *             square_sum -= tmp * tmp             # <<<<<<<<<<<<<<
- *             cur_sum -= tmp
- *             self.weight_right -= self.sample_weight[p]
- */
-    __pyx_v_square_sum = (__pyx_v_square_sum - (__pyx_v_tmp * __pyx_v_tmp));
-
-    /* "adaXT/criteria/criteria.pyx":441
- *             tmp = self.y[p] * self.sample_weight[p]
- *             square_sum -= tmp * tmp
- *             cur_sum -= tmp             # <<<<<<<<<<<<<<
- *             self.weight_right -= self.sample_weight[p]
- *         self.old_right_square_sum = square_sum
- */
-    __pyx_v_cur_sum = (__pyx_v_cur_sum - __pyx_v_tmp);
-
-    /* "adaXT/criteria/criteria.pyx":442
- *             square_sum -= tmp * tmp
- *             cur_sum -= tmp
- *             self.weight_right -= self.sample_weight[p]             # <<<<<<<<<<<<<<
- *         self.old_right_square_sum = square_sum
- *         self.old_right_sum = cur_sum
+  /* "adaXT/criteria/criteria.pyx":415
+ *         self.weight_right = 0.0
+ * 
+ *         for i in range(split_idx):             # <<<<<<<<<<<<<<
+ *             idx = indices[i]
+ *             weight = self.sample_weight[idx]
  */
-    __pyx_t_6 = __pyx_v_p;
-    __pyx_v_self->weight_right = (__pyx_v_self->weight_right - (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_6)) ))));
+  __pyx_t_1 = __pyx_v_split_idx;
+  __pyx_t_2 = __pyx_t_1;
+  for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
+    __pyx_v_i = __pyx_t_3;
+
+    /* "adaXT/criteria/criteria.pyx":416
+ * 
+ *         for i in range(split_idx):
+ *             idx = indices[i]             # <<<<<<<<<<<<<<
+ *             weight = self.sample_weight[idx]
+ *             y_val = self.y[idx]*weight
+ */
+    __pyx_t_4 = __pyx_v_i;
+    __pyx_v_idx = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_4)) )));
+
+    /* "adaXT/criteria/criteria.pyx":417
+ *         for i in range(split_idx):
+ *             idx = indices[i]
+ *             weight = self.sample_weight[idx]             # <<<<<<<<<<<<<<
+ *             y_val = self.y[idx]*weight
+ *             self.left_sum += y_val
+ */
+    __pyx_t_4 = __pyx_v_idx;
+    __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_4)) )));
+
+    /* "adaXT/criteria/criteria.pyx":418
+ *             idx = indices[i]
+ *             weight = self.sample_weight[idx]
+ *             y_val = self.y[idx]*weight             # <<<<<<<<<<<<<<
+ *             self.left_sum += y_val
+ *             self.weight_left += weight
+ */
+    __pyx_t_4 = __pyx_v_idx;
+    __pyx_v_y_val = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_4)) ))) * __pyx_v_weight);
+
+    /* "adaXT/criteria/criteria.pyx":419
+ *             weight = self.sample_weight[idx]
+ *             y_val = self.y[idx]*weight
+ *             self.left_sum += y_val             # <<<<<<<<<<<<<<
+ *             self.weight_left += weight
+ * 
+ */
+    __pyx_v_self->left_sum = (__pyx_v_self->left_sum + __pyx_v_y_val);
+
+    /* "adaXT/criteria/criteria.pyx":420
+ *             y_val = self.y[idx]*weight
+ *             self.left_sum += y_val
+ *             self.weight_left += weight             # <<<<<<<<<<<<<<
+ * 
+ *         for i in range(split_idx, n_obs):
+ */
+    __pyx_v_self->weight_left = (__pyx_v_self->weight_left + __pyx_v_weight);
   }
 
-  /* "adaXT/criteria/criteria.pyx":443
- *             cur_sum -= tmp
- *             self.weight_right -= self.sample_weight[p]
- *         self.old_right_square_sum = square_sum             # <<<<<<<<<<<<<<
- *         self.old_right_sum = cur_sum
- *         new_mu = cur_sum / self.weight_right
+  /* "adaXT/criteria/criteria.pyx":422
+ *             self.weight_left += weight
+ * 
+ *         for i in range(split_idx, n_obs):             # <<<<<<<<<<<<<<
+ *             idx = indices[i]
+ *             weight = self.sample_weight[idx]
+ */
+  __pyx_t_1 = __pyx_v_n_obs;
+  __pyx_t_2 = __pyx_t_1;
+  for (__pyx_t_3 = __pyx_v_split_idx; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
+    __pyx_v_i = __pyx_t_3;
+
+    /* "adaXT/criteria/criteria.pyx":423
+ * 
+ *         for i in range(split_idx, n_obs):
+ *             idx = indices[i]             # <<<<<<<<<<<<<<
+ *             weight = self.sample_weight[idx]
+ *             y_val = self.y[idx]*weight
  */
-  __pyx_v_self->old_right_square_sum = __pyx_v_square_sum;
+    __pyx_t_4 = __pyx_v_i;
+    __pyx_v_idx = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_4)) )));
+
+    /* "adaXT/criteria/criteria.pyx":424
+ *         for i in range(split_idx, n_obs):
+ *             idx = indices[i]
+ *             weight = self.sample_weight[idx]             # <<<<<<<<<<<<<<
+ *             y_val = self.y[idx]*weight
+ *             self.right_sum += y_val
+ */
+    __pyx_t_4 = __pyx_v_idx;
+    __pyx_v_weight = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_4)) )));
 
-  /* "adaXT/criteria/criteria.pyx":444
- *             self.weight_right -= self.sample_weight[p]
- *         self.old_right_square_sum = square_sum
- *         self.old_right_sum = cur_sum             # <<<<<<<<<<<<<<
- *         new_mu = cur_sum / self.weight_right
- *         return (square_sum/self.weight_right - new_mu*new_mu)
+    /* "adaXT/criteria/criteria.pyx":425
+ *             idx = indices[i]
+ *             weight = self.sample_weight[idx]
+ *             y_val = self.y[idx]*weight             # <<<<<<<<<<<<<<
+ *             self.right_sum += y_val
+ *             self.weight_right += weight
  */
-  __pyx_v_self->old_right_sum = __pyx_v_cur_sum;
+    __pyx_t_4 = __pyx_v_idx;
+    __pyx_v_y_val = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_4)) ))) * __pyx_v_weight);
 
-  /* "adaXT/criteria/criteria.pyx":445
- *         self.old_right_square_sum = square_sum
- *         self.old_right_sum = cur_sum
- *         new_mu = cur_sum / self.weight_right             # <<<<<<<<<<<<<<
- *         return (square_sum/self.weight_right - new_mu*new_mu)
+    /* "adaXT/criteria/criteria.pyx":426
+ *             weight = self.sample_weight[idx]
+ *             y_val = self.y[idx]*weight
+ *             self.right_sum += y_val             # <<<<<<<<<<<<<<
+ *             self.weight_right += weight
  * 
  */
-  __pyx_v_new_mu = (__pyx_v_cur_sum / __pyx_v_self->weight_right);
+    __pyx_v_self->right_sum = (__pyx_v_self->right_sum + __pyx_v_y_val);
 
-  /* "adaXT/criteria/criteria.pyx":446
- *         self.old_right_sum = cur_sum
- *         new_mu = cur_sum / self.weight_right
- *         return (square_sum/self.weight_right - new_mu*new_mu)             # <<<<<<<<<<<<<<
+    /* "adaXT/criteria/criteria.pyx":427
+ *             y_val = self.y[idx]*weight
+ *             self.right_sum += y_val
+ *             self.weight_right += weight             # <<<<<<<<<<<<<<
  * 
- *     cpdef double impurity(self, int[:] indices):
+ *         return -((self.left_sum*self.left_sum) / self.weight_left +
  */
-  __pyx_r = ((__pyx_v_square_sum / __pyx_v_self->weight_right) - (__pyx_v_new_mu * __pyx_v_new_mu));
-  goto __pyx_L0;
+    __pyx_v_self->weight_right = (__pyx_v_self->weight_right + __pyx_v_weight);
+  }
 
   /* "adaXT/criteria/criteria.pyx":429
- *         return (square_sum/self.weight_left - new_mu*new_mu)
+ *             self.weight_right += weight
+ * 
+ *         return -((self.left_sum*self.left_sum) / self.weight_left +             # <<<<<<<<<<<<<<
+ *                  (self.right_sum*self.right_sum) / self.weight_right)
  * 
- *     cdef double update_right(self, int[:] indices, int new_split):             # <<<<<<<<<<<<<<
+ */
+  __pyx_r = (-(((__pyx_v_self->left_sum * __pyx_v_self->left_sum) / __pyx_v_self->weight_left) + ((__pyx_v_self->right_sum * __pyx_v_self->right_sum) / __pyx_v_self->weight_right)));
+  goto __pyx_L0;
+
+  /* "adaXT/criteria/criteria.pyx":404
+ *                  (self.right_sum*self.right_sum) / self.weight_right)
+ * 
+ *     cdef double proxy_improvement(self, int[::1] indices, int split_idx):             # <<<<<<<<<<<<<<
  *         cdef:
- *             int i, start_idx, p
+ *             int i, idx
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":448
- *         return (square_sum/self.weight_right - new_mu*new_mu)
+/* "adaXT/criteria/criteria.pyx":432
+ *                  (self.right_sum*self.right_sum) / self.weight_right)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         return self._squared_error(indices)
  * 
  */
 
-static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_3impurity(PyObject *__pyx_v_self, 
+static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_1impurity(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
 static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_skip_dispatch) {
@@ -23041,18 +22869,18 @@
   /* Check if overridden in Python */
   else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || __Pyx_PyType_HasFeature(Py_TYPE(((PyObject *)__pyx_v_self)), (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
     #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
     if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
       PY_UINT64_T __pyx_typedict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
       #endif
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 448, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 432, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_3impurity)) {
-        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 448, __pyx_L1_error)
+      if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_1impurity)) {
+        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 432, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
         __pyx_t_6 = 0;
         #if CYTHON_UNPACK_METHODS
         if (unlikely(PyMethod_Check(__pyx_t_4))) {
           __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
@@ -23066,19 +22894,19 @@
         }
         #endif
         {
           PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_t_3};
           __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
           __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 448, __pyx_L1_error)
+          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 432, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_2);
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
         }
-        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 448, __pyx_L1_error)
+        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 432, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
         __pyx_r = __pyx_t_7;
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         goto __pyx_L0;
       }
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
       __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
@@ -23089,29 +22917,29 @@
       #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     }
     #endif
   }
 
-  /* "adaXT/criteria/criteria.pyx":449
+  /* "adaXT/criteria/criteria.pyx":433
  * 
- *     cpdef double impurity(self, int[:] indices):
+ *     cpdef double impurity(self, int[::1] indices):
  *         return self._squared_error(indices)             # <<<<<<<<<<<<<<
  * 
- *     # Override the default evaluate_split
+ *     cdef double _squared_error(self, int[::1] indices):
  */
-  __pyx_t_7 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self->__pyx_base.__pyx_vtab)->_squared_error(__pyx_v_self, __pyx_v_indices, NULL); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 449, __pyx_L1_error)
+  __pyx_t_7 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self->__pyx_base.__pyx_vtab)->_squared_error(__pyx_v_self, __pyx_v_indices); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 433, __pyx_L1_error)
   __pyx_r = __pyx_t_7;
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":448
- *         return (square_sum/self.weight_right - new_mu*new_mu)
+  /* "adaXT/criteria/criteria.pyx":432
+ *                  (self.right_sum*self.right_sum) / self.weight_right)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         return self._squared_error(indices)
  * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
@@ -23123,23 +22951,23 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_3impurity(PyObject *__pyx_v_self, 
+static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_1impurity(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_3impurity = {"impurity", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_3impurity, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_3impurity(PyObject *__pyx_v_self, 
+static PyMethodDef __pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_1impurity = {"impurity", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_1impurity, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_1impurity(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
   __Pyx_memviewslice __pyx_v_indices = { 0, 0, { 0 }, { 0 }, { 0 } };
@@ -23175,71 +23003,71 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 448, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 432, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 448, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 432, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_ds_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 448, __pyx_L3_error)
+    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 432, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 448, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 432, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_indices, 1);
   __Pyx_AddTraceback("adaXT.criteria.criteria.Squared_error.impurity", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_2impurity(((struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self), __pyx_v_indices);
+  __pyx_r = __pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_impurity(((struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self), __pyx_v_indices);
 
   /* function exit code */
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_indices, 1);
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_2impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices) {
+static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_impurity(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   double __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("impurity", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 448, __pyx_L1_error)
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 448, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 432, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 432, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -23248,341 +23076,23 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":452
- * 
- *     # Override the default evaluate_split
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
- *         cdef:
- *             int n_obs = indices.shape[0]
- */
-
-static __pyx_ctuple_double__and_double__and_double__and_double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error_evaluate_split(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, int __pyx_v_split_idx, int __pyx_v_feature) {
-  int __pyx_v_n_obs;
-  int __pyx_v_n_left;
-  int __pyx_v_n_right;
-  double __pyx_v_mean_thresh;
-  double __pyx_v_left_imp;
-  double __pyx_v_right_imp;
-  double __pyx_v_crit;
-  __Pyx_memviewslice __pyx_v_features = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __pyx_ctuple_double__and_double__and_double__and_double __pyx_r;
-  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_t_2;
-  int __pyx_t_3;
-  double __pyx_t_4;
-  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_t_6;
-  struct __pyx_opt_args_5adaXT_8criteria_8criteria_13Squared_error__squared_error __pyx_t_7;
-  Py_ssize_t __pyx_t_8;
-  Py_ssize_t __pyx_t_9;
-  Py_ssize_t __pyx_t_10;
-  Py_ssize_t __pyx_t_11;
-  Py_ssize_t __pyx_t_12;
-  Py_ssize_t __pyx_t_13;
-  __pyx_ctuple_double__and_double__and_double__and_double __pyx_t_14;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-
-  /* "adaXT/criteria/criteria.pyx":454
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):
- *         cdef:
- *             int n_obs = indices.shape[0]             # <<<<<<<<<<<<<<
- *             int n_left = split_idx
- *             int n_right = n_obs - n_left
- */
-  __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
-
-  /* "adaXT/criteria/criteria.pyx":455
- *         cdef:
- *             int n_obs = indices.shape[0]
- *             int n_left = split_idx             # <<<<<<<<<<<<<<
- *             int n_right = n_obs - n_left
- *             double mean_thresh
- */
-  __pyx_v_n_left = __pyx_v_split_idx;
-
-  /* "adaXT/criteria/criteria.pyx":456
- *             int n_obs = indices.shape[0]
- *             int n_left = split_idx
- *             int n_right = n_obs - n_left             # <<<<<<<<<<<<<<
- *             double mean_thresh
- *             double left_imp = 0.0
- */
-  __pyx_v_n_right = (__pyx_v_n_obs - __pyx_v_n_left);
-
-  /* "adaXT/criteria/criteria.pyx":458
- *             int n_right = n_obs - n_left
- *             double mean_thresh
- *             double left_imp = 0.0             # <<<<<<<<<<<<<<
- *             double right_imp = 0.0
- *             double crit = 0.0
- */
-  __pyx_v_left_imp = 0.0;
-
-  /* "adaXT/criteria/criteria.pyx":459
- *             double mean_thresh
- *             double left_imp = 0.0
- *             double right_imp = 0.0             # <<<<<<<<<<<<<<
- *             double crit = 0.0
- *             double[:, ::1] features = self.x
- */
-  __pyx_v_right_imp = 0.0;
-
-  /* "adaXT/criteria/criteria.pyx":460
- *             double left_imp = 0.0
- *             double right_imp = 0.0
- *             double crit = 0.0             # <<<<<<<<<<<<<<
- *             double[:, ::1] features = self.x
- * 
- */
-  __pyx_v_crit = 0.0;
-
-  /* "adaXT/criteria/criteria.pyx":461
- *             double right_imp = 0.0
- *             double crit = 0.0
- *             double[:, ::1] features = self.x             # <<<<<<<<<<<<<<
- * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
- */
-  __pyx_t_1 = __pyx_v_self->__pyx_base.x;
-  __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
-  __pyx_v_features = __pyx_t_1;
-  __pyx_t_1.memview = NULL;
-  __pyx_t_1.data = NULL;
-
-  /* "adaXT/criteria/criteria.pyx":463
- *             double[:, ::1] features = self.x
- * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting             # <<<<<<<<<<<<<<
- *             left_imp = self.update_left(indices, split_idx)
- *             right_imp = self.update_right(indices, split_idx)
- */
-  __pyx_t_3 = (__pyx_v_n_obs == __pyx_v_self->old_obs);
-  if (__pyx_t_3) {
-  } else {
-    __pyx_t_2 = __pyx_t_3;
-    goto __pyx_L4_bool_binop_done;
-  }
-  __pyx_t_3 = (__pyx_v_feature == __pyx_v_self->old_feature);
-  __pyx_t_2 = __pyx_t_3;
-  __pyx_L4_bool_binop_done:;
-  if (__pyx_t_2) {
-
-    /* "adaXT/criteria/criteria.pyx":464
- * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
- *             left_imp = self.update_left(indices, split_idx)             # <<<<<<<<<<<<<<
- *             right_imp = self.update_right(indices, split_idx)
- * 
- */
-    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self->__pyx_base.__pyx_vtab)->update_left(__pyx_v_self, __pyx_v_indices, __pyx_v_split_idx); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 464, __pyx_L1_error)
-    __pyx_v_left_imp = __pyx_t_4;
-
-    /* "adaXT/criteria/criteria.pyx":465
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting
- *             left_imp = self.update_left(indices, split_idx)
- *             right_imp = self.update_right(indices, split_idx)             # <<<<<<<<<<<<<<
- * 
- *         else:
- */
-    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self->__pyx_base.__pyx_vtab)->update_right(__pyx_v_self, __pyx_v_indices, __pyx_v_split_idx); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 465, __pyx_L1_error)
-    __pyx_v_right_imp = __pyx_t_4;
-
-    /* "adaXT/criteria/criteria.pyx":463
- *             double[:, ::1] features = self.x
- * 
- *         if n_obs == self.old_obs and feature == self.old_feature:  # If we are checking the same node with same sorting             # <<<<<<<<<<<<<<
- *             left_imp = self.update_left(indices, split_idx)
- *             right_imp = self.update_right(indices, split_idx)
- */
-    goto __pyx_L3;
-  }
-
-  /* "adaXT/criteria/criteria.pyx":468
- * 
- *         else:
- *             left_imp = self._squared_error(indices[:split_idx], 1)             # <<<<<<<<<<<<<<
- *             right_imp = self._squared_error(indices[split_idx:], 0)
- * 
- */
-  /*else*/ {
-    __pyx_t_5.data = __pyx_v_indices.data;
-    __pyx_t_5.memview = __pyx_v_indices.memview;
-    __PYX_INC_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_6 = -1;
-    if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_5,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_6,
-    0,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 468, __pyx_L1_error)
-}
-
-__pyx_t_7.__pyx_n = 1;
-    __pyx_t_7.left_or_right = 1;
-    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self->__pyx_base.__pyx_vtab)->_squared_error(__pyx_v_self, __pyx_t_5, &__pyx_t_7); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 468, __pyx_L1_error)
-    __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_5.memview = NULL; __pyx_t_5.data = NULL;
-    __pyx_v_left_imp = __pyx_t_4;
-
-    /* "adaXT/criteria/criteria.pyx":469
- *         else:
- *             left_imp = self._squared_error(indices[:split_idx], 1)
- *             right_imp = self._squared_error(indices[split_idx:], 0)             # <<<<<<<<<<<<<<
- * 
- *         self.old_feature = feature
- */
-    __pyx_t_5.data = __pyx_v_indices.data;
-    __pyx_t_5.memview = __pyx_v_indices.memview;
-    __PYX_INC_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_6 = -1;
-    if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_5,
-    __pyx_v_indices.shape[0], __pyx_v_indices.strides[0], __pyx_v_indices.suboffsets[0],
-    0,
-    0,
-    &__pyx_t_6,
-    __pyx_v_split_idx,
-    0,
-    0,
-    1,
-    0,
-    0,
-    1) < 0))
-{
-    __PYX_ERR(1, 469, __pyx_L1_error)
-}
-
-__pyx_t_7.__pyx_n = 1;
-    __pyx_t_7.left_or_right = 0;
-    __pyx_t_4 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self->__pyx_base.__pyx_vtab)->_squared_error(__pyx_v_self, __pyx_t_5, &__pyx_t_7); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 469, __pyx_L1_error)
-    __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-    __pyx_t_5.memview = NULL; __pyx_t_5.data = NULL;
-    __pyx_v_right_imp = __pyx_t_4;
-  }
-  __pyx_L3:;
-
-  /* "adaXT/criteria/criteria.pyx":471
- *             right_imp = self._squared_error(indices[split_idx:], 0)
- * 
- *         self.old_feature = feature             # <<<<<<<<<<<<<<
- *         self.old_obs = n_obs
- *         self.old_split = split_idx
- */
-  __pyx_v_self->old_feature = __pyx_v_feature;
-
-  /* "adaXT/criteria/criteria.pyx":472
- * 
- *         self.old_feature = feature
- *         self.old_obs = n_obs             # <<<<<<<<<<<<<<
- *         self.old_split = split_idx
- *         crit = left_imp * n_left / n_obs
- */
-  __pyx_v_self->old_obs = __pyx_v_n_obs;
-
-  /* "adaXT/criteria/criteria.pyx":473
- *         self.old_feature = feature
- *         self.old_obs = n_obs
- *         self.old_split = split_idx             # <<<<<<<<<<<<<<
- *         crit = left_imp * n_left / n_obs
- *         crit += right_imp * n_right / n_obs
- */
-  __pyx_v_self->old_split = __pyx_v_split_idx;
-
-  /* "adaXT/criteria/criteria.pyx":474
- *         self.old_obs = n_obs
- *         self.old_split = split_idx
- *         crit = left_imp * n_left / n_obs             # <<<<<<<<<<<<<<
- *         crit += right_imp * n_right / n_obs
- * 
- */
-  __pyx_v_crit = ((__pyx_v_left_imp * __pyx_v_n_left) / ((double)__pyx_v_n_obs));
-
-  /* "adaXT/criteria/criteria.pyx":475
- *         self.old_split = split_idx
- *         crit = left_imp * n_left / n_obs
- *         crit += right_imp * n_right / n_obs             # <<<<<<<<<<<<<<
- * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0
- */
-  __pyx_v_crit = (__pyx_v_crit + ((__pyx_v_right_imp * __pyx_v_n_right) / ((double)__pyx_v_n_obs)));
-
-  /* "adaXT/criteria/criteria.pyx":477
- *         crit += right_imp * n_right / n_obs
- * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0             # <<<<<<<<<<<<<<
- *         return (crit, left_imp, right_imp, mean_thresh)
- * 
- */
-  __pyx_t_8 = (__pyx_v_split_idx - 1);
-  __pyx_t_9 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_8 * __pyx_v_indices.strides[0]) )));
-  __pyx_t_10 = __pyx_v_feature;
-  __pyx_t_11 = __pyx_v_split_idx;
-  __pyx_t_12 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_11 * __pyx_v_indices.strides[0]) )));
-  __pyx_t_13 = __pyx_v_feature;
-  __pyx_v_mean_thresh = (((*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_features.data + __pyx_t_9 * __pyx_v_features.strides[0]) )) + __pyx_t_10)) ))) + (*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_features.data + __pyx_t_12 * __pyx_v_features.strides[0]) )) + __pyx_t_13)) )))) / 2.0);
-
-  /* "adaXT/criteria/criteria.pyx":478
- * 
- *         mean_thresh = (features[indices[split_idx-1]][feature] + features[indices[split_idx]][feature]) / 2.0
- *         return (crit, left_imp, right_imp, mean_thresh)             # <<<<<<<<<<<<<<
- * 
- *     cdef double _squared_error(self, int[:] indices, int left_or_right = -1):
- */
-  __pyx_t_14.f0 = __pyx_v_crit;
-  __pyx_t_14.f1 = __pyx_v_left_imp;
-  __pyx_t_14.f2 = __pyx_v_right_imp;
-  __pyx_t_14.f3 = __pyx_v_mean_thresh;
-  __pyx_r = __pyx_t_14;
-  goto __pyx_L0;
-
-  /* "adaXT/criteria/criteria.pyx":452
- * 
- *     # Override the default evaluate_split
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):             # <<<<<<<<<<<<<<
- *         cdef:
- *             int n_obs = indices.shape[0]
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-  __Pyx_AddTraceback("adaXT.criteria.criteria.Squared_error.evaluate_split", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __Pyx_pretend_to_initialize(&__pyx_r);
-  __pyx_L0:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_features, 1);
-  return __pyx_r;
-}
-
-/* "adaXT/criteria/criteria.pyx":480
- *         return (crit, left_imp, right_imp, mean_thresh)
+/* "adaXT/criteria/criteria.pyx":435
+ *         return self._squared_error(indices)
  * 
- *     cdef double _squared_error(self, int[:] indices, int left_or_right = -1):             # <<<<<<<<<<<<<<
+ *     cdef double _squared_error(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         """
  *         Function used to calculate the squared error of y[indices]
  */
 
-static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error__squared_error(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, struct __pyx_opt_args_5adaXT_8criteria_8criteria_13Squared_error__squared_error *__pyx_optional_args) {
-  int __pyx_v_left_or_right = ((int)-1);
+static double __pyx_f_5adaXT_8criteria_8criteria_13Squared_error__squared_error(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices) {
   double __pyx_v_cur_sum;
   __Pyx_memviewslice __pyx_v_y = { 0, 0, { 0 }, { 0 }, { 0 } };
   double __pyx_v_mu;
   double __pyx_v_square_err;
   double __pyx_v_tmp;
   double __pyx_v_obs_weight;
   int __pyx_v_i;
@@ -23592,254 +23102,144 @@
   __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
   double __pyx_t_2;
   int __pyx_t_3;
   int __pyx_t_4;
   int __pyx_t_5;
   Py_ssize_t __pyx_t_6;
   Py_ssize_t __pyx_t_7;
-  int __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  if (__pyx_optional_args) {
-    if (__pyx_optional_args->__pyx_n > 0) {
-      __pyx_v_left_or_right = __pyx_optional_args->left_or_right;
-    }
-  }
 
-  /* "adaXT/criteria/criteria.pyx":499
+  /* "adaXT/criteria/criteria.pyx":454
  *         """
  *         cdef:
  *             double cur_sum = 0.0             # <<<<<<<<<<<<<<
  *             double[::1] y = self.y
  *             double mu = weighted_mean(y, indices, self.sample_weight)  # set mu to be the mean of the dataset
  */
   __pyx_v_cur_sum = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":500
+  /* "adaXT/criteria/criteria.pyx":455
  *         cdef:
  *             double cur_sum = 0.0
  *             double[::1] y = self.y             # <<<<<<<<<<<<<<
  *             double mu = weighted_mean(y, indices, self.sample_weight)  # set mu to be the mean of the dataset
  *             double square_err, tmp
  */
   __pyx_t_1 = __pyx_v_self->__pyx_base.y;
   __PYX_INC_MEMVIEW(&__pyx_t_1, 1);
   __pyx_v_y = __pyx_t_1;
   __pyx_t_1.memview = NULL;
   __pyx_t_1.data = NULL;
 
-  /* "adaXT/criteria/criteria.pyx":501
+  /* "adaXT/criteria/criteria.pyx":456
  *             double cur_sum = 0.0
  *             double[::1] y = self.y
  *             double mu = weighted_mean(y, indices, self.sample_weight)  # set mu to be the mean of the dataset             # <<<<<<<<<<<<<<
  *             double square_err, tmp
  *             double obs_weight = 0.0
  */
-  __pyx_t_2 = __pyx_f_5adaXT_8criteria_12crit_helpers_weighted_mean(__pyx_v_y, __pyx_v_indices, __pyx_v_self->__pyx_base.sample_weight); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 501, __pyx_L1_error)
+  __pyx_t_2 = __pyx_f_5adaXT_8criteria_12crit_helpers_weighted_mean(__pyx_v_y, __pyx_v_indices, __pyx_v_self->__pyx_base.sample_weight); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 456, __pyx_L1_error)
   __pyx_v_mu = __pyx_t_2;
 
-  /* "adaXT/criteria/criteria.pyx":503
+  /* "adaXT/criteria/criteria.pyx":458
  *             double mu = weighted_mean(y, indices, self.sample_weight)  # set mu to be the mean of the dataset
  *             double square_err, tmp
  *             double obs_weight = 0.0             # <<<<<<<<<<<<<<
  *             int i, p
  *             int n_indices = indices.shape[0]
  */
   __pyx_v_obs_weight = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":505
+  /* "adaXT/criteria/criteria.pyx":460
  *             double obs_weight = 0.0
  *             int i, p
  *             int n_indices = indices.shape[0]             # <<<<<<<<<<<<<<
  *         # Calculate the variance using: variance = sum((y_i - mu)^2)/y_len
  *         for i in range(n_indices):
  */
   __pyx_v_n_indices = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":507
+  /* "adaXT/criteria/criteria.pyx":462
  *             int n_indices = indices.shape[0]
  *         # Calculate the variance using: variance = sum((y_i - mu)^2)/y_len
  *         for i in range(n_indices):             # <<<<<<<<<<<<<<
  *             p = indices[i]
  *             tmp = y[p] * self.sample_weight[p]
  */
   __pyx_t_3 = __pyx_v_n_indices;
   __pyx_t_4 = __pyx_t_3;
   for (__pyx_t_5 = 0; __pyx_t_5 < __pyx_t_4; __pyx_t_5+=1) {
     __pyx_v_i = __pyx_t_5;
 
-    /* "adaXT/criteria/criteria.pyx":508
+    /* "adaXT/criteria/criteria.pyx":463
  *         # Calculate the variance using: variance = sum((y_i - mu)^2)/y_len
  *         for i in range(n_indices):
  *             p = indices[i]             # <<<<<<<<<<<<<<
  *             tmp = y[p] * self.sample_weight[p]
  *             cur_sum += tmp*tmp
  */
     __pyx_t_6 = __pyx_v_i;
-    __pyx_v_p = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_6 * __pyx_v_indices.strides[0]) )));
+    __pyx_v_p = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_6)) )));
 
-    /* "adaXT/criteria/criteria.pyx":509
+    /* "adaXT/criteria/criteria.pyx":464
  *         for i in range(n_indices):
  *             p = indices[i]
  *             tmp = y[p] * self.sample_weight[p]             # <<<<<<<<<<<<<<
  *             cur_sum += tmp*tmp
  *             obs_weight += self.sample_weight[p]
  */
     __pyx_t_6 = __pyx_v_p;
     __pyx_t_7 = __pyx_v_p;
     __pyx_v_tmp = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_y.data) + __pyx_t_6)) ))) * (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_7)) ))));
 
-    /* "adaXT/criteria/criteria.pyx":510
+    /* "adaXT/criteria/criteria.pyx":465
  *             p = indices[i]
  *             tmp = y[p] * self.sample_weight[p]
  *             cur_sum += tmp*tmp             # <<<<<<<<<<<<<<
  *             obs_weight += self.sample_weight[p]
  *         square_err = cur_sum/obs_weight - mu*mu
  */
     __pyx_v_cur_sum = (__pyx_v_cur_sum + (__pyx_v_tmp * __pyx_v_tmp));
 
-    /* "adaXT/criteria/criteria.pyx":511
+    /* "adaXT/criteria/criteria.pyx":466
  *             tmp = y[p] * self.sample_weight[p]
  *             cur_sum += tmp*tmp
  *             obs_weight += self.sample_weight[p]             # <<<<<<<<<<<<<<
  *         square_err = cur_sum/obs_weight - mu*mu
- *         if left_or_right != -1:
+ *         return square_err
  */
     __pyx_t_7 = __pyx_v_p;
     __pyx_v_obs_weight = (__pyx_v_obs_weight + (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.sample_weight.data) + __pyx_t_7)) ))));
   }
 
-  /* "adaXT/criteria/criteria.pyx":512
+  /* "adaXT/criteria/criteria.pyx":467
  *             cur_sum += tmp*tmp
  *             obs_weight += self.sample_weight[p]
  *         square_err = cur_sum/obs_weight - mu*mu             # <<<<<<<<<<<<<<
- *         if left_or_right != -1:
- *             # Left subnode
- */
-  __pyx_v_square_err = ((__pyx_v_cur_sum / __pyx_v_obs_weight) - (__pyx_v_mu * __pyx_v_mu));
-
-  /* "adaXT/criteria/criteria.pyx":513
- *             obs_weight += self.sample_weight[p]
- *         square_err = cur_sum/obs_weight - mu*mu
- *         if left_or_right != -1:             # <<<<<<<<<<<<<<
- *             # Left subnode
- *             if left_or_right == 1:
- */
-  __pyx_t_8 = (__pyx_v_left_or_right != -1L);
-  if (__pyx_t_8) {
-
-    /* "adaXT/criteria/criteria.pyx":515
- *         if left_or_right != -1:
- *             # Left subnode
- *             if left_or_right == 1:             # <<<<<<<<<<<<<<
- *                 self.old_left_sum = mu * obs_weight
- *                 self.old_left_square_sum = cur_sum
- */
-    switch (__pyx_v_left_or_right) {
-      case 1:
-
-      /* "adaXT/criteria/criteria.pyx":516
- *             # Left subnode
- *             if left_or_right == 1:
- *                 self.old_left_sum = mu * obs_weight             # <<<<<<<<<<<<<<
- *                 self.old_left_square_sum = cur_sum
- *                 self.weight_left = obs_weight
- */
-      __pyx_v_self->old_left_sum = (__pyx_v_mu * __pyx_v_obs_weight);
-
-      /* "adaXT/criteria/criteria.pyx":517
- *             if left_or_right == 1:
- *                 self.old_left_sum = mu * obs_weight
- *                 self.old_left_square_sum = cur_sum             # <<<<<<<<<<<<<<
- *                 self.weight_left = obs_weight
- *             # Right subnode
- */
-      __pyx_v_self->old_left_square_sum = __pyx_v_cur_sum;
-
-      /* "adaXT/criteria/criteria.pyx":518
- *                 self.old_left_sum = mu * obs_weight
- *                 self.old_left_square_sum = cur_sum
- *                 self.weight_left = obs_weight             # <<<<<<<<<<<<<<
- *             # Right subnode
- *             elif left_or_right == 0:
- */
-      __pyx_v_self->weight_left = __pyx_v_obs_weight;
-
-      /* "adaXT/criteria/criteria.pyx":515
- *         if left_or_right != -1:
- *             # Left subnode
- *             if left_or_right == 1:             # <<<<<<<<<<<<<<
- *                 self.old_left_sum = mu * obs_weight
- *                 self.old_left_square_sum = cur_sum
- */
-      break;
-      case 0:
-
-      /* "adaXT/criteria/criteria.pyx":521
- *             # Right subnode
- *             elif left_or_right == 0:
- *                 self.old_right_sum = mu * obs_weight             # <<<<<<<<<<<<<<
- *                 self.old_right_square_sum = cur_sum
- *                 self.weight_right = obs_weight
- */
-      __pyx_v_self->old_right_sum = (__pyx_v_mu * __pyx_v_obs_weight);
-
-      /* "adaXT/criteria/criteria.pyx":522
- *             elif left_or_right == 0:
- *                 self.old_right_sum = mu * obs_weight
- *                 self.old_right_square_sum = cur_sum             # <<<<<<<<<<<<<<
- *                 self.weight_right = obs_weight
- *         return square_err
- */
-      __pyx_v_self->old_right_square_sum = __pyx_v_cur_sum;
-
-      /* "adaXT/criteria/criteria.pyx":523
- *                 self.old_right_sum = mu * obs_weight
- *                 self.old_right_square_sum = cur_sum
- *                 self.weight_right = obs_weight             # <<<<<<<<<<<<<<
  *         return square_err
  * 
  */
-      __pyx_v_self->weight_right = __pyx_v_obs_weight;
-
-      /* "adaXT/criteria/criteria.pyx":520
- *                 self.weight_left = obs_weight
- *             # Right subnode
- *             elif left_or_right == 0:             # <<<<<<<<<<<<<<
- *                 self.old_right_sum = mu * obs_weight
- *                 self.old_right_square_sum = cur_sum
- */
-      break;
-      default: break;
-    }
+  __pyx_v_square_err = ((__pyx_v_cur_sum / __pyx_v_obs_weight) - (__pyx_v_mu * __pyx_v_mu));
 
-    /* "adaXT/criteria/criteria.pyx":513
+  /* "adaXT/criteria/criteria.pyx":468
  *             obs_weight += self.sample_weight[p]
  *         square_err = cur_sum/obs_weight - mu*mu
- *         if left_or_right != -1:             # <<<<<<<<<<<<<<
- *             # Left subnode
- *             if left_or_right == 1:
- */
-  }
-
-  /* "adaXT/criteria/criteria.pyx":524
- *                 self.old_right_square_sum = cur_sum
- *                 self.weight_right = obs_weight
  *         return square_err             # <<<<<<<<<<<<<<
  * 
  * cdef class Linear_regression(Criteria):
  */
   __pyx_r = __pyx_v_square_err;
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":480
- *         return (crit, left_imp, right_imp, mean_thresh)
+  /* "adaXT/criteria/criteria.pyx":435
+ *         return self._squared_error(indices)
  * 
- *     cdef double _squared_error(self, int[:] indices, int left_or_right = -1):             # <<<<<<<<<<<<<<
+ *     cdef double _squared_error(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         """
  *         Function used to calculate the squared error of y[indices]
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
@@ -23853,23 +23253,23 @@
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_5__reduce_cython__(PyObject *__pyx_v_self, 
+static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_3__reduce_cython__(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_5__reduce_cython__ = {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_5__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_5__reduce_cython__(PyObject *__pyx_v_self, 
+static PyMethodDef __pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_3__reduce_cython__ = {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_3__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_3__reduce_cython__(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
   #if !CYTHON_METH_FASTCALL
@@ -23886,22 +23286,22 @@
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   if (unlikely(__pyx_nargs > 0)) {
     __Pyx_RaiseArgtupleInvalid("__reduce_cython__", 1, 0, 0, __pyx_nargs); return NULL;}
   if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce_cython__", 0))) return NULL;
-  __pyx_r = __pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_4__reduce_cython__(((struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self));
+  __pyx_r = __pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_2__reduce_cython__(((struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_4__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self) {
+static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_2__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 1);
 
@@ -23933,23 +23333,23 @@
  * def __reduce_cython__(self):
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_7__setstate_cython__(PyObject *__pyx_v_self, 
+static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_5__setstate_cython__(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_7__setstate_cython__ = {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_7__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_7__setstate_cython__(PyObject *__pyx_v_self, 
+static PyMethodDef __pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_5__setstate_cython__ = {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_5__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_5__setstate_cython__(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
   CYTHON_UNUSED PyObject *__pyx_v___pyx_state = 0;
@@ -24015,28 +23415,28 @@
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_AddTraceback("adaXT.criteria.criteria.Squared_error.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_6__setstate_cython__(((struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self), __pyx_v___pyx_state);
+  __pyx_r = __pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_4__setstate_cython__(((struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *)__pyx_v_self), __pyx_v___pyx_state);
 
   /* function exit code */
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_6__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
+static PyObject *__pyx_pf_5adaXT_8criteria_8criteria_13Squared_error_4__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 1);
 
@@ -24060,15 +23460,15 @@
   __Pyx_AddTraceback("adaXT.criteria.criteria.Squared_error.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":529
+/* "adaXT/criteria/criteria.pyx":473
  * 
  *     # Custom mean function, such that we don't have to loop through twice.
  *     cdef (double, double) custom_mean(self, int[:] indices):             # <<<<<<<<<<<<<<
  *         cdef:
  *             double sumX, sumY
  */
 
@@ -24082,108 +23482,108 @@
   int __pyx_t_2;
   int __pyx_t_3;
   Py_ssize_t __pyx_t_4;
   Py_ssize_t __pyx_t_5;
   Py_ssize_t __pyx_t_6;
   __pyx_ctuple_double__and_double __pyx_t_7;
 
-  /* "adaXT/criteria/criteria.pyx":533
+  /* "adaXT/criteria/criteria.pyx":477
  *             double sumX, sumY
  *             int i
  *             int length = indices.shape[0]             # <<<<<<<<<<<<<<
  *         sumX = 0.0
  *         sumY = 0.0
  */
   __pyx_v_length = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":534
+  /* "adaXT/criteria/criteria.pyx":478
  *             int i
  *             int length = indices.shape[0]
  *         sumX = 0.0             # <<<<<<<<<<<<<<
  *         sumY = 0.0
  *         for i in range(length):
  */
   __pyx_v_sumX = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":535
+  /* "adaXT/criteria/criteria.pyx":479
  *             int length = indices.shape[0]
  *         sumX = 0.0
  *         sumY = 0.0             # <<<<<<<<<<<<<<
  *         for i in range(length):
  *             sumX += self.x[indices[i], 0]
  */
   __pyx_v_sumY = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":536
+  /* "adaXT/criteria/criteria.pyx":480
  *         sumX = 0.0
  *         sumY = 0.0
  *         for i in range(length):             # <<<<<<<<<<<<<<
  *             sumX += self.x[indices[i], 0]
  *             sumY += self.y[indices[i]]
  */
   __pyx_t_1 = __pyx_v_length;
   __pyx_t_2 = __pyx_t_1;
   for (__pyx_t_3 = 0; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
     __pyx_v_i = __pyx_t_3;
 
-    /* "adaXT/criteria/criteria.pyx":537
+    /* "adaXT/criteria/criteria.pyx":481
  *         sumY = 0.0
  *         for i in range(length):
  *             sumX += self.x[indices[i], 0]             # <<<<<<<<<<<<<<
  *             sumY += self.y[indices[i]]
  * 
  */
     __pyx_t_4 = __pyx_v_i;
     __pyx_t_5 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_4 * __pyx_v_indices.strides[0]) )));
     __pyx_t_6 = 0;
     __pyx_v_sumX = (__pyx_v_sumX + (*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_self->__pyx_base.x.data + __pyx_t_5 * __pyx_v_self->__pyx_base.x.strides[0]) )) + __pyx_t_6)) ))));
 
-    /* "adaXT/criteria/criteria.pyx":538
+    /* "adaXT/criteria/criteria.pyx":482
  *         for i in range(length):
  *             sumX += self.x[indices[i], 0]
  *             sumY += self.y[indices[i]]             # <<<<<<<<<<<<<<
  * 
  *         return ((sumX / (<double> length)), (sumY/ (<double> length)))
  */
     __pyx_t_4 = __pyx_v_i;
     __pyx_t_6 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_4 * __pyx_v_indices.strides[0]) )));
     __pyx_v_sumY = (__pyx_v_sumY + (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_6)) ))));
   }
 
-  /* "adaXT/criteria/criteria.pyx":540
+  /* "adaXT/criteria/criteria.pyx":484
  *             sumY += self.y[indices[i]]
  * 
  *         return ((sumX / (<double> length)), (sumY/ (<double> length)))             # <<<<<<<<<<<<<<
  * 
  *     cdef (double, double) theta(self, int[:] indices):
  */
   __pyx_t_7.f0 = (__pyx_v_sumX / ((double)__pyx_v_length));
   __pyx_t_7.f1 = (__pyx_v_sumY / ((double)__pyx_v_length));
   __pyx_r = __pyx_t_7;
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":529
+  /* "adaXT/criteria/criteria.pyx":473
  * 
  *     # Custom mean function, such that we don't have to loop through twice.
  *     cdef (double, double) custom_mean(self, int[:] indices):             # <<<<<<<<<<<<<<
  *         cdef:
  *             double sumX, sumY
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":542
+/* "adaXT/criteria/criteria.pyx":486
  *         return ((sumX / (<double> length)), (sumY/ (<double> length)))
  * 
  *     cdef (double, double) theta(self, int[:] indices):             # <<<<<<<<<<<<<<
  *         """
- *         Calculate theta0 and theta1 used for a Linear Regression
+ *         Calculate theta0 and theta1 by a linear regression
  */
 
 static __pyx_ctuple_double__and_double __pyx_f_5adaXT_8criteria_8criteria_17Linear_regression_theta(struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices) {
   double __pyx_v_muX;
   double __pyx_v_muY;
   double __pyx_v_theta0;
   double __pyx_v_theta1;
@@ -24203,183 +23603,183 @@
   Py_ssize_t __pyx_t_8;
   Py_ssize_t __pyx_t_9;
   int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "adaXT/criteria/criteria.pyx":564
+  /* "adaXT/criteria/criteria.pyx":508
  *             double X_diff
  * 
  *         length = indices.shape[0]             # <<<<<<<<<<<<<<
  *         denominator = 0.0
  *         numerator = 0.0
  */
   __pyx_v_length = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":565
+  /* "adaXT/criteria/criteria.pyx":509
  * 
  *         length = indices.shape[0]
  *         denominator = 0.0             # <<<<<<<<<<<<<<
  *         numerator = 0.0
  *         muX, muY = self.custom_mean(indices)
  */
   __pyx_v_denominator = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":566
+  /* "adaXT/criteria/criteria.pyx":510
  *         length = indices.shape[0]
  *         denominator = 0.0
  *         numerator = 0.0             # <<<<<<<<<<<<<<
  *         muX, muY = self.custom_mean(indices)
  *         for i in range(length):
  */
   __pyx_v_numerator = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":567
+  /* "adaXT/criteria/criteria.pyx":511
  *         denominator = 0.0
  *         numerator = 0.0
  *         muX, muY = self.custom_mean(indices)             # <<<<<<<<<<<<<<
  *         for i in range(length):
  *             X_diff = self.x[indices[i], 0] - muX
  */
-  __pyx_t_1 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Linear_regression *)__pyx_v_self->__pyx_base.__pyx_vtab)->custom_mean(__pyx_v_self, __pyx_v_indices); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 567, __pyx_L1_error)
+  __pyx_t_1 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Linear_regression *)__pyx_v_self->__pyx_base.__pyx_vtab)->custom_mean(__pyx_v_self, __pyx_v_indices); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 511, __pyx_L1_error)
   __pyx_t_2 = __pyx_t_1.f0;
   __pyx_t_3 = __pyx_t_1.f1;
   __pyx_v_muX = __pyx_t_2;
   __pyx_v_muY = __pyx_t_3;
 
-  /* "adaXT/criteria/criteria.pyx":568
+  /* "adaXT/criteria/criteria.pyx":512
  *         numerator = 0.0
  *         muX, muY = self.custom_mean(indices)
  *         for i in range(length):             # <<<<<<<<<<<<<<
  *             X_diff = self.x[indices[i], 0] - muX
  *             numerator += (X_diff)*(self.y[indices[i]]-muY)
  */
   __pyx_t_4 = __pyx_v_length;
   __pyx_t_5 = __pyx_t_4;
   for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6+=1) {
     __pyx_v_i = __pyx_t_6;
 
-    /* "adaXT/criteria/criteria.pyx":569
+    /* "adaXT/criteria/criteria.pyx":513
  *         muX, muY = self.custom_mean(indices)
  *         for i in range(length):
  *             X_diff = self.x[indices[i], 0] - muX             # <<<<<<<<<<<<<<
  *             numerator += (X_diff)*(self.y[indices[i]]-muY)
  *             denominator += (X_diff)*X_diff
  */
     __pyx_t_7 = __pyx_v_i;
     __pyx_t_8 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_7 * __pyx_v_indices.strides[0]) )));
     __pyx_t_9 = 0;
     __pyx_v_X_diff = ((*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_self->__pyx_base.x.data + __pyx_t_8 * __pyx_v_self->__pyx_base.x.strides[0]) )) + __pyx_t_9)) ))) - __pyx_v_muX);
 
-    /* "adaXT/criteria/criteria.pyx":570
+    /* "adaXT/criteria/criteria.pyx":514
  *         for i in range(length):
  *             X_diff = self.x[indices[i], 0] - muX
  *             numerator += (X_diff)*(self.y[indices[i]]-muY)             # <<<<<<<<<<<<<<
  *             denominator += (X_diff)*X_diff
  *         if denominator == 0.0:
  */
     __pyx_t_7 = __pyx_v_i;
     __pyx_t_9 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_7 * __pyx_v_indices.strides[0]) )));
     __pyx_v_numerator = (__pyx_v_numerator + (__pyx_v_X_diff * ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_9)) ))) - __pyx_v_muY)));
 
-    /* "adaXT/criteria/criteria.pyx":571
+    /* "adaXT/criteria/criteria.pyx":515
  *             X_diff = self.x[indices[i], 0] - muX
  *             numerator += (X_diff)*(self.y[indices[i]]-muY)
  *             denominator += (X_diff)*X_diff             # <<<<<<<<<<<<<<
  *         if denominator == 0.0:
  *             theta1 = 0.0
  */
     __pyx_v_denominator = (__pyx_v_denominator + (__pyx_v_X_diff * __pyx_v_X_diff));
   }
 
-  /* "adaXT/criteria/criteria.pyx":572
+  /* "adaXT/criteria/criteria.pyx":516
  *             numerator += (X_diff)*(self.y[indices[i]]-muY)
  *             denominator += (X_diff)*X_diff
  *         if denominator == 0.0:             # <<<<<<<<<<<<<<
  *             theta1 = 0.0
  *         else:
  */
   __pyx_t_10 = (__pyx_v_denominator == 0.0);
   if (__pyx_t_10) {
 
-    /* "adaXT/criteria/criteria.pyx":573
+    /* "adaXT/criteria/criteria.pyx":517
  *             denominator += (X_diff)*X_diff
  *         if denominator == 0.0:
  *             theta1 = 0.0             # <<<<<<<<<<<<<<
  *         else:
  *             theta1 = numerator / denominator
  */
     __pyx_v_theta1 = 0.0;
 
-    /* "adaXT/criteria/criteria.pyx":572
+    /* "adaXT/criteria/criteria.pyx":516
  *             numerator += (X_diff)*(self.y[indices[i]]-muY)
  *             denominator += (X_diff)*X_diff
  *         if denominator == 0.0:             # <<<<<<<<<<<<<<
  *             theta1 = 0.0
  *         else:
  */
     goto __pyx_L5;
   }
 
-  /* "adaXT/criteria/criteria.pyx":575
+  /* "adaXT/criteria/criteria.pyx":519
  *             theta1 = 0.0
  *         else:
  *             theta1 = numerator / denominator             # <<<<<<<<<<<<<<
  *         theta0 = muY - theta1*muX
  *         return (theta0, theta1)
  */
   /*else*/ {
     __pyx_v_theta1 = (__pyx_v_numerator / __pyx_v_denominator);
   }
   __pyx_L5:;
 
-  /* "adaXT/criteria/criteria.pyx":576
+  /* "adaXT/criteria/criteria.pyx":520
  *         else:
  *             theta1 = numerator / denominator
  *         theta0 = muY - theta1*muX             # <<<<<<<<<<<<<<
  *         return (theta0, theta1)
  * 
  */
   __pyx_v_theta0 = (__pyx_v_muY - (__pyx_v_theta1 * __pyx_v_muX));
 
-  /* "adaXT/criteria/criteria.pyx":577
+  /* "adaXT/criteria/criteria.pyx":521
  *             theta1 = numerator / denominator
  *         theta0 = muY - theta1*muX
  *         return (theta0, theta1)             # <<<<<<<<<<<<<<
  * 
- *     cpdef double impurity(self, int[:] indices):
+ *     cpdef double impurity(self, int[::1] indices):
  */
   __pyx_t_1.f0 = __pyx_v_theta0;
   __pyx_t_1.f1 = __pyx_v_theta1;
   __pyx_r = __pyx_t_1;
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":542
+  /* "adaXT/criteria/criteria.pyx":486
  *         return ((sumX / (<double> length)), (sumY/ (<double> length)))
  * 
  *     cdef (double, double) theta(self, int[:] indices):             # <<<<<<<<<<<<<<
  *         """
- *         Calculate theta0 and theta1 used for a Linear Regression
+ *         Calculate theta0 and theta1 by a linear regression
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_AddTraceback("adaXT.criteria.criteria.Linear_regression.theta", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_pretend_to_initialize(&__pyx_r);
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "adaXT/criteria/criteria.pyx":579
+/* "adaXT/criteria/criteria.pyx":523
  *         return (theta0, theta1)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         cdef:
- *             double step_calc, theta0, theta1, cur_sum
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         """
+ *         Calculates the impurity of a node by
  */
 
 static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_17Linear_regression_1impurity(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
@@ -24419,18 +23819,18 @@
   /* Check if overridden in Python */
   else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || __Pyx_PyType_HasFeature(Py_TYPE(((PyObject *)__pyx_v_self)), (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
     #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
     if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
       PY_UINT64_T __pyx_typedict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
       #endif
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 579, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 523, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_8criteria_8criteria_17Linear_regression_1impurity)) {
-        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 579, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 523, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
         __pyx_t_6 = 0;
         #if CYTHON_UNPACK_METHODS
         if (unlikely(PyMethod_Check(__pyx_t_4))) {
           __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
@@ -24444,19 +23844,19 @@
         }
         #endif
         {
           PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_t_3};
           __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
           __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
+          if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 523, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_2);
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
         }
-        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 579, __pyx_L1_error)
+        __pyx_t_7 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_7 == (double)-1) && PyErr_Occurred())) __PYX_ERR(1, 523, __pyx_L1_error)
         __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
         __pyx_r = __pyx_t_7;
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         goto __pyx_L0;
       }
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
       __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
@@ -24467,94 +23867,94 @@
       #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     }
     #endif
   }
 
-  /* "adaXT/criteria/criteria.pyx":584
+  /* "adaXT/criteria/criteria.pyx":543
  *             int i, length
  * 
  *         length = indices.shape[0]             # <<<<<<<<<<<<<<
  *         theta0, theta1 = self.theta(indices)
  *         cur_sum = 0.0
  */
   __pyx_v_length = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/criteria/criteria.pyx":585
+  /* "adaXT/criteria/criteria.pyx":544
  * 
  *         length = indices.shape[0]
  *         theta0, theta1 = self.theta(indices)             # <<<<<<<<<<<<<<
  *         cur_sum = 0.0
  *         for i in range(length):
  */
-  __pyx_t_8 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Linear_regression *)__pyx_v_self->__pyx_base.__pyx_vtab)->theta(__pyx_v_self, __pyx_v_indices); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 585, __pyx_L1_error)
+  __pyx_t_8 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Linear_regression *)__pyx_v_self->__pyx_base.__pyx_vtab)->theta(__pyx_v_self, __pyx_v_indices); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 544, __pyx_L1_error)
   __pyx_t_7 = __pyx_t_8.f0;
   __pyx_t_9 = __pyx_t_8.f1;
   __pyx_v_theta0 = __pyx_t_7;
   __pyx_v_theta1 = __pyx_t_9;
 
-  /* "adaXT/criteria/criteria.pyx":586
+  /* "adaXT/criteria/criteria.pyx":545
  *         length = indices.shape[0]
  *         theta0, theta1 = self.theta(indices)
  *         cur_sum = 0.0             # <<<<<<<<<<<<<<
  *         for i in range(length):
  *             step_calc = self.y[indices[i]] - theta0 - theta1 * self.x[indices[i], 0]
  */
   __pyx_v_cur_sum = 0.0;
 
-  /* "adaXT/criteria/criteria.pyx":587
+  /* "adaXT/criteria/criteria.pyx":546
  *         theta0, theta1 = self.theta(indices)
  *         cur_sum = 0.0
  *         for i in range(length):             # <<<<<<<<<<<<<<
  *             step_calc = self.y[indices[i]] - theta0 - theta1 * self.x[indices[i], 0]
  *             cur_sum += step_calc*step_calc
  */
   __pyx_t_6 = __pyx_v_length;
   __pyx_t_10 = __pyx_t_6;
   for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_10; __pyx_t_11+=1) {
     __pyx_v_i = __pyx_t_11;
 
-    /* "adaXT/criteria/criteria.pyx":588
+    /* "adaXT/criteria/criteria.pyx":547
  *         cur_sum = 0.0
  *         for i in range(length):
  *             step_calc = self.y[indices[i]] - theta0 - theta1 * self.x[indices[i], 0]             # <<<<<<<<<<<<<<
  *             cur_sum += step_calc*step_calc
  *         return cur_sum
  */
     __pyx_t_12 = __pyx_v_i;
-    __pyx_t_13 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_12 * __pyx_v_indices.strides[0]) )));
+    __pyx_t_13 = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_12)) )));
     __pyx_t_14 = __pyx_v_i;
-    __pyx_t_15 = (*((int *) ( /* dim=0 */ (__pyx_v_indices.data + __pyx_t_14 * __pyx_v_indices.strides[0]) )));
+    __pyx_t_15 = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_indices.data) + __pyx_t_14)) )));
     __pyx_t_16 = 0;
     __pyx_v_step_calc = (((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->__pyx_base.y.data) + __pyx_t_13)) ))) - __pyx_v_theta0) - (__pyx_v_theta1 * (*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_self->__pyx_base.x.data + __pyx_t_15 * __pyx_v_self->__pyx_base.x.strides[0]) )) + __pyx_t_16)) )))));
 
-    /* "adaXT/criteria/criteria.pyx":589
+    /* "adaXT/criteria/criteria.pyx":548
  *         for i in range(length):
  *             step_calc = self.y[indices[i]] - theta0 - theta1 * self.x[indices[i], 0]
  *             cur_sum += step_calc*step_calc             # <<<<<<<<<<<<<<
  *         return cur_sum
  */
     __pyx_v_cur_sum = (__pyx_v_cur_sum + (__pyx_v_step_calc * __pyx_v_step_calc));
   }
 
-  /* "adaXT/criteria/criteria.pyx":590
+  /* "adaXT/criteria/criteria.pyx":549
  *             step_calc = self.y[indices[i]] - theta0 - theta1 * self.x[indices[i], 0]
  *             cur_sum += step_calc*step_calc
  *         return cur_sum             # <<<<<<<<<<<<<<
  */
   __pyx_r = __pyx_v_cur_sum;
   goto __pyx_L0;
 
-  /* "adaXT/criteria/criteria.pyx":579
+  /* "adaXT/criteria/criteria.pyx":523
  *         return (theta0, theta1)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         cdef:
- *             double step_calc, theta0, theta1, cur_sum
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         """
+ *         Calculates the impurity of a node by
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -24571,15 +23971,16 @@
 static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_17Linear_regression_1impurity(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_8criteria_8criteria_17Linear_regression_1impurity = {"impurity", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_17Linear_regression_1impurity, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+PyDoc_STRVAR(__pyx_doc_5adaXT_8criteria_8criteria_17Linear_regression_impurity, "\n        Calculates the impurity of a node by\n        L = sum_{i in indices} (Y[i] - theta0 - theta1 X[i, 0])^2\n        ----------\n\n        Parameters\n        ----------\n        indices : memoryview of NDArray\n            The indices to calculate\n\n        Returns\n        -------\n        double\n            evaluated impurity\n        ");
+static PyMethodDef __pyx_mdef_5adaXT_8criteria_8criteria_17Linear_regression_1impurity = {"impurity", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_17Linear_regression_1impurity, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_5adaXT_8criteria_8criteria_17Linear_regression_impurity};
 static PyObject *__pyx_pw_5adaXT_8criteria_8criteria_17Linear_regression_1impurity(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
@@ -24616,31 +24017,31 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 579, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 523, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 579, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "impurity") < 0)) __PYX_ERR(1, 523, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_ds_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 579, __pyx_L3_error)
+    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(1, 523, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 579, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("impurity", 1, 1, 1, __pyx_nargs); __PYX_ERR(1, 523, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -24671,16 +24072,16 @@
   double __pyx_t_1;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("impurity", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_17Linear_regression_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 579, __pyx_L1_error)
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_5adaXT_8criteria_8criteria_17Linear_regression_impurity(__pyx_v_self, __pyx_v_indices, 1); if (unlikely(PyErr_Occurred())) __PYX_ERR(1, 523, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 523, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -25356,22 +24757,21 @@
   if (unlikely(!o)) return 0;
   p = ((struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *)o);
   p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria*)__pyx_vtabptr_5adaXT_8criteria_8criteria_Squared_error;
   return o;
 }
 
 static PyMethodDef __pyx_methods_5adaXT_8criteria_8criteria_Squared_error[] = {
-  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_5__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
-  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_7__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_3__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_5__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
   {0, 0, 0, 0}
 };
 #if CYTHON_USE_TYPE_SPECS
 static PyType_Slot __pyx_type_5adaXT_8criteria_8criteria_Squared_error_slots[] = {
   {Py_tp_methods, (void *)__pyx_methods_5adaXT_8criteria_8criteria_Squared_error},
-  {Py_tp_init, (void *)__pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_1__init__},
   {Py_tp_new, (void *)__pyx_tp_new_5adaXT_8criteria_8criteria_Squared_error},
   {0, 0},
 };
 static PyType_Spec __pyx_type_5adaXT_8criteria_8criteria_Squared_error_spec = {
   "adaXT.criteria.criteria.Squared_error",
   sizeof(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error),
   0,
@@ -25424,15 +24824,15 @@
   0, /*tp_base*/
   0, /*tp_dict*/
   0, /*tp_descr_get*/
   0, /*tp_descr_set*/
   #if !CYTHON_USE_TYPE_SPECS
   0, /*tp_dictoffset*/
   #endif
-  __pyx_pw_5adaXT_8criteria_8criteria_13Squared_error_1__init__, /*tp_init*/
+  0, /*tp_init*/
   0, /*tp_alloc*/
   __pyx_tp_new_5adaXT_8criteria_8criteria_Squared_error, /*tp_new*/
   0, /*tp_free*/
   0, /*tp_is_gc*/
   0, /*tp_bases*/
   0, /*tp_mro*/
   0, /*tp_cache*/
@@ -26559,15 +25959,15 @@
     {&__pyx_n_s_Entropy___reduce_cython, __pyx_k_Entropy___reduce_cython, sizeof(__pyx_k_Entropy___reduce_cython), 0, 0, 1, 1},
     {&__pyx_n_s_Entropy___setstate_cython, __pyx_k_Entropy___setstate_cython, sizeof(__pyx_k_Entropy___setstate_cython), 0, 0, 1, 1},
     {&__pyx_n_s_Entropy_impurity, __pyx_k_Entropy_impurity, sizeof(__pyx_k_Entropy_impurity), 0, 0, 1, 1},
     {&__pyx_n_s_Gini_index, __pyx_k_Gini_index, sizeof(__pyx_k_Gini_index), 0, 0, 1, 1},
     {&__pyx_n_s_Gini_index___reduce_cython, __pyx_k_Gini_index___reduce_cython, sizeof(__pyx_k_Gini_index___reduce_cython), 0, 0, 1, 1},
     {&__pyx_n_s_Gini_index___setstate_cython, __pyx_k_Gini_index___setstate_cython, sizeof(__pyx_k_Gini_index___setstate_cython), 0, 0, 1, 1},
     {&__pyx_n_s_Gini_index_impurity, __pyx_k_Gini_index_impurity, sizeof(__pyx_k_Gini_index_impurity), 0, 0, 1, 1},
-    {&__pyx_kp_s_Impurity_must_be_implemented, __pyx_k_Impurity_must_be_implemented, sizeof(__pyx_k_Impurity_must_be_implemented), 0, 0, 1, 0},
+    {&__pyx_kp_u_Impurity_must_be_implemented, __pyx_k_Impurity_must_be_implemented, sizeof(__pyx_k_Impurity_must_be_implemented), 0, 1, 0, 0},
     {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
     {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
     {&__pyx_kp_s_Index_out_of_bounds_axis_d, __pyx_k_Index_out_of_bounds_axis_d, sizeof(__pyx_k_Index_out_of_bounds_axis_d), 0, 0, 1, 0},
     {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
     {&__pyx_kp_u_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 1, 0, 0},
     {&__pyx_kp_u_Invalid_shape_in_axis, __pyx_k_Invalid_shape_in_axis, sizeof(__pyx_k_Invalid_shape_in_axis), 0, 1, 0, 0},
     {&__pyx_n_s_Linear_regression, __pyx_k_Linear_regression, sizeof(__pyx_k_Linear_regression), 0, 0, 1, 1},
@@ -26690,15 +26090,15 @@
     {0, 0, 0, 0, 0, 0, 0}
   };
   return __Pyx_InitStrings(__pyx_string_tab);
 }
 /* #### Code section: cached_builtins ### */
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(0, 2, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(1, 102, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(1, 131, __pyx_L1_error)
   __pyx_builtin___import__ = __Pyx_GetBuiltinName(__pyx_n_s_import); if (!__pyx_builtin___import__) __PYX_ERR(0, 100, __pyx_L1_error)
   __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 141, __pyx_L1_error)
   __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 156, __pyx_L1_error)
   __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(0, 159, __pyx_L1_error)
   __pyx_builtin_AssertionError = __Pyx_GetBuiltinName(__pyx_n_s_AssertionError); if (!__pyx_builtin_AssertionError) __PYX_ERR(0, 373, __pyx_L1_error)
   __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(0, 408, __pyx_L1_error)
   __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(0, 618, __pyx_L1_error)
@@ -26745,22 +26145,22 @@
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
  */
   __pyx_tuple__8 = PyTuple_Pack(3, __pyx_int_136983863, __pyx_int_112105877, __pyx_int_184977713); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "adaXT/criteria/criteria.pyx":15
+  /* "adaXT/criteria/criteria.pyx":49
  * 
- *     cpdef double impurity(self, int[:] indices):
+ *     cpdef double impurity(self, int[::1] indices):
  *         raise Exception("Impurity must be implemented!")             # <<<<<<<<<<<<<<
  * 
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature):
+ *     cdef (double, double) evaluate_split(self, int[::1] indices, int split_idx, int feature):
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_Impurity_must_be_implemented); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 15, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_Impurity_must_be_implemented); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(1, 49, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__9);
   __Pyx_GIVEREF(__pyx_tuple__9);
 
   /* "View.MemoryView":100
  * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
  * try:
  *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
@@ -26857,25 +26257,25 @@
  *     cdef object __pyx_result
  */
   __pyx_tuple__19 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__19);
   __Pyx_GIVEREF(__pyx_tuple__19);
   __pyx_codeobj__20 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__19, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__20)) __PYX_ERR(0, 1, __pyx_L1_error)
 
-  /* "adaXT/criteria/criteria.pyx":14
- *         self.sample_weight = sample_weight
+  /* "adaXT/criteria/criteria.pyx":48
+ *         return crit
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         raise Exception("Impurity must be implemented!")
  * 
  */
-  __pyx_tuple__21 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_indices); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 14, __pyx_L1_error)
+  __pyx_tuple__21 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_indices); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 48, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__21);
   __Pyx_GIVEREF(__pyx_tuple__21);
-  __pyx_codeobj__22 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 14, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__22)) __PYX_ERR(1, 14, __pyx_L1_error)
+  __pyx_codeobj__22 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 48, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__22)) __PYX_ERR(1, 48, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
  */
   __pyx_tuple__23 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -26890,22 +26290,22 @@
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  */
   __pyx_tuple__25 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_pyx_state); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__25);
   __Pyx_GIVEREF(__pyx_tuple__25);
   __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) __PYX_ERR(0, 3, __pyx_L1_error)
 
-  /* "adaXT/criteria/criteria.pyx":91
- *         free(self.n_in_class_right)
+  /* "adaXT/criteria/criteria.pyx":90
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
  */
-  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 91, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(1, 91, __pyx_L1_error)
+  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 90, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(1, 90, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
  */
   __pyx_codeobj__28 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__28)) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -26914,22 +26314,22 @@
  * def __reduce_cython__(self):
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  */
   __pyx_codeobj__29 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__29)) __PYX_ERR(0, 3, __pyx_L1_error)
 
-  /* "adaXT/criteria/criteria.pyx":251
- *         free(self.n_in_class_right)
+  /* "adaXT/criteria/criteria.pyx":239
+ *         free(self.weight_in_class_right)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
  */
-  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 251, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(1, 251, __pyx_L1_error)
+  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 239, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(1, 239, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
  */
   __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -26938,22 +26338,22 @@
  * def __reduce_cython__(self):
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  */
   __pyx_codeobj__32 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__32)) __PYX_ERR(0, 3, __pyx_L1_error)
 
-  /* "adaXT/criteria/criteria.pyx":448
- *         return (square_sum/self.weight_right - new_mu*new_mu)
+  /* "adaXT/criteria/criteria.pyx":432
+ *                  (self.right_sum*self.right_sum) / self.weight_right)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         return self._squared_error(indices)
  * 
  */
-  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 448, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(1, 448, __pyx_L1_error)
+  __pyx_codeobj__33 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 432, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__33)) __PYX_ERR(1, 432, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
  */
   __pyx_codeobj__34 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__34)) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -26962,22 +26362,22 @@
  * def __reduce_cython__(self):
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  */
   __pyx_codeobj__35 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__35)) __PYX_ERR(0, 3, __pyx_L1_error)
 
-  /* "adaXT/criteria/criteria.pyx":579
+  /* "adaXT/criteria/criteria.pyx":523
  *         return (theta0, theta1)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         cdef:
- *             double step_calc, theta0, theta1, cur_sum
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         """
+ *         Calculates the impurity of a node by
  */
-  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 579, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__21, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_criteria_criteria_pyx, __pyx_n_s_impurity, 523, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(1, 523, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
  */
   __pyx_codeobj__37 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__37)) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -27067,198 +26467,197 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
   __pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria = &__pyx_vtable_5adaXT_8criteria_8criteria_Criteria;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Criteria.proxy_improvement = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_8Criteria_proxy_improvement;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Criteria.update_proxy = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_8Criteria_update_proxy;
   __pyx_vtable_5adaXT_8criteria_8criteria_Criteria.impurity = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_5adaXT_8criteria_8criteria_8Criteria_impurity;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Criteria.evaluate_split = (__pyx_ctuple_double__and_double__and_double__and_double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int, int))__pyx_f_5adaXT_8criteria_8criteria_8Criteria_evaluate_split;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Criteria.evaluate_split = (__pyx_ctuple_double__and_double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int, int))__pyx_f_5adaXT_8criteria_8criteria_8Criteria_evaluate_split;
   #if CYTHON_USE_TYPE_SPECS
-  __pyx_ptype_5adaXT_8criteria_8criteria_Criteria = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_8criteria_8criteria_Criteria_spec, NULL); if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Criteria)) __PYX_ERR(1, 8, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Criteria_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 8, __pyx_L1_error)
+  __pyx_ptype_5adaXT_8criteria_8criteria_Criteria = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_8criteria_8criteria_Criteria_spec, NULL); if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Criteria)) __PYX_ERR(1, 9, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Criteria_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 9, __pyx_L1_error)
   #else
   __pyx_ptype_5adaXT_8criteria_8criteria_Criteria = &__pyx_type_5adaXT_8criteria_8criteria_Criteria;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   #endif
   #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 8, __pyx_L1_error)
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 9, __pyx_L1_error)
   #endif
   #if PY_MAJOR_VERSION < 3
   __pyx_ptype_5adaXT_8criteria_8criteria_Criteria->tp_print = 0;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_8criteria_8criteria_Criteria->tp_dictoffset && __pyx_ptype_5adaXT_8criteria_8criteria_Criteria->tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_ptype_5adaXT_8criteria_8criteria_Criteria->tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #endif
-  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Criteria, __pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 8, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Criteria, __pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 9, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 8, __pyx_L1_error)
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 9, __pyx_L1_error)
   #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Criteria, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 8, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Criteria, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 9, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 8, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Criteria) < 0) __PYX_ERR(1, 9, __pyx_L1_error)
   #endif
   __pyx_vtabptr_5adaXT_8criteria_8criteria_Gini_index = &__pyx_vtable_5adaXT_8criteria_8criteria_Gini_index;
   __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index.__pyx_base = *__pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index.__pyx_base.proxy_improvement = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index_proxy_improvement;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index.__pyx_base.update_proxy = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index_update_proxy;
   __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index.__pyx_base.impurity = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index_impurity;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index.__pyx_base.evaluate_split = (__pyx_ctuple_double__and_double__and_double__and_double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int, int))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index_evaluate_split;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index.reset_n_in_class = (void (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, double *))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index_reset_n_in_class;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index._gini = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, __Pyx_memviewslice, double *, int))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index__gini;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index.update_left = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index_update_left;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index.update_right = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index_update_right;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index.reset_weight_list = (void (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, double *))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index_reset_weight_list;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Gini_index._gini = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Gini_index *, __Pyx_memviewslice, double *))__pyx_f_5adaXT_8criteria_8criteria_10Gini_index__gini;
   #if CYTHON_USE_TYPE_SPECS
-  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 72, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 69, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_8criteria_8criteria_Gini_index_spec, __pyx_t_1);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index)) __PYX_ERR(1, 72, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Gini_index_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 72, __pyx_L1_error)
+  if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index)) __PYX_ERR(1, 69, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Gini_index_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 69, __pyx_L1_error)
   #else
   __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index = &__pyx_type_5adaXT_8criteria_8criteria_Gini_index;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index->tp_base = __pyx_ptype_5adaXT_8criteria_8criteria_Criteria;
   #endif
   #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 72, __pyx_L1_error)
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 69, __pyx_L1_error)
   #endif
   #if PY_MAJOR_VERSION < 3
   __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index->tp_print = 0;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index->tp_dictoffset && __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index->tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index->tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #endif
-  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index, __pyx_vtabptr_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 72, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index, __pyx_vtabptr_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 69, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 72, __pyx_L1_error)
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 69, __pyx_L1_error)
   #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Gini_index, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 72, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Gini_index, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 69, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 72, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Gini_index) < 0) __PYX_ERR(1, 69, __pyx_L1_error)
   #endif
   __pyx_vtabptr_5adaXT_8criteria_8criteria_Entropy = &__pyx_vtable_5adaXT_8criteria_8criteria_Entropy;
   __pyx_vtable_5adaXT_8criteria_8criteria_Entropy.__pyx_base = *__pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Entropy.__pyx_base.proxy_improvement = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_7Entropy_proxy_improvement;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Entropy.__pyx_base.update_proxy = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_7Entropy_update_proxy;
   __pyx_vtable_5adaXT_8criteria_8criteria_Entropy.__pyx_base.impurity = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_5adaXT_8criteria_8criteria_7Entropy_impurity;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Entropy.__pyx_base.evaluate_split = (__pyx_ctuple_double__and_double__and_double__and_double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int, int))__pyx_f_5adaXT_8criteria_8criteria_7Entropy_evaluate_split;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Entropy.reset_n_in_class = (void (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, double *))__pyx_f_5adaXT_8criteria_8criteria_7Entropy_reset_n_in_class;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Entropy._entropy = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, __Pyx_memviewslice, double *, int))__pyx_f_5adaXT_8criteria_8criteria_7Entropy__entropy;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Entropy.update_left = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_7Entropy_update_left;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Entropy.update_right = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_7Entropy_update_right;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Entropy.reset_weight_list = (void (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, double *))__pyx_f_5adaXT_8criteria_8criteria_7Entropy_reset_weight_list;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Entropy._entropy = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Entropy *, __Pyx_memviewslice, double *))__pyx_f_5adaXT_8criteria_8criteria_7Entropy__entropy;
   #if CYTHON_USE_TYPE_SPECS
-  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 232, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 222, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_ptype_5adaXT_8criteria_8criteria_Entropy = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_8criteria_8criteria_Entropy_spec, __pyx_t_1);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Entropy)) __PYX_ERR(1, 232, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Entropy_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 232, __pyx_L1_error)
+  if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Entropy)) __PYX_ERR(1, 222, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Entropy_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 222, __pyx_L1_error)
   #else
   __pyx_ptype_5adaXT_8criteria_8criteria_Entropy = &__pyx_type_5adaXT_8criteria_8criteria_Entropy;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   __pyx_ptype_5adaXT_8criteria_8criteria_Entropy->tp_base = __pyx_ptype_5adaXT_8criteria_8criteria_Criteria;
   #endif
   #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 232, __pyx_L1_error)
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 222, __pyx_L1_error)
   #endif
   #if PY_MAJOR_VERSION < 3
   __pyx_ptype_5adaXT_8criteria_8criteria_Entropy->tp_print = 0;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_8criteria_8criteria_Entropy->tp_dictoffset && __pyx_ptype_5adaXT_8criteria_8criteria_Entropy->tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_ptype_5adaXT_8criteria_8criteria_Entropy->tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #endif
-  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Entropy, __pyx_vtabptr_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 232, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Entropy, __pyx_vtabptr_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 222, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 232, __pyx_L1_error)
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 222, __pyx_L1_error)
   #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Entropy, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 232, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Entropy, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 222, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 232, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Entropy) < 0) __PYX_ERR(1, 222, __pyx_L1_error)
   #endif
   __pyx_vtabptr_5adaXT_8criteria_8criteria_Squared_error = &__pyx_vtable_5adaXT_8criteria_8criteria_Squared_error;
   __pyx_vtable_5adaXT_8criteria_8criteria_Squared_error.__pyx_base = *__pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Squared_error.__pyx_base.proxy_improvement = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_13Squared_error_proxy_improvement;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Squared_error.__pyx_base.update_proxy = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_13Squared_error_update_proxy;
   __pyx_vtable_5adaXT_8criteria_8criteria_Squared_error.__pyx_base.impurity = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_5adaXT_8criteria_8criteria_13Squared_error_impurity;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Squared_error.__pyx_base.evaluate_split = (__pyx_ctuple_double__and_double__and_double__and_double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int, int))__pyx_f_5adaXT_8criteria_8criteria_13Squared_error_evaluate_split;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Squared_error.update_left = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_13Squared_error_update_left;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Squared_error.update_right = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *, __Pyx_memviewslice, int))__pyx_f_5adaXT_8criteria_8criteria_13Squared_error_update_right;
-  __pyx_vtable_5adaXT_8criteria_8criteria_Squared_error._squared_error = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *, __Pyx_memviewslice, struct __pyx_opt_args_5adaXT_8criteria_8criteria_13Squared_error__squared_error *__pyx_optional_args))__pyx_f_5adaXT_8criteria_8criteria_13Squared_error__squared_error;
+  __pyx_vtable_5adaXT_8criteria_8criteria_Squared_error._squared_error = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Squared_error *, __Pyx_memviewslice))__pyx_f_5adaXT_8criteria_8criteria_13Squared_error__squared_error;
   #if CYTHON_USE_TYPE_SPECS
-  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 393, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 382, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_8criteria_8criteria_Squared_error_spec, __pyx_t_1);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error)) __PYX_ERR(1, 393, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Squared_error_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 393, __pyx_L1_error)
+  if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error)) __PYX_ERR(1, 382, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Squared_error_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 382, __pyx_L1_error)
   #else
   __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error = &__pyx_type_5adaXT_8criteria_8criteria_Squared_error;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error->tp_base = __pyx_ptype_5adaXT_8criteria_8criteria_Criteria;
   #endif
   #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 393, __pyx_L1_error)
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 382, __pyx_L1_error)
   #endif
   #if PY_MAJOR_VERSION < 3
   __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error->tp_print = 0;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error->tp_dictoffset && __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error->tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error->tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #endif
-  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error, __pyx_vtabptr_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 393, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error, __pyx_vtabptr_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 382, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 393, __pyx_L1_error)
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 382, __pyx_L1_error)
   #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Squared_error, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 393, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Squared_error, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 382, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 393, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Squared_error) < 0) __PYX_ERR(1, 382, __pyx_L1_error)
   #endif
   __pyx_vtabptr_5adaXT_8criteria_8criteria_Linear_regression = &__pyx_vtable_5adaXT_8criteria_8criteria_Linear_regression;
   __pyx_vtable_5adaXT_8criteria_8criteria_Linear_regression.__pyx_base = *__pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria;
   __pyx_vtable_5adaXT_8criteria_8criteria_Linear_regression.__pyx_base.impurity = (double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_5adaXT_8criteria_8criteria_17Linear_regression_impurity;
   __pyx_vtable_5adaXT_8criteria_8criteria_Linear_regression.custom_mean = (__pyx_ctuple_double__and_double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression *, __Pyx_memviewslice))__pyx_f_5adaXT_8criteria_8criteria_17Linear_regression_custom_mean;
   __pyx_vtable_5adaXT_8criteria_8criteria_Linear_regression.theta = (__pyx_ctuple_double__and_double (*)(struct __pyx_obj_5adaXT_8criteria_8criteria_Linear_regression *, __Pyx_memviewslice))__pyx_f_5adaXT_8criteria_8criteria_17Linear_regression_theta;
   #if CYTHON_USE_TYPE_SPECS
-  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 526, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 470, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_8criteria_8criteria_Linear_regression_spec, __pyx_t_1);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression)) __PYX_ERR(1, 526, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Linear_regression_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 526, __pyx_L1_error)
+  if (unlikely(!__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression)) __PYX_ERR(1, 470, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_8criteria_8criteria_Linear_regression_spec, __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 470, __pyx_L1_error)
   #else
   __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression = &__pyx_type_5adaXT_8criteria_8criteria_Linear_regression;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression->tp_base = __pyx_ptype_5adaXT_8criteria_8criteria_Criteria;
   #endif
   #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 526, __pyx_L1_error)
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 470, __pyx_L1_error)
   #endif
   #if PY_MAJOR_VERSION < 3
   __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression->tp_print = 0;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression->tp_dictoffset && __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression->tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression->tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #endif
-  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression, __pyx_vtabptr_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 526, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression, __pyx_vtabptr_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 470, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 526, __pyx_L1_error)
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 470, __pyx_L1_error)
   #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Linear_regression, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 526, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Linear_regression, (PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 470, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 526, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression) < 0) __PYX_ERR(1, 470, __pyx_L1_error)
   #endif
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
   #if CYTHON_USE_TYPE_SPECS
   __pyx_array_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_array_spec, NULL); if (unlikely(!__pyx_array_type)) __PYX_ERR(0, 114, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
   __pyx_array_type->tp_as_buffer = &__pyx_tp_as_buffer_array;
@@ -27426,15 +26825,15 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
   /*--- Function import code ---*/
   __pyx_t_1 = PyImport_ImportModule("adaXT.criteria.crit_helpers"); if (!__pyx_t_1) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (__Pyx_ImportFunction_3_0_8(__pyx_t_1, "weighted_mean", (void (**)(void))&__pyx_f_5adaXT_8criteria_12crit_helpers_weighted_mean, "double (__Pyx_memviewslice, __Pyx_memviewslice, __Pyx_memviewslice)") < 0) __PYX_ERR(1, 1, __pyx_L1_error)
+  if (__Pyx_ImportFunction_3_0_10(__pyx_t_1, "weighted_mean", (void (**)(void))&__pyx_f_5adaXT_8criteria_12crit_helpers_weighted_mean, "double (__Pyx_memviewslice, __Pyx_memviewslice, __Pyx_memviewslice)") < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -28233,36 +27632,36 @@
  *     cdef object __pyx_result
  */
   __pyx_t_7 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_7) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/criteria/criteria.pyx":5
- * from libc.math cimport log2
+  /* "adaXT/criteria/criteria.pyx":6
  * from libc.stdlib cimport malloc, free
+ * from libc.string cimport memset
  * import numpy as np             # <<<<<<<<<<<<<<
  * from .crit_helpers cimport weighted_mean
  * 
  */
-  __pyx_t_7 = __Pyx_ImportDottedModule(__pyx_n_s_numpy, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 5, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_ImportDottedModule(__pyx_n_s_numpy, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 6, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_7) < 0) __PYX_ERR(1, 5, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_7) < 0) __PYX_ERR(1, 6, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/criteria/criteria.pyx":14
- *         self.sample_weight = sample_weight
+  /* "adaXT/criteria/criteria.pyx":48
+ *         return crit
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         raise Exception("Impurity must be implemented!")
  * 
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_8Criteria_3impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Criteria_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__22)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 14, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_8Criteria_3impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Criteria_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__22)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 48, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 14, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Criteria, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 48, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   PyType_Modified(__pyx_ptype_5adaXT_8criteria_8criteria_Criteria);
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
@@ -28279,24 +27678,24 @@
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  */
   __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_8Criteria_7__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Criteria___setstate_cython, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__26)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_7) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/criteria/criteria.pyx":91
- *         free(self.n_in_class_right)
+  /* "adaXT/criteria/criteria.pyx":90
+ *         memset(class_occurences, 0, self.num_classes*sizeof(double))
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_10Gini_index_5impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Gini_index_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__27)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 91, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_10Gini_index_5impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Gini_index_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__27)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 91, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 90, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   PyType_Modified(__pyx_ptype_5adaXT_8criteria_8criteria_Gini_index);
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
@@ -28313,24 +27712,24 @@
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  */
   __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_10Gini_index_9__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Gini_index___setstate_cython, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__29)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_7) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/criteria/criteria.pyx":251
- *         free(self.n_in_class_right)
+  /* "adaXT/criteria/criteria.pyx":239
+ *         free(self.weight_in_class_right)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         self.class_labels = np.unique(self.y.base[indices])
- *         self.num_classes = self.class_labels.shape[0]
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         if self.first_call:
+ *             self.class_labels = np.unique(self.y.base[indices])
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_7Entropy_5impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Entropy_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__30)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 251, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_7Entropy_5impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Entropy_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__30)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 239, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Entropy, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 251, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Entropy, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 239, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   PyType_Modified(__pyx_ptype_5adaXT_8criteria_8criteria_Entropy);
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
@@ -28347,58 +27746,58 @@
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  */
   __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_7Entropy_9__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Entropy___setstate_cython, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__32)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_7) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/criteria/criteria.pyx":448
- *         return (square_sum/self.weight_right - new_mu*new_mu)
+  /* "adaXT/criteria/criteria.pyx":432
+ *                  (self.right_sum*self.right_sum) / self.weight_right)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
  *         return self._squared_error(indices)
  * 
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_3impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Squared_error_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__33)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 448, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_1impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Squared_error_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__33)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 432, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 448, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 432, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   PyType_Modified(__pyx_ptype_5adaXT_8criteria_8criteria_Squared_error);
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_5__reduce_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Squared_error___reduce_cython, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__34)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_3__reduce_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Squared_error___reduce_cython, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__34)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_reduce_cython, __pyx_t_7) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
   /* "(tree fragment)":3
  * def __reduce_cython__(self):
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_7__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Squared_error___setstate_cython, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__35)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_13Squared_error_5__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Squared_error___setstate_cython, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__35)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_7) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/criteria/criteria.pyx":579
+  /* "adaXT/criteria/criteria.pyx":523
  *         return (theta0, theta1)
  * 
- *     cpdef double impurity(self, int[:] indices):             # <<<<<<<<<<<<<<
- *         cdef:
- *             double step_calc, theta0, theta1, cur_sum
+ *     cpdef double impurity(self, int[::1] indices):             # <<<<<<<<<<<<<<
+ *         """
+ *         Calculates the impurity of a node by
  */
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_17Linear_regression_1impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Linear_regression_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 579, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_8criteria_8criteria_17Linear_regression_1impurity, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Linear_regression_impurity, NULL, __pyx_n_s_adaXT_criteria_criteria, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 523, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 579, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression, __pyx_n_s_impurity, __pyx_t_7) < 0) __PYX_ERR(1, 523, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   PyType_Modified(__pyx_ptype_5adaXT_8criteria_8criteria_Linear_regression);
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "no default __reduce__ due to non-trivial __cinit__"
  * def __setstate_cython__(self, __pyx_state):
@@ -32514,15 +31913,15 @@
         break;
     case 0:
         self = ((PyCFunctionObject*)cyfunc)->m_self;
         break;
     default:
         return NULL;
     }
-    return ((_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
+    return ((__Pyx_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
 }
 static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
 {
     __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
     PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
     PyTypeObject *cls = (PyTypeObject *) __Pyx_CyFunction_GetClassObj(cyfunc);
 #if CYTHON_BACKPORT_VECTORCALL
@@ -33898,59 +33297,36 @@
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
     return result;
 }
 
 /* ObjectToMemviewSlice */
-  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_int(PyObject *obj, int writable_flag) {
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_int(PyObject *obj, int writable_flag) {
     __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
     __Pyx_BufFmt_StackElem stack[1];
-    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_STRIDED) };
+    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
     int retcode;
     if (obj == Py_None) {
         result.memview = (struct __pyx_memoryview_obj *) Py_None;
         return result;
     }
-    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, 0,
-                                                 PyBUF_RECORDS_RO | writable_flag, 1,
+    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
+                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
                                                  &__Pyx_TypeInfo_int, stack,
                                                  &result, obj);
     if (unlikely(retcode == -1))
         goto __pyx_fail;
     return result;
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
     return result;
 }
 
-/* ObjectToMemviewSlice */
-  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_double(PyObject *obj, int writable_flag) {
-    __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
-    __Pyx_BufFmt_StackElem stack[1];
-    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_STRIDED) };
-    int retcode;
-    if (obj == Py_None) {
-        result.memview = (struct __pyx_memoryview_obj *) Py_None;
-        return result;
-    }
-    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, 0,
-                                                 PyBUF_RECORDS_RO | writable_flag, 1,
-                                                 &__Pyx_TypeInfo_double, stack,
-                                                 &result, obj);
-    if (unlikely(retcode == -1))
-        goto __pyx_fail;
-    return result;
-__pyx_fail:
-    result.memview = NULL;
-    result.data = NULL;
-    return result;
-}
-
 /* CIntFromPyVerify */
   #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
 #define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
     __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
 #define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
     {\
@@ -35202,17 +34578,17 @@
                        (int) (rt_version >> 24), (int) ((rt_version >> 16) & 0xFF)
        );
         return PyErr_WarnEx(NULL, message, 1);
     }
 }
 
 /* FunctionImport */
-  #ifndef __PYX_HAVE_RT_ImportFunction_3_0_8
-#define __PYX_HAVE_RT_ImportFunction_3_0_8
-static int __Pyx_ImportFunction_3_0_8(PyObject *module, const char *funcname, void (**f)(void), const char *sig) {
+  #ifndef __PYX_HAVE_RT_ImportFunction_3_0_10
+#define __PYX_HAVE_RT_ImportFunction_3_0_10
+static int __Pyx_ImportFunction_3_0_10(PyObject *module, const char *funcname, void (**f)(void), const char *sig) {
     PyObject *d = 0;
     PyObject *cobj = 0;
     union {
         void (*fp)(void);
         void *p;
     } tmp;
     d = PyObject_GetAttrString(module, (char *)"__pyx_capi__");
```

### Comparing `adaXT-1.0.1/src/adaXT/decision_tree/DecisionTree.cpp` & `adaxt-1.1.0/src/adaXT/predict/predict.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,31 @@
-/* Generated by Cython 3.0.8 */
+/* Generated by Cython 3.0.10 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
+        "define_macros": [
+            [
+                "NPY_NO_DEPRECATED_API",
+                "NPY_1_7_API_VERSION"
+            ]
+        ],
         "extra_compile_args": [
             "-O3"
         ],
         "include_dirs": [
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include"
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include"
         ],
         "language": "c++",
-        "name": "adaXT.decision_tree.DecisionTree",
+        "name": "adaXT.predict.predict",
         "sources": [
-            "src/adaXT/decision_tree/DecisionTree.pyx"
+            "src/adaXT/predict/predict.pyx"
         ]
     },
-    "module_name": "adaXT.decision_tree.DecisionTree"
+    "module_name": "adaXT.predict.predict"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
 #if defined(CYTHON_LIMITED_API) && 0
@@ -39,18 +45,18 @@
     #error Cython requires Python 2.7+ or Python 3.3+.
 #else
 #if defined(CYTHON_LIMITED_API) && CYTHON_LIMITED_API
 #define __PYX_EXTRA_ABI_MODULE_NAME "limited"
 #else
 #define __PYX_EXTRA_ABI_MODULE_NAME ""
 #endif
-#define CYTHON_ABI "3_0_8" __PYX_EXTRA_ABI_MODULE_NAME
+#define CYTHON_ABI "3_0_10" __PYX_EXTRA_ABI_MODULE_NAME
 #define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
 #define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
-#define CYTHON_HEX_VERSION 0x030008F0
+#define CYTHON_HEX_VERSION 0x03000AF0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -134,14 +140,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(PYPY_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
@@ -195,14 +203,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(CYTHON_LIMITED_API)
   #ifdef Py_LIMITED_API
     #undef __PYX_LIMITED_VERSION_HEX
     #define __PYX_LIMITED_VERSION_HEX Py_LIMITED_API
   #endif
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
@@ -256,60 +266,83 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(Py_GIL_DISABLED) || defined(Py_NOGIL)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_TYPE_SPECS
+    #define CYTHON_USE_TYPE_SPECS 0
+  #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #ifndef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #endif
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #ifndef CYTHON_METH_FASTCALL
+    #define CYTHON_METH_FASTCALL 1
+  #endif
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT 1
   #endif
+  #ifndef CYTHON_USE_MODULE_STATE
+    #define CYTHON_USE_MODULE_STATE 0
+  #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE 1
   #endif
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 0
+  #endif
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
@@ -392,14 +425,17 @@
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK 1
   #endif
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
   #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 1
+  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if !defined(CYTHON_VECTORCALL)
 #define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
 #endif
@@ -751,16 +787,21 @@
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
   typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
   typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
-  #define __Pyx_PyCFunctionFast _PyCFunctionFast
-  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #if PY_VERSION_HEX >= 0x030d00A4
+  #  define __Pyx_PyCFunctionFast PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords PyCFunctionFastWithKeywords
+  #else
+  #  define __Pyx_PyCFunctionFast _PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #endif
 #endif
 #if CYTHON_METH_FASTCALL
   #define __Pyx_METH_FASTCALL METH_FASTCALL
   #define __Pyx_PyCFunction_FastCall __Pyx_PyCFunctionFast
   #define __Pyx_PyCFunction_FastCallWithKeywords __Pyx_PyCFunctionFastWithKeywords
 #else
   #define __Pyx_METH_FASTCALL METH_VARARGS
@@ -1104,15 +1145,15 @@
   #define __Pyx_PyList_SET_ITEM(o, i, v) PyList_SetItem(o, i, v)
   #define __Pyx_PyTuple_GET_SIZE(o) PyTuple_Size(o)
   #define __Pyx_PyList_GET_SIZE(o) PyList_Size(o)
   #define __Pyx_PySet_GET_SIZE(o) PySet_Size(o)
   #define __Pyx_PyBytes_GET_SIZE(o) PyBytes_Size(o)
   #define __Pyx_PyByteArray_GET_SIZE(o) PyByteArray_Size(o)
 #endif
-#if PY_VERSION_HEX >= 0x030d00A1
+#if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
   #define __Pyx_PyImport_AddModuleRef(name) PyImport_AddModuleRef(name)
 #else
   static CYTHON_INLINE PyObject *__Pyx_PyImport_AddModuleRef(const char *name) {
       PyObject *module = PyImport_AddModule(name);
       Py_XINCREF(module);
       return module;
   }
@@ -1191,15 +1232,15 @@
 #if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
 #define __Pyx_truncl trunc
 #else
 #define __Pyx_truncl truncl
 #endif
 
 #define __PYX_MARK_ERR_POS(f_index, lineno) \
-    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
+    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__;  (void)__pyx_clineno; }
 #define __PYX_ERR(f_index, lineno, Ln_error) \
     { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
 
 #ifdef CYTHON_EXTERN_C
     #undef __PYX_EXTERN_C
     #define __PYX_EXTERN_C CYTHON_EXTERN_C
 #elif defined(__PYX_EXTERN_C)
@@ -1208,16 +1249,16 @@
     #else
     #warning Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.
     #endif
 #else
     #define __PYX_EXTERN_C extern "C++"
 #endif
 
-#define __PYX_HAVE__adaXT__decision_tree__DecisionTree
-#define __PYX_HAVE_API__adaXT__decision_tree__DecisionTree
+#define __PYX_HAVE__adaXT__predict__predict
+#define __PYX_HAVE_API__adaXT__predict__predict
 /* Early includes */
 #include "pythread.h"
 #include <string.h>
 #include <stdlib.h>
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
@@ -1293,32 +1334,15 @@
 #define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
 #define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
 #define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
 #define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
 #define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const wchar_t *u)
-{
-    const wchar_t *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#else
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
-    const Py_UNICODE *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#endif
 #define __Pyx_PyUnicode_FromOrdinal(o)       PyUnicode_FromOrdinal((int)o)
-#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
-#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
@@ -1479,15 +1503,15 @@
 static int __pyx_clineno = 0;
 static const char * __pyx_cfilenm = __FILE__;
 static const char *__pyx_filename;
 
 /* #### Code section: filename_table ### */
 
 static const char *__pyx_f[] = {
-  "src/adaXT/decision_tree/DecisionTree.pyx",
+  "src/adaXT/predict/predict.pyx",
   "<stringsource>",
 };
 /* #### Code section: utility_code_proto_before_types ### */
 /* ForceInitThreads.proto */
 #ifndef __PYX_FORCE_INIT_THREADS
   #define __PYX_FORCE_INIT_THREADS 0
 #endif
@@ -1629,26 +1653,101 @@
 #define __Pyx_MemoryView_Len(m)  (m.shape[0])
 
 /* #### Code section: numeric_typedefs ### */
 /* #### Code section: complex_type_declarations ### */
 /* #### Code section: type_declarations ### */
 
 /*--- Type declarations ---*/
+struct __pyx_obj_5adaXT_7predict_7predict_Predict;
+struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification;
+struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression;
+struct __pyx_obj_5adaXT_7predict_7predict_PredictLinearRegression;
+struct __pyx_obj_5adaXT_7predict_7predict_PredictQuantile;
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
-struct __pyx_defaults;
-typedef struct __pyx_defaults __pyx_defaults;
-struct __pyx_defaults {
-  PyObject *__pyx_arg_max_depth;
-  PyObject *__pyx_arg_min_samples_split;
-  PyObject *__pyx_arg_min_samples_leaf;
+struct __pyx_opt_args_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix;
+
+/* "adaXT/predict/predict.pxd":11
+ *     cdef double[:, ::1] __check_dimensions(self, object X)
+ * 
+ *     cpdef double[:, ::1] predict_leaf_matrix(self, object X, bint scale=*)             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef list predict_proba(self, object X)
+ */
+struct __pyx_opt_args_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix {
+  int __pyx_n;
+  int scale;
 };
 
+/* "adaXT/predict/predict.pxd":2
+ * 
+ * cdef class Predict():             # <<<<<<<<<<<<<<
+ *     cdef:
+ *         double[:, ::1] X
+ */
+struct __pyx_obj_5adaXT_7predict_7predict_Predict {
+  PyObject_HEAD
+  struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict *__pyx_vtab;
+  __Pyx_memviewslice X;
+  __Pyx_memviewslice Y;
+  int n_features;
+  PyObject *root;
+};
+
+
+/* "adaXT/predict/predict.pxd":16
+ * 
+ * 
+ * cdef class PredictClassification(Predict):             # <<<<<<<<<<<<<<
+ *     cdef:
+ *         double[::1] classes
+ */
+struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification {
+  struct __pyx_obj_5adaXT_7predict_7predict_Predict __pyx_base;
+  __Pyx_memviewslice classes;
+};
+
+
+/* "adaXT/predict/predict.pxd":25
+ * 
+ * 
+ * cdef class PredictRegression(Predict):             # <<<<<<<<<<<<<<
+ *     pass
+ * 
+ */
+struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression {
+  struct __pyx_obj_5adaXT_7predict_7predict_Predict __pyx_base;
+};
+
+
+/* "adaXT/predict/predict.pxd":29
+ * 
+ * 
+ * cdef class PredictLinearRegression(PredictRegression):             # <<<<<<<<<<<<<<
+ *     pass
+ * 
+ */
+struct __pyx_obj_5adaXT_7predict_7predict_PredictLinearRegression {
+  struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression __pyx_base;
+};
+
+
+/* "adaXT/predict/predict.pxd":33
+ * 
+ * 
+ * cdef class PredictQuantile(Predict):             # <<<<<<<<<<<<<<
+ *     pass
+ */
+struct __pyx_obj_5adaXT_7predict_7predict_PredictQuantile {
+  struct __pyx_obj_5adaXT_7predict_7predict_Predict __pyx_base;
+};
+
+
 /* "View.MemoryView":114
  * @cython.collection_type("sequence")
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
@@ -1718,14 +1817,87 @@
   PyObject *from_object;
   PyObject *(*to_object_func)(char *);
   int (*to_dtype_func)(char *, PyObject *);
 };
 
 
 
+/* "adaXT/predict/predict.pyx":6
+ * from ..decision_tree.nodes import DecisionNode
+ * 
+ * cdef class Predict():             # <<<<<<<<<<<<<<
+ * 
+ *     def __cinit__(self, double[:, ::1] X, double[::1] Y, object root):
+ */
+
+struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict {
+  __Pyx_memviewslice (*_Predict__check_dimensions)(struct __pyx_obj_5adaXT_7predict_7predict_Predict *, PyObject *);
+  __Pyx_memviewslice (*predict_leaf_matrix)(struct __pyx_obj_5adaXT_7predict_7predict_Predict *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix *__pyx_optional_args);
+  PyObject *(*predict_proba)(struct __pyx_obj_5adaXT_7predict_7predict_Predict *, PyObject *, int __pyx_skip_dispatch);
+};
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict *__pyx_vtabptr_5adaXT_7predict_7predict_Predict;
+
+
+/* "adaXT/predict/predict.pyx":83
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
+ * 
+ * cdef class PredictClassification(Predict):             # <<<<<<<<<<<<<<
+ *     def __cinit__(self, double[:, ::1] X, double[::1] Y, object root, **kwargs):
+ *         self.classes = np.unique(Y)
+ */
+
+struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictClassification {
+  struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict __pyx_base;
+  int (*_PredictClassification__find_max_index)(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *, __Pyx_memviewslice);
+};
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictClassification *__pyx_vtabptr_5adaXT_7predict_7predict_PredictClassification;
+
+
+/* "adaXT/predict/predict.pyx":165
+ * 
+ * 
+ * cdef class PredictRegression(Predict):             # <<<<<<<<<<<<<<
+ *     def predict(self, object X, **kwargs):
+ *         cdef:
+ */
+
+struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictRegression {
+  struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict __pyx_base;
+};
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictRegression *__pyx_vtabptr_5adaXT_7predict_7predict_PredictRegression;
+
+
+/* "adaXT/predict/predict.pyx":194
+ *         return np.mean(predictions, axis=1)
+ * 
+ * cdef class PredictLinearRegression(PredictRegression):             # <<<<<<<<<<<<<<
+ *     def predict(self, object X, **kwargs):
+ *         cdef:
+ */
+
+struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictLinearRegression {
+  struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictRegression __pyx_base;
+};
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictLinearRegression *__pyx_vtabptr_5adaXT_7predict_7predict_PredictLinearRegression;
+
+
+/* "adaXT/predict/predict.pyx":219
+ * 
+ * 
+ * cdef class PredictQuantile(Predict):             # <<<<<<<<<<<<<<
+ * 
+ *     def predict(self, object X, **kwargs):
+ */
+
+struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictQuantile {
+  struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict __pyx_base;
+};
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictQuantile *__pyx_vtabptr_5adaXT_7predict_7predict_PredictQuantile;
+
+
 /* "View.MemoryView":114
  * @cython.collection_type("sequence")
  * @cname("__pyx_array")
  * cdef class array:             # <<<<<<<<<<<<<<
  * 
  *     cdef:
  */
@@ -2355,56 +2527,17 @@
 /* HasAttr.proto */
 #if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
 #define __Pyx_HasAttr(o, n)  PyObject_HasAttrWithError(o, n)
 #else
 static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 #endif
 
-/* PyObjectSetAttrStr.proto */
-#if CYTHON_USE_TYPE_SLOTS
-#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
-static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
-#else
-#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
-#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
-#endif
-
-/* PyIntCompare.proto */
-static CYTHON_INLINE int __Pyx_PyInt_BoolEqCObj(PyObject *op1, PyObject *op2, long intval, long inplace);
-
 /* PyIntCompare.proto */
 static CYTHON_INLINE int __Pyx_PyInt_BoolEqObjC(PyObject *op1, PyObject *op2, long intval, long inplace);
 
-/* IterFinish.proto */
-static CYTHON_INLINE int __Pyx_IterFinish(void);
-
-/* UnpackItemEndCheck.proto */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
-
-/* ListAppend.proto */
-#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
-static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
-    PyListObject* L = (PyListObject*) list;
-    Py_ssize_t len = Py_SIZE(list);
-    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
-        Py_INCREF(x);
-        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030d0000
-        L->ob_item[len] = x;
-        #else
-        PyList_SET_ITEM(list, len, x);
-        #endif
-        __Pyx_SET_SIZE(list, len + 1);
-        return 0;
-    }
-    return PyList_Append(list, x);
-}
-#else
-#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
-#endif
-
 /* py_dict_keys.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyDict_Keys(PyObject* d);
 
 /* UnpackUnboundCMethod.proto */
 typedef struct {
     PyObject *type;
     PyObject **method_name;
@@ -2440,23 +2573,29 @@
     (likely(PyDict_CheckExact(obj)) ?\
      __Pyx_PyDict_GetItem(obj, name) : PyObject_GetItem(obj, name))
 #else
 #define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
 #define __Pyx_PyObject_Dict_GetItem(obj, name)  PyObject_GetItem(obj, name)
 #endif
 
+/* IterFinish.proto */
+static CYTHON_INLINE int __Pyx_IterFinish(void);
+
 /* PyObjectCallNoArg.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
 
 /* PyObjectGetMethod.proto */
 static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);
 
 /* PyObjectCallMethod0.proto */
 static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);
 
+/* UnpackItemEndCheck.proto */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);
+
 /* UnpackTupleError.proto */
 static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index);
 
 /* UnpackTuple2.proto */
 #define __Pyx_unpack_tuple2(tuple, value1, value2, is_tuple, has_known_size, decref_tuple)\
     (likely(is_tuple || PyTuple_Check(tuple)) ?\
         (likely(has_known_size || PyTuple_GET_SIZE(tuple) == 2) ?\
@@ -2470,60 +2609,43 @@
 
 /* dict_iter.proto */
 static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* dict, int is_dict, PyObject* method_name,
                                                    Py_ssize_t* p_orig_length, int* p_is_dict);
 static CYTHON_INLINE int __Pyx_dict_iter_next(PyObject* dict_or_iter, Py_ssize_t orig_length, Py_ssize_t* ppos,
                                               PyObject** pkey, PyObject** pvalue, PyObject** pitem, int is_dict);
 
-/* PyObject_GenericGetAttrNoDict.proto */
-#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
-#else
-#define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
-#endif
-
-/* PyObject_GenericGetAttr.proto */
-#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
-static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
+/* ListAppend.proto */
+#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
+static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
+    PyListObject* L = (PyListObject*) list;
+    Py_ssize_t len = Py_SIZE(list);
+    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
+        Py_INCREF(x);
+        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030d0000
+        L->ob_item[len] = x;
+        #else
+        PyList_SET_ITEM(list, len, x);
+        #endif
+        __Pyx_SET_SIZE(list, len + 1);
+        return 0;
+    }
+    return PyList_Append(list, x);
+}
 #else
-#define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
+#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
 #endif
 
 /* IncludeStructmemberH.proto */
 #include <structmember.h>
 
 /* FixUpExtensionType.proto */
 #if CYTHON_USE_TYPE_SPECS
 static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type);
 #endif
 
-/* ValidateBasesTuple.proto */
-#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
-static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases);
-#endif
-
-/* PyType_Ready.proto */
-CYTHON_UNUSED static int __Pyx_PyType_Ready(PyTypeObject *t);
-
-/* SetVTable.proto */
-static int __Pyx_SetVtable(PyTypeObject* typeptr , void* vtable);
-
-/* GetVTable.proto */
-static void* __Pyx_GetVtable(PyTypeObject *type);
-
-/* MergeVTables.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_MergeVtables(PyTypeObject *type);
-#endif
-
-/* SetupReduce.proto */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_setup_reduce(PyObject* type_obj);
-#endif
-
 /* FetchSharedCythonModule.proto */
 static PyObject *__Pyx_FetchSharedCythonABIModule(void);
 
 /* FetchCommonType.proto */
 #if !CYTHON_USE_TYPE_SPECS
 static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
 #else
@@ -2656,46 +2778,55 @@
 /* CythonFunction.proto */
 static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
                                       int flags, PyObject* qualname,
                                       PyObject *closure,
                                       PyObject *module, PyObject *globals,
                                       PyObject* code);
 
-/* SetNameInClass.proto */
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && PY_VERSION_HEX < 0x030d0000
-#define __Pyx_SetNameInClass(ns, name, value)\
-    (likely(PyDict_CheckExact(ns)) ? _PyDict_SetItem_KnownHash(ns, name, value, ((PyASCIIObject *) name)->hash) : PyObject_SetItem(ns, name, value))
-#elif CYTHON_COMPILING_IN_CPYTHON
-#define __Pyx_SetNameInClass(ns, name, value)\
-    (likely(PyDict_CheckExact(ns)) ? PyDict_SetItem(ns, name, value) : PyObject_SetItem(ns, name, value))
+/* PyObject_GenericGetAttrNoDict.proto */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
 #else
-#define __Pyx_SetNameInClass(ns, name, value)  PyObject_SetItem(ns, name, value)
+#define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
 #endif
 
-/* CalculateMetaclass.proto */
-static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases);
+/* PyObject_GenericGetAttr.proto */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name);
+#else
+#define __Pyx_PyObject_GenericGetAttr PyObject_GenericGetAttr
+#endif
 
-/* PyObjectCall2Args.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);
+/* ValidateBasesTuple.proto */
+#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
+static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases);
+#endif
 
-/* PyObjectLookupSpecial.proto */
-#if CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
-#define __Pyx_PyObject_LookupSpecialNoError(obj, attr_name)  __Pyx__PyObject_LookupSpecial(obj, attr_name, 0)
-#define __Pyx_PyObject_LookupSpecial(obj, attr_name)  __Pyx__PyObject_LookupSpecial(obj, attr_name, 1)
-static CYTHON_INLINE PyObject* __Pyx__PyObject_LookupSpecial(PyObject* obj, PyObject* attr_name, int with_error);
-#else
-#define __Pyx_PyObject_LookupSpecialNoError(o,n) __Pyx_PyObject_GetAttrStrNoError(o,n)
-#define __Pyx_PyObject_LookupSpecial(o,n) __Pyx_PyObject_GetAttrStr(o,n)
+/* PyType_Ready.proto */
+CYTHON_UNUSED static int __Pyx_PyType_Ready(PyTypeObject *t);
+
+/* SetVTable.proto */
+static int __Pyx_SetVtable(PyTypeObject* typeptr , void* vtable);
+
+/* GetVTable.proto */
+static void* __Pyx_GetVtable(PyTypeObject *type);
+
+/* MergeVTables.proto */
+#if !CYTHON_COMPILING_IN_LIMITED_API
+static int __Pyx_MergeVtables(PyTypeObject *type);
 #endif
 
-/* Py3ClassCreate.proto */
-static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name, PyObject *qualname,
-                                           PyObject *mkw, PyObject *modname, PyObject *doc);
-static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases, PyObject *dict,
-                                      PyObject *mkw, int calculate_metaclass, int allow_py2_metaclass);
+/* SetupReduce.proto */
+#if !CYTHON_COMPILING_IN_LIMITED_API
+static int __Pyx_setup_reduce(PyObject* type_obj);
+#endif
+
+/* GetNameInClass.proto */
+#define __Pyx_GetNameInClass(var, nmspace, name)  (var) = __Pyx__GetNameInClass(nmspace, name)
+static PyObject *__Pyx__GetNameInClass(PyObject *nmspace, PyObject *name);
 
 /* CLineInTraceback.proto */
 #ifdef CYTHON_CLINE_IN_TRACEBACK
 #define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
 #else
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
 #endif
@@ -2772,15 +2903,18 @@
                 int ndim,
                 __Pyx_TypeInfo *dtype,
                 __Pyx_BufFmt_StackElem stack[],
                 __Pyx_memviewslice *memviewslice,
                 PyObject *original_obj);
 
 /* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dsds_double(PyObject *, int writable_flag);
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(PyObject *, int writable_flag);
+
+/* ObjectToMemviewSlice.proto */
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_double(PyObject *, int writable_flag);
 
 /* MemviewDtypeToObject.proto */
 static CYTHON_INLINE PyObject *__pyx_memview_get_double(const char *itemp);
 static CYTHON_INLINE int __pyx_memview_set_double(const char *itemp, PyObject *obj);
 
 /* ObjectToMemviewSlice.proto */
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_double(PyObject *, int writable_flag);
@@ -2816,20 +2950,20 @@
 #define __PYX_XCLEAR_MEMVIEW(slice, have_gil) __Pyx_XCLEAR_MEMVIEW(slice, have_gil, __LINE__)
 static CYTHON_INLINE void __Pyx_INC_MEMVIEW(__Pyx_memviewslice *, int, int);
 static CYTHON_INLINE void __Pyx_XCLEAR_MEMVIEW(__Pyx_memviewslice *, int, int);
 
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
 
-/* CIntFromPy.proto */
-static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
-
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
 
+/* CIntFromPy.proto */
+static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
+
 /* None.proto */
 #include <new>
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
 
 /* CIntFromPy.proto */
@@ -2864,17 +2998,21 @@
 static PyObject *__pyx_memoryview_setitem_indexed(struct __pyx_memoryview_obj *__pyx_v_self, PyObject *__pyx_v_index, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryview_convert_item_to_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp); /* proto*/
 static PyObject *__pyx_memoryview_assign_item_from_object(struct __pyx_memoryview_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryview__get_base(struct __pyx_memoryview_obj *__pyx_v_self); /* proto*/
 static PyObject *__pyx_memoryviewslice_convert_item_to_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp); /* proto*/
 static PyObject *__pyx_memoryviewslice_assign_item_from_object(struct __pyx_memoryviewslice_obj *__pyx_v_self, char *__pyx_v_itemp, PyObject *__pyx_v_value); /* proto*/
 static PyObject *__pyx_memoryviewslice__get_base(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto*/
+static __Pyx_memviewslice __pyx_f_5adaXT_7predict_7predict_7Predict__Predict__check_dimensions(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, PyObject *__pyx_v_X); /* proto*/
+static PyObject *__pyx_f_5adaXT_7predict_7predict_7Predict_predict_proba(CYTHON_UNUSED struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_X, int __pyx_skip_dispatch); /* proto*/
+static __Pyx_memviewslice __pyx_f_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, PyObject *__pyx_v_X, int __pyx_skip_dispatch, struct __pyx_opt_args_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix *__pyx_optional_args); /* proto*/
+static int __pyx_f_5adaXT_7predict_7predict_21PredictClassification__PredictClassification__find_max_index(CYTHON_UNUSED struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, __Pyx_memviewslice __pyx_v_lst); /* proto*/
+static PyObject *__pyx_f_5adaXT_7predict_7predict_21PredictClassification_predict_proba(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, PyObject *__pyx_v_X, int __pyx_skip_dispatch); /* proto*/
 
-/* Module declarations from "adaXT.decision_tree.DecisionTree" */
-static double __pyx_v_5adaXT_13decision_tree_12DecisionTree_EPSILON;
+/* Module declarations from "adaXT.predict.predict" */
 static PyObject *__pyx_collections_abc_Sequence = 0;
 static PyObject *generic = 0;
 static PyObject *strided = 0;
 static PyObject *indirect = 0;
 static PyObject *contiguous = 0;
 static PyObject *indirect_contiguous = 0;
 static int __pyx_memoryview_thread_locks_used;
@@ -2912,28 +3050,29 @@
 static void __pyx_memoryview_refcount_objects_in_slice(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *, int, size_t, void *, int); /*proto*/
 static void __pyx_memoryview__slice_assign_scalar(char *, Py_ssize_t *, Py_ssize_t *, int, size_t, void *); /*proto*/
 static PyObject *__pyx_unpickle_Enum__set_state(struct __pyx_MemviewEnum_obj *, PyObject *); /*proto*/
 /* #### Code section: typeinfo ### */
 static __Pyx_TypeInfo __Pyx_TypeInfo_double = { "double", NULL, sizeof(double), { 0 }, 0, 'R', 0, 0 };
 /* #### Code section: before_global_var ### */
-#define __Pyx_MODULE_NAME "adaXT.decision_tree.DecisionTree"
-extern int __pyx_module_is_main_adaXT__decision_tree__DecisionTree;
-int __pyx_module_is_main_adaXT__decision_tree__DecisionTree = 0;
+#define __Pyx_MODULE_NAME "adaXT.predict.predict"
+extern int __pyx_module_is_main_adaXT__predict__predict;
+int __pyx_module_is_main_adaXT__predict__predict = 0;
 
-/* Implementation of "adaXT.decision_tree.DecisionTree" */
+/* Implementation of "adaXT.predict.predict" */
 /* #### Code section: global_var ### */
-static PyObject *__pyx_builtin_AssertionError;
+static PyObject *__pyx_builtin_staticmethod;
 static PyObject *__pyx_builtin_ValueError;
-static PyObject *__pyx_builtin_AttributeError;
+static PyObject *__pyx_builtin_NotImplementedError;
 static PyObject *__pyx_builtin_range;
 static PyObject *__pyx_builtin___import__;
 static PyObject *__pyx_builtin_MemoryError;
 static PyObject *__pyx_builtin_enumerate;
 static PyObject *__pyx_builtin_TypeError;
+static PyObject *__pyx_builtin_AssertionError;
 static PyObject *__pyx_builtin_Ellipsis;
 static PyObject *__pyx_builtin_id;
 static PyObject *__pyx_builtin_IndexError;
 /* #### Code section: string_decls ### */
 static const char __pyx_k_[] = ": ";
 static const char __pyx_k_O[] = "O";
 static const char __pyx_k_X[] = "X";
@@ -2941,253 +3080,204 @@
 static const char __pyx_k_c[] = "c";
 static const char __pyx_k_i[] = "i";
 static const char __pyx_k__2[] = ".";
 static const char __pyx_k__3[] = "*";
 static const char __pyx_k__6[] = "'";
 static const char __pyx_k__7[] = ")";
 static const char __pyx_k_gc[] = "gc";
-static const char __pyx_k_ht[] = "ht";
 static const char __pyx_k_id[] = "id";
 static const char __pyx_k_ix[] = "ix_";
 static const char __pyx_k_np[] = "np";
-static const char __pyx_k__51[] = "?";
+static const char __pyx_k__52[] = "?";
 static const char __pyx_k_abc[] = "abc";
 static const char __pyx_k_and[] = " and ";
-static const char __pyx_k_col[] = "col";
-static const char __pyx_k_doc[] = "__doc__";
-static const char __pyx_k_eps[] = "eps";
-static const char __pyx_k_fit[] = "fit";
+static const char __pyx_k_arr[] = "arr";
 static const char __pyx_k_got[] = " (got ";
 static const char __pyx_k_idx[] = "idx";
-static const char __pyx_k_int[] = "int";
-static const char __pyx_k_key[] = "key";
-static const char __pyx_k_lst[] = "lst";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_obj[] = "obj";
-static const char __pyx_k_row[] = "row";
-static const char __pyx_k_str[] = "str";
 static const char __pyx_k_sys[] = "sys";
-static const char __pyx_k_val[] = "val";
-static const char __pyx_k_None[] = "None";
 static const char __pyx_k_axis[] = "axis";
 static const char __pyx_k_base[] = "base";
-static const char __pyx_k_bool[] = "bool";
 static const char __pyx_k_dict[] = "__dict__";
-static const char __pyx_k_init[] = "__init__";
 static const char __pyx_k_keys[] = "keys";
 static const char __pyx_k_main[] = "__main__";
+static const char __pyx_k_mean[] = "mean";
 static const char __pyx_k_mode[] = "mode";
 static const char __pyx_k_name[] = "name";
 static const char __pyx_k_ndim[] = "ndim";
-static const char __pyx_k_node[] = "node";
-static const char __pyx_k_ones[] = "ones";
 static const char __pyx_k_pack[] = "pack";
 static const char __pyx_k_root[] = "root";
 static const char __pyx_k_self[] = "self";
 static const char __pyx_k_size[] = "size";
 static const char __pyx_k_spec[] = "__spec__";
 static const char __pyx_k_step[] = "step";
 static const char __pyx_k_stop[] = "stop";
 static const char __pyx_k_test[] = "__test__";
 static const char __pyx_k_ASCII[] = "ASCII";
-static const char __pyx_k_Nodes[] = "Nodes";
-static const char __pyx_k_array[] = "array";
 static const char __pyx_k_class[] = "__class__";
 static const char __pyx_k_count[] = "count";
 static const char __pyx_k_dtype[] = "dtype";
 static const char __pyx_k_empty[] = "empty";
 static const char __pyx_k_error[] = "error";
-static const char __pyx_k_finfo[] = "finfo";
 static const char __pyx_k_flags[] = "flags";
-static const char __pyx_k_float[] = "float";
 static const char __pyx_k_got_2[] = ", got ";
 static const char __pyx_k_index[] = "index";
-static const char __pyx_k_int32[] = "int32";
 static const char __pyx_k_n_obs[] = "n_obs";
 static const char __pyx_k_numpy[] = "numpy";
 static const char __pyx_k_range[] = "range";
 static const char __pyx_k_scale[] = "scale";
 static const char __pyx_k_shape[] = "shape";
+static const char __pyx_k_stack[] = "stack";
 static const char __pyx_k_start[] = "start";
-static const char __pyx_k_super[] = "super";
 static const char __pyx_k_value[] = "value";
 static const char __pyx_k_zeros[] = "zeros";
 static const char __pyx_k_DOUBLE[] = "DOUBLE";
-static const char __pyx_k_arange[] = "arange";
-static const char __pyx_k_double[] = "double";
+static const char __pyx_k_argmax[] = "argmax";
+static const char __pyx_k_counts[] = "counts";
 static const char __pyx_k_enable[] = "enable";
 static const char __pyx_k_encode[] = "encode";
 static const char __pyx_k_format[] = "format";
 static const char __pyx_k_import[] = "__import__";
-static const char __pyx_k_matrix[] = "matrix";
-static const char __pyx_k_module[] = "__module__";
-static const char __pyx_k_n_node[] = "n_node";
+static const char __pyx_k_kwargs[] = "kwargs";
 static const char __pyx_k_name_2[] = "__name__";
-static const char __pyx_k_object[] = "object";
 static const char __pyx_k_pickle[] = "pickle";
 static const char __pyx_k_reduce[] = "__reduce__";
-static const char __pyx_k_return[] = "return";
 static const char __pyx_k_struct[] = "struct";
+static const char __pyx_k_theta0[] = "theta0";
+static const char __pyx_k_theta1[] = "theta1";
+static const char __pyx_k_unique[] = "unique";
 static const char __pyx_k_unpack[] = "unpack";
 static const char __pyx_k_update[] = "update";
-static const char __pyx_k_asarray[] = "asarray";
-static const char __pyx_k_builder[] = "builder";
-static const char __pyx_k_classes[] = "classes";
-static const char __pyx_k_cur_max[] = "cur_max";
+static const char __pyx_k_values[] = "values";
+static const char __pyx_k_Predict[] = "Predict";
 static const char __pyx_k_disable[] = "disable";
 static const char __pyx_k_float64[] = "float64";
 static const char __pyx_k_fortran[] = "fortran";
 static const char __pyx_k_indices[] = "indices";
-static const char __pyx_k_maxsize[] = "maxsize";
 static const char __pyx_k_memview[] = "memview";
-static const char __pyx_k_n_nodes[] = "n_nodes";
 static const char __pyx_k_predict[] = "predict";
-static const char __pyx_k_prepare[] = "__prepare__";
-static const char __pyx_k_reshape[] = "reshape";
-static const char __pyx_k_ret_val[] = "ret_val";
-static const char __pyx_k_Criteria[] = "Criteria";
 static const char __pyx_k_Ellipsis[] = "Ellipsis";
 static const char __pyx_k_Sequence[] = "Sequence";
-static const char __pyx_k_Splitter[] = "Splitter";
-static const char __pyx_k_criteria[] = "criteria";
 static const char __pyx_k_cur_node[] = "cur_node";
 static const char __pyx_k_getstate[] = "__getstate__";
 static const char __pyx_k_itemsize[] = "itemsize";
 static const char __pyx_k_pyx_type[] = "__pyx_type";
-static const char __pyx_k_qualname[] = "__qualname__";
+static const char __pyx_k_quantile[] = "quantile";
 static const char __pyx_k_register[] = "register";
-static const char __pyx_k_set_name[] = "__set_name__";
 static const char __pyx_k_setstate[] = "__setstate__";
-static const char __pyx_k_splitter[] = "splitter";
 static const char __pyx_k_TypeError[] = "TypeError";
 static const char __pyx_k_enumerate[] = "enumerate";
 static const char __pyx_k_isenabled[] = "isenabled";
-static const char __pyx_k_max_depth[] = "max_depth";
-static const char __pyx_k_metaclass[] = "__metaclass__";
-static const char __pyx_k_n_classes[] = "n_classes";
-static const char __pyx_k_n_samples[] = "n_samples";
 static const char __pyx_k_pyx_state[] = "__pyx_state";
 static const char __pyx_k_reduce_ex[] = "__reduce_ex__";
 static const char __pyx_k_split_idx[] = "split_idx";
 static const char __pyx_k_threshold[] = "threshold";
-static const char __pyx_k_tree_type[] = "tree_type";
 static const char __pyx_k_IndexError[] = "IndexError";
-static const char __pyx_k_Regression[] = "Regression";
 static const char __pyx_k_ValueError[] = "ValueError";
-static const char __pyx_k_build_tree[] = "build_tree";
-static const char __pyx_k_leaf_nodes[] = "leaf_nodes";
 static const char __pyx_k_left_child[] = "left_child";
-static const char __pyx_k_n_features[] = "n_features";
 static const char __pyx_k_np_ndarray[] = "np.ndarray";
 static const char __pyx_k_pyx_result[] = "__pyx_result";
 static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
-static const char __pyx_k_tree_types[] = "tree_types";
 static const char __pyx_k_MemoryError[] = "MemoryError";
 static const char __pyx_k_PickleError[] = "PickleError";
-static const char __pyx_k_check_input[] = "__check_input";
 static const char __pyx_k_collections[] = "collections";
 static const char __pyx_k_expand_dims[] = "expand_dims";
+static const char __pyx_k_predictions[] = "predictions";
 static const char __pyx_k_right_child[] = "right_child";
 static const char __pyx_k_DecisionNode[] = "DecisionNode";
-static const char __pyx_k_DecisionTree[] = "DecisionTree";
-static const char __pyx_k_impurity_tol[] = "impurity_tol";
 static const char __pyx_k_initializing[] = "_initializing";
 static const char __pyx_k_is_coroutine[] = "_is_coroutine";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
+static const char __pyx_k_save_indices[] = "save_indices";
+static const char __pyx_k_staticmethod[] = "staticmethod";
 static const char __pyx_k_stringsource[] = "<stringsource>";
 static const char __pyx_k_version_info[] = "version_info";
-static const char __pyx_k_Splitter_None[] = "Splitter | None";
 static const char __pyx_k_class_getitem[] = "__class_getitem__";
 static const char __pyx_k_cur_split_idx[] = "cur_split_idx";
 static const char __pyx_k_cur_threshold[] = "cur_threshold";
-static const char __pyx_k_init_subclass[] = "__init_subclass__";
 static const char __pyx_k_predict_proba[] = "predict_proba";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
-static const char __pyx_k_sample_weight[] = "sample_weight";
+static const char __pyx_k_return_counts[] = "return_counts";
 static const char __pyx_k_AssertionError[] = "AssertionError";
-static const char __pyx_k_AttributeError[] = "AttributeError";
-static const char __pyx_k_Classification[] = "Classification";
-static const char __pyx_k_find_max_index[] = "__find_max_index";
-static const char __pyx_k_sample_indices[] = "sample_indices";
+static const char __pyx_k_forest_predict[] = "forest_predict";
+static const char __pyx_k_PredictQuantile[] = "PredictQuantile";
+static const char __pyx_k_Predict_predict[] = "Predict.predict";
 static const char __pyx_k_View_MemoryView[] = "View.MemoryView";
 static const char __pyx_k_allocate_buffer[] = "allocate_buffer";
 static const char __pyx_k_collections_abc[] = "collections.abc";
 static const char __pyx_k_dtype_is_object[] = "dtype_is_object";
-static const char __pyx_k_feature_indices[] = "feature_indices";
-static const char __pyx_k_get_leaf_matrix[] = "get_leaf_matrix";
-static const char __pyx_k_min_improvement[] = "min_improvement";
-static const char __pyx_k_np_ndarray_None[] = "np.ndarray | None";
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
-static const char __pyx_k_DecisionTree_fit[] = "DecisionTree.fit";
-static const char __pyx_k_DepthTreeBuilder[] = "DepthTreeBuilder";
-static const char __pyx_k_check_dimensions[] = "__check_dimensions";
-static const char __pyx_k_min_samples_leaf[] = "min_samples_leaf";
+static const char __pyx_k_Predict___reduce[] = "Predict.__reduce__";
+static const char __pyx_k_apply_along_axis[] = "apply_along_axis";
+static const char __pyx_k_PredictRegression[] = "PredictRegression";
 static const char __pyx_k_ascontiguousarray[] = "ascontiguousarray";
-static const char __pyx_k_min_samples_split[] = "min_samples_split";
 static const char __pyx_k_pyx_unpickle_Enum[] = "__pyx_unpickle_Enum";
 static const char __pyx_k_asyncio_coroutines[] = "asyncio.coroutines";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_strided_and_direct[] = "<strided and direct>";
-static const char __pyx_k_DecisionTree___init[] = "DecisionTree.__init__";
 static const char __pyx_k_Dimension_should_be[] = "Dimension should be ";
-static const char __pyx_k_check_sample_weight[] = "__check_sample_weight";
+static const char __pyx_k_NotImplementedError[] = "NotImplementedError";
+static const char __pyx_k_decision_tree_nodes[] = "decision_tree.nodes";
 static const char __pyx_k_predict_leaf_matrix[] = "predict_leaf_matrix";
-static const char __pyx_k_DecisionTree_predict[] = "DecisionTree.predict";
+static const char __pyx_k_forest_predict_proba[] = "forest_predict_proba";
 static const char __pyx_k_strided_and_indirect[] = "<strided and indirect>";
 static const char __pyx_k_Invalid_shape_in_axis[] = "Invalid shape in axis ";
+static const char __pyx_k_PredictClassification[] = "PredictClassification";
+static const char __pyx_k_Predict_predict_proba[] = "Predict.predict_proba";
+static const char __pyx_k_adaXT_predict_predict[] = "adaXT.predict.predict";
 static const char __pyx_k_contiguous_and_direct[] = "<contiguous and direct>";
+static const char __pyx_k_most_frequent_element[] = "__most_frequent_element";
 static const char __pyx_k_Cannot_index_with_type[] = "Cannot index with type '";
 static const char __pyx_k_MemoryView_of_r_object[] = "<MemoryView of %r object>";
+static const char __pyx_k_Predict_forest_predict[] = "Predict.forest_predict";
 static const char __pyx_k_MemoryView_of_r_at_0x_x[] = "<MemoryView of %r at 0x%x>";
+static const char __pyx_k_PredictLinearRegression[] = "PredictLinearRegression";
+static const char __pyx_k_PredictQuantile_predict[] = "PredictQuantile.predict";
 static const char __pyx_k_contiguous_and_indirect[] = "<contiguous and indirect>";
-static const char __pyx_k_DecisionTree__check_input[] = "_DecisionTree__check_input";
+static const char __pyx_k_stacked_tree_predictions[] = "stacked_tree_predictions";
 static const char __pyx_k_Dimension_d_is_not_direct[] = "Dimension %d is not direct";
-static const char __pyx_k_DecisionTree___check_input[] = "DecisionTree.__check_input";
-static const char __pyx_k_DecisionTree_predict_proba[] = "DecisionTree.predict_proba";
+static const char __pyx_k_PredictRegression_predict[] = "PredictRegression.predict";
 static const char __pyx_k_Index_out_of_bounds_axis_d[] = "Index out of bounds (axis %d)";
+static const char __pyx_k_Predict_predict_leaf_matrix[] = "Predict.predict_leaf_matrix";
 static const char __pyx_k_Step_may_not_be_zero_axis_d[] = "Step may not be zero (axis %d)";
 static const char __pyx_k_itemsize_0_for_cython_array[] = "itemsize <= 0 for cython.array";
-static const char __pyx_k_DecisionTree__find_max_index[] = "_DecisionTree__find_max_index";
-static const char __pyx_k_DecisionTree_get_leaf_matrix[] = "DecisionTree.get_leaf_matrix";
 static const char __pyx_k_Number_of_features_should_be[] = "Number of features should be ";
-static const char __pyx_k_DecisionTree___find_max_index[] = "DecisionTree.__find_max_index";
+static const char __pyx_k_Predict_forest_predict_proba[] = "Predict.forest_predict_proba";
+static const char __pyx_k_PredictClassification_predict[] = "PredictClassification.predict";
+static const char __pyx_k_src_adaXT_predict_predict_pyx[] = "src/adaXT/predict/predict.pyx";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
-static const char __pyx_k_DecisionTree__check_dimensions[] = "_DecisionTree__check_dimensions";
+static const char __pyx_k_PredictQuantile_forest_predict[] = "PredictQuantile.forest_predict";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
-static const char __pyx_k_DecisionTree___check_dimensions[] = "DecisionTree.__check_dimensions";
-static const char __pyx_k_DecisionTree__check_sample_weig[] = "_DecisionTree__check_sample_weight";
-static const char __pyx_k_Y_should_have_dimensions_n_1_or[] = "Y should have dimensions (n,1) or (n,)";
+static const char __pyx_k_PredictClassification__most_fre[] = "_PredictClassification__most_frequent_element";
+static const char __pyx_k_PredictLinearRegression_predict[] = "PredictLinearRegression.predict";
 static const char __pyx_k_All_dimensions_preceding_dimensi[] = "All dimensions preceding dimension %d must be indexed and not sliced";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
 static const char __pyx_k_Cannot_transpose_memoryview_with[] = "Cannot transpose memoryview with indirect dimensions";
-static const char __pyx_k_DecisionTree___check_sample_weig[] = "DecisionTree.__check_sample_weight";
-static const char __pyx_k_DecisionTree_predict_leaf_matrix[] = "DecisionTree.predict_leaf_matrix";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
-static const char __pyx_k_Expected_Classification_or_Regre[] = "Expected Classification or Regression as tree type, got: ";
+static const char __pyx_k_Function_predict_is_not_implemen[] = "Function predict is not implemented for this Predict class";
+static const char __pyx_k_Function_predict_proba_is_not_im[] = "Function predict_proba is not implemented for this Predict class";
 static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
 static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got ";
 static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis ";
-static const char __pyx_k_The_tree_has_not_been_fitted_bef[] = "The tree has not been fitted before trying to call predict";
-static const char __pyx_k_The_tree_has_not_been_trained_be[] = "The tree has not been trained before trying to predict";
+static const char __pyx_k_PredictClassification_forest_pre[] = "PredictClassification.forest_predict";
+static const char __pyx_k_PredictClassification_predict_pr[] = "PredictClassification.predict_proba";
+static const char __pyx_k_PredictRegression_forest_predict[] = "PredictRegression.forest_predict";
+static const char __pyx_k_The_forest_predict_function_is_n[] = "The forest predict function is not implemented for this Predict Class";
 static const char __pyx_k_Unable_to_convert_item_to_object[] = "Unable to convert item to object";
-static const char __pyx_k_X_and_Y_should_have_the_same_num[] = "X and Y should have the same number of rows";
-static const char __pyx_k_adaXT_decision_tree_DecisionTree[] = "adaXT.decision_tree.DecisionTree";
+static const char __pyx_k_forest_predict_locals___most_fre[] = "forest_predict.<locals>.__most_frequent_element";
 static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension ";
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
-static const char __pyx_k_predict_proba_can_only_be_called[] = "predict_proba can only be called on a Classification tree";
-static const char __pyx_k_sample_weight_should_have_as_man[] = "sample_weight should have as many elements as X and Y";
-static const char __pyx_k_sample_weight_should_have_dimens[] = "sample_weight should have dimension (n_samples,)";
-static const char __pyx_k_src_adaXT_decision_tree_Decision[] = "src/adaXT/decision_tree/DecisionTree.pyx";
 static const char __pyx_k_unable_to_allocate_shape_and_str[] = "unable to allocate shape and strides.";
-static const char __pyx_k_The_tree_has_not_been_fitted_bef_2[] = "The tree has not been fitted before trying to call predict_proba";
+static const char __pyx_k_PredictClassification_forest_pre_2[] = "PredictClassification.forest_predict_proba";
 /* #### Code section: decls ### */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_attr); /* proto */
@@ -3222,25 +3312,37 @@
 static PyObject *__pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_22copy_fortran(struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryview___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryview_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryview_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static void __pyx_memoryviewslice___pyx_pf_15View_dot_MemoryView_16_memoryviewslice___dealloc__(struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryviewslice___reduce_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf___pyx_memoryviewslice_2__setstate_cython__(CYTHON_UNUSED struct __pyx_memoryviewslice_obj *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView___pyx_unpickle_Enum(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree___defaults__(CYTHON_UNUSED PyObject *__pyx_self); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_tree_type, PyObject *__pyx_v_criteria, PyObject *__pyx_v_max_depth, double __pyx_v_impurity_tol, PyObject *__pyx_v_min_samples_split, PyObject *__pyx_v_min_samples_leaf, double __pyx_v_min_improvement, PyObject *__pyx_v_splitter); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_2__check_input(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, PyObject *__pyx_v_X, PyObject *__pyx_v_Y); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_4__check_sample_weight(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, PyObject *__pyx_v_sample_weight, PyObject *__pyx_v_n_samples); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_6__check_dimensions(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, __Pyx_memviewslice __pyx_v_X); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_8fit(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_X, PyObject *__pyx_v_Y, PyObject *__pyx_v_feature_indices, PyObject *__pyx_v_sample_indices, PyObject *__pyx_v_sample_weight); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_10predict(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_X); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_12predict_proba(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_X); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_14__find_max_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, PyObject *__pyx_v_lst); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_16get_leaf_matrix(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_scale); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_18predict_leaf_matrix(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_X, PyObject *__pyx_v_scale); /* proto */
+static int __pyx_pf_5adaXT_7predict_7predict_7Predict___cinit__(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, __Pyx_memviewslice __pyx_v_X, __Pyx_memviewslice __pyx_v_Y, PyObject *__pyx_v_root); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_2__reduce__(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_4predict(CYTHON_UNUSED struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_6predict_proba(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, PyObject *__pyx_v_X); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_8predict_leaf_matrix(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, PyObject *__pyx_v_X, int __pyx_v_scale); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_10forest_predict(CYTHON_UNUSED PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_12forest_predict_proba(CYTHON_UNUSED PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static int __pyx_pf_5adaXT_7predict_7predict_21PredictClassification___cinit__(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_X, __Pyx_memviewslice __pyx_v_Y, CYTHON_UNUSED PyObject *__pyx_v_root, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_2predict(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_4predict_proba(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, PyObject *__pyx_v_X); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_14forest_predict___most_frequent_element(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_6forest_predict(PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_8forest_predict_proba(PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_17PredictRegression_predict(struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression *__pyx_v_self, PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_17PredictRegression_2forest_predict(PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_23PredictLinearRegression_predict(struct __pyx_obj_5adaXT_7predict_7predict_PredictLinearRegression *__pyx_v_self, PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_15PredictQuantile_predict(struct __pyx_obj_5adaXT_7predict_7predict_PredictQuantile *__pyx_v_self, PyObject *__pyx_v_X, PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_15PredictQuantile_2forest_predict(PyObject *__pyx_v_predictions, PyObject *__pyx_v_kwargs); /* proto */
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_Predict(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_PredictClassification(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_PredictRegression(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_PredictLinearRegression(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_PredictQuantile(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
 static __Pyx_CachedCFunction __pyx_umethod_PyDict_Type_keys = {0, 0, 0, 0, 0};
 /* #### Code section: late_includes ### */
 /* #### Code section: module_state ### */
@@ -3266,328 +3368,291 @@
   #ifdef __Pyx_Coroutine_USED
   PyTypeObject *__pyx_CoroutineAwaitType;
   #endif
   #ifdef __Pyx_Coroutine_USED
   PyTypeObject *__pyx_CoroutineType;
   #endif
   #if CYTHON_USE_MODULE_STATE
+  PyObject *__pyx_type_5adaXT_7predict_7predict_Predict;
+  PyObject *__pyx_type_5adaXT_7predict_7predict_PredictClassification;
+  PyObject *__pyx_type_5adaXT_7predict_7predict_PredictRegression;
+  PyObject *__pyx_type_5adaXT_7predict_7predict_PredictLinearRegression;
+  PyObject *__pyx_type_5adaXT_7predict_7predict_PredictQuantile;
   PyObject *__pyx_type___pyx_array;
   PyObject *__pyx_type___pyx_MemviewEnum;
   PyObject *__pyx_type___pyx_memoryview;
   PyObject *__pyx_type___pyx_memoryviewslice;
   #endif
+  PyTypeObject *__pyx_ptype_5adaXT_7predict_7predict_Predict;
+  PyTypeObject *__pyx_ptype_5adaXT_7predict_7predict_PredictClassification;
+  PyTypeObject *__pyx_ptype_5adaXT_7predict_7predict_PredictRegression;
+  PyTypeObject *__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression;
+  PyTypeObject *__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile;
   PyTypeObject *__pyx_array_type;
   PyTypeObject *__pyx_MemviewEnum_type;
   PyTypeObject *__pyx_memoryview_type;
   PyTypeObject *__pyx_memoryviewslice_type;
   PyObject *__pyx_kp_u_;
   PyObject *__pyx_n_s_ASCII;
   PyObject *__pyx_kp_s_All_dimensions_preceding_dimensi;
   PyObject *__pyx_n_s_AssertionError;
-  PyObject *__pyx_n_s_AttributeError;
   PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
   PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
   PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
   PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
   PyObject *__pyx_kp_u_Cannot_index_with_type;
   PyObject *__pyx_kp_s_Cannot_transpose_memoryview_with;
-  PyObject *__pyx_n_s_Classification;
-  PyObject *__pyx_n_s_Criteria;
   PyObject *__pyx_n_s_DOUBLE;
   PyObject *__pyx_n_s_DecisionNode;
-  PyObject *__pyx_n_s_DecisionTree;
-  PyObject *__pyx_n_s_DecisionTree___check_dimensions;
-  PyObject *__pyx_n_s_DecisionTree___check_input;
-  PyObject *__pyx_n_s_DecisionTree___check_sample_weig;
-  PyObject *__pyx_n_s_DecisionTree___find_max_index;
-  PyObject *__pyx_n_s_DecisionTree___init;
-  PyObject *__pyx_n_s_DecisionTree__check_dimensions;
-  PyObject *__pyx_n_s_DecisionTree__check_input;
-  PyObject *__pyx_n_s_DecisionTree__check_sample_weig;
-  PyObject *__pyx_n_s_DecisionTree__find_max_index;
-  PyObject *__pyx_n_s_DecisionTree_fit;
-  PyObject *__pyx_n_s_DecisionTree_get_leaf_matrix;
-  PyObject *__pyx_n_s_DecisionTree_predict;
-  PyObject *__pyx_n_s_DecisionTree_predict_leaf_matrix;
-  PyObject *__pyx_n_s_DecisionTree_predict_proba;
-  PyObject *__pyx_n_s_DepthTreeBuilder;
   PyObject *__pyx_kp_s_Dimension_d_is_not_direct;
   PyObject *__pyx_kp_u_Dimension_should_be;
   PyObject *__pyx_n_s_Ellipsis;
   PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
-  PyObject *__pyx_kp_u_Expected_Classification_or_Regre;
+  PyObject *__pyx_kp_u_Function_predict_is_not_implemen;
+  PyObject *__pyx_kp_u_Function_predict_proba_is_not_im;
   PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
   PyObject *__pyx_n_s_IndexError;
   PyObject *__pyx_kp_s_Index_out_of_bounds_axis_d;
   PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
   PyObject *__pyx_kp_u_Invalid_mode_expected_c_or_fortr;
   PyObject *__pyx_kp_u_Invalid_shape_in_axis;
   PyObject *__pyx_n_s_MemoryError;
   PyObject *__pyx_kp_s_MemoryView_of_r_at_0x_x;
   PyObject *__pyx_kp_s_MemoryView_of_r_object;
-  PyObject *__pyx_n_s_Nodes;
-  PyObject *__pyx_n_s_None;
+  PyObject *__pyx_n_s_NotImplementedError;
   PyObject *__pyx_kp_u_Number_of_features_should_be;
   PyObject *__pyx_n_b_O;
   PyObject *__pyx_kp_u_Out_of_bounds_on_buffer_access_a;
   PyObject *__pyx_n_s_PickleError;
-  PyObject *__pyx_n_s_Regression;
+  PyObject *__pyx_n_s_Predict;
+  PyObject *__pyx_n_s_PredictClassification;
+  PyObject *__pyx_n_s_PredictClassification__most_fre;
+  PyObject *__pyx_n_s_PredictClassification_forest_pre;
+  PyObject *__pyx_n_s_PredictClassification_forest_pre_2;
+  PyObject *__pyx_n_s_PredictClassification_predict;
+  PyObject *__pyx_n_s_PredictClassification_predict_pr;
+  PyObject *__pyx_n_s_PredictLinearRegression;
+  PyObject *__pyx_n_s_PredictLinearRegression_predict;
+  PyObject *__pyx_n_s_PredictQuantile;
+  PyObject *__pyx_n_s_PredictQuantile_forest_predict;
+  PyObject *__pyx_n_s_PredictQuantile_predict;
+  PyObject *__pyx_n_s_PredictRegression;
+  PyObject *__pyx_n_s_PredictRegression_forest_predict;
+  PyObject *__pyx_n_s_PredictRegression_predict;
+  PyObject *__pyx_n_s_Predict___reduce;
+  PyObject *__pyx_n_s_Predict_forest_predict;
+  PyObject *__pyx_n_s_Predict_forest_predict_proba;
+  PyObject *__pyx_n_s_Predict_predict;
+  PyObject *__pyx_n_s_Predict_predict_leaf_matrix;
+  PyObject *__pyx_n_s_Predict_predict_proba;
   PyObject *__pyx_n_s_Sequence;
-  PyObject *__pyx_n_s_Splitter;
-  PyObject *__pyx_kp_s_Splitter_None;
   PyObject *__pyx_kp_s_Step_may_not_be_zero_axis_d;
-  PyObject *__pyx_kp_s_The_tree_has_not_been_fitted_bef;
-  PyObject *__pyx_kp_s_The_tree_has_not_been_fitted_bef_2;
-  PyObject *__pyx_kp_s_The_tree_has_not_been_trained_be;
+  PyObject *__pyx_kp_u_The_forest_predict_function_is_n;
   PyObject *__pyx_n_s_TypeError;
   PyObject *__pyx_kp_s_Unable_to_convert_item_to_object;
   PyObject *__pyx_n_s_ValueError;
   PyObject *__pyx_n_s_View_MemoryView;
   PyObject *__pyx_n_s_X;
-  PyObject *__pyx_kp_s_X_and_Y_should_have_the_same_num;
   PyObject *__pyx_n_s_Y;
-  PyObject *__pyx_kp_s_Y_should_have_dimensions_n_1_or;
   PyObject *__pyx_kp_u__2;
   PyObject *__pyx_n_s__3;
-  PyObject *__pyx_n_s__51;
+  PyObject *__pyx_n_s__52;
   PyObject *__pyx_kp_u__6;
   PyObject *__pyx_kp_u__7;
   PyObject *__pyx_n_s_abc;
-  PyObject *__pyx_n_s_adaXT_decision_tree_DecisionTree;
+  PyObject *__pyx_n_s_adaXT_predict_predict;
   PyObject *__pyx_n_s_allocate_buffer;
   PyObject *__pyx_kp_u_and;
-  PyObject *__pyx_n_s_arange;
-  PyObject *__pyx_n_s_array;
-  PyObject *__pyx_n_s_asarray;
+  PyObject *__pyx_n_s_apply_along_axis;
+  PyObject *__pyx_n_s_argmax;
+  PyObject *__pyx_n_s_arr;
   PyObject *__pyx_n_s_ascontiguousarray;
   PyObject *__pyx_n_s_asyncio_coroutines;
   PyObject *__pyx_n_s_axis;
   PyObject *__pyx_n_s_base;
-  PyObject *__pyx_n_s_bool;
-  PyObject *__pyx_n_s_build_tree;
-  PyObject *__pyx_n_s_builder;
   PyObject *__pyx_n_s_c;
   PyObject *__pyx_n_u_c;
-  PyObject *__pyx_n_s_check_dimensions;
-  PyObject *__pyx_n_s_check_input;
-  PyObject *__pyx_n_s_check_sample_weight;
   PyObject *__pyx_n_s_class;
   PyObject *__pyx_n_s_class_getitem;
-  PyObject *__pyx_n_s_classes;
   PyObject *__pyx_n_s_cline_in_traceback;
-  PyObject *__pyx_n_s_col;
   PyObject *__pyx_n_s_collections;
   PyObject *__pyx_kp_s_collections_abc;
   PyObject *__pyx_kp_s_contiguous_and_direct;
   PyObject *__pyx_kp_s_contiguous_and_indirect;
   PyObject *__pyx_n_s_count;
-  PyObject *__pyx_n_s_criteria;
-  PyObject *__pyx_n_s_cur_max;
+  PyObject *__pyx_n_s_counts;
   PyObject *__pyx_n_s_cur_node;
   PyObject *__pyx_n_s_cur_split_idx;
   PyObject *__pyx_n_s_cur_threshold;
+  PyObject *__pyx_n_s_decision_tree_nodes;
   PyObject *__pyx_n_s_dict;
   PyObject *__pyx_kp_u_disable;
-  PyObject *__pyx_n_s_doc;
-  PyObject *__pyx_n_s_double;
   PyObject *__pyx_n_s_dtype;
   PyObject *__pyx_n_s_dtype_is_object;
   PyObject *__pyx_n_s_empty;
   PyObject *__pyx_kp_u_enable;
   PyObject *__pyx_n_s_encode;
   PyObject *__pyx_n_s_enumerate;
-  PyObject *__pyx_n_s_eps;
   PyObject *__pyx_n_s_error;
   PyObject *__pyx_n_s_expand_dims;
-  PyObject *__pyx_n_s_feature_indices;
-  PyObject *__pyx_n_s_find_max_index;
-  PyObject *__pyx_n_s_finfo;
-  PyObject *__pyx_n_s_fit;
   PyObject *__pyx_n_s_flags;
-  PyObject *__pyx_n_s_float;
   PyObject *__pyx_n_s_float64;
+  PyObject *__pyx_n_s_forest_predict;
+  PyObject *__pyx_n_s_forest_predict_locals___most_fre;
+  PyObject *__pyx_n_s_forest_predict_proba;
   PyObject *__pyx_n_s_format;
   PyObject *__pyx_n_s_fortran;
   PyObject *__pyx_n_u_fortran;
   PyObject *__pyx_kp_u_gc;
-  PyObject *__pyx_n_s_get_leaf_matrix;
   PyObject *__pyx_n_s_getstate;
   PyObject *__pyx_kp_u_got;
   PyObject *__pyx_kp_u_got_2;
   PyObject *__pyx_kp_u_got_differing_extents_in_dimensi;
-  PyObject *__pyx_n_s_ht;
   PyObject *__pyx_n_s_i;
   PyObject *__pyx_n_s_id;
   PyObject *__pyx_n_s_idx;
   PyObject *__pyx_n_s_import;
-  PyObject *__pyx_n_s_impurity_tol;
   PyObject *__pyx_n_s_index;
   PyObject *__pyx_n_s_indices;
-  PyObject *__pyx_n_s_init;
-  PyObject *__pyx_n_s_init_subclass;
   PyObject *__pyx_n_s_initializing;
-  PyObject *__pyx_n_s_int;
-  PyObject *__pyx_n_s_int32;
   PyObject *__pyx_n_s_is_coroutine;
   PyObject *__pyx_kp_u_isenabled;
   PyObject *__pyx_n_s_itemsize;
   PyObject *__pyx_kp_s_itemsize_0_for_cython_array;
   PyObject *__pyx_n_s_ix;
-  PyObject *__pyx_n_s_key;
   PyObject *__pyx_n_s_keys;
-  PyObject *__pyx_n_s_leaf_nodes;
+  PyObject *__pyx_n_s_kwargs;
   PyObject *__pyx_n_s_left_child;
-  PyObject *__pyx_n_s_lst;
   PyObject *__pyx_n_s_main;
-  PyObject *__pyx_n_s_matrix;
-  PyObject *__pyx_n_s_max_depth;
-  PyObject *__pyx_n_s_maxsize;
+  PyObject *__pyx_n_s_mean;
   PyObject *__pyx_n_s_memview;
-  PyObject *__pyx_n_s_metaclass;
-  PyObject *__pyx_n_s_min_improvement;
-  PyObject *__pyx_n_s_min_samples_leaf;
-  PyObject *__pyx_n_s_min_samples_split;
   PyObject *__pyx_n_s_mode;
-  PyObject *__pyx_n_s_module;
-  PyObject *__pyx_n_s_n_classes;
-  PyObject *__pyx_n_s_n_features;
-  PyObject *__pyx_n_s_n_node;
-  PyObject *__pyx_n_s_n_nodes;
+  PyObject *__pyx_n_s_most_frequent_element;
   PyObject *__pyx_n_s_n_obs;
-  PyObject *__pyx_n_s_n_samples;
   PyObject *__pyx_n_s_name;
   PyObject *__pyx_n_s_name_2;
   PyObject *__pyx_n_s_ndim;
   PyObject *__pyx_n_s_new;
   PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
-  PyObject *__pyx_n_s_node;
   PyObject *__pyx_n_s_np;
   PyObject *__pyx_kp_s_np_ndarray;
-  PyObject *__pyx_kp_s_np_ndarray_None;
   PyObject *__pyx_n_s_numpy;
   PyObject *__pyx_n_s_obj;
-  PyObject *__pyx_n_s_object;
-  PyObject *__pyx_n_s_ones;
   PyObject *__pyx_n_s_pack;
   PyObject *__pyx_n_s_pickle;
   PyObject *__pyx_n_s_predict;
   PyObject *__pyx_n_s_predict_leaf_matrix;
   PyObject *__pyx_n_s_predict_proba;
-  PyObject *__pyx_kp_s_predict_proba_can_only_be_called;
-  PyObject *__pyx_n_s_prepare;
+  PyObject *__pyx_n_s_predictions;
   PyObject *__pyx_n_s_pyx_PickleError;
   PyObject *__pyx_n_s_pyx_checksum;
   PyObject *__pyx_n_s_pyx_result;
   PyObject *__pyx_n_s_pyx_state;
   PyObject *__pyx_n_s_pyx_type;
   PyObject *__pyx_n_s_pyx_unpickle_Enum;
   PyObject *__pyx_n_s_pyx_vtable;
-  PyObject *__pyx_n_s_qualname;
+  PyObject *__pyx_n_s_quantile;
+  PyObject *__pyx_n_u_quantile;
   PyObject *__pyx_n_s_range;
   PyObject *__pyx_n_s_reduce;
   PyObject *__pyx_n_s_reduce_cython;
   PyObject *__pyx_n_s_reduce_ex;
   PyObject *__pyx_n_s_register;
-  PyObject *__pyx_n_s_reshape;
-  PyObject *__pyx_n_s_ret_val;
-  PyObject *__pyx_n_s_return;
+  PyObject *__pyx_n_s_return_counts;
   PyObject *__pyx_n_s_right_child;
   PyObject *__pyx_n_s_root;
-  PyObject *__pyx_n_s_row;
-  PyObject *__pyx_n_s_sample_indices;
-  PyObject *__pyx_n_s_sample_weight;
-  PyObject *__pyx_kp_s_sample_weight_should_have_as_man;
-  PyObject *__pyx_kp_s_sample_weight_should_have_dimens;
+  PyObject *__pyx_n_s_save_indices;
+  PyObject *__pyx_n_u_save_indices;
   PyObject *__pyx_n_s_scale;
   PyObject *__pyx_n_s_self;
-  PyObject *__pyx_n_s_set_name;
   PyObject *__pyx_n_s_setstate;
   PyObject *__pyx_n_s_setstate_cython;
   PyObject *__pyx_n_s_shape;
   PyObject *__pyx_n_s_size;
   PyObject *__pyx_n_s_spec;
   PyObject *__pyx_n_s_split_idx;
-  PyObject *__pyx_n_s_splitter;
-  PyObject *__pyx_kp_s_src_adaXT_decision_tree_Decision;
+  PyObject *__pyx_kp_s_src_adaXT_predict_predict_pyx;
+  PyObject *__pyx_n_s_stack;
+  PyObject *__pyx_n_s_stacked_tree_predictions;
   PyObject *__pyx_n_s_start;
+  PyObject *__pyx_n_s_staticmethod;
   PyObject *__pyx_n_s_step;
   PyObject *__pyx_n_s_stop;
-  PyObject *__pyx_n_s_str;
   PyObject *__pyx_kp_s_strided_and_direct;
   PyObject *__pyx_kp_s_strided_and_direct_or_indirect;
   PyObject *__pyx_kp_s_strided_and_indirect;
   PyObject *__pyx_kp_s_stringsource;
   PyObject *__pyx_n_s_struct;
-  PyObject *__pyx_n_s_super;
   PyObject *__pyx_n_s_sys;
   PyObject *__pyx_n_s_test;
+  PyObject *__pyx_n_s_theta0;
+  PyObject *__pyx_n_s_theta1;
   PyObject *__pyx_n_s_threshold;
-  PyObject *__pyx_n_s_tree_type;
-  PyObject *__pyx_n_s_tree_types;
   PyObject *__pyx_kp_s_unable_to_allocate_array_data;
   PyObject *__pyx_kp_s_unable_to_allocate_shape_and_str;
+  PyObject *__pyx_n_s_unique;
   PyObject *__pyx_n_s_unpack;
   PyObject *__pyx_n_s_update;
-  PyObject *__pyx_n_s_val;
   PyObject *__pyx_n_s_value;
+  PyObject *__pyx_n_s_values;
   PyObject *__pyx_n_s_version_info;
   PyObject *__pyx_n_s_zeros;
   PyObject *__pyx_int_0;
   PyObject *__pyx_int_1;
-  PyObject *__pyx_int_2;
   PyObject *__pyx_int_3;
   PyObject *__pyx_int_112105877;
   PyObject *__pyx_int_136983863;
   PyObject *__pyx_int_184977713;
   PyObject *__pyx_int_neg_1;
   PyObject *__pyx_slice__5;
   PyObject *__pyx_tuple__4;
   PyObject *__pyx_tuple__8;
   PyObject *__pyx_tuple__9;
   PyObject *__pyx_tuple__10;
   PyObject *__pyx_tuple__11;
   PyObject *__pyx_tuple__12;
-  PyObject *__pyx_tuple__13;
   PyObject *__pyx_tuple__14;
   PyObject *__pyx_tuple__15;
   PyObject *__pyx_tuple__16;
   PyObject *__pyx_tuple__17;
   PyObject *__pyx_tuple__18;
   PyObject *__pyx_tuple__19;
   PyObject *__pyx_tuple__20;
   PyObject *__pyx_tuple__21;
   PyObject *__pyx_tuple__22;
   PyObject *__pyx_tuple__23;
-  PyObject *__pyx_tuple__24;
   PyObject *__pyx_tuple__25;
-  PyObject *__pyx_tuple__26;
-  PyObject *__pyx_tuple__28;
+  PyObject *__pyx_tuple__27;
   PyObject *__pyx_tuple__29;
   PyObject *__pyx_tuple__31;
   PyObject *__pyx_tuple__33;
-  PyObject *__pyx_tuple__35;
+  PyObject *__pyx_tuple__34;
   PyObject *__pyx_tuple__37;
-  PyObject *__pyx_tuple__39;
   PyObject *__pyx_tuple__40;
   PyObject *__pyx_tuple__42;
   PyObject *__pyx_tuple__44;
-  PyObject *__pyx_tuple__46;
   PyObject *__pyx_tuple__48;
-  PyObject *__pyx_tuple__49;
-  PyObject *__pyx_codeobj__27;
+  PyObject *__pyx_tuple__50;
+  PyObject *__pyx_codeobj__13;
+  PyObject *__pyx_codeobj__24;
+  PyObject *__pyx_codeobj__26;
+  PyObject *__pyx_codeobj__28;
   PyObject *__pyx_codeobj__30;
   PyObject *__pyx_codeobj__32;
-  PyObject *__pyx_codeobj__34;
+  PyObject *__pyx_codeobj__35;
   PyObject *__pyx_codeobj__36;
   PyObject *__pyx_codeobj__38;
+  PyObject *__pyx_codeobj__39;
   PyObject *__pyx_codeobj__41;
   PyObject *__pyx_codeobj__43;
   PyObject *__pyx_codeobj__45;
+  PyObject *__pyx_codeobj__46;
   PyObject *__pyx_codeobj__47;
-  PyObject *__pyx_codeobj__50;
+  PyObject *__pyx_codeobj__49;
+  PyObject *__pyx_codeobj__51;
 } __pyx_mstate;
 
 #if CYTHON_USE_MODULE_STATE
 #ifdef __cplusplus
 namespace {
   extern struct PyModuleDef __pyx_moduledef;
 } /* anonymous namespace */
@@ -3622,327 +3687,290 @@
   Py_CLEAR(clear_module_state->__pyx_empty_unicode);
   #ifdef __Pyx_CyFunction_USED
   Py_CLEAR(clear_module_state->__pyx_CyFunctionType);
   #endif
   #ifdef __Pyx_FusedFunction_USED
   Py_CLEAR(clear_module_state->__pyx_FusedFunctionType);
   #endif
+  Py_CLEAR(clear_module_state->__pyx_ptype_5adaXT_7predict_7predict_Predict);
+  Py_CLEAR(clear_module_state->__pyx_type_5adaXT_7predict_7predict_Predict);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5adaXT_7predict_7predict_PredictClassification);
+  Py_CLEAR(clear_module_state->__pyx_type_5adaXT_7predict_7predict_PredictClassification);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5adaXT_7predict_7predict_PredictRegression);
+  Py_CLEAR(clear_module_state->__pyx_type_5adaXT_7predict_7predict_PredictRegression);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression);
+  Py_CLEAR(clear_module_state->__pyx_type_5adaXT_7predict_7predict_PredictLinearRegression);
+  Py_CLEAR(clear_module_state->__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile);
+  Py_CLEAR(clear_module_state->__pyx_type_5adaXT_7predict_7predict_PredictQuantile);
   Py_CLEAR(clear_module_state->__pyx_array_type);
   Py_CLEAR(clear_module_state->__pyx_type___pyx_array);
   Py_CLEAR(clear_module_state->__pyx_MemviewEnum_type);
   Py_CLEAR(clear_module_state->__pyx_type___pyx_MemviewEnum);
   Py_CLEAR(clear_module_state->__pyx_memoryview_type);
   Py_CLEAR(clear_module_state->__pyx_type___pyx_memoryview);
   Py_CLEAR(clear_module_state->__pyx_memoryviewslice_type);
   Py_CLEAR(clear_module_state->__pyx_type___pyx_memoryviewslice);
   Py_CLEAR(clear_module_state->__pyx_kp_u_);
   Py_CLEAR(clear_module_state->__pyx_n_s_ASCII);
   Py_CLEAR(clear_module_state->__pyx_kp_s_All_dimensions_preceding_dimensi);
   Py_CLEAR(clear_module_state->__pyx_n_s_AssertionError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_AttributeError);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Buffer_view_does_not_expose_stri);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Can_only_create_a_buffer_that_is);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_assign_to_read_only_memor);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_create_writable_memory_vi);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Cannot_index_with_type);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Cannot_transpose_memoryview_with);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Classification);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Criteria);
   Py_CLEAR(clear_module_state->__pyx_n_s_DOUBLE);
   Py_CLEAR(clear_module_state->__pyx_n_s_DecisionNode);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree___check_dimensions);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree___check_input);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree___check_sample_weig);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree___find_max_index);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree___init);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree__check_dimensions);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree__check_input);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree__check_sample_weig);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree__find_max_index);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree_fit);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree_get_leaf_matrix);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree_predict);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree_predict_leaf_matrix);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DecisionTree_predict_proba);
-  Py_CLEAR(clear_module_state->__pyx_n_s_DepthTreeBuilder);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Dimension_d_is_not_direct);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Dimension_should_be);
   Py_CLEAR(clear_module_state->__pyx_n_s_Ellipsis);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Empty_shape_tuple_for_cython_arr);
-  Py_CLEAR(clear_module_state->__pyx_kp_u_Expected_Classification_or_Regre);
+  Py_CLEAR(clear_module_state->__pyx_kp_u_Function_predict_is_not_implemen);
+  Py_CLEAR(clear_module_state->__pyx_kp_u_Function_predict_proba_is_not_im);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
   Py_CLEAR(clear_module_state->__pyx_n_s_IndexError);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Invalid_shape_in_axis);
   Py_CLEAR(clear_module_state->__pyx_n_s_MemoryError);
   Py_CLEAR(clear_module_state->__pyx_kp_s_MemoryView_of_r_at_0x_x);
   Py_CLEAR(clear_module_state->__pyx_kp_s_MemoryView_of_r_object);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Nodes);
-  Py_CLEAR(clear_module_state->__pyx_n_s_None);
+  Py_CLEAR(clear_module_state->__pyx_n_s_NotImplementedError);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Number_of_features_should_be);
   Py_CLEAR(clear_module_state->__pyx_n_b_O);
   Py_CLEAR(clear_module_state->__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
   Py_CLEAR(clear_module_state->__pyx_n_s_PickleError);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Regression);
+  Py_CLEAR(clear_module_state->__pyx_n_s_Predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictClassification);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictClassification__most_fre);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictClassification_forest_pre);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictClassification_forest_pre_2);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictClassification_predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictClassification_predict_pr);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictLinearRegression);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictLinearRegression_predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictQuantile);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictQuantile_forest_predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictQuantile_predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictRegression);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictRegression_forest_predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_PredictRegression_predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_Predict___reduce);
+  Py_CLEAR(clear_module_state->__pyx_n_s_Predict_forest_predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_Predict_forest_predict_proba);
+  Py_CLEAR(clear_module_state->__pyx_n_s_Predict_predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_Predict_predict_leaf_matrix);
+  Py_CLEAR(clear_module_state->__pyx_n_s_Predict_predict_proba);
   Py_CLEAR(clear_module_state->__pyx_n_s_Sequence);
-  Py_CLEAR(clear_module_state->__pyx_n_s_Splitter);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Splitter_None);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Step_may_not_be_zero_axis_d);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_The_tree_has_not_been_fitted_bef);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_The_tree_has_not_been_fitted_bef_2);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_The_tree_has_not_been_trained_be);
+  Py_CLEAR(clear_module_state->__pyx_kp_u_The_forest_predict_function_is_n);
   Py_CLEAR(clear_module_state->__pyx_n_s_TypeError);
   Py_CLEAR(clear_module_state->__pyx_kp_s_Unable_to_convert_item_to_object);
   Py_CLEAR(clear_module_state->__pyx_n_s_ValueError);
   Py_CLEAR(clear_module_state->__pyx_n_s_View_MemoryView);
   Py_CLEAR(clear_module_state->__pyx_n_s_X);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_X_and_Y_should_have_the_same_num);
   Py_CLEAR(clear_module_state->__pyx_n_s_Y);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_Y_should_have_dimensions_n_1_or);
   Py_CLEAR(clear_module_state->__pyx_kp_u__2);
   Py_CLEAR(clear_module_state->__pyx_n_s__3);
-  Py_CLEAR(clear_module_state->__pyx_n_s__51);
+  Py_CLEAR(clear_module_state->__pyx_n_s__52);
   Py_CLEAR(clear_module_state->__pyx_kp_u__6);
   Py_CLEAR(clear_module_state->__pyx_kp_u__7);
   Py_CLEAR(clear_module_state->__pyx_n_s_abc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_adaXT_decision_tree_DecisionTree);
+  Py_CLEAR(clear_module_state->__pyx_n_s_adaXT_predict_predict);
   Py_CLEAR(clear_module_state->__pyx_n_s_allocate_buffer);
   Py_CLEAR(clear_module_state->__pyx_kp_u_and);
-  Py_CLEAR(clear_module_state->__pyx_n_s_arange);
-  Py_CLEAR(clear_module_state->__pyx_n_s_array);
-  Py_CLEAR(clear_module_state->__pyx_n_s_asarray);
+  Py_CLEAR(clear_module_state->__pyx_n_s_apply_along_axis);
+  Py_CLEAR(clear_module_state->__pyx_n_s_argmax);
+  Py_CLEAR(clear_module_state->__pyx_n_s_arr);
   Py_CLEAR(clear_module_state->__pyx_n_s_ascontiguousarray);
   Py_CLEAR(clear_module_state->__pyx_n_s_asyncio_coroutines);
   Py_CLEAR(clear_module_state->__pyx_n_s_axis);
   Py_CLEAR(clear_module_state->__pyx_n_s_base);
-  Py_CLEAR(clear_module_state->__pyx_n_s_bool);
-  Py_CLEAR(clear_module_state->__pyx_n_s_build_tree);
-  Py_CLEAR(clear_module_state->__pyx_n_s_builder);
   Py_CLEAR(clear_module_state->__pyx_n_s_c);
   Py_CLEAR(clear_module_state->__pyx_n_u_c);
-  Py_CLEAR(clear_module_state->__pyx_n_s_check_dimensions);
-  Py_CLEAR(clear_module_state->__pyx_n_s_check_input);
-  Py_CLEAR(clear_module_state->__pyx_n_s_check_sample_weight);
   Py_CLEAR(clear_module_state->__pyx_n_s_class);
   Py_CLEAR(clear_module_state->__pyx_n_s_class_getitem);
-  Py_CLEAR(clear_module_state->__pyx_n_s_classes);
   Py_CLEAR(clear_module_state->__pyx_n_s_cline_in_traceback);
-  Py_CLEAR(clear_module_state->__pyx_n_s_col);
   Py_CLEAR(clear_module_state->__pyx_n_s_collections);
   Py_CLEAR(clear_module_state->__pyx_kp_s_collections_abc);
   Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_direct);
   Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_indirect);
   Py_CLEAR(clear_module_state->__pyx_n_s_count);
-  Py_CLEAR(clear_module_state->__pyx_n_s_criteria);
-  Py_CLEAR(clear_module_state->__pyx_n_s_cur_max);
+  Py_CLEAR(clear_module_state->__pyx_n_s_counts);
   Py_CLEAR(clear_module_state->__pyx_n_s_cur_node);
   Py_CLEAR(clear_module_state->__pyx_n_s_cur_split_idx);
   Py_CLEAR(clear_module_state->__pyx_n_s_cur_threshold);
+  Py_CLEAR(clear_module_state->__pyx_n_s_decision_tree_nodes);
   Py_CLEAR(clear_module_state->__pyx_n_s_dict);
   Py_CLEAR(clear_module_state->__pyx_kp_u_disable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_doc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_double);
   Py_CLEAR(clear_module_state->__pyx_n_s_dtype);
   Py_CLEAR(clear_module_state->__pyx_n_s_dtype_is_object);
   Py_CLEAR(clear_module_state->__pyx_n_s_empty);
   Py_CLEAR(clear_module_state->__pyx_kp_u_enable);
   Py_CLEAR(clear_module_state->__pyx_n_s_encode);
   Py_CLEAR(clear_module_state->__pyx_n_s_enumerate);
-  Py_CLEAR(clear_module_state->__pyx_n_s_eps);
   Py_CLEAR(clear_module_state->__pyx_n_s_error);
   Py_CLEAR(clear_module_state->__pyx_n_s_expand_dims);
-  Py_CLEAR(clear_module_state->__pyx_n_s_feature_indices);
-  Py_CLEAR(clear_module_state->__pyx_n_s_find_max_index);
-  Py_CLEAR(clear_module_state->__pyx_n_s_finfo);
-  Py_CLEAR(clear_module_state->__pyx_n_s_fit);
   Py_CLEAR(clear_module_state->__pyx_n_s_flags);
-  Py_CLEAR(clear_module_state->__pyx_n_s_float);
   Py_CLEAR(clear_module_state->__pyx_n_s_float64);
+  Py_CLEAR(clear_module_state->__pyx_n_s_forest_predict);
+  Py_CLEAR(clear_module_state->__pyx_n_s_forest_predict_locals___most_fre);
+  Py_CLEAR(clear_module_state->__pyx_n_s_forest_predict_proba);
   Py_CLEAR(clear_module_state->__pyx_n_s_format);
   Py_CLEAR(clear_module_state->__pyx_n_s_fortran);
   Py_CLEAR(clear_module_state->__pyx_n_u_fortran);
   Py_CLEAR(clear_module_state->__pyx_kp_u_gc);
-  Py_CLEAR(clear_module_state->__pyx_n_s_get_leaf_matrix);
   Py_CLEAR(clear_module_state->__pyx_n_s_getstate);
   Py_CLEAR(clear_module_state->__pyx_kp_u_got);
   Py_CLEAR(clear_module_state->__pyx_kp_u_got_2);
   Py_CLEAR(clear_module_state->__pyx_kp_u_got_differing_extents_in_dimensi);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ht);
   Py_CLEAR(clear_module_state->__pyx_n_s_i);
   Py_CLEAR(clear_module_state->__pyx_n_s_id);
   Py_CLEAR(clear_module_state->__pyx_n_s_idx);
   Py_CLEAR(clear_module_state->__pyx_n_s_import);
-  Py_CLEAR(clear_module_state->__pyx_n_s_impurity_tol);
   Py_CLEAR(clear_module_state->__pyx_n_s_index);
   Py_CLEAR(clear_module_state->__pyx_n_s_indices);
-  Py_CLEAR(clear_module_state->__pyx_n_s_init);
-  Py_CLEAR(clear_module_state->__pyx_n_s_init_subclass);
   Py_CLEAR(clear_module_state->__pyx_n_s_initializing);
-  Py_CLEAR(clear_module_state->__pyx_n_s_int);
-  Py_CLEAR(clear_module_state->__pyx_n_s_int32);
   Py_CLEAR(clear_module_state->__pyx_n_s_is_coroutine);
   Py_CLEAR(clear_module_state->__pyx_kp_u_isenabled);
   Py_CLEAR(clear_module_state->__pyx_n_s_itemsize);
   Py_CLEAR(clear_module_state->__pyx_kp_s_itemsize_0_for_cython_array);
   Py_CLEAR(clear_module_state->__pyx_n_s_ix);
-  Py_CLEAR(clear_module_state->__pyx_n_s_key);
   Py_CLEAR(clear_module_state->__pyx_n_s_keys);
-  Py_CLEAR(clear_module_state->__pyx_n_s_leaf_nodes);
+  Py_CLEAR(clear_module_state->__pyx_n_s_kwargs);
   Py_CLEAR(clear_module_state->__pyx_n_s_left_child);
-  Py_CLEAR(clear_module_state->__pyx_n_s_lst);
   Py_CLEAR(clear_module_state->__pyx_n_s_main);
-  Py_CLEAR(clear_module_state->__pyx_n_s_matrix);
-  Py_CLEAR(clear_module_state->__pyx_n_s_max_depth);
-  Py_CLEAR(clear_module_state->__pyx_n_s_maxsize);
+  Py_CLEAR(clear_module_state->__pyx_n_s_mean);
   Py_CLEAR(clear_module_state->__pyx_n_s_memview);
-  Py_CLEAR(clear_module_state->__pyx_n_s_metaclass);
-  Py_CLEAR(clear_module_state->__pyx_n_s_min_improvement);
-  Py_CLEAR(clear_module_state->__pyx_n_s_min_samples_leaf);
-  Py_CLEAR(clear_module_state->__pyx_n_s_min_samples_split);
   Py_CLEAR(clear_module_state->__pyx_n_s_mode);
-  Py_CLEAR(clear_module_state->__pyx_n_s_module);
-  Py_CLEAR(clear_module_state->__pyx_n_s_n_classes);
-  Py_CLEAR(clear_module_state->__pyx_n_s_n_features);
-  Py_CLEAR(clear_module_state->__pyx_n_s_n_node);
-  Py_CLEAR(clear_module_state->__pyx_n_s_n_nodes);
+  Py_CLEAR(clear_module_state->__pyx_n_s_most_frequent_element);
   Py_CLEAR(clear_module_state->__pyx_n_s_n_obs);
-  Py_CLEAR(clear_module_state->__pyx_n_s_n_samples);
   Py_CLEAR(clear_module_state->__pyx_n_s_name);
   Py_CLEAR(clear_module_state->__pyx_n_s_name_2);
   Py_CLEAR(clear_module_state->__pyx_n_s_ndim);
   Py_CLEAR(clear_module_state->__pyx_n_s_new);
   Py_CLEAR(clear_module_state->__pyx_kp_s_no_default___reduce___due_to_non);
-  Py_CLEAR(clear_module_state->__pyx_n_s_node);
   Py_CLEAR(clear_module_state->__pyx_n_s_np);
   Py_CLEAR(clear_module_state->__pyx_kp_s_np_ndarray);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_np_ndarray_None);
   Py_CLEAR(clear_module_state->__pyx_n_s_numpy);
   Py_CLEAR(clear_module_state->__pyx_n_s_obj);
-  Py_CLEAR(clear_module_state->__pyx_n_s_object);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ones);
   Py_CLEAR(clear_module_state->__pyx_n_s_pack);
   Py_CLEAR(clear_module_state->__pyx_n_s_pickle);
   Py_CLEAR(clear_module_state->__pyx_n_s_predict);
   Py_CLEAR(clear_module_state->__pyx_n_s_predict_leaf_matrix);
   Py_CLEAR(clear_module_state->__pyx_n_s_predict_proba);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_predict_proba_can_only_be_called);
-  Py_CLEAR(clear_module_state->__pyx_n_s_prepare);
+  Py_CLEAR(clear_module_state->__pyx_n_s_predictions);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_PickleError);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_checksum);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_result);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_state);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_type);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_unpickle_Enum);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_vtable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_qualname);
+  Py_CLEAR(clear_module_state->__pyx_n_s_quantile);
+  Py_CLEAR(clear_module_state->__pyx_n_u_quantile);
   Py_CLEAR(clear_module_state->__pyx_n_s_range);
   Py_CLEAR(clear_module_state->__pyx_n_s_reduce);
   Py_CLEAR(clear_module_state->__pyx_n_s_reduce_cython);
   Py_CLEAR(clear_module_state->__pyx_n_s_reduce_ex);
   Py_CLEAR(clear_module_state->__pyx_n_s_register);
-  Py_CLEAR(clear_module_state->__pyx_n_s_reshape);
-  Py_CLEAR(clear_module_state->__pyx_n_s_ret_val);
-  Py_CLEAR(clear_module_state->__pyx_n_s_return);
+  Py_CLEAR(clear_module_state->__pyx_n_s_return_counts);
   Py_CLEAR(clear_module_state->__pyx_n_s_right_child);
   Py_CLEAR(clear_module_state->__pyx_n_s_root);
-  Py_CLEAR(clear_module_state->__pyx_n_s_row);
-  Py_CLEAR(clear_module_state->__pyx_n_s_sample_indices);
-  Py_CLEAR(clear_module_state->__pyx_n_s_sample_weight);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_sample_weight_should_have_as_man);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_sample_weight_should_have_dimens);
+  Py_CLEAR(clear_module_state->__pyx_n_s_save_indices);
+  Py_CLEAR(clear_module_state->__pyx_n_u_save_indices);
   Py_CLEAR(clear_module_state->__pyx_n_s_scale);
   Py_CLEAR(clear_module_state->__pyx_n_s_self);
-  Py_CLEAR(clear_module_state->__pyx_n_s_set_name);
   Py_CLEAR(clear_module_state->__pyx_n_s_setstate);
   Py_CLEAR(clear_module_state->__pyx_n_s_setstate_cython);
   Py_CLEAR(clear_module_state->__pyx_n_s_shape);
   Py_CLEAR(clear_module_state->__pyx_n_s_size);
   Py_CLEAR(clear_module_state->__pyx_n_s_spec);
   Py_CLEAR(clear_module_state->__pyx_n_s_split_idx);
-  Py_CLEAR(clear_module_state->__pyx_n_s_splitter);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_src_adaXT_decision_tree_Decision);
+  Py_CLEAR(clear_module_state->__pyx_kp_s_src_adaXT_predict_predict_pyx);
+  Py_CLEAR(clear_module_state->__pyx_n_s_stack);
+  Py_CLEAR(clear_module_state->__pyx_n_s_stacked_tree_predictions);
   Py_CLEAR(clear_module_state->__pyx_n_s_start);
+  Py_CLEAR(clear_module_state->__pyx_n_s_staticmethod);
   Py_CLEAR(clear_module_state->__pyx_n_s_step);
   Py_CLEAR(clear_module_state->__pyx_n_s_stop);
-  Py_CLEAR(clear_module_state->__pyx_n_s_str);
   Py_CLEAR(clear_module_state->__pyx_kp_s_strided_and_direct);
   Py_CLEAR(clear_module_state->__pyx_kp_s_strided_and_direct_or_indirect);
   Py_CLEAR(clear_module_state->__pyx_kp_s_strided_and_indirect);
   Py_CLEAR(clear_module_state->__pyx_kp_s_stringsource);
   Py_CLEAR(clear_module_state->__pyx_n_s_struct);
-  Py_CLEAR(clear_module_state->__pyx_n_s_super);
   Py_CLEAR(clear_module_state->__pyx_n_s_sys);
   Py_CLEAR(clear_module_state->__pyx_n_s_test);
+  Py_CLEAR(clear_module_state->__pyx_n_s_theta0);
+  Py_CLEAR(clear_module_state->__pyx_n_s_theta1);
   Py_CLEAR(clear_module_state->__pyx_n_s_threshold);
-  Py_CLEAR(clear_module_state->__pyx_n_s_tree_type);
-  Py_CLEAR(clear_module_state->__pyx_n_s_tree_types);
   Py_CLEAR(clear_module_state->__pyx_kp_s_unable_to_allocate_array_data);
   Py_CLEAR(clear_module_state->__pyx_kp_s_unable_to_allocate_shape_and_str);
+  Py_CLEAR(clear_module_state->__pyx_n_s_unique);
   Py_CLEAR(clear_module_state->__pyx_n_s_unpack);
   Py_CLEAR(clear_module_state->__pyx_n_s_update);
-  Py_CLEAR(clear_module_state->__pyx_n_s_val);
   Py_CLEAR(clear_module_state->__pyx_n_s_value);
+  Py_CLEAR(clear_module_state->__pyx_n_s_values);
   Py_CLEAR(clear_module_state->__pyx_n_s_version_info);
   Py_CLEAR(clear_module_state->__pyx_n_s_zeros);
   Py_CLEAR(clear_module_state->__pyx_int_0);
   Py_CLEAR(clear_module_state->__pyx_int_1);
-  Py_CLEAR(clear_module_state->__pyx_int_2);
   Py_CLEAR(clear_module_state->__pyx_int_3);
   Py_CLEAR(clear_module_state->__pyx_int_112105877);
   Py_CLEAR(clear_module_state->__pyx_int_136983863);
   Py_CLEAR(clear_module_state->__pyx_int_184977713);
   Py_CLEAR(clear_module_state->__pyx_int_neg_1);
   Py_CLEAR(clear_module_state->__pyx_slice__5);
   Py_CLEAR(clear_module_state->__pyx_tuple__4);
   Py_CLEAR(clear_module_state->__pyx_tuple__8);
   Py_CLEAR(clear_module_state->__pyx_tuple__9);
   Py_CLEAR(clear_module_state->__pyx_tuple__10);
   Py_CLEAR(clear_module_state->__pyx_tuple__11);
   Py_CLEAR(clear_module_state->__pyx_tuple__12);
-  Py_CLEAR(clear_module_state->__pyx_tuple__13);
   Py_CLEAR(clear_module_state->__pyx_tuple__14);
   Py_CLEAR(clear_module_state->__pyx_tuple__15);
   Py_CLEAR(clear_module_state->__pyx_tuple__16);
   Py_CLEAR(clear_module_state->__pyx_tuple__17);
   Py_CLEAR(clear_module_state->__pyx_tuple__18);
   Py_CLEAR(clear_module_state->__pyx_tuple__19);
   Py_CLEAR(clear_module_state->__pyx_tuple__20);
   Py_CLEAR(clear_module_state->__pyx_tuple__21);
   Py_CLEAR(clear_module_state->__pyx_tuple__22);
   Py_CLEAR(clear_module_state->__pyx_tuple__23);
-  Py_CLEAR(clear_module_state->__pyx_tuple__24);
   Py_CLEAR(clear_module_state->__pyx_tuple__25);
-  Py_CLEAR(clear_module_state->__pyx_tuple__26);
-  Py_CLEAR(clear_module_state->__pyx_tuple__28);
+  Py_CLEAR(clear_module_state->__pyx_tuple__27);
   Py_CLEAR(clear_module_state->__pyx_tuple__29);
   Py_CLEAR(clear_module_state->__pyx_tuple__31);
   Py_CLEAR(clear_module_state->__pyx_tuple__33);
-  Py_CLEAR(clear_module_state->__pyx_tuple__35);
+  Py_CLEAR(clear_module_state->__pyx_tuple__34);
   Py_CLEAR(clear_module_state->__pyx_tuple__37);
-  Py_CLEAR(clear_module_state->__pyx_tuple__39);
   Py_CLEAR(clear_module_state->__pyx_tuple__40);
   Py_CLEAR(clear_module_state->__pyx_tuple__42);
   Py_CLEAR(clear_module_state->__pyx_tuple__44);
-  Py_CLEAR(clear_module_state->__pyx_tuple__46);
   Py_CLEAR(clear_module_state->__pyx_tuple__48);
-  Py_CLEAR(clear_module_state->__pyx_tuple__49);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__27);
+  Py_CLEAR(clear_module_state->__pyx_tuple__50);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__13);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__24);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__26);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__28);
   Py_CLEAR(clear_module_state->__pyx_codeobj__30);
   Py_CLEAR(clear_module_state->__pyx_codeobj__32);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__34);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__35);
   Py_CLEAR(clear_module_state->__pyx_codeobj__36);
   Py_CLEAR(clear_module_state->__pyx_codeobj__38);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__39);
   Py_CLEAR(clear_module_state->__pyx_codeobj__41);
   Py_CLEAR(clear_module_state->__pyx_codeobj__43);
   Py_CLEAR(clear_module_state->__pyx_codeobj__45);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__46);
   Py_CLEAR(clear_module_state->__pyx_codeobj__47);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__50);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__49);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__51);
   return 0;
 }
 #endif
 /* #### Code section: module_state_traverse ### */
 #if CYTHON_USE_MODULE_STATE
 static int __pyx_m_traverse(PyObject *m, visitproc visit, void *arg) {
   __pyx_mstate *traverse_module_state = __pyx_mstate(m);
@@ -3955,327 +3983,290 @@
   Py_VISIT(traverse_module_state->__pyx_empty_unicode);
   #ifdef __Pyx_CyFunction_USED
   Py_VISIT(traverse_module_state->__pyx_CyFunctionType);
   #endif
   #ifdef __Pyx_FusedFunction_USED
   Py_VISIT(traverse_module_state->__pyx_FusedFunctionType);
   #endif
+  Py_VISIT(traverse_module_state->__pyx_ptype_5adaXT_7predict_7predict_Predict);
+  Py_VISIT(traverse_module_state->__pyx_type_5adaXT_7predict_7predict_Predict);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5adaXT_7predict_7predict_PredictClassification);
+  Py_VISIT(traverse_module_state->__pyx_type_5adaXT_7predict_7predict_PredictClassification);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5adaXT_7predict_7predict_PredictRegression);
+  Py_VISIT(traverse_module_state->__pyx_type_5adaXT_7predict_7predict_PredictRegression);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression);
+  Py_VISIT(traverse_module_state->__pyx_type_5adaXT_7predict_7predict_PredictLinearRegression);
+  Py_VISIT(traverse_module_state->__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile);
+  Py_VISIT(traverse_module_state->__pyx_type_5adaXT_7predict_7predict_PredictQuantile);
   Py_VISIT(traverse_module_state->__pyx_array_type);
   Py_VISIT(traverse_module_state->__pyx_type___pyx_array);
   Py_VISIT(traverse_module_state->__pyx_MemviewEnum_type);
   Py_VISIT(traverse_module_state->__pyx_type___pyx_MemviewEnum);
   Py_VISIT(traverse_module_state->__pyx_memoryview_type);
   Py_VISIT(traverse_module_state->__pyx_type___pyx_memoryview);
   Py_VISIT(traverse_module_state->__pyx_memoryviewslice_type);
   Py_VISIT(traverse_module_state->__pyx_type___pyx_memoryviewslice);
   Py_VISIT(traverse_module_state->__pyx_kp_u_);
   Py_VISIT(traverse_module_state->__pyx_n_s_ASCII);
   Py_VISIT(traverse_module_state->__pyx_kp_s_All_dimensions_preceding_dimensi);
   Py_VISIT(traverse_module_state->__pyx_n_s_AssertionError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_AttributeError);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Buffer_view_does_not_expose_stri);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Can_only_create_a_buffer_that_is);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_assign_to_read_only_memor);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_create_writable_memory_vi);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Cannot_index_with_type);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Cannot_transpose_memoryview_with);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Classification);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Criteria);
   Py_VISIT(traverse_module_state->__pyx_n_s_DOUBLE);
   Py_VISIT(traverse_module_state->__pyx_n_s_DecisionNode);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree___check_dimensions);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree___check_input);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree___check_sample_weig);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree___find_max_index);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree___init);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree__check_dimensions);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree__check_input);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree__check_sample_weig);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree__find_max_index);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree_fit);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree_get_leaf_matrix);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree_predict);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree_predict_leaf_matrix);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DecisionTree_predict_proba);
-  Py_VISIT(traverse_module_state->__pyx_n_s_DepthTreeBuilder);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Dimension_d_is_not_direct);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Dimension_should_be);
   Py_VISIT(traverse_module_state->__pyx_n_s_Ellipsis);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Empty_shape_tuple_for_cython_arr);
-  Py_VISIT(traverse_module_state->__pyx_kp_u_Expected_Classification_or_Regre);
+  Py_VISIT(traverse_module_state->__pyx_kp_u_Function_predict_is_not_implemen);
+  Py_VISIT(traverse_module_state->__pyx_kp_u_Function_predict_proba_is_not_im);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0);
   Py_VISIT(traverse_module_state->__pyx_n_s_IndexError);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Index_out_of_bounds_axis_d);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Indirect_dimensions_not_supporte);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_mode_expected_c_or_fortr);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Invalid_shape_in_axis);
   Py_VISIT(traverse_module_state->__pyx_n_s_MemoryError);
   Py_VISIT(traverse_module_state->__pyx_kp_s_MemoryView_of_r_at_0x_x);
   Py_VISIT(traverse_module_state->__pyx_kp_s_MemoryView_of_r_object);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Nodes);
-  Py_VISIT(traverse_module_state->__pyx_n_s_None);
+  Py_VISIT(traverse_module_state->__pyx_n_s_NotImplementedError);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Number_of_features_should_be);
   Py_VISIT(traverse_module_state->__pyx_n_b_O);
   Py_VISIT(traverse_module_state->__pyx_kp_u_Out_of_bounds_on_buffer_access_a);
   Py_VISIT(traverse_module_state->__pyx_n_s_PickleError);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Regression);
+  Py_VISIT(traverse_module_state->__pyx_n_s_Predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictClassification);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictClassification__most_fre);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictClassification_forest_pre);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictClassification_forest_pre_2);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictClassification_predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictClassification_predict_pr);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictLinearRegression);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictLinearRegression_predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictQuantile);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictQuantile_forest_predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictQuantile_predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictRegression);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictRegression_forest_predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_PredictRegression_predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_Predict___reduce);
+  Py_VISIT(traverse_module_state->__pyx_n_s_Predict_forest_predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_Predict_forest_predict_proba);
+  Py_VISIT(traverse_module_state->__pyx_n_s_Predict_predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_Predict_predict_leaf_matrix);
+  Py_VISIT(traverse_module_state->__pyx_n_s_Predict_predict_proba);
   Py_VISIT(traverse_module_state->__pyx_n_s_Sequence);
-  Py_VISIT(traverse_module_state->__pyx_n_s_Splitter);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Splitter_None);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Step_may_not_be_zero_axis_d);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_The_tree_has_not_been_fitted_bef);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_The_tree_has_not_been_fitted_bef_2);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_The_tree_has_not_been_trained_be);
+  Py_VISIT(traverse_module_state->__pyx_kp_u_The_forest_predict_function_is_n);
   Py_VISIT(traverse_module_state->__pyx_n_s_TypeError);
   Py_VISIT(traverse_module_state->__pyx_kp_s_Unable_to_convert_item_to_object);
   Py_VISIT(traverse_module_state->__pyx_n_s_ValueError);
   Py_VISIT(traverse_module_state->__pyx_n_s_View_MemoryView);
   Py_VISIT(traverse_module_state->__pyx_n_s_X);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_X_and_Y_should_have_the_same_num);
   Py_VISIT(traverse_module_state->__pyx_n_s_Y);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_Y_should_have_dimensions_n_1_or);
   Py_VISIT(traverse_module_state->__pyx_kp_u__2);
   Py_VISIT(traverse_module_state->__pyx_n_s__3);
-  Py_VISIT(traverse_module_state->__pyx_n_s__51);
+  Py_VISIT(traverse_module_state->__pyx_n_s__52);
   Py_VISIT(traverse_module_state->__pyx_kp_u__6);
   Py_VISIT(traverse_module_state->__pyx_kp_u__7);
   Py_VISIT(traverse_module_state->__pyx_n_s_abc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_adaXT_decision_tree_DecisionTree);
+  Py_VISIT(traverse_module_state->__pyx_n_s_adaXT_predict_predict);
   Py_VISIT(traverse_module_state->__pyx_n_s_allocate_buffer);
   Py_VISIT(traverse_module_state->__pyx_kp_u_and);
-  Py_VISIT(traverse_module_state->__pyx_n_s_arange);
-  Py_VISIT(traverse_module_state->__pyx_n_s_array);
-  Py_VISIT(traverse_module_state->__pyx_n_s_asarray);
+  Py_VISIT(traverse_module_state->__pyx_n_s_apply_along_axis);
+  Py_VISIT(traverse_module_state->__pyx_n_s_argmax);
+  Py_VISIT(traverse_module_state->__pyx_n_s_arr);
   Py_VISIT(traverse_module_state->__pyx_n_s_ascontiguousarray);
   Py_VISIT(traverse_module_state->__pyx_n_s_asyncio_coroutines);
   Py_VISIT(traverse_module_state->__pyx_n_s_axis);
   Py_VISIT(traverse_module_state->__pyx_n_s_base);
-  Py_VISIT(traverse_module_state->__pyx_n_s_bool);
-  Py_VISIT(traverse_module_state->__pyx_n_s_build_tree);
-  Py_VISIT(traverse_module_state->__pyx_n_s_builder);
   Py_VISIT(traverse_module_state->__pyx_n_s_c);
   Py_VISIT(traverse_module_state->__pyx_n_u_c);
-  Py_VISIT(traverse_module_state->__pyx_n_s_check_dimensions);
-  Py_VISIT(traverse_module_state->__pyx_n_s_check_input);
-  Py_VISIT(traverse_module_state->__pyx_n_s_check_sample_weight);
   Py_VISIT(traverse_module_state->__pyx_n_s_class);
   Py_VISIT(traverse_module_state->__pyx_n_s_class_getitem);
-  Py_VISIT(traverse_module_state->__pyx_n_s_classes);
   Py_VISIT(traverse_module_state->__pyx_n_s_cline_in_traceback);
-  Py_VISIT(traverse_module_state->__pyx_n_s_col);
   Py_VISIT(traverse_module_state->__pyx_n_s_collections);
   Py_VISIT(traverse_module_state->__pyx_kp_s_collections_abc);
   Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_direct);
   Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_indirect);
   Py_VISIT(traverse_module_state->__pyx_n_s_count);
-  Py_VISIT(traverse_module_state->__pyx_n_s_criteria);
-  Py_VISIT(traverse_module_state->__pyx_n_s_cur_max);
+  Py_VISIT(traverse_module_state->__pyx_n_s_counts);
   Py_VISIT(traverse_module_state->__pyx_n_s_cur_node);
   Py_VISIT(traverse_module_state->__pyx_n_s_cur_split_idx);
   Py_VISIT(traverse_module_state->__pyx_n_s_cur_threshold);
+  Py_VISIT(traverse_module_state->__pyx_n_s_decision_tree_nodes);
   Py_VISIT(traverse_module_state->__pyx_n_s_dict);
   Py_VISIT(traverse_module_state->__pyx_kp_u_disable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_doc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_double);
   Py_VISIT(traverse_module_state->__pyx_n_s_dtype);
   Py_VISIT(traverse_module_state->__pyx_n_s_dtype_is_object);
   Py_VISIT(traverse_module_state->__pyx_n_s_empty);
   Py_VISIT(traverse_module_state->__pyx_kp_u_enable);
   Py_VISIT(traverse_module_state->__pyx_n_s_encode);
   Py_VISIT(traverse_module_state->__pyx_n_s_enumerate);
-  Py_VISIT(traverse_module_state->__pyx_n_s_eps);
   Py_VISIT(traverse_module_state->__pyx_n_s_error);
   Py_VISIT(traverse_module_state->__pyx_n_s_expand_dims);
-  Py_VISIT(traverse_module_state->__pyx_n_s_feature_indices);
-  Py_VISIT(traverse_module_state->__pyx_n_s_find_max_index);
-  Py_VISIT(traverse_module_state->__pyx_n_s_finfo);
-  Py_VISIT(traverse_module_state->__pyx_n_s_fit);
   Py_VISIT(traverse_module_state->__pyx_n_s_flags);
-  Py_VISIT(traverse_module_state->__pyx_n_s_float);
   Py_VISIT(traverse_module_state->__pyx_n_s_float64);
+  Py_VISIT(traverse_module_state->__pyx_n_s_forest_predict);
+  Py_VISIT(traverse_module_state->__pyx_n_s_forest_predict_locals___most_fre);
+  Py_VISIT(traverse_module_state->__pyx_n_s_forest_predict_proba);
   Py_VISIT(traverse_module_state->__pyx_n_s_format);
   Py_VISIT(traverse_module_state->__pyx_n_s_fortran);
   Py_VISIT(traverse_module_state->__pyx_n_u_fortran);
   Py_VISIT(traverse_module_state->__pyx_kp_u_gc);
-  Py_VISIT(traverse_module_state->__pyx_n_s_get_leaf_matrix);
   Py_VISIT(traverse_module_state->__pyx_n_s_getstate);
   Py_VISIT(traverse_module_state->__pyx_kp_u_got);
   Py_VISIT(traverse_module_state->__pyx_kp_u_got_2);
   Py_VISIT(traverse_module_state->__pyx_kp_u_got_differing_extents_in_dimensi);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ht);
   Py_VISIT(traverse_module_state->__pyx_n_s_i);
   Py_VISIT(traverse_module_state->__pyx_n_s_id);
   Py_VISIT(traverse_module_state->__pyx_n_s_idx);
   Py_VISIT(traverse_module_state->__pyx_n_s_import);
-  Py_VISIT(traverse_module_state->__pyx_n_s_impurity_tol);
   Py_VISIT(traverse_module_state->__pyx_n_s_index);
   Py_VISIT(traverse_module_state->__pyx_n_s_indices);
-  Py_VISIT(traverse_module_state->__pyx_n_s_init);
-  Py_VISIT(traverse_module_state->__pyx_n_s_init_subclass);
   Py_VISIT(traverse_module_state->__pyx_n_s_initializing);
-  Py_VISIT(traverse_module_state->__pyx_n_s_int);
-  Py_VISIT(traverse_module_state->__pyx_n_s_int32);
   Py_VISIT(traverse_module_state->__pyx_n_s_is_coroutine);
   Py_VISIT(traverse_module_state->__pyx_kp_u_isenabled);
   Py_VISIT(traverse_module_state->__pyx_n_s_itemsize);
   Py_VISIT(traverse_module_state->__pyx_kp_s_itemsize_0_for_cython_array);
   Py_VISIT(traverse_module_state->__pyx_n_s_ix);
-  Py_VISIT(traverse_module_state->__pyx_n_s_key);
   Py_VISIT(traverse_module_state->__pyx_n_s_keys);
-  Py_VISIT(traverse_module_state->__pyx_n_s_leaf_nodes);
+  Py_VISIT(traverse_module_state->__pyx_n_s_kwargs);
   Py_VISIT(traverse_module_state->__pyx_n_s_left_child);
-  Py_VISIT(traverse_module_state->__pyx_n_s_lst);
   Py_VISIT(traverse_module_state->__pyx_n_s_main);
-  Py_VISIT(traverse_module_state->__pyx_n_s_matrix);
-  Py_VISIT(traverse_module_state->__pyx_n_s_max_depth);
-  Py_VISIT(traverse_module_state->__pyx_n_s_maxsize);
+  Py_VISIT(traverse_module_state->__pyx_n_s_mean);
   Py_VISIT(traverse_module_state->__pyx_n_s_memview);
-  Py_VISIT(traverse_module_state->__pyx_n_s_metaclass);
-  Py_VISIT(traverse_module_state->__pyx_n_s_min_improvement);
-  Py_VISIT(traverse_module_state->__pyx_n_s_min_samples_leaf);
-  Py_VISIT(traverse_module_state->__pyx_n_s_min_samples_split);
   Py_VISIT(traverse_module_state->__pyx_n_s_mode);
-  Py_VISIT(traverse_module_state->__pyx_n_s_module);
-  Py_VISIT(traverse_module_state->__pyx_n_s_n_classes);
-  Py_VISIT(traverse_module_state->__pyx_n_s_n_features);
-  Py_VISIT(traverse_module_state->__pyx_n_s_n_node);
-  Py_VISIT(traverse_module_state->__pyx_n_s_n_nodes);
+  Py_VISIT(traverse_module_state->__pyx_n_s_most_frequent_element);
   Py_VISIT(traverse_module_state->__pyx_n_s_n_obs);
-  Py_VISIT(traverse_module_state->__pyx_n_s_n_samples);
   Py_VISIT(traverse_module_state->__pyx_n_s_name);
   Py_VISIT(traverse_module_state->__pyx_n_s_name_2);
   Py_VISIT(traverse_module_state->__pyx_n_s_ndim);
   Py_VISIT(traverse_module_state->__pyx_n_s_new);
   Py_VISIT(traverse_module_state->__pyx_kp_s_no_default___reduce___due_to_non);
-  Py_VISIT(traverse_module_state->__pyx_n_s_node);
   Py_VISIT(traverse_module_state->__pyx_n_s_np);
   Py_VISIT(traverse_module_state->__pyx_kp_s_np_ndarray);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_np_ndarray_None);
   Py_VISIT(traverse_module_state->__pyx_n_s_numpy);
   Py_VISIT(traverse_module_state->__pyx_n_s_obj);
-  Py_VISIT(traverse_module_state->__pyx_n_s_object);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ones);
   Py_VISIT(traverse_module_state->__pyx_n_s_pack);
   Py_VISIT(traverse_module_state->__pyx_n_s_pickle);
   Py_VISIT(traverse_module_state->__pyx_n_s_predict);
   Py_VISIT(traverse_module_state->__pyx_n_s_predict_leaf_matrix);
   Py_VISIT(traverse_module_state->__pyx_n_s_predict_proba);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_predict_proba_can_only_be_called);
-  Py_VISIT(traverse_module_state->__pyx_n_s_prepare);
+  Py_VISIT(traverse_module_state->__pyx_n_s_predictions);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_PickleError);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_checksum);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_result);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_state);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_type);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_unpickle_Enum);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_vtable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_qualname);
+  Py_VISIT(traverse_module_state->__pyx_n_s_quantile);
+  Py_VISIT(traverse_module_state->__pyx_n_u_quantile);
   Py_VISIT(traverse_module_state->__pyx_n_s_range);
   Py_VISIT(traverse_module_state->__pyx_n_s_reduce);
   Py_VISIT(traverse_module_state->__pyx_n_s_reduce_cython);
   Py_VISIT(traverse_module_state->__pyx_n_s_reduce_ex);
   Py_VISIT(traverse_module_state->__pyx_n_s_register);
-  Py_VISIT(traverse_module_state->__pyx_n_s_reshape);
-  Py_VISIT(traverse_module_state->__pyx_n_s_ret_val);
-  Py_VISIT(traverse_module_state->__pyx_n_s_return);
+  Py_VISIT(traverse_module_state->__pyx_n_s_return_counts);
   Py_VISIT(traverse_module_state->__pyx_n_s_right_child);
   Py_VISIT(traverse_module_state->__pyx_n_s_root);
-  Py_VISIT(traverse_module_state->__pyx_n_s_row);
-  Py_VISIT(traverse_module_state->__pyx_n_s_sample_indices);
-  Py_VISIT(traverse_module_state->__pyx_n_s_sample_weight);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_sample_weight_should_have_as_man);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_sample_weight_should_have_dimens);
+  Py_VISIT(traverse_module_state->__pyx_n_s_save_indices);
+  Py_VISIT(traverse_module_state->__pyx_n_u_save_indices);
   Py_VISIT(traverse_module_state->__pyx_n_s_scale);
   Py_VISIT(traverse_module_state->__pyx_n_s_self);
-  Py_VISIT(traverse_module_state->__pyx_n_s_set_name);
   Py_VISIT(traverse_module_state->__pyx_n_s_setstate);
   Py_VISIT(traverse_module_state->__pyx_n_s_setstate_cython);
   Py_VISIT(traverse_module_state->__pyx_n_s_shape);
   Py_VISIT(traverse_module_state->__pyx_n_s_size);
   Py_VISIT(traverse_module_state->__pyx_n_s_spec);
   Py_VISIT(traverse_module_state->__pyx_n_s_split_idx);
-  Py_VISIT(traverse_module_state->__pyx_n_s_splitter);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_src_adaXT_decision_tree_Decision);
+  Py_VISIT(traverse_module_state->__pyx_kp_s_src_adaXT_predict_predict_pyx);
+  Py_VISIT(traverse_module_state->__pyx_n_s_stack);
+  Py_VISIT(traverse_module_state->__pyx_n_s_stacked_tree_predictions);
   Py_VISIT(traverse_module_state->__pyx_n_s_start);
+  Py_VISIT(traverse_module_state->__pyx_n_s_staticmethod);
   Py_VISIT(traverse_module_state->__pyx_n_s_step);
   Py_VISIT(traverse_module_state->__pyx_n_s_stop);
-  Py_VISIT(traverse_module_state->__pyx_n_s_str);
   Py_VISIT(traverse_module_state->__pyx_kp_s_strided_and_direct);
   Py_VISIT(traverse_module_state->__pyx_kp_s_strided_and_direct_or_indirect);
   Py_VISIT(traverse_module_state->__pyx_kp_s_strided_and_indirect);
   Py_VISIT(traverse_module_state->__pyx_kp_s_stringsource);
   Py_VISIT(traverse_module_state->__pyx_n_s_struct);
-  Py_VISIT(traverse_module_state->__pyx_n_s_super);
   Py_VISIT(traverse_module_state->__pyx_n_s_sys);
   Py_VISIT(traverse_module_state->__pyx_n_s_test);
+  Py_VISIT(traverse_module_state->__pyx_n_s_theta0);
+  Py_VISIT(traverse_module_state->__pyx_n_s_theta1);
   Py_VISIT(traverse_module_state->__pyx_n_s_threshold);
-  Py_VISIT(traverse_module_state->__pyx_n_s_tree_type);
-  Py_VISIT(traverse_module_state->__pyx_n_s_tree_types);
   Py_VISIT(traverse_module_state->__pyx_kp_s_unable_to_allocate_array_data);
   Py_VISIT(traverse_module_state->__pyx_kp_s_unable_to_allocate_shape_and_str);
+  Py_VISIT(traverse_module_state->__pyx_n_s_unique);
   Py_VISIT(traverse_module_state->__pyx_n_s_unpack);
   Py_VISIT(traverse_module_state->__pyx_n_s_update);
-  Py_VISIT(traverse_module_state->__pyx_n_s_val);
   Py_VISIT(traverse_module_state->__pyx_n_s_value);
+  Py_VISIT(traverse_module_state->__pyx_n_s_values);
   Py_VISIT(traverse_module_state->__pyx_n_s_version_info);
   Py_VISIT(traverse_module_state->__pyx_n_s_zeros);
   Py_VISIT(traverse_module_state->__pyx_int_0);
   Py_VISIT(traverse_module_state->__pyx_int_1);
-  Py_VISIT(traverse_module_state->__pyx_int_2);
   Py_VISIT(traverse_module_state->__pyx_int_3);
   Py_VISIT(traverse_module_state->__pyx_int_112105877);
   Py_VISIT(traverse_module_state->__pyx_int_136983863);
   Py_VISIT(traverse_module_state->__pyx_int_184977713);
   Py_VISIT(traverse_module_state->__pyx_int_neg_1);
   Py_VISIT(traverse_module_state->__pyx_slice__5);
   Py_VISIT(traverse_module_state->__pyx_tuple__4);
   Py_VISIT(traverse_module_state->__pyx_tuple__8);
   Py_VISIT(traverse_module_state->__pyx_tuple__9);
   Py_VISIT(traverse_module_state->__pyx_tuple__10);
   Py_VISIT(traverse_module_state->__pyx_tuple__11);
   Py_VISIT(traverse_module_state->__pyx_tuple__12);
-  Py_VISIT(traverse_module_state->__pyx_tuple__13);
   Py_VISIT(traverse_module_state->__pyx_tuple__14);
   Py_VISIT(traverse_module_state->__pyx_tuple__15);
   Py_VISIT(traverse_module_state->__pyx_tuple__16);
   Py_VISIT(traverse_module_state->__pyx_tuple__17);
   Py_VISIT(traverse_module_state->__pyx_tuple__18);
   Py_VISIT(traverse_module_state->__pyx_tuple__19);
   Py_VISIT(traverse_module_state->__pyx_tuple__20);
   Py_VISIT(traverse_module_state->__pyx_tuple__21);
   Py_VISIT(traverse_module_state->__pyx_tuple__22);
   Py_VISIT(traverse_module_state->__pyx_tuple__23);
-  Py_VISIT(traverse_module_state->__pyx_tuple__24);
   Py_VISIT(traverse_module_state->__pyx_tuple__25);
-  Py_VISIT(traverse_module_state->__pyx_tuple__26);
-  Py_VISIT(traverse_module_state->__pyx_tuple__28);
+  Py_VISIT(traverse_module_state->__pyx_tuple__27);
   Py_VISIT(traverse_module_state->__pyx_tuple__29);
   Py_VISIT(traverse_module_state->__pyx_tuple__31);
   Py_VISIT(traverse_module_state->__pyx_tuple__33);
-  Py_VISIT(traverse_module_state->__pyx_tuple__35);
+  Py_VISIT(traverse_module_state->__pyx_tuple__34);
   Py_VISIT(traverse_module_state->__pyx_tuple__37);
-  Py_VISIT(traverse_module_state->__pyx_tuple__39);
   Py_VISIT(traverse_module_state->__pyx_tuple__40);
   Py_VISIT(traverse_module_state->__pyx_tuple__42);
   Py_VISIT(traverse_module_state->__pyx_tuple__44);
-  Py_VISIT(traverse_module_state->__pyx_tuple__46);
   Py_VISIT(traverse_module_state->__pyx_tuple__48);
-  Py_VISIT(traverse_module_state->__pyx_tuple__49);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__27);
+  Py_VISIT(traverse_module_state->__pyx_tuple__50);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__13);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__24);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__26);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__28);
   Py_VISIT(traverse_module_state->__pyx_codeobj__30);
   Py_VISIT(traverse_module_state->__pyx_codeobj__32);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__34);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__35);
   Py_VISIT(traverse_module_state->__pyx_codeobj__36);
   Py_VISIT(traverse_module_state->__pyx_codeobj__38);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__39);
   Py_VISIT(traverse_module_state->__pyx_codeobj__41);
   Py_VISIT(traverse_module_state->__pyx_codeobj__43);
   Py_VISIT(traverse_module_state->__pyx_codeobj__45);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__46);
   Py_VISIT(traverse_module_state->__pyx_codeobj__47);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__50);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__49);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__51);
   return 0;
 }
 #endif
 /* #### Code section: module_state_defines ### */
 #define __pyx_d __pyx_mstate_global->__pyx_d
 #define __pyx_b __pyx_mstate_global->__pyx_b
 #define __pyx_cython_runtime __pyx_mstate_global->__pyx_cython_runtime
@@ -4297,328 +4288,291 @@
 #ifdef __Pyx_Coroutine_USED
 #define __pyx_CoroutineAwaitType __pyx_mstate_global->__pyx_CoroutineAwaitType
 #endif
 #ifdef __Pyx_Coroutine_USED
 #define __pyx_CoroutineType __pyx_mstate_global->__pyx_CoroutineType
 #endif
 #if CYTHON_USE_MODULE_STATE
+#define __pyx_type_5adaXT_7predict_7predict_Predict __pyx_mstate_global->__pyx_type_5adaXT_7predict_7predict_Predict
+#define __pyx_type_5adaXT_7predict_7predict_PredictClassification __pyx_mstate_global->__pyx_type_5adaXT_7predict_7predict_PredictClassification
+#define __pyx_type_5adaXT_7predict_7predict_PredictRegression __pyx_mstate_global->__pyx_type_5adaXT_7predict_7predict_PredictRegression
+#define __pyx_type_5adaXT_7predict_7predict_PredictLinearRegression __pyx_mstate_global->__pyx_type_5adaXT_7predict_7predict_PredictLinearRegression
+#define __pyx_type_5adaXT_7predict_7predict_PredictQuantile __pyx_mstate_global->__pyx_type_5adaXT_7predict_7predict_PredictQuantile
 #define __pyx_type___pyx_array __pyx_mstate_global->__pyx_type___pyx_array
 #define __pyx_type___pyx_MemviewEnum __pyx_mstate_global->__pyx_type___pyx_MemviewEnum
 #define __pyx_type___pyx_memoryview __pyx_mstate_global->__pyx_type___pyx_memoryview
 #define __pyx_type___pyx_memoryviewslice __pyx_mstate_global->__pyx_type___pyx_memoryviewslice
 #endif
+#define __pyx_ptype_5adaXT_7predict_7predict_Predict __pyx_mstate_global->__pyx_ptype_5adaXT_7predict_7predict_Predict
+#define __pyx_ptype_5adaXT_7predict_7predict_PredictClassification __pyx_mstate_global->__pyx_ptype_5adaXT_7predict_7predict_PredictClassification
+#define __pyx_ptype_5adaXT_7predict_7predict_PredictRegression __pyx_mstate_global->__pyx_ptype_5adaXT_7predict_7predict_PredictRegression
+#define __pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression __pyx_mstate_global->__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression
+#define __pyx_ptype_5adaXT_7predict_7predict_PredictQuantile __pyx_mstate_global->__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile
 #define __pyx_array_type __pyx_mstate_global->__pyx_array_type
 #define __pyx_MemviewEnum_type __pyx_mstate_global->__pyx_MemviewEnum_type
 #define __pyx_memoryview_type __pyx_mstate_global->__pyx_memoryview_type
 #define __pyx_memoryviewslice_type __pyx_mstate_global->__pyx_memoryviewslice_type
 #define __pyx_kp_u_ __pyx_mstate_global->__pyx_kp_u_
 #define __pyx_n_s_ASCII __pyx_mstate_global->__pyx_n_s_ASCII
 #define __pyx_kp_s_All_dimensions_preceding_dimensi __pyx_mstate_global->__pyx_kp_s_All_dimensions_preceding_dimensi
 #define __pyx_n_s_AssertionError __pyx_mstate_global->__pyx_n_s_AssertionError
-#define __pyx_n_s_AttributeError __pyx_mstate_global->__pyx_n_s_AttributeError
 #define __pyx_kp_s_Buffer_view_does_not_expose_stri __pyx_mstate_global->__pyx_kp_s_Buffer_view_does_not_expose_stri
 #define __pyx_kp_s_Can_only_create_a_buffer_that_is __pyx_mstate_global->__pyx_kp_s_Can_only_create_a_buffer_that_is
 #define __pyx_kp_s_Cannot_assign_to_read_only_memor __pyx_mstate_global->__pyx_kp_s_Cannot_assign_to_read_only_memor
 #define __pyx_kp_s_Cannot_create_writable_memory_vi __pyx_mstate_global->__pyx_kp_s_Cannot_create_writable_memory_vi
 #define __pyx_kp_u_Cannot_index_with_type __pyx_mstate_global->__pyx_kp_u_Cannot_index_with_type
 #define __pyx_kp_s_Cannot_transpose_memoryview_with __pyx_mstate_global->__pyx_kp_s_Cannot_transpose_memoryview_with
-#define __pyx_n_s_Classification __pyx_mstate_global->__pyx_n_s_Classification
-#define __pyx_n_s_Criteria __pyx_mstate_global->__pyx_n_s_Criteria
 #define __pyx_n_s_DOUBLE __pyx_mstate_global->__pyx_n_s_DOUBLE
 #define __pyx_n_s_DecisionNode __pyx_mstate_global->__pyx_n_s_DecisionNode
-#define __pyx_n_s_DecisionTree __pyx_mstate_global->__pyx_n_s_DecisionTree
-#define __pyx_n_s_DecisionTree___check_dimensions __pyx_mstate_global->__pyx_n_s_DecisionTree___check_dimensions
-#define __pyx_n_s_DecisionTree___check_input __pyx_mstate_global->__pyx_n_s_DecisionTree___check_input
-#define __pyx_n_s_DecisionTree___check_sample_weig __pyx_mstate_global->__pyx_n_s_DecisionTree___check_sample_weig
-#define __pyx_n_s_DecisionTree___find_max_index __pyx_mstate_global->__pyx_n_s_DecisionTree___find_max_index
-#define __pyx_n_s_DecisionTree___init __pyx_mstate_global->__pyx_n_s_DecisionTree___init
-#define __pyx_n_s_DecisionTree__check_dimensions __pyx_mstate_global->__pyx_n_s_DecisionTree__check_dimensions
-#define __pyx_n_s_DecisionTree__check_input __pyx_mstate_global->__pyx_n_s_DecisionTree__check_input
-#define __pyx_n_s_DecisionTree__check_sample_weig __pyx_mstate_global->__pyx_n_s_DecisionTree__check_sample_weig
-#define __pyx_n_s_DecisionTree__find_max_index __pyx_mstate_global->__pyx_n_s_DecisionTree__find_max_index
-#define __pyx_n_s_DecisionTree_fit __pyx_mstate_global->__pyx_n_s_DecisionTree_fit
-#define __pyx_n_s_DecisionTree_get_leaf_matrix __pyx_mstate_global->__pyx_n_s_DecisionTree_get_leaf_matrix
-#define __pyx_n_s_DecisionTree_predict __pyx_mstate_global->__pyx_n_s_DecisionTree_predict
-#define __pyx_n_s_DecisionTree_predict_leaf_matrix __pyx_mstate_global->__pyx_n_s_DecisionTree_predict_leaf_matrix
-#define __pyx_n_s_DecisionTree_predict_proba __pyx_mstate_global->__pyx_n_s_DecisionTree_predict_proba
-#define __pyx_n_s_DepthTreeBuilder __pyx_mstate_global->__pyx_n_s_DepthTreeBuilder
 #define __pyx_kp_s_Dimension_d_is_not_direct __pyx_mstate_global->__pyx_kp_s_Dimension_d_is_not_direct
 #define __pyx_kp_u_Dimension_should_be __pyx_mstate_global->__pyx_kp_u_Dimension_should_be
 #define __pyx_n_s_Ellipsis __pyx_mstate_global->__pyx_n_s_Ellipsis
 #define __pyx_kp_s_Empty_shape_tuple_for_cython_arr __pyx_mstate_global->__pyx_kp_s_Empty_shape_tuple_for_cython_arr
-#define __pyx_kp_u_Expected_Classification_or_Regre __pyx_mstate_global->__pyx_kp_u_Expected_Classification_or_Regre
+#define __pyx_kp_u_Function_predict_is_not_implemen __pyx_mstate_global->__pyx_kp_u_Function_predict_is_not_implemen
+#define __pyx_kp_u_Function_predict_proba_is_not_im __pyx_mstate_global->__pyx_kp_u_Function_predict_proba_is_not_im
 #define __pyx_kp_s_Incompatible_checksums_0x_x_vs_0 __pyx_mstate_global->__pyx_kp_s_Incompatible_checksums_0x_x_vs_0
 #define __pyx_n_s_IndexError __pyx_mstate_global->__pyx_n_s_IndexError
 #define __pyx_kp_s_Index_out_of_bounds_axis_d __pyx_mstate_global->__pyx_kp_s_Index_out_of_bounds_axis_d
 #define __pyx_kp_s_Indirect_dimensions_not_supporte __pyx_mstate_global->__pyx_kp_s_Indirect_dimensions_not_supporte
 #define __pyx_kp_u_Invalid_mode_expected_c_or_fortr __pyx_mstate_global->__pyx_kp_u_Invalid_mode_expected_c_or_fortr
 #define __pyx_kp_u_Invalid_shape_in_axis __pyx_mstate_global->__pyx_kp_u_Invalid_shape_in_axis
 #define __pyx_n_s_MemoryError __pyx_mstate_global->__pyx_n_s_MemoryError
 #define __pyx_kp_s_MemoryView_of_r_at_0x_x __pyx_mstate_global->__pyx_kp_s_MemoryView_of_r_at_0x_x
 #define __pyx_kp_s_MemoryView_of_r_object __pyx_mstate_global->__pyx_kp_s_MemoryView_of_r_object
-#define __pyx_n_s_Nodes __pyx_mstate_global->__pyx_n_s_Nodes
-#define __pyx_n_s_None __pyx_mstate_global->__pyx_n_s_None
+#define __pyx_n_s_NotImplementedError __pyx_mstate_global->__pyx_n_s_NotImplementedError
 #define __pyx_kp_u_Number_of_features_should_be __pyx_mstate_global->__pyx_kp_u_Number_of_features_should_be
 #define __pyx_n_b_O __pyx_mstate_global->__pyx_n_b_O
 #define __pyx_kp_u_Out_of_bounds_on_buffer_access_a __pyx_mstate_global->__pyx_kp_u_Out_of_bounds_on_buffer_access_a
 #define __pyx_n_s_PickleError __pyx_mstate_global->__pyx_n_s_PickleError
-#define __pyx_n_s_Regression __pyx_mstate_global->__pyx_n_s_Regression
+#define __pyx_n_s_Predict __pyx_mstate_global->__pyx_n_s_Predict
+#define __pyx_n_s_PredictClassification __pyx_mstate_global->__pyx_n_s_PredictClassification
+#define __pyx_n_s_PredictClassification__most_fre __pyx_mstate_global->__pyx_n_s_PredictClassification__most_fre
+#define __pyx_n_s_PredictClassification_forest_pre __pyx_mstate_global->__pyx_n_s_PredictClassification_forest_pre
+#define __pyx_n_s_PredictClassification_forest_pre_2 __pyx_mstate_global->__pyx_n_s_PredictClassification_forest_pre_2
+#define __pyx_n_s_PredictClassification_predict __pyx_mstate_global->__pyx_n_s_PredictClassification_predict
+#define __pyx_n_s_PredictClassification_predict_pr __pyx_mstate_global->__pyx_n_s_PredictClassification_predict_pr
+#define __pyx_n_s_PredictLinearRegression __pyx_mstate_global->__pyx_n_s_PredictLinearRegression
+#define __pyx_n_s_PredictLinearRegression_predict __pyx_mstate_global->__pyx_n_s_PredictLinearRegression_predict
+#define __pyx_n_s_PredictQuantile __pyx_mstate_global->__pyx_n_s_PredictQuantile
+#define __pyx_n_s_PredictQuantile_forest_predict __pyx_mstate_global->__pyx_n_s_PredictQuantile_forest_predict
+#define __pyx_n_s_PredictQuantile_predict __pyx_mstate_global->__pyx_n_s_PredictQuantile_predict
+#define __pyx_n_s_PredictRegression __pyx_mstate_global->__pyx_n_s_PredictRegression
+#define __pyx_n_s_PredictRegression_forest_predict __pyx_mstate_global->__pyx_n_s_PredictRegression_forest_predict
+#define __pyx_n_s_PredictRegression_predict __pyx_mstate_global->__pyx_n_s_PredictRegression_predict
+#define __pyx_n_s_Predict___reduce __pyx_mstate_global->__pyx_n_s_Predict___reduce
+#define __pyx_n_s_Predict_forest_predict __pyx_mstate_global->__pyx_n_s_Predict_forest_predict
+#define __pyx_n_s_Predict_forest_predict_proba __pyx_mstate_global->__pyx_n_s_Predict_forest_predict_proba
+#define __pyx_n_s_Predict_predict __pyx_mstate_global->__pyx_n_s_Predict_predict
+#define __pyx_n_s_Predict_predict_leaf_matrix __pyx_mstate_global->__pyx_n_s_Predict_predict_leaf_matrix
+#define __pyx_n_s_Predict_predict_proba __pyx_mstate_global->__pyx_n_s_Predict_predict_proba
 #define __pyx_n_s_Sequence __pyx_mstate_global->__pyx_n_s_Sequence
-#define __pyx_n_s_Splitter __pyx_mstate_global->__pyx_n_s_Splitter
-#define __pyx_kp_s_Splitter_None __pyx_mstate_global->__pyx_kp_s_Splitter_None
 #define __pyx_kp_s_Step_may_not_be_zero_axis_d __pyx_mstate_global->__pyx_kp_s_Step_may_not_be_zero_axis_d
-#define __pyx_kp_s_The_tree_has_not_been_fitted_bef __pyx_mstate_global->__pyx_kp_s_The_tree_has_not_been_fitted_bef
-#define __pyx_kp_s_The_tree_has_not_been_fitted_bef_2 __pyx_mstate_global->__pyx_kp_s_The_tree_has_not_been_fitted_bef_2
-#define __pyx_kp_s_The_tree_has_not_been_trained_be __pyx_mstate_global->__pyx_kp_s_The_tree_has_not_been_trained_be
+#define __pyx_kp_u_The_forest_predict_function_is_n __pyx_mstate_global->__pyx_kp_u_The_forest_predict_function_is_n
 #define __pyx_n_s_TypeError __pyx_mstate_global->__pyx_n_s_TypeError
 #define __pyx_kp_s_Unable_to_convert_item_to_object __pyx_mstate_global->__pyx_kp_s_Unable_to_convert_item_to_object
 #define __pyx_n_s_ValueError __pyx_mstate_global->__pyx_n_s_ValueError
 #define __pyx_n_s_View_MemoryView __pyx_mstate_global->__pyx_n_s_View_MemoryView
 #define __pyx_n_s_X __pyx_mstate_global->__pyx_n_s_X
-#define __pyx_kp_s_X_and_Y_should_have_the_same_num __pyx_mstate_global->__pyx_kp_s_X_and_Y_should_have_the_same_num
 #define __pyx_n_s_Y __pyx_mstate_global->__pyx_n_s_Y
-#define __pyx_kp_s_Y_should_have_dimensions_n_1_or __pyx_mstate_global->__pyx_kp_s_Y_should_have_dimensions_n_1_or
 #define __pyx_kp_u__2 __pyx_mstate_global->__pyx_kp_u__2
 #define __pyx_n_s__3 __pyx_mstate_global->__pyx_n_s__3
-#define __pyx_n_s__51 __pyx_mstate_global->__pyx_n_s__51
+#define __pyx_n_s__52 __pyx_mstate_global->__pyx_n_s__52
 #define __pyx_kp_u__6 __pyx_mstate_global->__pyx_kp_u__6
 #define __pyx_kp_u__7 __pyx_mstate_global->__pyx_kp_u__7
 #define __pyx_n_s_abc __pyx_mstate_global->__pyx_n_s_abc
-#define __pyx_n_s_adaXT_decision_tree_DecisionTree __pyx_mstate_global->__pyx_n_s_adaXT_decision_tree_DecisionTree
+#define __pyx_n_s_adaXT_predict_predict __pyx_mstate_global->__pyx_n_s_adaXT_predict_predict
 #define __pyx_n_s_allocate_buffer __pyx_mstate_global->__pyx_n_s_allocate_buffer
 #define __pyx_kp_u_and __pyx_mstate_global->__pyx_kp_u_and
-#define __pyx_n_s_arange __pyx_mstate_global->__pyx_n_s_arange
-#define __pyx_n_s_array __pyx_mstate_global->__pyx_n_s_array
-#define __pyx_n_s_asarray __pyx_mstate_global->__pyx_n_s_asarray
+#define __pyx_n_s_apply_along_axis __pyx_mstate_global->__pyx_n_s_apply_along_axis
+#define __pyx_n_s_argmax __pyx_mstate_global->__pyx_n_s_argmax
+#define __pyx_n_s_arr __pyx_mstate_global->__pyx_n_s_arr
 #define __pyx_n_s_ascontiguousarray __pyx_mstate_global->__pyx_n_s_ascontiguousarray
 #define __pyx_n_s_asyncio_coroutines __pyx_mstate_global->__pyx_n_s_asyncio_coroutines
 #define __pyx_n_s_axis __pyx_mstate_global->__pyx_n_s_axis
 #define __pyx_n_s_base __pyx_mstate_global->__pyx_n_s_base
-#define __pyx_n_s_bool __pyx_mstate_global->__pyx_n_s_bool
-#define __pyx_n_s_build_tree __pyx_mstate_global->__pyx_n_s_build_tree
-#define __pyx_n_s_builder __pyx_mstate_global->__pyx_n_s_builder
 #define __pyx_n_s_c __pyx_mstate_global->__pyx_n_s_c
 #define __pyx_n_u_c __pyx_mstate_global->__pyx_n_u_c
-#define __pyx_n_s_check_dimensions __pyx_mstate_global->__pyx_n_s_check_dimensions
-#define __pyx_n_s_check_input __pyx_mstate_global->__pyx_n_s_check_input
-#define __pyx_n_s_check_sample_weight __pyx_mstate_global->__pyx_n_s_check_sample_weight
 #define __pyx_n_s_class __pyx_mstate_global->__pyx_n_s_class
 #define __pyx_n_s_class_getitem __pyx_mstate_global->__pyx_n_s_class_getitem
-#define __pyx_n_s_classes __pyx_mstate_global->__pyx_n_s_classes
 #define __pyx_n_s_cline_in_traceback __pyx_mstate_global->__pyx_n_s_cline_in_traceback
-#define __pyx_n_s_col __pyx_mstate_global->__pyx_n_s_col
 #define __pyx_n_s_collections __pyx_mstate_global->__pyx_n_s_collections
 #define __pyx_kp_s_collections_abc __pyx_mstate_global->__pyx_kp_s_collections_abc
 #define __pyx_kp_s_contiguous_and_direct __pyx_mstate_global->__pyx_kp_s_contiguous_and_direct
 #define __pyx_kp_s_contiguous_and_indirect __pyx_mstate_global->__pyx_kp_s_contiguous_and_indirect
 #define __pyx_n_s_count __pyx_mstate_global->__pyx_n_s_count
-#define __pyx_n_s_criteria __pyx_mstate_global->__pyx_n_s_criteria
-#define __pyx_n_s_cur_max __pyx_mstate_global->__pyx_n_s_cur_max
+#define __pyx_n_s_counts __pyx_mstate_global->__pyx_n_s_counts
 #define __pyx_n_s_cur_node __pyx_mstate_global->__pyx_n_s_cur_node
 #define __pyx_n_s_cur_split_idx __pyx_mstate_global->__pyx_n_s_cur_split_idx
 #define __pyx_n_s_cur_threshold __pyx_mstate_global->__pyx_n_s_cur_threshold
+#define __pyx_n_s_decision_tree_nodes __pyx_mstate_global->__pyx_n_s_decision_tree_nodes
 #define __pyx_n_s_dict __pyx_mstate_global->__pyx_n_s_dict
 #define __pyx_kp_u_disable __pyx_mstate_global->__pyx_kp_u_disable
-#define __pyx_n_s_doc __pyx_mstate_global->__pyx_n_s_doc
-#define __pyx_n_s_double __pyx_mstate_global->__pyx_n_s_double
 #define __pyx_n_s_dtype __pyx_mstate_global->__pyx_n_s_dtype
 #define __pyx_n_s_dtype_is_object __pyx_mstate_global->__pyx_n_s_dtype_is_object
 #define __pyx_n_s_empty __pyx_mstate_global->__pyx_n_s_empty
 #define __pyx_kp_u_enable __pyx_mstate_global->__pyx_kp_u_enable
 #define __pyx_n_s_encode __pyx_mstate_global->__pyx_n_s_encode
 #define __pyx_n_s_enumerate __pyx_mstate_global->__pyx_n_s_enumerate
-#define __pyx_n_s_eps __pyx_mstate_global->__pyx_n_s_eps
 #define __pyx_n_s_error __pyx_mstate_global->__pyx_n_s_error
 #define __pyx_n_s_expand_dims __pyx_mstate_global->__pyx_n_s_expand_dims
-#define __pyx_n_s_feature_indices __pyx_mstate_global->__pyx_n_s_feature_indices
-#define __pyx_n_s_find_max_index __pyx_mstate_global->__pyx_n_s_find_max_index
-#define __pyx_n_s_finfo __pyx_mstate_global->__pyx_n_s_finfo
-#define __pyx_n_s_fit __pyx_mstate_global->__pyx_n_s_fit
 #define __pyx_n_s_flags __pyx_mstate_global->__pyx_n_s_flags
-#define __pyx_n_s_float __pyx_mstate_global->__pyx_n_s_float
 #define __pyx_n_s_float64 __pyx_mstate_global->__pyx_n_s_float64
+#define __pyx_n_s_forest_predict __pyx_mstate_global->__pyx_n_s_forest_predict
+#define __pyx_n_s_forest_predict_locals___most_fre __pyx_mstate_global->__pyx_n_s_forest_predict_locals___most_fre
+#define __pyx_n_s_forest_predict_proba __pyx_mstate_global->__pyx_n_s_forest_predict_proba
 #define __pyx_n_s_format __pyx_mstate_global->__pyx_n_s_format
 #define __pyx_n_s_fortran __pyx_mstate_global->__pyx_n_s_fortran
 #define __pyx_n_u_fortran __pyx_mstate_global->__pyx_n_u_fortran
 #define __pyx_kp_u_gc __pyx_mstate_global->__pyx_kp_u_gc
-#define __pyx_n_s_get_leaf_matrix __pyx_mstate_global->__pyx_n_s_get_leaf_matrix
 #define __pyx_n_s_getstate __pyx_mstate_global->__pyx_n_s_getstate
 #define __pyx_kp_u_got __pyx_mstate_global->__pyx_kp_u_got
 #define __pyx_kp_u_got_2 __pyx_mstate_global->__pyx_kp_u_got_2
 #define __pyx_kp_u_got_differing_extents_in_dimensi __pyx_mstate_global->__pyx_kp_u_got_differing_extents_in_dimensi
-#define __pyx_n_s_ht __pyx_mstate_global->__pyx_n_s_ht
 #define __pyx_n_s_i __pyx_mstate_global->__pyx_n_s_i
 #define __pyx_n_s_id __pyx_mstate_global->__pyx_n_s_id
 #define __pyx_n_s_idx __pyx_mstate_global->__pyx_n_s_idx
 #define __pyx_n_s_import __pyx_mstate_global->__pyx_n_s_import
-#define __pyx_n_s_impurity_tol __pyx_mstate_global->__pyx_n_s_impurity_tol
 #define __pyx_n_s_index __pyx_mstate_global->__pyx_n_s_index
 #define __pyx_n_s_indices __pyx_mstate_global->__pyx_n_s_indices
-#define __pyx_n_s_init __pyx_mstate_global->__pyx_n_s_init
-#define __pyx_n_s_init_subclass __pyx_mstate_global->__pyx_n_s_init_subclass
 #define __pyx_n_s_initializing __pyx_mstate_global->__pyx_n_s_initializing
-#define __pyx_n_s_int __pyx_mstate_global->__pyx_n_s_int
-#define __pyx_n_s_int32 __pyx_mstate_global->__pyx_n_s_int32
 #define __pyx_n_s_is_coroutine __pyx_mstate_global->__pyx_n_s_is_coroutine
 #define __pyx_kp_u_isenabled __pyx_mstate_global->__pyx_kp_u_isenabled
 #define __pyx_n_s_itemsize __pyx_mstate_global->__pyx_n_s_itemsize
 #define __pyx_kp_s_itemsize_0_for_cython_array __pyx_mstate_global->__pyx_kp_s_itemsize_0_for_cython_array
 #define __pyx_n_s_ix __pyx_mstate_global->__pyx_n_s_ix
-#define __pyx_n_s_key __pyx_mstate_global->__pyx_n_s_key
 #define __pyx_n_s_keys __pyx_mstate_global->__pyx_n_s_keys
-#define __pyx_n_s_leaf_nodes __pyx_mstate_global->__pyx_n_s_leaf_nodes
+#define __pyx_n_s_kwargs __pyx_mstate_global->__pyx_n_s_kwargs
 #define __pyx_n_s_left_child __pyx_mstate_global->__pyx_n_s_left_child
-#define __pyx_n_s_lst __pyx_mstate_global->__pyx_n_s_lst
 #define __pyx_n_s_main __pyx_mstate_global->__pyx_n_s_main
-#define __pyx_n_s_matrix __pyx_mstate_global->__pyx_n_s_matrix
-#define __pyx_n_s_max_depth __pyx_mstate_global->__pyx_n_s_max_depth
-#define __pyx_n_s_maxsize __pyx_mstate_global->__pyx_n_s_maxsize
+#define __pyx_n_s_mean __pyx_mstate_global->__pyx_n_s_mean
 #define __pyx_n_s_memview __pyx_mstate_global->__pyx_n_s_memview
-#define __pyx_n_s_metaclass __pyx_mstate_global->__pyx_n_s_metaclass
-#define __pyx_n_s_min_improvement __pyx_mstate_global->__pyx_n_s_min_improvement
-#define __pyx_n_s_min_samples_leaf __pyx_mstate_global->__pyx_n_s_min_samples_leaf
-#define __pyx_n_s_min_samples_split __pyx_mstate_global->__pyx_n_s_min_samples_split
 #define __pyx_n_s_mode __pyx_mstate_global->__pyx_n_s_mode
-#define __pyx_n_s_module __pyx_mstate_global->__pyx_n_s_module
-#define __pyx_n_s_n_classes __pyx_mstate_global->__pyx_n_s_n_classes
-#define __pyx_n_s_n_features __pyx_mstate_global->__pyx_n_s_n_features
-#define __pyx_n_s_n_node __pyx_mstate_global->__pyx_n_s_n_node
-#define __pyx_n_s_n_nodes __pyx_mstate_global->__pyx_n_s_n_nodes
+#define __pyx_n_s_most_frequent_element __pyx_mstate_global->__pyx_n_s_most_frequent_element
 #define __pyx_n_s_n_obs __pyx_mstate_global->__pyx_n_s_n_obs
-#define __pyx_n_s_n_samples __pyx_mstate_global->__pyx_n_s_n_samples
 #define __pyx_n_s_name __pyx_mstate_global->__pyx_n_s_name
 #define __pyx_n_s_name_2 __pyx_mstate_global->__pyx_n_s_name_2
 #define __pyx_n_s_ndim __pyx_mstate_global->__pyx_n_s_ndim
 #define __pyx_n_s_new __pyx_mstate_global->__pyx_n_s_new
 #define __pyx_kp_s_no_default___reduce___due_to_non __pyx_mstate_global->__pyx_kp_s_no_default___reduce___due_to_non
-#define __pyx_n_s_node __pyx_mstate_global->__pyx_n_s_node
 #define __pyx_n_s_np __pyx_mstate_global->__pyx_n_s_np
 #define __pyx_kp_s_np_ndarray __pyx_mstate_global->__pyx_kp_s_np_ndarray
-#define __pyx_kp_s_np_ndarray_None __pyx_mstate_global->__pyx_kp_s_np_ndarray_None
 #define __pyx_n_s_numpy __pyx_mstate_global->__pyx_n_s_numpy
 #define __pyx_n_s_obj __pyx_mstate_global->__pyx_n_s_obj
-#define __pyx_n_s_object __pyx_mstate_global->__pyx_n_s_object
-#define __pyx_n_s_ones __pyx_mstate_global->__pyx_n_s_ones
 #define __pyx_n_s_pack __pyx_mstate_global->__pyx_n_s_pack
 #define __pyx_n_s_pickle __pyx_mstate_global->__pyx_n_s_pickle
 #define __pyx_n_s_predict __pyx_mstate_global->__pyx_n_s_predict
 #define __pyx_n_s_predict_leaf_matrix __pyx_mstate_global->__pyx_n_s_predict_leaf_matrix
 #define __pyx_n_s_predict_proba __pyx_mstate_global->__pyx_n_s_predict_proba
-#define __pyx_kp_s_predict_proba_can_only_be_called __pyx_mstate_global->__pyx_kp_s_predict_proba_can_only_be_called
-#define __pyx_n_s_prepare __pyx_mstate_global->__pyx_n_s_prepare
+#define __pyx_n_s_predictions __pyx_mstate_global->__pyx_n_s_predictions
 #define __pyx_n_s_pyx_PickleError __pyx_mstate_global->__pyx_n_s_pyx_PickleError
 #define __pyx_n_s_pyx_checksum __pyx_mstate_global->__pyx_n_s_pyx_checksum
 #define __pyx_n_s_pyx_result __pyx_mstate_global->__pyx_n_s_pyx_result
 #define __pyx_n_s_pyx_state __pyx_mstate_global->__pyx_n_s_pyx_state
 #define __pyx_n_s_pyx_type __pyx_mstate_global->__pyx_n_s_pyx_type
 #define __pyx_n_s_pyx_unpickle_Enum __pyx_mstate_global->__pyx_n_s_pyx_unpickle_Enum
 #define __pyx_n_s_pyx_vtable __pyx_mstate_global->__pyx_n_s_pyx_vtable
-#define __pyx_n_s_qualname __pyx_mstate_global->__pyx_n_s_qualname
+#define __pyx_n_s_quantile __pyx_mstate_global->__pyx_n_s_quantile
+#define __pyx_n_u_quantile __pyx_mstate_global->__pyx_n_u_quantile
 #define __pyx_n_s_range __pyx_mstate_global->__pyx_n_s_range
 #define __pyx_n_s_reduce __pyx_mstate_global->__pyx_n_s_reduce
 #define __pyx_n_s_reduce_cython __pyx_mstate_global->__pyx_n_s_reduce_cython
 #define __pyx_n_s_reduce_ex __pyx_mstate_global->__pyx_n_s_reduce_ex
 #define __pyx_n_s_register __pyx_mstate_global->__pyx_n_s_register
-#define __pyx_n_s_reshape __pyx_mstate_global->__pyx_n_s_reshape
-#define __pyx_n_s_ret_val __pyx_mstate_global->__pyx_n_s_ret_val
-#define __pyx_n_s_return __pyx_mstate_global->__pyx_n_s_return
+#define __pyx_n_s_return_counts __pyx_mstate_global->__pyx_n_s_return_counts
 #define __pyx_n_s_right_child __pyx_mstate_global->__pyx_n_s_right_child
 #define __pyx_n_s_root __pyx_mstate_global->__pyx_n_s_root
-#define __pyx_n_s_row __pyx_mstate_global->__pyx_n_s_row
-#define __pyx_n_s_sample_indices __pyx_mstate_global->__pyx_n_s_sample_indices
-#define __pyx_n_s_sample_weight __pyx_mstate_global->__pyx_n_s_sample_weight
-#define __pyx_kp_s_sample_weight_should_have_as_man __pyx_mstate_global->__pyx_kp_s_sample_weight_should_have_as_man
-#define __pyx_kp_s_sample_weight_should_have_dimens __pyx_mstate_global->__pyx_kp_s_sample_weight_should_have_dimens
+#define __pyx_n_s_save_indices __pyx_mstate_global->__pyx_n_s_save_indices
+#define __pyx_n_u_save_indices __pyx_mstate_global->__pyx_n_u_save_indices
 #define __pyx_n_s_scale __pyx_mstate_global->__pyx_n_s_scale
 #define __pyx_n_s_self __pyx_mstate_global->__pyx_n_s_self
-#define __pyx_n_s_set_name __pyx_mstate_global->__pyx_n_s_set_name
 #define __pyx_n_s_setstate __pyx_mstate_global->__pyx_n_s_setstate
 #define __pyx_n_s_setstate_cython __pyx_mstate_global->__pyx_n_s_setstate_cython
 #define __pyx_n_s_shape __pyx_mstate_global->__pyx_n_s_shape
 #define __pyx_n_s_size __pyx_mstate_global->__pyx_n_s_size
 #define __pyx_n_s_spec __pyx_mstate_global->__pyx_n_s_spec
 #define __pyx_n_s_split_idx __pyx_mstate_global->__pyx_n_s_split_idx
-#define __pyx_n_s_splitter __pyx_mstate_global->__pyx_n_s_splitter
-#define __pyx_kp_s_src_adaXT_decision_tree_Decision __pyx_mstate_global->__pyx_kp_s_src_adaXT_decision_tree_Decision
+#define __pyx_kp_s_src_adaXT_predict_predict_pyx __pyx_mstate_global->__pyx_kp_s_src_adaXT_predict_predict_pyx
+#define __pyx_n_s_stack __pyx_mstate_global->__pyx_n_s_stack
+#define __pyx_n_s_stacked_tree_predictions __pyx_mstate_global->__pyx_n_s_stacked_tree_predictions
 #define __pyx_n_s_start __pyx_mstate_global->__pyx_n_s_start
+#define __pyx_n_s_staticmethod __pyx_mstate_global->__pyx_n_s_staticmethod
 #define __pyx_n_s_step __pyx_mstate_global->__pyx_n_s_step
 #define __pyx_n_s_stop __pyx_mstate_global->__pyx_n_s_stop
-#define __pyx_n_s_str __pyx_mstate_global->__pyx_n_s_str
 #define __pyx_kp_s_strided_and_direct __pyx_mstate_global->__pyx_kp_s_strided_and_direct
 #define __pyx_kp_s_strided_and_direct_or_indirect __pyx_mstate_global->__pyx_kp_s_strided_and_direct_or_indirect
 #define __pyx_kp_s_strided_and_indirect __pyx_mstate_global->__pyx_kp_s_strided_and_indirect
 #define __pyx_kp_s_stringsource __pyx_mstate_global->__pyx_kp_s_stringsource
 #define __pyx_n_s_struct __pyx_mstate_global->__pyx_n_s_struct
-#define __pyx_n_s_super __pyx_mstate_global->__pyx_n_s_super
 #define __pyx_n_s_sys __pyx_mstate_global->__pyx_n_s_sys
 #define __pyx_n_s_test __pyx_mstate_global->__pyx_n_s_test
+#define __pyx_n_s_theta0 __pyx_mstate_global->__pyx_n_s_theta0
+#define __pyx_n_s_theta1 __pyx_mstate_global->__pyx_n_s_theta1
 #define __pyx_n_s_threshold __pyx_mstate_global->__pyx_n_s_threshold
-#define __pyx_n_s_tree_type __pyx_mstate_global->__pyx_n_s_tree_type
-#define __pyx_n_s_tree_types __pyx_mstate_global->__pyx_n_s_tree_types
 #define __pyx_kp_s_unable_to_allocate_array_data __pyx_mstate_global->__pyx_kp_s_unable_to_allocate_array_data
 #define __pyx_kp_s_unable_to_allocate_shape_and_str __pyx_mstate_global->__pyx_kp_s_unable_to_allocate_shape_and_str
+#define __pyx_n_s_unique __pyx_mstate_global->__pyx_n_s_unique
 #define __pyx_n_s_unpack __pyx_mstate_global->__pyx_n_s_unpack
 #define __pyx_n_s_update __pyx_mstate_global->__pyx_n_s_update
-#define __pyx_n_s_val __pyx_mstate_global->__pyx_n_s_val
 #define __pyx_n_s_value __pyx_mstate_global->__pyx_n_s_value
+#define __pyx_n_s_values __pyx_mstate_global->__pyx_n_s_values
 #define __pyx_n_s_version_info __pyx_mstate_global->__pyx_n_s_version_info
 #define __pyx_n_s_zeros __pyx_mstate_global->__pyx_n_s_zeros
 #define __pyx_int_0 __pyx_mstate_global->__pyx_int_0
 #define __pyx_int_1 __pyx_mstate_global->__pyx_int_1
-#define __pyx_int_2 __pyx_mstate_global->__pyx_int_2
 #define __pyx_int_3 __pyx_mstate_global->__pyx_int_3
 #define __pyx_int_112105877 __pyx_mstate_global->__pyx_int_112105877
 #define __pyx_int_136983863 __pyx_mstate_global->__pyx_int_136983863
 #define __pyx_int_184977713 __pyx_mstate_global->__pyx_int_184977713
 #define __pyx_int_neg_1 __pyx_mstate_global->__pyx_int_neg_1
 #define __pyx_slice__5 __pyx_mstate_global->__pyx_slice__5
 #define __pyx_tuple__4 __pyx_mstate_global->__pyx_tuple__4
 #define __pyx_tuple__8 __pyx_mstate_global->__pyx_tuple__8
 #define __pyx_tuple__9 __pyx_mstate_global->__pyx_tuple__9
 #define __pyx_tuple__10 __pyx_mstate_global->__pyx_tuple__10
 #define __pyx_tuple__11 __pyx_mstate_global->__pyx_tuple__11
 #define __pyx_tuple__12 __pyx_mstate_global->__pyx_tuple__12
-#define __pyx_tuple__13 __pyx_mstate_global->__pyx_tuple__13
 #define __pyx_tuple__14 __pyx_mstate_global->__pyx_tuple__14
 #define __pyx_tuple__15 __pyx_mstate_global->__pyx_tuple__15
 #define __pyx_tuple__16 __pyx_mstate_global->__pyx_tuple__16
 #define __pyx_tuple__17 __pyx_mstate_global->__pyx_tuple__17
 #define __pyx_tuple__18 __pyx_mstate_global->__pyx_tuple__18
 #define __pyx_tuple__19 __pyx_mstate_global->__pyx_tuple__19
 #define __pyx_tuple__20 __pyx_mstate_global->__pyx_tuple__20
 #define __pyx_tuple__21 __pyx_mstate_global->__pyx_tuple__21
 #define __pyx_tuple__22 __pyx_mstate_global->__pyx_tuple__22
 #define __pyx_tuple__23 __pyx_mstate_global->__pyx_tuple__23
-#define __pyx_tuple__24 __pyx_mstate_global->__pyx_tuple__24
 #define __pyx_tuple__25 __pyx_mstate_global->__pyx_tuple__25
-#define __pyx_tuple__26 __pyx_mstate_global->__pyx_tuple__26
-#define __pyx_tuple__28 __pyx_mstate_global->__pyx_tuple__28
+#define __pyx_tuple__27 __pyx_mstate_global->__pyx_tuple__27
 #define __pyx_tuple__29 __pyx_mstate_global->__pyx_tuple__29
 #define __pyx_tuple__31 __pyx_mstate_global->__pyx_tuple__31
 #define __pyx_tuple__33 __pyx_mstate_global->__pyx_tuple__33
-#define __pyx_tuple__35 __pyx_mstate_global->__pyx_tuple__35
+#define __pyx_tuple__34 __pyx_mstate_global->__pyx_tuple__34
 #define __pyx_tuple__37 __pyx_mstate_global->__pyx_tuple__37
-#define __pyx_tuple__39 __pyx_mstate_global->__pyx_tuple__39
 #define __pyx_tuple__40 __pyx_mstate_global->__pyx_tuple__40
 #define __pyx_tuple__42 __pyx_mstate_global->__pyx_tuple__42
 #define __pyx_tuple__44 __pyx_mstate_global->__pyx_tuple__44
-#define __pyx_tuple__46 __pyx_mstate_global->__pyx_tuple__46
 #define __pyx_tuple__48 __pyx_mstate_global->__pyx_tuple__48
-#define __pyx_tuple__49 __pyx_mstate_global->__pyx_tuple__49
-#define __pyx_codeobj__27 __pyx_mstate_global->__pyx_codeobj__27
+#define __pyx_tuple__50 __pyx_mstate_global->__pyx_tuple__50
+#define __pyx_codeobj__13 __pyx_mstate_global->__pyx_codeobj__13
+#define __pyx_codeobj__24 __pyx_mstate_global->__pyx_codeobj__24
+#define __pyx_codeobj__26 __pyx_mstate_global->__pyx_codeobj__26
+#define __pyx_codeobj__28 __pyx_mstate_global->__pyx_codeobj__28
 #define __pyx_codeobj__30 __pyx_mstate_global->__pyx_codeobj__30
 #define __pyx_codeobj__32 __pyx_mstate_global->__pyx_codeobj__32
-#define __pyx_codeobj__34 __pyx_mstate_global->__pyx_codeobj__34
+#define __pyx_codeobj__35 __pyx_mstate_global->__pyx_codeobj__35
 #define __pyx_codeobj__36 __pyx_mstate_global->__pyx_codeobj__36
 #define __pyx_codeobj__38 __pyx_mstate_global->__pyx_codeobj__38
+#define __pyx_codeobj__39 __pyx_mstate_global->__pyx_codeobj__39
 #define __pyx_codeobj__41 __pyx_mstate_global->__pyx_codeobj__41
 #define __pyx_codeobj__43 __pyx_mstate_global->__pyx_codeobj__43
 #define __pyx_codeobj__45 __pyx_mstate_global->__pyx_codeobj__45
+#define __pyx_codeobj__46 __pyx_mstate_global->__pyx_codeobj__46
 #define __pyx_codeobj__47 __pyx_mstate_global->__pyx_codeobj__47
-#define __pyx_codeobj__50 __pyx_mstate_global->__pyx_codeobj__50
+#define __pyx_codeobj__49 __pyx_mstate_global->__pyx_codeobj__49
+#define __pyx_codeobj__51 __pyx_mstate_global->__pyx_codeobj__51
 /* #### Code section: module_code ### */
 
 /* "View.MemoryView":131
  *         cdef bint dtype_is_object
  * 
  *     def __cinit__(array self, tuple shape, Py_ssize_t itemsize, format not None,             # <<<<<<<<<<<<<<
  *                   mode="c", bint allocate_buffer=True):
@@ -18239,3056 +18193,3160 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":18
+/* "adaXT/predict/predict.pyx":8
+ * cdef class Predict():
+ * 
+ *     def __cinit__(self, double[:, ::1] X, double[::1] Y, object root):             # <<<<<<<<<<<<<<
+ *         self.X = X
+ *         self.Y = Y
+ */
+
+/* Python wrapper */
+static int __pyx_pw_5adaXT_7predict_7predict_7Predict_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_5adaXT_7predict_7predict_7Predict_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  __Pyx_memviewslice __pyx_v_X = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_Y = { 0, 0, { 0 }, { 0 }, { 0 } };
+  PyObject *__pyx_v_root = 0;
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[3] = {0,0,0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return -1;
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_Y,&__pyx_n_s_root,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
+          (void)__Pyx_Arg_NewRef_VARARGS(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_Y)) != 0)) {
+          (void)__Pyx_Arg_NewRef_VARARGS(values[1]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 1); __PYX_ERR(0, 8, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_root)) != 0)) {
+          (void)__Pyx_Arg_NewRef_VARARGS(values[2]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 2); __PYX_ERR(0, 8, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__cinit__") < 0)) __PYX_ERR(0, 8, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 3)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+      values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+      values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
+    }
+    __pyx_v_X = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_X.memview)) __PYX_ERR(0, 8, __pyx_L3_error)
+    __pyx_v_Y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_Y.memview)) __PYX_ERR(0, 8, __pyx_L3_error)
+    __pyx_v_root = values[2];
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 8, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
+    }
+  }
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return -1;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_7Predict___cinit__(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self), __pyx_v_X, __pyx_v_Y, __pyx_v_root);
+
+  /* function exit code */
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static int __pyx_pf_5adaXT_7predict_7predict_7Predict___cinit__(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, __Pyx_memviewslice __pyx_v_X, __Pyx_memviewslice __pyx_v_Y, PyObject *__pyx_v_root) {
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__cinit__", 1);
+
+  /* "adaXT/predict/predict.pyx":9
+ * 
+ *     def __cinit__(self, double[:, ::1] X, double[::1] Y, object root):
+ *         self.X = X             # <<<<<<<<<<<<<<
+ *         self.Y = Y
+ *         self.n_features = X.shape[1]
+ */
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->X, 0);
+  __PYX_INC_MEMVIEW(&__pyx_v_X, 1);
+  __pyx_v_self->X = __pyx_v_X;
+
+  /* "adaXT/predict/predict.pyx":10
+ *     def __cinit__(self, double[:, ::1] X, double[::1] Y, object root):
+ *         self.X = X
+ *         self.Y = Y             # <<<<<<<<<<<<<<
+ *         self.n_features = X.shape[1]
+ *         self.root = root
+ */
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->Y, 0);
+  __PYX_INC_MEMVIEW(&__pyx_v_Y, 1);
+  __pyx_v_self->Y = __pyx_v_Y;
+
+  /* "adaXT/predict/predict.pyx":11
+ *         self.X = X
+ *         self.Y = Y
+ *         self.n_features = X.shape[1]             # <<<<<<<<<<<<<<
+ *         self.root = root
+ * 
+ */
+  __pyx_v_self->n_features = (__pyx_v_X.shape[1]);
+
+  /* "adaXT/predict/predict.pyx":12
+ *         self.Y = Y
+ *         self.n_features = X.shape[1]
+ *         self.root = root             # <<<<<<<<<<<<<<
+ * 
+ *     def __reduce__(self):
+ */
+  __Pyx_INCREF(__pyx_v_root);
+  __Pyx_GIVEREF(__pyx_v_root);
+  __Pyx_GOTREF(__pyx_v_self->root);
+  __Pyx_DECREF(__pyx_v_self->root);
+  __pyx_v_self->root = __pyx_v_root;
+
+  /* "adaXT/predict/predict.pyx":8
+ * cdef class Predict():
+ * 
+ *     def __cinit__(self, double[:, ::1] X, double[::1] Y, object root):             # <<<<<<<<<<<<<<
+ *         self.X = X
+ *         self.Y = Y
+ */
+
+  /* function exit code */
+  __pyx_r = 0;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/predict/predict.pyx":14
+ *         self.root = root
+ * 
+ *     def __reduce__(self):             # <<<<<<<<<<<<<<
+ *         return (self.__class__, (self.X.base, self.Y.base, self.root))
  * 
- * class DecisionTree:
- *     def __init__(             # <<<<<<<<<<<<<<
- *             self,
- *             tree_type: str,
  */
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree___defaults__(CYTHON_UNUSED PyObject *__pyx_self) {
+/* Python wrapper */
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_3__reduce__(PyObject *__pyx_v_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_7Predict_3__reduce__ = {"__reduce__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_3__reduce__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_3__reduce__(PyObject *__pyx_v_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__reduce__ (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  if (unlikely(__pyx_nargs > 0)) {
+    __Pyx_RaiseArgtupleInvalid("__reduce__", 1, 0, 0, __pyx_nargs); return NULL;}
+  if (unlikely(__pyx_kwds) && __Pyx_NumKwargs_FASTCALL(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__reduce__", 0))) return NULL;
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_7Predict_2__reduce__(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_2__reduce__(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__defaults__", 1);
-  __Pyx_XDECREF(__pyx_r);
+  __Pyx_RefNannySetupContext("__reduce__", 1);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":23
- *             criteria: Criteria,
- *             max_depth: int = sys.maxsize,
- *             impurity_tol: float = 0,             # <<<<<<<<<<<<<<
- *             min_samples_split: int = 1,
- *             min_samples_leaf: int = 1,
- */
-  __pyx_t_1 = PyFloat_FromDouble(((double)0.0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 23, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":26
- *             min_samples_split: int = 1,
- *             min_samples_leaf: int = 1,
- *             min_improvement: float = 0,             # <<<<<<<<<<<<<<
- *             splitter: Splitter | None = None) -> None:
+  /* "adaXT/predict/predict.pyx":15
  * 
- */
-  __pyx_t_2 = PyFloat_FromDouble(((double)0.0)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 26, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":18
+ *     def __reduce__(self):
+ *         return (self.__class__, (self.X.base, self.Y.base, self.root))             # <<<<<<<<<<<<<<
  * 
- * class DecisionTree:
- *     def __init__(             # <<<<<<<<<<<<<<
- *             self,
- *             tree_type: str,
+ *     cdef double[:, ::1] __check_dimensions(self, object X):
  */
-  __pyx_t_3 = PyTuple_New(6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_class); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_self->X, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_base); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 15, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_INCREF(__Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_max_depth);
-  __Pyx_GIVEREF(__Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_max_depth);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_max_depth)) __PYX_ERR(0, 18, __pyx_L1_error);
-  __Pyx_GIVEREF(__pyx_t_1);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1)) __PYX_ERR(0, 18, __pyx_L1_error);
-  __Pyx_INCREF(__Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_min_samples_split);
-  __Pyx_GIVEREF(__Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_min_samples_split);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 2, __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_min_samples_split)) __PYX_ERR(0, 18, __pyx_L1_error);
-  __Pyx_INCREF(__Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_min_samples_leaf);
-  __Pyx_GIVEREF(__Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_min_samples_leaf);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 3, __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self)->__pyx_arg_min_samples_leaf)) __PYX_ERR(0, 18, __pyx_L1_error);
-  __Pyx_GIVEREF(__pyx_t_2);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 4, __pyx_t_2)) __PYX_ERR(0, 18, __pyx_L1_error);
-  __Pyx_INCREF(Py_None);
-  __Pyx_GIVEREF(Py_None);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 5, Py_None)) __PYX_ERR(0, 18, __pyx_L1_error);
-  __pyx_t_1 = 0;
-  __pyx_t_2 = 0;
-  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_self->Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_base); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 15, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_3);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3)) __PYX_ERR(0, 18, __pyx_L1_error);
-  __Pyx_INCREF(Py_None);
-  __Pyx_GIVEREF(Py_None);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 1, Py_None)) __PYX_ERR(0, 18, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3)) __PYX_ERR(0, 15, __pyx_L1_error);
+  __Pyx_GIVEREF(__pyx_t_4);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_4)) __PYX_ERR(0, 15, __pyx_L1_error);
+  __Pyx_INCREF(__pyx_v_self->root);
+  __Pyx_GIVEREF(__pyx_v_self->root);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_v_self->root)) __PYX_ERR(0, 15, __pyx_L1_error);
   __pyx_t_3 = 0;
-  __pyx_r = __pyx_t_2;
+  __pyx_t_4 = 0;
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 15, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_1);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1)) __PYX_ERR(0, 15, __pyx_L1_error);
+  __Pyx_GIVEREF(__pyx_t_2);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2)) __PYX_ERR(0, 15, __pyx_L1_error);
+  __pyx_t_1 = 0;
   __pyx_t_2 = 0;
+  __pyx_r = __pyx_t_4;
+  __pyx_t_4 = 0;
   goto __pyx_L0;
 
+  /* "adaXT/predict/predict.pyx":14
+ *         self.root = root
+ * 
+ *     def __reduce__(self):             # <<<<<<<<<<<<<<
+ *         return (self.__class__, (self.X.base, self.Y.base, self.root))
+ * 
+ */
+
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.__defaults__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.__reduce__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
+/* "adaXT/predict/predict.pyx":17
+ *         return (self.__class__, (self.X.base, self.Y.base, self.root))
+ * 
+ *     cdef double[:, ::1] __check_dimensions(self, object X):             # <<<<<<<<<<<<<<
+ *         X = np.ascontiguousarray(X, dtype=DOUBLE)
+ *         # If there is only a single point
+ */
+
+static __Pyx_memviewslice __pyx_f_5adaXT_7predict_7predict_7Predict__Predict__check_dimensions(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, PyObject *__pyx_v_X) {
+  __Pyx_memviewslice __pyx_r = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  Py_ssize_t __pyx_t_6;
+  Py_UCS4 __pyx_t_7;
+  __Pyx_memviewslice __pyx_t_8 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("_Predict__check_dimensions", 0);
+  __Pyx_INCREF(__pyx_v_X);
+
+  /* "adaXT/predict/predict.pyx":18
+ * 
+ *     cdef double[:, ::1] __check_dimensions(self, object X):
+ *         X = np.ascontiguousarray(X, dtype=DOUBLE)             # <<<<<<<<<<<<<<
+ *         # If there is only a single point
+ *         if X.ndim == 1:
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_v_X);
+  __Pyx_GIVEREF(__pyx_v_X);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_X)) __PYX_ERR(0, 18, __pyx_L1_error);
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DOUBLE); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_4) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "adaXT/predict/predict.pyx":20
+ *         X = np.ascontiguousarray(X, dtype=DOUBLE)
+ *         # If there is only a single point
+ *         if X.ndim == 1:             # <<<<<<<<<<<<<<
+ *             if (X.shape[0] != self.n_features):
+ *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")
+ */
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_ndim); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 20, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = (__Pyx_PyInt_BoolEqObjC(__pyx_t_4, __pyx_int_1, 1, 0)); if (unlikely((__pyx_t_5 < 0))) __PYX_ERR(0, 20, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (__pyx_t_5) {
+
+    /* "adaXT/predict/predict.pyx":21
+ *         # If there is only a single point
+ *         if X.ndim == 1:
+ *             if (X.shape[0] != self.n_features):             # <<<<<<<<<<<<<<
+ *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")
+ * 
+ */
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 21, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_4, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 21, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_self->n_features); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 21, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_1 = PyObject_RichCompare(__pyx_t_3, __pyx_t_4, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 21, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_5 < 0))) __PYX_ERR(0, 21, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (unlikely(__pyx_t_5)) {
+
+      /* "adaXT/predict/predict.pyx":22
+ *         if X.ndim == 1:
+ *             if (X.shape[0] != self.n_features):
+ *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")             # <<<<<<<<<<<<<<
+ * 
+ *             # expand the dimensions
+ */
+      __pyx_t_1 = PyTuple_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 22, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_6 = 0;
+      __pyx_t_7 = 127;
+      __Pyx_INCREF(__pyx_kp_u_Number_of_features_should_be);
+      __pyx_t_6 += 29;
+      __Pyx_GIVEREF(__pyx_kp_u_Number_of_features_should_be);
+      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Number_of_features_should_be);
+      __pyx_t_4 = __Pyx_PyUnicode_From_int(__pyx_v_self->n_features, 0, ' ', 'd'); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 22, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_4);
+      __pyx_t_4 = 0;
+      __Pyx_INCREF(__pyx_kp_u_got_2);
+      __pyx_t_6 += 6;
+      __Pyx_GIVEREF(__pyx_kp_u_got_2);
+      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_got_2);
+      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 22, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_4, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 22, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_t_3, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 22, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_7;
+      __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_1, 4, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 22, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 22, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __PYX_ERR(0, 22, __pyx_L1_error)
+
+      /* "adaXT/predict/predict.pyx":21
+ *         # If there is only a single point
+ *         if X.ndim == 1:
+ *             if (X.shape[0] != self.n_features):             # <<<<<<<<<<<<<<
+ *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")
+ * 
+ */
+    }
+
+    /* "adaXT/predict/predict.pyx":25
+ * 
+ *             # expand the dimensions
+ *             X = np.expand_dims(X, axis=0)             # <<<<<<<<<<<<<<
+ *         else:
+ *             if X.shape[1] != self.n_features:
+ */
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 25, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_expand_dims); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 25, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 25, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_INCREF(__pyx_v_X);
+    __Pyx_GIVEREF(__pyx_v_X);
+    if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_X)) __PYX_ERR(0, 25, __pyx_L1_error);
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 25, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_axis, __pyx_int_0) < 0) __PYX_ERR(0, 25, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 25, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_2);
+    __pyx_t_2 = 0;
+
+    /* "adaXT/predict/predict.pyx":20
+ *         X = np.ascontiguousarray(X, dtype=DOUBLE)
+ *         # If there is only a single point
+ *         if X.ndim == 1:             # <<<<<<<<<<<<<<
+ *             if (X.shape[0] != self.n_features):
+ *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")
+ */
+    goto __pyx_L3;
+  }
+
+  /* "adaXT/predict/predict.pyx":27
+ *             X = np.expand_dims(X, axis=0)
+ *         else:
+ *             if X.shape[1] != self.n_features:             # <<<<<<<<<<<<<<
+ *                 raise ValueError(f"Dimension should be {self.n_features}, got {X.shape[1]}")
+ *         return X
+ */
+  /*else*/ {
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 27, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_2, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 27, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->n_features); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 27, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_1 = PyObject_RichCompare(__pyx_t_3, __pyx_t_2, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 27, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_5 < 0))) __PYX_ERR(0, 27, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (unlikely(__pyx_t_5)) {
+
+      /* "adaXT/predict/predict.pyx":28
+ *         else:
+ *             if X.shape[1] != self.n_features:
+ *                 raise ValueError(f"Dimension should be {self.n_features}, got {X.shape[1]}")             # <<<<<<<<<<<<<<
+ *         return X
+ * 
+ */
+      __pyx_t_1 = PyTuple_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_6 = 0;
+      __pyx_t_7 = 127;
+      __Pyx_INCREF(__pyx_kp_u_Dimension_should_be);
+      __pyx_t_6 += 20;
+      __Pyx_GIVEREF(__pyx_kp_u_Dimension_should_be);
+      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Dimension_should_be);
+      __pyx_t_2 = __Pyx_PyUnicode_From_int(__pyx_v_self->n_features, 0, ' ', 'd'); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 28, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_2);
+      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
+      __pyx_t_2 = 0;
+      __Pyx_INCREF(__pyx_kp_u_got_2);
+      __pyx_t_6 += 6;
+      __Pyx_GIVEREF(__pyx_kp_u_got_2);
+      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_got_2);
+      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 28, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_2, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 28, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_t_3, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 28, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_7;
+      __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_2);
+      PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_2);
+      __pyx_t_2 = 0;
+      __pyx_t_2 = __Pyx_PyUnicode_Join(__pyx_t_1, 4, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 28, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __PYX_ERR(0, 28, __pyx_L1_error)
+
+      /* "adaXT/predict/predict.pyx":27
+ *             X = np.expand_dims(X, axis=0)
+ *         else:
+ *             if X.shape[1] != self.n_features:             # <<<<<<<<<<<<<<
+ *                 raise ValueError(f"Dimension should be {self.n_features}, got {X.shape[1]}")
+ *         return X
+ */
+    }
+  }
+  __pyx_L3:;
+
+  /* "adaXT/predict/predict.pyx":29
+ *             if X.shape[1] != self.n_features:
+ *                 raise ValueError(f"Dimension should be {self.n_features}, got {X.shape[1]}")
+ *         return X             # <<<<<<<<<<<<<<
+ * 
+ *     def predict(self, object X, **kwargs):
+ */
+  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_X, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 29, __pyx_L1_error)
+  __pyx_r = __pyx_t_8;
+  __pyx_t_8.memview = NULL;
+  __pyx_t_8.data = NULL;
+  goto __pyx_L0;
+
+  /* "adaXT/predict/predict.pyx":17
+ *         return (self.__class__, (self.X.base, self.Y.base, self.root))
+ * 
+ *     cdef double[:, ::1] __check_dimensions(self, object X):             # <<<<<<<<<<<<<<
+ *         X = np.ascontiguousarray(X, dtype=DOUBLE)
+ *         # If there is only a single point
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_8, 1);
+  __pyx_r.data = NULL;
+  __pyx_r.memview = NULL;
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict._Predict__check_dimensions", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  goto __pyx_L2;
+  __pyx_L0:;
+  if (unlikely(!__pyx_r.memview)) {
+    PyErr_SetString(PyExc_TypeError, "Memoryview return value is not initialized");
+  }
+  __pyx_L2:;
+  __Pyx_XDECREF(__pyx_v_X);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/predict/predict.pyx":31
+ *         return X
+ * 
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")
+ * 
+ */
+
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_1__init__(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_5predict(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_1__init__ = {"__init__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_1__init__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_1__init__(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_7Predict_5predict = {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_5predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_5predict(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  PyObject *__pyx_v_self = 0;
-  PyObject *__pyx_v_tree_type = 0;
-  PyObject *__pyx_v_criteria = 0;
-  PyObject *__pyx_v_max_depth = 0;
-  double __pyx_v_impurity_tol;
-  PyObject *__pyx_v_min_samples_split = 0;
-  PyObject *__pyx_v_min_samples_leaf = 0;
-  double __pyx_v_min_improvement;
-  PyObject *__pyx_v_splitter = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_X = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[9] = {0,0,0,0,0,0,0,0,0};
+  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
+  __Pyx_RefNannySetupContext("predict (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
   #if CYTHON_ASSUME_SAFE_MACROS
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_tree_type,&__pyx_n_s_criteria,&__pyx_n_s_max_depth,&__pyx_n_s_impurity_tol,&__pyx_n_s_min_samples_split,&__pyx_n_s_min_samples_leaf,&__pyx_n_s_min_improvement,&__pyx_n_s_splitter,0};
-    __pyx_defaults *__pyx_dynamic_args = __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_self);
-    values[3] = __Pyx_Arg_NewRef_FASTCALL(__pyx_dynamic_args->__pyx_arg_max_depth);
-    values[5] = __Pyx_Arg_NewRef_FASTCALL(__pyx_dynamic_args->__pyx_arg_min_samples_split);
-    values[6] = __Pyx_Arg_NewRef_FASTCALL(__pyx_dynamic_args->__pyx_arg_min_samples_leaf);
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":27
- *             min_samples_leaf: int = 1,
- *             min_improvement: float = 0,
- *             splitter: Splitter | None = None) -> None:             # <<<<<<<<<<<<<<
- * 
- *         tree_types = ["Classification", "Regression"]
- */
-    values[8] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)Py_None));
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  9: values[8] = __Pyx_Arg_FASTCALL(__pyx_args, 8);
-        CYTHON_FALLTHROUGH;
-        case  8: values[7] = __Pyx_Arg_FASTCALL(__pyx_args, 7);
-        CYTHON_FALLTHROUGH;
-        case  7: values[6] = __Pyx_Arg_FASTCALL(__pyx_args, 6);
-        CYTHON_FALLTHROUGH;
-        case  6: values[5] = __Pyx_Arg_FASTCALL(__pyx_args, 5);
-        CYTHON_FALLTHROUGH;
-        case  5: values[4] = __Pyx_Arg_FASTCALL(__pyx_args, 4);
-        CYTHON_FALLTHROUGH;
-        case  4: values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
-        CYTHON_FALLTHROUGH;
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
         case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 18, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 31, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_tree_type)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 18, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 9, 1); __PYX_ERR(0, 18, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_criteria)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 18, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 9, 2); __PYX_ERR(0, 18, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  3:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_max_depth);
-          if (value) { values[3] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 18, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  4:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_impurity_tol);
-          if (value) { values[4] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 18, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  5:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_min_samples_split);
-          if (value) { values[5] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 18, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  6:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_min_samples_leaf);
-          if (value) { values[6] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 18, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  7:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_min_improvement);
-          if (value) { values[7] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 18, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  8:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_splitter);
-          if (value) { values[8] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 18, __pyx_L3_error)
-        }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 18, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "predict") < 0)) __PYX_ERR(0, 31, __pyx_L3_error)
       }
+    } else if (unlikely(__pyx_nargs != 1)) {
+      goto __pyx_L5_argtuple_error;
     } else {
-      switch (__pyx_nargs) {
-        case  9: values[8] = __Pyx_Arg_FASTCALL(__pyx_args, 8);
-        CYTHON_FALLTHROUGH;
-        case  8: values[7] = __Pyx_Arg_FASTCALL(__pyx_args, 7);
-        CYTHON_FALLTHROUGH;
-        case  7: values[6] = __Pyx_Arg_FASTCALL(__pyx_args, 6);
-        CYTHON_FALLTHROUGH;
-        case  6: values[5] = __Pyx_Arg_FASTCALL(__pyx_args, 5);
-        CYTHON_FALLTHROUGH;
-        case  5: values[4] = __Pyx_Arg_FASTCALL(__pyx_args, 4);
-        CYTHON_FALLTHROUGH;
-        case  4: values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
-        CYTHON_FALLTHROUGH;
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
-        values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        break;
-        default: goto __pyx_L5_argtuple_error;
-      }
-    }
-    __pyx_v_self = values[0];
-    __pyx_v_tree_type = ((PyObject*)values[1]);
-    __pyx_v_criteria = values[2];
-    __pyx_v_max_depth = ((PyObject*)values[3]);
-    if (values[4]) {
-      __pyx_v_impurity_tol = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_impurity_tol == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 23, __pyx_L3_error)
-    } else {
-      __pyx_v_impurity_tol = ((double)((double)0.0));
-    }
-    __pyx_v_min_samples_split = ((PyObject*)values[5]);
-    __pyx_v_min_samples_leaf = ((PyObject*)values[6]);
-    if (values[7]) {
-      __pyx_v_min_improvement = __pyx_PyFloat_AsDouble(values[7]); if (unlikely((__pyx_v_min_improvement == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 26, __pyx_L3_error)
-    } else {
-      __pyx_v_min_improvement = ((double)((double)0.0));
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_splitter = values[8];
+    __pyx_v_X = values[0];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 3, 9, __pyx_nargs); __PYX_ERR(0, 18, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("predict", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 31, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_tree_type), (&PyString_Type), 0, "tree_type", 1))) __PYX_ERR(0, 20, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_max_depth), (&PyInt_Type), 0, "max_depth", 1))) __PYX_ERR(0, 22, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_min_samples_split), (&PyInt_Type), 0, "min_samples_split", 1))) __PYX_ERR(0, 24, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_min_samples_leaf), (&PyInt_Type), 0, "min_samples_leaf", 1))) __PYX_ERR(0, 25, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree___init__(__pyx_self, __pyx_v_self, __pyx_v_tree_type, __pyx_v_criteria, __pyx_v_max_depth, __pyx_v_impurity_tol, __pyx_v_min_samples_split, __pyx_v_min_samples_leaf, __pyx_v_min_improvement, __pyx_v_splitter);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":18
- * 
- * class DecisionTree:
- *     def __init__(             # <<<<<<<<<<<<<<
- *             self,
- *             tree_type: str,
- */
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_7Predict_4predict(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self), __pyx_v_X, __pyx_v_kwargs);
 
   /* function exit code */
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __pyx_r = NULL;
-  __pyx_L0:;
+  __Pyx_DECREF(__pyx_v_kwargs);
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_tree_type, PyObject *__pyx_v_criteria, PyObject *__pyx_v_max_depth, double __pyx_v_impurity_tol, PyObject *__pyx_v_min_samples_split, PyObject *__pyx_v_min_samples_leaf, double __pyx_v_min_improvement, PyObject *__pyx_v_splitter) {
-  PyObject *__pyx_v_tree_types = NULL;
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_4predict(CYTHON_UNUSED struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__init__", 1);
+  __Pyx_RefNannySetupContext("predict", 1);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":29
- *             splitter: Splitter | None = None) -> None:
+  /* "adaXT/predict/predict.pyx":32
  * 
- *         tree_types = ["Classification", "Regression"]             # <<<<<<<<<<<<<<
- *         assert tree_type in tree_types, f"Expected Classification or Regression as tree type, got: {tree_type}"
- *         self.max_depth = max_depth
+ *     def predict(self, object X, **kwargs):
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef list predict_proba(self, object X):
  */
-  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 32, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_INCREF(__pyx_n_s_Classification);
-  __Pyx_GIVEREF(__pyx_n_s_Classification);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_Classification)) __PYX_ERR(0, 29, __pyx_L1_error);
-  __Pyx_INCREF(__pyx_n_s_Regression);
-  __Pyx_GIVEREF(__pyx_n_s_Regression);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_Regression)) __PYX_ERR(0, 29, __pyx_L1_error);
-  __pyx_v_tree_types = ((PyObject*)__pyx_t_1);
-  __pyx_t_1 = 0;
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(0, 32, __pyx_L1_error)
+
+  /* "adaXT/predict/predict.pyx":31
+ *         return X
+ * 
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":30
+/* "adaXT/predict/predict.pyx":34
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")
+ * 
+ *     cpdef list predict_proba(self, object X):             # <<<<<<<<<<<<<<
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")
  * 
- *         tree_types = ["Classification", "Regression"]
- *         assert tree_type in tree_types, f"Expected Classification or Regression as tree type, got: {tree_type}"             # <<<<<<<<<<<<<<
- *         self.max_depth = max_depth
- *         self.impurity_tol = impurity_tol
  */
-  #ifndef CYTHON_WITHOUT_ASSERTIONS
-  if (unlikely(__pyx_assertions_enabled())) {
-    __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_tree_type, __pyx_v_tree_types, Py_EQ)); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 30, __pyx_L1_error)
-    if (unlikely(!__pyx_t_2)) {
-      __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_tree_type, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 30, __pyx_L1_error)
+
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_7predict_proba(PyObject *__pyx_v_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyObject *__pyx_f_5adaXT_7predict_7predict_7Predict_predict_proba(CYTHON_UNUSED struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_X, int __pyx_skip_dispatch) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("predict_proba", 1);
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || __Pyx_PyType_HasFeature(Py_TYPE(((PyObject *)__pyx_v_self)), (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_typedict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_predict_proba); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Expected_Classification_or_Regre, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
+      if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_7predict_7predict_7Predict_7predict_proba)) {
+        __Pyx_XDECREF(__pyx_r);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
+        __pyx_t_5 = 0;
+        #if CYTHON_UNPACK_METHODS
+        if (unlikely(PyMethod_Check(__pyx_t_3))) {
+          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+          if (likely(__pyx_t_4)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+            __Pyx_INCREF(__pyx_t_4);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_3, function);
+            __pyx_t_5 = 1;
+          }
+        }
+        #endif
+        {
+          PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_v_X};
+          __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
+          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+          if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 34, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        }
+        if (!(likely(PyList_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None) || __Pyx_RaiseUnexpectedTypeError("list", __pyx_t_2))) __PYX_ERR(0, 34, __pyx_L1_error)
+        __pyx_r = ((PyObject*)__pyx_t_2);
+        __pyx_t_2 = 0;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_typedict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_Raise(__pyx_builtin_AssertionError, __pyx_t_3, 0, 0);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 30, __pyx_L1_error)
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     }
+    #endif
   }
-  #else
-  if ((1)); else __PYX_ERR(0, 30, __pyx_L1_error)
-  #endif
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":31
- *         tree_types = ["Classification", "Regression"]
- *         assert tree_type in tree_types, f"Expected Classification or Regression as tree type, got: {tree_type}"
- *         self.max_depth = max_depth             # <<<<<<<<<<<<<<
- *         self.impurity_tol = impurity_tol
- *         self.min_samples_split = min_samples_split
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_max_depth, __pyx_v_max_depth) < 0) __PYX_ERR(0, 31, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":32
- *         assert tree_type in tree_types, f"Expected Classification or Regression as tree type, got: {tree_type}"
- *         self.max_depth = max_depth
- *         self.impurity_tol = impurity_tol             # <<<<<<<<<<<<<<
- *         self.min_samples_split = min_samples_split
- *         self.min_samples_leaf = min_samples_leaf
- */
-  __pyx_t_3 = PyFloat_FromDouble(__pyx_v_impurity_tol); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 32, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_impurity_tol, __pyx_t_3) < 0) __PYX_ERR(0, 32, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":33
- *         self.max_depth = max_depth
- *         self.impurity_tol = impurity_tol
- *         self.min_samples_split = min_samples_split             # <<<<<<<<<<<<<<
- *         self.min_samples_leaf = min_samples_leaf
- *         self.min_improvement = min_improvement
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_min_samples_split, __pyx_v_min_samples_split) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":34
- *         self.impurity_tol = impurity_tol
- *         self.min_samples_split = min_samples_split
- *         self.min_samples_leaf = min_samples_leaf             # <<<<<<<<<<<<<<
- *         self.min_improvement = min_improvement
- *         self.criteria = criteria
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_min_samples_leaf, __pyx_v_min_samples_leaf) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":35
- *         self.min_samples_split = min_samples_split
- *         self.min_samples_leaf = min_samples_leaf
- *         self.min_improvement = min_improvement             # <<<<<<<<<<<<<<
- *         self.criteria = criteria
- *         self.tree_type = tree_type
+  /* "adaXT/predict/predict.pyx":35
+ * 
+ *     cpdef list predict_proba(self, object X):
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef double[:, ::1] predict_leaf_matrix(self, object X, bint scale = False):
  */
-  __pyx_t_3 = PyFloat_FromDouble(__pyx_v_min_improvement); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 35, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_min_improvement, __pyx_t_3) < 0) __PYX_ERR(0, 35, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 35, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(0, 35, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":36
- *         self.min_samples_leaf = min_samples_leaf
- *         self.min_improvement = min_improvement
- *         self.criteria = criteria             # <<<<<<<<<<<<<<
- *         self.tree_type = tree_type
- *         self.leaf_nodes = None
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_criteria, __pyx_v_criteria) < 0) __PYX_ERR(0, 36, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":37
- *         self.min_improvement = min_improvement
- *         self.criteria = criteria
- *         self.tree_type = tree_type             # <<<<<<<<<<<<<<
- *         self.leaf_nodes = None
- *         self.root = None
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_tree_type, __pyx_v_tree_type) < 0) __PYX_ERR(0, 37, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":38
- *         self.criteria = criteria
- *         self.tree_type = tree_type
- *         self.leaf_nodes = None             # <<<<<<<<<<<<<<
- *         self.root = None
- *         self.n_nodes = -1
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_leaf_nodes, Py_None) < 0) __PYX_ERR(0, 38, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":39
- *         self.tree_type = tree_type
- *         self.leaf_nodes = None
- *         self.root = None             # <<<<<<<<<<<<<<
- *         self.n_nodes = -1
- *         self.n_features = -1
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_root, Py_None) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":40
- *         self.leaf_nodes = None
- *         self.root = None
- *         self.n_nodes = -1             # <<<<<<<<<<<<<<
- *         self.n_features = -1
- *         self.n_classes = -1
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_n_nodes, __pyx_int_neg_1) < 0) __PYX_ERR(0, 40, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":41
- *         self.root = None
- *         self.n_nodes = -1
- *         self.n_features = -1             # <<<<<<<<<<<<<<
- *         self.n_classes = -1
- *         self.n_obs = -1
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_n_features, __pyx_int_neg_1) < 0) __PYX_ERR(0, 41, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":42
- *         self.n_nodes = -1
- *         self.n_features = -1
- *         self.n_classes = -1             # <<<<<<<<<<<<<<
- *         self.n_obs = -1
- *         self.classes = None
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_n_classes, __pyx_int_neg_1) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":43
- *         self.n_features = -1
- *         self.n_classes = -1
- *         self.n_obs = -1             # <<<<<<<<<<<<<<
- *         self.classes = None
- *         self.splitter = splitter
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_n_obs, __pyx_int_neg_1) < 0) __PYX_ERR(0, 43, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":44
- *         self.n_classes = -1
- *         self.n_obs = -1
- *         self.classes = None             # <<<<<<<<<<<<<<
- *         self.splitter = splitter
- * 
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_classes, Py_None) < 0) __PYX_ERR(0, 44, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":45
- *         self.n_obs = -1
- *         self.classes = None
- *         self.splitter = splitter             # <<<<<<<<<<<<<<
- * 
- *     def __check_input(self, X: object, Y: object):
- */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_splitter, __pyx_v_splitter) < 0) __PYX_ERR(0, 45, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":18
- * 
- * class DecisionTree:
- *     def __init__(             # <<<<<<<<<<<<<<
- *             self,
- *             tree_type: str,
+  /* "adaXT/predict/predict.pyx":34
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")
+ * 
+ *     cpdef list predict_proba(self, object X):             # <<<<<<<<<<<<<<
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")
+ * 
  */
 
   /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_tree_types);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":47
- *         self.splitter = splitter
- * 
- *     def __check_input(self, X: object, Y: object):             # <<<<<<<<<<<<<<
- *         # Make sure input arrays are c contigous
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
- */
-
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_3__check_input(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_7predict_proba(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_3__check_input = {"__check_input", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_3__check_input, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_3__check_input(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_7Predict_7predict_proba = {"predict_proba", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_7predict_proba, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_7predict_proba(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
   PyObject *__pyx_v_X = 0;
-  PyObject *__pyx_v_Y = 0;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[3] = {0,0,0};
+  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__check_input (wrapper)", 0);
+  __Pyx_RefNannySetupContext("predict_proba (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
   #if CYTHON_ASSUME_SAFE_MACROS
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_X,&__pyx_n_s_Y,0};
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
         case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 47, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 34, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 47, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__check_input", 1, 3, 3, 1); __PYX_ERR(0, 47, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_Y)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 47, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__check_input", 1, 3, 3, 2); __PYX_ERR(0, 47, __pyx_L3_error)
-        }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__check_input") < 0)) __PYX_ERR(0, 47, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "predict_proba") < 0)) __PYX_ERR(0, 34, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 3)) {
+    } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
     }
-    __pyx_v_self = values[0];
-    __pyx_v_X = values[1];
-    __pyx_v_Y = values[2];
+    __pyx_v_X = values[0];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__check_input", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 47, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("predict_proba", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 34, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__check_input", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_2__check_input(__pyx_self, __pyx_v_self, __pyx_v_X, __pyx_v_Y);
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_7Predict_6predict_proba(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self), __pyx_v_X);
 
   /* function exit code */
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_2__check_input(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, PyObject *__pyx_v_X, PyObject *__pyx_v_Y) {
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_6predict_proba(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, PyObject *__pyx_v_X) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("predict_proba", 1);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_5adaXT_7predict_7predict_7Predict_predict_proba(__pyx_v_self, __pyx_v_X, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/predict/predict.pyx":37
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")
+ * 
+ *     cpdef double[:, ::1] predict_leaf_matrix(self, object X, bint scale = False):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i
+ */
+
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_9predict_leaf_matrix(PyObject *__pyx_v_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static __Pyx_memviewslice __pyx_f_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, PyObject *__pyx_v_X, int __pyx_skip_dispatch, struct __pyx_opt_args_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix *__pyx_optional_args) {
+  int __pyx_v_scale = ((int)0);
+  int __pyx_v_i;
+  int __pyx_v_row;
+  PyObject *__pyx_v_ht = 0;
+  int __pyx_v_cur_split_idx;
+  double __pyx_v_cur_threshold;
+  PyObject *__pyx_v_cur_node = NULL;
+  PyObject *__pyx_v_matrix = NULL;
+  PyObject *__pyx_v_key = NULL;
+  PyObject *__pyx_v_indices = NULL;
+  PyObject *__pyx_v_val = NULL;
+  PyObject *__pyx_v_count = NULL;
+  __Pyx_memviewslice __pyx_r = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
+  PyObject *__pyx_t_5 = NULL;
   int __pyx_t_6;
+  __Pyx_memviewslice __pyx_t_7 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_t_8;
+  int __pyx_t_9;
+  int __pyx_t_10;
+  int __pyx_t_11;
+  double __pyx_t_12;
+  Py_ssize_t __pyx_t_13;
+  Py_ssize_t __pyx_t_14;
+  Py_ssize_t __pyx_t_15;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__check_input", 0);
+  __Pyx_RefNannySetupContext("predict_leaf_matrix", 0);
+  if (__pyx_optional_args) {
+    if (__pyx_optional_args->__pyx_n > 0) {
+      __pyx_v_scale = __pyx_optional_args->scale;
+    }
+  }
   __Pyx_INCREF(__pyx_v_X);
-  __Pyx_INCREF(__pyx_v_Y);
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || __Pyx_PyType_HasFeature(Py_TYPE(((PyObject *)__pyx_v_self)), (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_typedict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_predict_leaf_matrix); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 37, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_7predict_7predict_7Predict_9predict_leaf_matrix)) {
+        __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_v_scale); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 37, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_4 = __pyx_t_1; __pyx_t_5 = NULL;
+        __pyx_t_6 = 0;
+        #if CYTHON_UNPACK_METHODS
+        if (unlikely(PyMethod_Check(__pyx_t_4))) {
+          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+          if (likely(__pyx_t_5)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+            __Pyx_INCREF(__pyx_t_5);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_4, function);
+            __pyx_t_6 = 1;
+          }
+        }
+        #endif
+        {
+          PyObject *__pyx_callargs[3] = {__pyx_t_5, __pyx_v_X, __pyx_t_3};
+          __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 2+__pyx_t_6);
+          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+          if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 37, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        }
+        __pyx_t_7 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_t_2, PyBUF_WRITABLE); if (unlikely(!__pyx_t_7.memview)) __PYX_ERR(0, 37, __pyx_L1_error)
+        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+        __pyx_r = __pyx_t_7;
+        __pyx_t_7.memview = NULL;
+        __pyx_t_7.data = NULL;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
+      }
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_typedict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+      }
+      #endif
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":49
- *     def __check_input(self, X: object, Y: object):
- *         # Make sure input arrays are c contigous
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)             # <<<<<<<<<<<<<<
- *         Y = np.ascontiguousarray(Y, dtype=DOUBLE)
+  /* "adaXT/predict/predict.pyx":46
+ * 
+ *         # Make sure that x fits the dimensions.
+ *         X = self.__check_dimensions(X)             # <<<<<<<<<<<<<<
+ *         row = X.shape[0]
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 49, __pyx_L1_error)
+  __pyx_t_7 = ((struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict *)__pyx_v_self->__pyx_vtab)->_Predict__check_dimensions(__pyx_v_self, __pyx_v_X); if (unlikely(!__pyx_t_7.memview)) __PYX_ERR(0, 46, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_fromslice(__pyx_t_7, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_INCREF(__pyx_v_X);
-  __Pyx_GIVEREF(__pyx_v_X);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_X)) __PYX_ERR(0, 49, __pyx_L1_error);
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DOUBLE); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_4) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 49, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_4);
-  __pyx_t_4 = 0;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_7, 1);
+  __pyx_t_7.memview = NULL; __pyx_t_7.data = NULL;
+  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_1);
+  __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":50
- *         # Make sure input arrays are c contigous
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
- *         Y = np.ascontiguousarray(Y, dtype=DOUBLE)             # <<<<<<<<<<<<<<
+  /* "adaXT/predict/predict.pyx":47
+ *         # Make sure that x fits the dimensions.
+ *         X = self.__check_dimensions(X)
+ *         row = X.shape[0]             # <<<<<<<<<<<<<<
  * 
- *         # Check if X and Y has same number of rows
+ *         ht = {}
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_INCREF(__pyx_v_Y);
-  __Pyx_GIVEREF(__pyx_v_Y);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_Y)) __PYX_ERR(0, 50, __pyx_L1_error);
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 50, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 47, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DOUBLE); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 50, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 47, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_t_2) < 0) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 50, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF_SET(__pyx_v_Y, __pyx_t_2);
-  __pyx_t_2 = 0;
+  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 47, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_v_row = __pyx_t_6;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":53
- * 
- *         # Check if X and Y has same number of rows
- *         if X.shape[0] != Y.shape[0]:             # <<<<<<<<<<<<<<
- *             raise ValueError("X and Y should have the same number of rows")
+  /* "adaXT/predict/predict.pyx":49
+ *         row = X.shape[0]
  * 
+ *         ht = {}             # <<<<<<<<<<<<<<
+ *         for i in range(row):
+ *             cur_node = self.root
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_2, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_Y, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 53, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 49, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_2, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyObject_RichCompare(__pyx_t_1, __pyx_t_4, Py_NE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_5 < 0))) __PYX_ERR(0, 53, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(__pyx_t_5)) {
+  __pyx_v_ht = ((PyObject*)__pyx_t_2);
+  __pyx_t_2 = 0;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":54
- *         # Check if X and Y has same number of rows
- *         if X.shape[0] != Y.shape[0]:
- *             raise ValueError("X and Y should have the same number of rows")             # <<<<<<<<<<<<<<
+  /* "adaXT/predict/predict.pyx":50
  * 
- *         # Check if Y has dimensions (n, 1) or (n,)
+ *         ht = {}
+ *         for i in range(row):             # <<<<<<<<<<<<<<
+ *             cur_node = self.root
+ *             while isinstance(cur_node, DecisionNode):
  */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 54, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 54, __pyx_L1_error)
+  __pyx_t_6 = __pyx_v_row;
+  __pyx_t_8 = __pyx_t_6;
+  for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
+    __pyx_v_i = __pyx_t_9;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":53
- * 
- *         # Check if X and Y has same number of rows
- *         if X.shape[0] != Y.shape[0]:             # <<<<<<<<<<<<<<
- *             raise ValueError("X and Y should have the same number of rows")
- * 
+    /* "adaXT/predict/predict.pyx":51
+ *         ht = {}
+ *         for i in range(row):
+ *             cur_node = self.root             # <<<<<<<<<<<<<<
+ *             while isinstance(cur_node, DecisionNode):
+ *                 cur_split_idx = cur_node.split_idx
  */
-  }
+    __pyx_t_2 = __pyx_v_self->root;
+    __Pyx_INCREF(__pyx_t_2);
+    __Pyx_XDECREF_SET(__pyx_v_cur_node, __pyx_t_2);
+    __pyx_t_2 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":57
- * 
- *         # Check if Y has dimensions (n, 1) or (n,)
- *         if 2 < Y.ndim:             # <<<<<<<<<<<<<<
- *             raise ValueError("Y should have dimensions (n,1) or (n,)")
- *         elif 2 == Y.ndim:
+    /* "adaXT/predict/predict.pyx":52
+ *         for i in range(row):
+ *             cur_node = self.root
+ *             while isinstance(cur_node, DecisionNode):             # <<<<<<<<<<<<<<
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_Y, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 57, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = PyObject_RichCompare(__pyx_int_2, __pyx_t_2, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 57, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_5 < 0))) __PYX_ERR(0, 57, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (unlikely(__pyx_t_5)) {
+    while (1) {
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 52, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_10 = PyObject_IsInstance(__pyx_v_cur_node, __pyx_t_2); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 52, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      if (!__pyx_t_10) break;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":58
- *         # Check if Y has dimensions (n, 1) or (n,)
- *         if 2 < Y.ndim:
- *             raise ValueError("Y should have dimensions (n,1) or (n,)")             # <<<<<<<<<<<<<<
- *         elif 2 == Y.ndim:
- *             if 1 < Y.shape[1]:
+      /* "adaXT/predict/predict.pyx":53
+ *             cur_node = self.root
+ *             while isinstance(cur_node, DecisionNode):
+ *                 cur_split_idx = cur_node.split_idx             # <<<<<<<<<<<<<<
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:
  */
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 58, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __PYX_ERR(0, 58, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_split_idx); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 53, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_11 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_11 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 53, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_v_cur_split_idx = __pyx_t_11;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":57
- * 
- *         # Check if Y has dimensions (n, 1) or (n,)
- *         if 2 < Y.ndim:             # <<<<<<<<<<<<<<
- *             raise ValueError("Y should have dimensions (n,1) or (n,)")
- *         elif 2 == Y.ndim:
+      /* "adaXT/predict/predict.pyx":54
+ *             while isinstance(cur_node, DecisionNode):
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold             # <<<<<<<<<<<<<<
+ *                 if X[i, cur_split_idx] < cur_threshold:
+ *                     cur_node = cur_node.left_child
  */
-  }
+      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_threshold); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 54, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 54, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_v_cur_threshold = __pyx_t_12;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":59
- *         if 2 < Y.ndim:
- *             raise ValueError("Y should have dimensions (n,1) or (n,)")
- *         elif 2 == Y.ndim:             # <<<<<<<<<<<<<<
- *             if 1 < Y.shape[1]:
- *                 raise ValueError("Y should have dimensions (n,1) or (n,)")
+      /* "adaXT/predict/predict.pyx":55
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
+ *                     cur_node = cur_node.left_child
+ *                 else:
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_Y, __pyx_n_s_ndim); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 59, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = (__Pyx_PyInt_BoolEqCObj(__pyx_int_2, __pyx_t_4, 2, 0)); if (unlikely((__pyx_t_5 < 0))) __PYX_ERR(0, 59, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (__pyx_t_5) {
+      __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 55, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_cur_split_idx); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 55, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 55, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_2);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2)) __PYX_ERR(0, 55, __pyx_L1_error);
+      __Pyx_GIVEREF(__pyx_t_1);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1)) __PYX_ERR(0, 55, __pyx_L1_error);
+      __pyx_t_2 = 0;
+      __pyx_t_1 = 0;
+      __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 55, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_4 = PyFloat_FromDouble(__pyx_v_cur_threshold); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 55, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_2 = PyObject_RichCompare(__pyx_t_1, __pyx_t_4, Py_LT); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 55, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_10 < 0))) __PYX_ERR(0, 55, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      if (__pyx_t_10) {
+
+        /* "adaXT/predict/predict.pyx":56
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:
+ *                     cur_node = cur_node.left_child             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     cur_node = cur_node.right_child
+ */
+        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_left_child); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 56, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_2);
+        __pyx_t_2 = 0;
+
+        /* "adaXT/predict/predict.pyx":55
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
+ *                     cur_node = cur_node.left_child
+ *                 else:
+ */
+        goto __pyx_L7;
+      }
+
+      /* "adaXT/predict/predict.pyx":58
+ *                     cur_node = cur_node.left_child
+ *                 else:
+ *                     cur_node = cur_node.right_child             # <<<<<<<<<<<<<<
+ * 
+ *             if cur_node.id not in ht.keys():
+ */
+      /*else*/ {
+        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_right_child); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 58, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_2);
+        __pyx_t_2 = 0;
+      }
+      __pyx_L7:;
+    }
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":60
- *             raise ValueError("Y should have dimensions (n,1) or (n,)")
- *         elif 2 == Y.ndim:
- *             if 1 < Y.shape[1]:             # <<<<<<<<<<<<<<
- *                 raise ValueError("Y should have dimensions (n,1) or (n,)")
+    /* "adaXT/predict/predict.pyx":60
+ *                     cur_node = cur_node.right_child
+ * 
+ *             if cur_node.id not in ht.keys():             # <<<<<<<<<<<<<<
+ *                 ht[cur_node.id] = [i]
  *             else:
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_Y, __pyx_n_s_shape); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 60, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_4, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 60, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_id); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 60, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_4 = PyObject_RichCompare(__pyx_int_1, __pyx_t_2, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 60, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyDict_Keys(__pyx_v_ht); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 60, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_10 = (__Pyx_PySequence_ContainsTF(__pyx_t_2, __pyx_t_4, Py_NE)); if (unlikely((__pyx_t_10 < 0))) __PYX_ERR(0, 60, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_5 < 0))) __PYX_ERR(0, 60, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(__pyx_t_5)) {
+    if (__pyx_t_10) {
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":61
- *         elif 2 == Y.ndim:
- *             if 1 < Y.shape[1]:
- *                 raise ValueError("Y should have dimensions (n,1) or (n,)")             # <<<<<<<<<<<<<<
+      /* "adaXT/predict/predict.pyx":61
+ * 
+ *             if cur_node.id not in ht.keys():
+ *                 ht[cur_node.id] = [i]             # <<<<<<<<<<<<<<
  *             else:
- *                 Y = Y.reshape(-1)
+ *                 ht[cur_node.id] += [i]
  */
-      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 61, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 61, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
+      __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 61, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_4);
+      if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 0, __pyx_t_4)) __PYX_ERR(0, 61, __pyx_L1_error);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 61, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      if (unlikely((PyDict_SetItem(__pyx_v_ht, __pyx_t_4, __pyx_t_2) < 0))) __PYX_ERR(0, 61, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __PYX_ERR(0, 61, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":60
- *             raise ValueError("Y should have dimensions (n,1) or (n,)")
- *         elif 2 == Y.ndim:
- *             if 1 < Y.shape[1]:             # <<<<<<<<<<<<<<
- *                 raise ValueError("Y should have dimensions (n,1) or (n,)")
+      /* "adaXT/predict/predict.pyx":60
+ *                     cur_node = cur_node.right_child
+ * 
+ *             if cur_node.id not in ht.keys():             # <<<<<<<<<<<<<<
+ *                 ht[cur_node.id] = [i]
  *             else:
  */
+      goto __pyx_L8;
     }
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":63
- *                 raise ValueError("Y should have dimensions (n,1) or (n,)")
+    /* "adaXT/predict/predict.pyx":63
+ *                 ht[cur_node.id] = [i]
  *             else:
- *                 Y = Y.reshape(-1)             # <<<<<<<<<<<<<<
- * 
- *         return X, Y
+ *                 ht[cur_node.id] += [i]             # <<<<<<<<<<<<<<
+ *         matrix = np.zeros((row, row))
+ *         for key in ht.keys():
  */
     /*else*/ {
-      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_Y, __pyx_n_s_reshape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 63, __pyx_L1_error)
+      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_id); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 63, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_1 = NULL;
-      __pyx_t_6 = 0;
-      #if CYTHON_UNPACK_METHODS
-      if (likely(PyMethod_Check(__pyx_t_2))) {
-        __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
-        if (likely(__pyx_t_1)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-          __Pyx_INCREF(__pyx_t_1);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_2, function);
-          __pyx_t_6 = 1;
-        }
-      }
-      #endif
-      {
-        PyObject *__pyx_callargs[2] = {__pyx_t_1, __pyx_int_neg_1};
-        __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_2, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-        if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 63, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      }
-      __Pyx_DECREF_SET(__pyx_v_Y, __pyx_t_4);
-      __pyx_t_4 = 0;
+      __pyx_t_4 = __Pyx_PyDict_GetItem(__pyx_v_ht, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 63, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 63, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 63, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_1);
+      if (__Pyx_PyList_SET_ITEM(__pyx_t_3, 0, __pyx_t_1)) __PYX_ERR(0, 63, __pyx_L1_error);
+      __pyx_t_1 = 0;
+      __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 63, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (unlikely((PyDict_SetItem(__pyx_v_ht, __pyx_t_2, __pyx_t_1) < 0))) __PYX_ERR(0, 63, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
     }
+    __pyx_L8:;
+  }
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":59
- *         if 2 < Y.ndim:
- *             raise ValueError("Y should have dimensions (n,1) or (n,)")
- *         elif 2 == Y.ndim:             # <<<<<<<<<<<<<<
- *             if 1 < Y.shape[1]:
- *                 raise ValueError("Y should have dimensions (n,1) or (n,)")
+  /* "adaXT/predict/predict.pyx":64
+ *             else:
+ *                 ht[cur_node.id] += [i]
+ *         matrix = np.zeros((row, row))             # <<<<<<<<<<<<<<
+ *         for key in ht.keys():
+ *             indices = ht[key]
  */
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_zeros); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_row); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_row); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_GIVEREF(__pyx_t_1);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error);
+  __Pyx_GIVEREF(__pyx_t_4);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_4)) __PYX_ERR(0, 64, __pyx_L1_error);
+  __pyx_t_1 = 0;
+  __pyx_t_4 = 0;
+  __pyx_t_4 = NULL;
+  __pyx_t_6 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __pyx_t_6 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_t_5};
+    __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 64, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
+  __pyx_v_matrix = __pyx_t_2;
+  __pyx_t_2 = 0;
+
+  /* "adaXT/predict/predict.pyx":65
+ *                 ht[cur_node.id] += [i]
+ *         matrix = np.zeros((row, row))
+ *         for key in ht.keys():             # <<<<<<<<<<<<<<
+ *             indices = ht[key]
+ *             val = 1
+ */
+  __pyx_t_13 = 0;
+  __pyx_t_3 = __Pyx_dict_iterator(__pyx_v_ht, 1, __pyx_n_s_keys, (&__pyx_t_14), (&__pyx_t_6)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_2);
+  __pyx_t_2 = __pyx_t_3;
+  __pyx_t_3 = 0;
+  while (1) {
+    __pyx_t_8 = __Pyx_dict_iter_next(__pyx_t_2, __pyx_t_14, &__pyx_t_13, &__pyx_t_3, NULL, NULL, __pyx_t_6);
+    if (unlikely(__pyx_t_8 == 0)) break;
+    if (unlikely(__pyx_t_8 == -1)) __PYX_ERR(0, 65, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_XDECREF_SET(__pyx_v_key, __pyx_t_3);
+    __pyx_t_3 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":65
- *                 Y = Y.reshape(-1)
+    /* "adaXT/predict/predict.pyx":66
+ *         matrix = np.zeros((row, row))
+ *         for key in ht.keys():
+ *             indices = ht[key]             # <<<<<<<<<<<<<<
+ *             val = 1
+ *             count = len(indices)
+ */
+    __pyx_t_3 = __Pyx_PyDict_GetItem(__pyx_v_ht, __pyx_v_key); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 66, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_XDECREF_SET(__pyx_v_indices, __pyx_t_3);
+    __pyx_t_3 = 0;
+
+    /* "adaXT/predict/predict.pyx":67
+ *         for key in ht.keys():
+ *             indices = ht[key]
+ *             val = 1             # <<<<<<<<<<<<<<
+ *             count = len(indices)
+ *             if scale:
+ */
+    __Pyx_INCREF(__pyx_int_1);
+    __Pyx_XDECREF_SET(__pyx_v_val, __pyx_int_1);
+
+    /* "adaXT/predict/predict.pyx":68
+ *             indices = ht[key]
+ *             val = 1
+ *             count = len(indices)             # <<<<<<<<<<<<<<
+ *             if scale:
+ *                 val = 1/count
+ */
+    __pyx_t_15 = PyObject_Length(__pyx_v_indices); if (unlikely(__pyx_t_15 == ((Py_ssize_t)-1))) __PYX_ERR(0, 68, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_15); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 68, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_XDECREF_SET(__pyx_v_count, __pyx_t_3);
+    __pyx_t_3 = 0;
+
+    /* "adaXT/predict/predict.pyx":69
+ *             val = 1
+ *             count = len(indices)
+ *             if scale:             # <<<<<<<<<<<<<<
+ *                 val = 1/count
+ *             matrix[np.ix_(indices, indices)] = val
+ */
+    if (__pyx_v_scale) {
+
+      /* "adaXT/predict/predict.pyx":70
+ *             count = len(indices)
+ *             if scale:
+ *                 val = 1/count             # <<<<<<<<<<<<<<
+ *             matrix[np.ix_(indices, indices)] = val
  * 
- *         return X, Y             # <<<<<<<<<<<<<<
+ */
+      __pyx_t_3 = __Pyx_PyNumber_Divide(__pyx_int_1, __pyx_v_count); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 70, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF_SET(__pyx_v_val, __pyx_t_3);
+      __pyx_t_3 = 0;
+
+      /* "adaXT/predict/predict.pyx":69
+ *             val = 1
+ *             count = len(indices)
+ *             if scale:             # <<<<<<<<<<<<<<
+ *                 val = 1/count
+ *             matrix[np.ix_(indices, indices)] = val
+ */
+    }
+
+    /* "adaXT/predict/predict.pyx":71
+ *             if scale:
+ *                 val = 1/count
+ *             matrix[np.ix_(indices, indices)] = val             # <<<<<<<<<<<<<<
  * 
- *     def __check_sample_weight(self, sample_weight: np.ndarray, n_samples):
+ *         return matrix
  */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 65, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_INCREF(__pyx_v_X);
-  __Pyx_GIVEREF(__pyx_v_X);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_X)) __PYX_ERR(0, 65, __pyx_L1_error);
-  __Pyx_INCREF(__pyx_v_Y);
-  __Pyx_GIVEREF(__pyx_v_Y);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_Y)) __PYX_ERR(0, 65, __pyx_L1_error);
-  __pyx_r = __pyx_t_4;
-  __pyx_t_4 = 0;
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 71, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_ix); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 71, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_5 = NULL;
+    __pyx_t_8 = 0;
+    #if CYTHON_UNPACK_METHODS
+    if (unlikely(PyMethod_Check(__pyx_t_4))) {
+      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
+      if (likely(__pyx_t_5)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
+        __Pyx_INCREF(__pyx_t_5);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_4, function);
+        __pyx_t_8 = 1;
+      }
+    }
+    #endif
+    {
+      PyObject *__pyx_callargs[3] = {__pyx_t_5, __pyx_v_indices, __pyx_v_indices};
+      __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_8, 2+__pyx_t_8);
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 71, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    }
+    if (unlikely((PyObject_SetItem(__pyx_v_matrix, __pyx_t_3, __pyx_v_val) < 0))) __PYX_ERR(0, 71, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  }
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "adaXT/predict/predict.pyx":73
+ *             matrix[np.ix_(indices, indices)] = val
+ * 
+ *         return matrix             # <<<<<<<<<<<<<<
+ * 
+ *     @staticmethod
+ */
+  __pyx_t_7 = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(__pyx_v_matrix, PyBUF_WRITABLE); if (unlikely(!__pyx_t_7.memview)) __PYX_ERR(0, 73, __pyx_L1_error)
+  __pyx_r = __pyx_t_7;
+  __pyx_t_7.memview = NULL;
+  __pyx_t_7.data = NULL;
   goto __pyx_L0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":47
- *         self.splitter = splitter
+  /* "adaXT/predict/predict.pyx":37
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")
  * 
- *     def __check_input(self, X: object, Y: object):             # <<<<<<<<<<<<<<
- *         # Make sure input arrays are c contigous
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
+ *     cpdef double[:, ::1] predict_leaf_matrix(self, object X, bint scale = False):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__check_input", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
+  __Pyx_XDECREF(__pyx_t_5);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_7, 1);
+  __pyx_r.data = NULL;
+  __pyx_r.memview = NULL;
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.predict_leaf_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  goto __pyx_L2;
   __pyx_L0:;
+  if (unlikely(!__pyx_r.memview)) {
+    PyErr_SetString(PyExc_TypeError, "Memoryview return value is not initialized");
+  }
+  __pyx_L2:;
+  __Pyx_XDECREF(__pyx_v_ht);
+  __Pyx_XDECREF(__pyx_v_cur_node);
+  __Pyx_XDECREF(__pyx_v_matrix);
+  __Pyx_XDECREF(__pyx_v_key);
+  __Pyx_XDECREF(__pyx_v_indices);
+  __Pyx_XDECREF(__pyx_v_val);
+  __Pyx_XDECREF(__pyx_v_count);
   __Pyx_XDECREF(__pyx_v_X);
-  __Pyx_XDECREF(__pyx_v_Y);
-  __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":67
- *         return X, Y
- * 
- *     def __check_sample_weight(self, sample_weight: np.ndarray, n_samples):             # <<<<<<<<<<<<<<
- * 
- *         if sample_weight is None:
- */
-
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_5__check_sample_weight(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_9predict_leaf_matrix(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_5__check_sample_weight = {"__check_sample_weight", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_5__check_sample_weight, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_5__check_sample_weight(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_7Predict_9predict_leaf_matrix = {"predict_leaf_matrix", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_9predict_leaf_matrix, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_9predict_leaf_matrix(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
-  PyObject *__pyx_v_sample_weight = 0;
-  PyObject *__pyx_v_n_samples = 0;
+  PyObject *__pyx_v_X = 0;
+  int __pyx_v_scale;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[3] = {0,0,0};
+  PyObject* values[2] = {0,0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__check_sample_weight (wrapper)", 0);
+  __Pyx_RefNannySetupContext("predict_leaf_matrix (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
   #if CYTHON_ASSUME_SAFE_MACROS
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_sample_weight,&__pyx_n_s_n_samples,0};
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_scale,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
         case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
         case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 67, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 37, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_sample_weight)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 67, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__check_sample_weight", 1, 3, 3, 1); __PYX_ERR(0, 67, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_n_samples)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 67, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__check_sample_weight", 1, 3, 3, 2); __PYX_ERR(0, 67, __pyx_L3_error)
+        if (kw_args > 0) {
+          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_scale);
+          if (value) { values[1] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
+          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 37, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__check_sample_weight") < 0)) __PYX_ERR(0, 67, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "predict_leaf_matrix") < 0)) __PYX_ERR(0, 37, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 3)) {
-      goto __pyx_L5_argtuple_error;
     } else {
-      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+      switch (__pyx_nargs) {
+        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+    }
+    __pyx_v_X = values[0];
+    if (values[1]) {
+      __pyx_v_scale = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_scale == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 37, __pyx_L3_error)
+    } else {
+      __pyx_v_scale = ((int)0);
     }
-    __pyx_v_self = values[0];
-    __pyx_v_sample_weight = values[1];
-    __pyx_v_n_samples = values[2];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__check_sample_weight", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 67, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("predict_leaf_matrix", 0, 1, 2, __pyx_nargs); __PYX_ERR(0, 37, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__check_sample_weight", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.predict_leaf_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_4__check_sample_weight(__pyx_self, __pyx_v_self, __pyx_v_sample_weight, __pyx_v_n_samples);
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_7Predict_8predict_leaf_matrix(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self), __pyx_v_X, __pyx_v_scale);
 
   /* function exit code */
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_4__check_sample_weight(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, PyObject *__pyx_v_sample_weight, PyObject *__pyx_v_n_samples) {
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_8predict_leaf_matrix(struct __pyx_obj_5adaXT_7predict_7predict_Predict *__pyx_v_self, PyObject *__pyx_v_X, int __pyx_v_scale) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  int __pyx_t_1;
-  PyObject *__pyx_t_2 = NULL;
+  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  struct __pyx_opt_args_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__check_sample_weight", 0);
-  __Pyx_INCREF(__pyx_v_sample_weight);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":69
- *     def __check_sample_weight(self, sample_weight: np.ndarray, n_samples):
- * 
- *         if sample_weight is None:             # <<<<<<<<<<<<<<
- *             return np.ones(n_samples, dtype=np.double)
- *         sample_weight = np.array(sample_weight, dtype=np.double)
- */
-  __pyx_t_1 = (__pyx_v_sample_weight == Py_None);
-  if (__pyx_t_1) {
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":70
- * 
- *         if sample_weight is None:
- *             return np.ones(n_samples, dtype=np.double)             # <<<<<<<<<<<<<<
- *         sample_weight = np.array(sample_weight, dtype=np.double)
- *         if sample_weight.shape[0] != n_samples:
- */
-    __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 70, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_ones); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 70, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 70, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_INCREF(__pyx_v_n_samples);
-    __Pyx_GIVEREF(__pyx_v_n_samples);
-    if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_n_samples)) __PYX_ERR(0, 70, __pyx_L1_error);
-    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 70, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 70, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_double); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 70, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_dtype, __pyx_t_6) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 70, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_6);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_r = __pyx_t_6;
-    __pyx_t_6 = 0;
-    goto __pyx_L0;
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":69
- *     def __check_sample_weight(self, sample_weight: np.ndarray, n_samples):
- * 
- *         if sample_weight is None:             # <<<<<<<<<<<<<<
- *             return np.ones(n_samples, dtype=np.double)
- *         sample_weight = np.array(sample_weight, dtype=np.double)
- */
-  }
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":71
- *         if sample_weight is None:
- *             return np.ones(n_samples, dtype=np.double)
- *         sample_weight = np.array(sample_weight, dtype=np.double)             # <<<<<<<<<<<<<<
- *         if sample_weight.shape[0] != n_samples:
- *             raise ValueError("sample_weight should have as many elements as X and Y")
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 71, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_array); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 71, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 71, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __Pyx_INCREF(__pyx_v_sample_weight);
-  __Pyx_GIVEREF(__pyx_v_sample_weight);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_sample_weight)) __PYX_ERR(0, 71, __pyx_L1_error);
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 71, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 71, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_double); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 71, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_dtype, __pyx_t_5) < 0) __PYX_ERR(0, 71, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 71, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF_SET(__pyx_v_sample_weight, __pyx_t_5);
-  __pyx_t_5 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":72
- *             return np.ones(n_samples, dtype=np.double)
- *         sample_weight = np.array(sample_weight, dtype=np.double)
- *         if sample_weight.shape[0] != n_samples:             # <<<<<<<<<<<<<<
- *             raise ValueError("sample_weight should have as many elements as X and Y")
- *         if sample_weight.ndim > 1:
- */
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_sample_weight, __pyx_n_s_shape); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 72, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_5, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 72, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = PyObject_RichCompare(__pyx_t_2, __pyx_v_n_samples, Py_NE); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 72, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(0, 72, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(__pyx_t_1)) {
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":73
- *         sample_weight = np.array(sample_weight, dtype=np.double)
- *         if sample_weight.shape[0] != n_samples:
- *             raise ValueError("sample_weight should have as many elements as X and Y")             # <<<<<<<<<<<<<<
- *         if sample_weight.ndim > 1:
- *             raise ValueError("sample_weight should have dimension (n_samples,)")
- */
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 73, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __PYX_ERR(0, 73, __pyx_L1_error)
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":72
- *             return np.ones(n_samples, dtype=np.double)
- *         sample_weight = np.array(sample_weight, dtype=np.double)
- *         if sample_weight.shape[0] != n_samples:             # <<<<<<<<<<<<<<
- *             raise ValueError("sample_weight should have as many elements as X and Y")
- *         if sample_weight.ndim > 1:
- */
-  }
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":74
- *         if sample_weight.shape[0] != n_samples:
- *             raise ValueError("sample_weight should have as many elements as X and Y")
- *         if sample_weight.ndim > 1:             # <<<<<<<<<<<<<<
- *             raise ValueError("sample_weight should have dimension (n_samples,)")
- *         return sample_weight
- */
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_sample_weight, __pyx_n_s_ndim); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 74, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_2 = PyObject_RichCompare(__pyx_t_5, __pyx_int_1, Py_GT); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 74, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_1 < 0))) __PYX_ERR(0, 74, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(__pyx_t_1)) {
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":75
- *             raise ValueError("sample_weight should have as many elements as X and Y")
- *         if sample_weight.ndim > 1:
- *             raise ValueError("sample_weight should have dimension (n_samples,)")             # <<<<<<<<<<<<<<
- *         return sample_weight
- * 
- */
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 75, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_ERR(0, 75, __pyx_L1_error)
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":74
- *         if sample_weight.shape[0] != n_samples:
- *             raise ValueError("sample_weight should have as many elements as X and Y")
- *         if sample_weight.ndim > 1:             # <<<<<<<<<<<<<<
- *             raise ValueError("sample_weight should have dimension (n_samples,)")
- *         return sample_weight
- */
-  }
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":76
- *         if sample_weight.ndim > 1:
- *             raise ValueError("sample_weight should have dimension (n_samples,)")
- *         return sample_weight             # <<<<<<<<<<<<<<
- * 
- *     def __check_dimensions(self, double[:, :] X):
- */
+  __Pyx_RefNannySetupContext("predict_leaf_matrix", 1);
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_sample_weight);
-  __pyx_r = __pyx_v_sample_weight;
+  __pyx_t_2.__pyx_n = 1;
+  __pyx_t_2.scale = __pyx_v_scale;
+  __pyx_t_1 = __pyx_vtabptr_5adaXT_7predict_7predict_Predict->predict_leaf_matrix(__pyx_v_self, __pyx_v_X, 1, &__pyx_t_2); if (unlikely(!__pyx_t_1.memview)) __PYX_ERR(0, 37, __pyx_L1_error)
+  __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_t_1, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 37, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_t_1.memview = NULL; __pyx_t_1.data = NULL;
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":67
- *         return X, Y
- * 
- *     def __check_sample_weight(self, sample_weight: np.ndarray, n_samples):             # <<<<<<<<<<<<<<
- * 
- *         if sample_weight is None:
- */
-
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_2);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
   __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__check_sample_weight", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.predict_leaf_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_sample_weight);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":78
- *         return sample_weight
+/* "adaXT/predict/predict.pyx":75
+ *         return matrix
  * 
- *     def __check_dimensions(self, double[:, :] X):             # <<<<<<<<<<<<<<
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
- *         # If there is only a single point
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_7__check_dimensions(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_11forest_predict(CYTHON_UNUSED PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_7__check_dimensions = {"__check_dimensions", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_7__check_dimensions, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_7__check_dimensions(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_7Predict_11forest_predict = {"forest_predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_11forest_predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_11forest_predict(CYTHON_UNUSED PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  PyObject *__pyx_v_self = 0;
-  __Pyx_memviewslice __pyx_v_X = { 0, 0, { 0 }, { 0 }, { 0 } };
+  CYTHON_UNUSED PyObject *__pyx_v_predictions = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
+  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__check_dimensions (wrapper)", 0);
+  __Pyx_RefNannySetupContext("forest_predict (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
   #if CYTHON_ASSUME_SAFE_MACROS
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_X,0};
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_predictions,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
         case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_predictions)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 78, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 75, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 78, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__check_dimensions", 1, 2, 2, 1); __PYX_ERR(0, 78, __pyx_L3_error)
-        }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__check_dimensions") < 0)) __PYX_ERR(0, 78, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "forest_predict") < 0)) __PYX_ERR(0, 75, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 2)) {
+    } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_self = values[0];
-    __pyx_v_X = __Pyx_PyObject_to_MemoryviewSlice_dsds_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_X.memview)) __PYX_ERR(0, 78, __pyx_L3_error)
+    __pyx_v_predictions = values[0];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__check_dimensions", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 78, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("forest_predict", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 75, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__check_dimensions", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.forest_predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_6__check_dimensions(__pyx_self, __pyx_v_self, __pyx_v_X);
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_7Predict_10forest_predict(__pyx_v_predictions, __pyx_v_kwargs);
 
   /* function exit code */
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
+  __Pyx_DECREF(__pyx_v_kwargs);
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_6__check_dimensions(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, __Pyx_memviewslice __pyx_v_X) {
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_10forest_predict(CYTHON_UNUSED PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  __Pyx_memviewslice __pyx_t_5 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  int __pyx_t_6;
-  Py_ssize_t __pyx_t_7;
-  Py_UCS4 __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__check_dimensions", 1);
-  __PYX_INC_MEMVIEW(&__pyx_v_X, 1);
+  __Pyx_RefNannySetupContext("forest_predict", 1);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":79
+  /* "adaXT/predict/predict.pyx":77
+ *     @staticmethod
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")             # <<<<<<<<<<<<<<
  * 
- *     def __check_dimensions(self, double[:, :] X):
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)             # <<<<<<<<<<<<<<
- *         # If there is only a single point
- *         if X.ndim == 1:
+ *     @staticmethod
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 79, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 77, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ascontiguousarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 79, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __pyx_memoryview_fromslice(__pyx_v_X, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 79, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 79, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GIVEREF(__pyx_t_1);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1)) __PYX_ERR(0, 79, __pyx_L1_error);
-  __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 79, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DOUBLE); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 79, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_t_4) < 0) __PYX_ERR(0, 79, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 79, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_dsds_double(__pyx_t_4, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 79, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
-  __pyx_v_X = __pyx_t_5;
-  __pyx_t_5.memview = NULL;
-  __pyx_t_5.data = NULL;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":81
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
- *         # If there is only a single point
- *         if X.ndim == 1:             # <<<<<<<<<<<<<<
- *             if (X.shape[0] != self.n_features):
- *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")
- */
-  __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_X, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 81, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 81, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_6 = (__Pyx_PyInt_BoolEqObjC(__pyx_t_1, __pyx_int_1, 1, 0)); if (unlikely((__pyx_t_6 < 0))) __PYX_ERR(0, 81, __pyx_L1_error)
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (__pyx_t_6) {
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":82
- *         # If there is only a single point
- *         if X.ndim == 1:
- *             if (X.shape[0] != self.n_features):             # <<<<<<<<<<<<<<
- *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")
- * 
- */
-    __pyx_t_1 = PyInt_FromSsize_t((__pyx_v_X.shape[0])); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_n_features); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 82, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = PyObject_RichCompare(__pyx_t_1, __pyx_t_4, Py_NE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 82, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_6 < 0))) __PYX_ERR(0, 82, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(__pyx_t_6)) {
-
-      /* "adaXT/decision_tree/DecisionTree.pyx":83
- *         if X.ndim == 1:
- *             if (X.shape[0] != self.n_features):
- *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")             # <<<<<<<<<<<<<<
- * 
- *             # expand the dimensions
- */
-      __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 83, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_7 = 0;
-      __pyx_t_8 = 127;
-      __Pyx_INCREF(__pyx_kp_u_Number_of_features_should_be);
-      __pyx_t_7 += 29;
-      __Pyx_GIVEREF(__pyx_kp_u_Number_of_features_should_be);
-      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_Number_of_features_should_be);
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_n_features); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 83, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_t_4, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 83, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_8;
-      __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
-      __Pyx_GIVEREF(__pyx_t_1);
-      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
-      __pyx_t_1 = 0;
-      __Pyx_INCREF(__pyx_kp_u_got_2);
-      __pyx_t_7 += 6;
-      __Pyx_GIVEREF(__pyx_kp_u_got_2);
-      PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u_got_2);
-      __pyx_t_1 = __Pyx_PyUnicode_From_Py_ssize_t((__pyx_v_X.shape[0]), 0, ' ', 'd'); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 83, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
-      __Pyx_GIVEREF(__pyx_t_1);
-      PyTuple_SET_ITEM(__pyx_t_3, 3, __pyx_t_1);
-      __pyx_t_1 = 0;
-      __pyx_t_1 = __Pyx_PyUnicode_Join(__pyx_t_3, 4, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 83, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 83, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __PYX_ERR(0, 83, __pyx_L1_error)
-
-      /* "adaXT/decision_tree/DecisionTree.pyx":82
- *         # If there is only a single point
- *         if X.ndim == 1:
- *             if (X.shape[0] != self.n_features):             # <<<<<<<<<<<<<<
- *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")
- * 
- */
-    }
+  __PYX_ERR(0, 77, __pyx_L1_error)
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":86
- * 
- *             # expand the dimensions
- *             X = np.expand_dims(X, axis=0)             # <<<<<<<<<<<<<<
- *         else:
- *             if X.shape[1] != self.n_features:
- */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 86, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_expand_dims); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 86, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_X, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 86, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 86, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_GIVEREF(__pyx_t_3);
-    if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3)) __PYX_ERR(0, 86, __pyx_L1_error);
-    __pyx_t_3 = 0;
-    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 86, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_axis, __pyx_int_0) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
-    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 86, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_5 = __Pyx_PyObject_to_MemoryviewSlice_dsds_double(__pyx_t_2, PyBUF_WRITABLE); if (unlikely(!__pyx_t_5.memview)) __PYX_ERR(0, 86, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
-    __pyx_v_X = __pyx_t_5;
-    __pyx_t_5.memview = NULL;
-    __pyx_t_5.data = NULL;
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":81
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
- *         # If there is only a single point
- *         if X.ndim == 1:             # <<<<<<<<<<<<<<
- *             if (X.shape[0] != self.n_features):
- *                 raise ValueError(f"Number of features should be {self.n_features}, got {X.shape[0]}")
- */
-    goto __pyx_L3;
-  }
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":88
- *             X = np.expand_dims(X, axis=0)
- *         else:
- *             if X.shape[1] != self.n_features:             # <<<<<<<<<<<<<<
- *                 raise ValueError(f"Dimension should be {self.n_features}, got {X.shape[1]}")
- *         return X
- */
-  /*else*/ {
-    __pyx_t_2 = PyInt_FromSsize_t((__pyx_v_X.shape[1])); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 88, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_n_features); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 88, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PyObject_RichCompare(__pyx_t_2, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 88, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_6 < 0))) __PYX_ERR(0, 88, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(__pyx_t_6)) {
-
-      /* "adaXT/decision_tree/DecisionTree.pyx":89
- *         else:
- *             if X.shape[1] != self.n_features:
- *                 raise ValueError(f"Dimension should be {self.n_features}, got {X.shape[1]}")             # <<<<<<<<<<<<<<
- *         return X
- * 
- */
-      __pyx_t_4 = PyTuple_New(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 89, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_7 = 0;
-      __pyx_t_8 = 127;
-      __Pyx_INCREF(__pyx_kp_u_Dimension_should_be);
-      __pyx_t_7 += 20;
-      __Pyx_GIVEREF(__pyx_kp_u_Dimension_should_be);
-      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_u_Dimension_should_be);
-      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_n_features); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 89, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_t_3, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-      __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_8;
-      __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
-      __Pyx_GIVEREF(__pyx_t_2);
-      PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
-      __pyx_t_2 = 0;
-      __Pyx_INCREF(__pyx_kp_u_got_2);
-      __pyx_t_7 += 6;
-      __Pyx_GIVEREF(__pyx_kp_u_got_2);
-      PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_kp_u_got_2);
-      __pyx_t_2 = __Pyx_PyUnicode_From_Py_ssize_t((__pyx_v_X.shape[1]), 0, ' ', 'd'); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
-      __Pyx_GIVEREF(__pyx_t_2);
-      PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_t_2);
-      __pyx_t_2 = 0;
-      __pyx_t_2 = __Pyx_PyUnicode_Join(__pyx_t_4, 4, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_2);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 89, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __PYX_ERR(0, 89, __pyx_L1_error)
-
-      /* "adaXT/decision_tree/DecisionTree.pyx":88
- *             X = np.expand_dims(X, axis=0)
- *         else:
- *             if X.shape[1] != self.n_features:             # <<<<<<<<<<<<<<
- *                 raise ValueError(f"Dimension should be {self.n_features}, got {X.shape[1]}")
- *         return X
- */
-    }
-  }
-  __pyx_L3:;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":90
- *             if X.shape[1] != self.n_features:
- *                 raise ValueError(f"Dimension should be {self.n_features}, got {X.shape[1]}")
- *         return X             # <<<<<<<<<<<<<<
- * 
- *     def fit(
- */
-  __Pyx_XDECREF(__pyx_r);
-  __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_X, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 90, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_r = __pyx_t_4;
-  __pyx_t_4 = 0;
-  goto __pyx_L0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":78
- *         return sample_weight
+  /* "adaXT/predict/predict.pyx":75
+ *         return matrix
  * 
- *     def __check_dimensions(self, double[:, :] X):             # <<<<<<<<<<<<<<
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
- *         # If there is only a single point
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_5, 1);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__check_dimensions", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.forest_predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
-  __pyx_L0:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":92
- *         return X
+/* "adaXT/predict/predict.pyx":79
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  * 
- *     def fit(             # <<<<<<<<<<<<<<
- *             self,
- *             X,
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_9fit(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_13forest_predict_proba(CYTHON_UNUSED PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_9fit = {"fit", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_9fit, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_9fit(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_7Predict_13forest_predict_proba = {"forest_predict_proba", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_13forest_predict_proba, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_7Predict_13forest_predict_proba(CYTHON_UNUSED PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  PyObject *__pyx_v_self = 0;
-  PyObject *__pyx_v_X = 0;
-  PyObject *__pyx_v_Y = 0;
-  PyObject *__pyx_v_feature_indices = 0;
-  PyObject *__pyx_v_sample_indices = 0;
-  PyObject *__pyx_v_sample_weight = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_predictions = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[6] = {0,0,0,0,0,0};
+  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("fit (wrapper)", 0);
+  __Pyx_RefNannySetupContext("forest_predict_proba (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
   #if CYTHON_ASSUME_SAFE_MACROS
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_predictions,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_predictions)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 79, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "forest_predict_proba") < 0)) __PYX_ERR(0, 79, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 1)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+    }
+    __pyx_v_predictions = values[0];
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("forest_predict_proba", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 79, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_X,&__pyx_n_s_Y,&__pyx_n_s_feature_indices,&__pyx_n_s_sample_indices,&__pyx_n_s_sample_weight,0};
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.forest_predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_7Predict_12forest_predict_proba(__pyx_v_predictions, __pyx_v_kwargs);
+
+  /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":96
- *             X,
- *             Y,
- *             feature_indices: np.ndarray | None = None,             # <<<<<<<<<<<<<<
- *             sample_indices: np.ndarray | None = None,
- *             sample_weight: np.ndarray | None = None,) -> None:
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_7Predict_12forest_predict_proba(CYTHON_UNUSED PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("forest_predict_proba", 1);
+
+  /* "adaXT/predict/predict.pyx":81
+ *     @staticmethod
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")             # <<<<<<<<<<<<<<
+ * 
+ * cdef class PredictClassification(Predict):
  */
-    values[3] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)Py_None));
+  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 81, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __PYX_ERR(0, 81, __pyx_L1_error)
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":97
- *             Y,
- *             feature_indices: np.ndarray | None = None,
- *             sample_indices: np.ndarray | None = None,             # <<<<<<<<<<<<<<
- *             sample_weight: np.ndarray | None = None,) -> None:
+  /* "adaXT/predict/predict.pyx":79
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  * 
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  */
-    values[4] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)Py_None));
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":98
- *             feature_indices: np.ndarray | None = None,
- *             sample_indices: np.ndarray | None = None,
- *             sample_weight: np.ndarray | None = None,) -> None:             # <<<<<<<<<<<<<<
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("adaXT.predict.predict.Predict.forest_predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/predict/predict.pyx":84
+ * 
+ * cdef class PredictClassification(Predict):
+ *     def __cinit__(self, double[:, ::1] X, double[::1] Y, object root, **kwargs):             # <<<<<<<<<<<<<<
+ *         self.classes = np.unique(Y)
  * 
- *         X, Y = self.__check_input(X, Y)
  */
-    values[5] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)Py_None));
+
+/* Python wrapper */
+static int __pyx_pw_5adaXT_7predict_7predict_21PredictClassification_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static int __pyx_pw_5adaXT_7predict_7predict_21PredictClassification_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  CYTHON_UNUSED __Pyx_memviewslice __pyx_v_X = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_v_Y = { 0, 0, { 0 }, { 0 }, { 0 } };
+  CYTHON_UNUSED PyObject *__pyx_v_root = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[3] = {0,0,0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  int __pyx_r;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return -1;
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_VARARGS(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return -1;
+  __Pyx_GOTREF(__pyx_v_kwargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_Y,&__pyx_n_s_root,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  6: values[5] = __Pyx_Arg_FASTCALL(__pyx_args, 5);
-        CYTHON_FALLTHROUGH;
-        case  5: values[4] = __Pyx_Arg_FASTCALL(__pyx_args, 4);
-        CYTHON_FALLTHROUGH;
-        case  4: values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
-        CYTHON_FALLTHROUGH;
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+        case  3: values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
         CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        case  2: values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
         CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        case  1: values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
-      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+        if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
+          (void)__Pyx_Arg_NewRef_VARARGS(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 92, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 84, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
+        if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_Y)) != 0)) {
+          (void)__Pyx_Arg_NewRef_VARARGS(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 92, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 84, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("fit", 0, 3, 6, 1); __PYX_ERR(0, 92, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 1); __PYX_ERR(0, 84, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
-        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_Y)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
+        if (likely((values[2] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_root)) != 0)) {
+          (void)__Pyx_Arg_NewRef_VARARGS(values[2]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 92, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 84, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("fit", 0, 3, 6, 2); __PYX_ERR(0, 92, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  3:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_feature_indices);
-          if (value) { values[3] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 92, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  4:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_sample_indices);
-          if (value) { values[4] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 92, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  5:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_sample_weight);
-          if (value) { values[5] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 92, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, 2); __PYX_ERR(0, 84, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "fit") < 0)) __PYX_ERR(0, 92, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "__cinit__") < 0)) __PYX_ERR(0, 84, __pyx_L3_error)
       }
+    } else if (unlikely(__pyx_nargs != 3)) {
+      goto __pyx_L5_argtuple_error;
     } else {
-      switch (__pyx_nargs) {
-        case  6: values[5] = __Pyx_Arg_FASTCALL(__pyx_args, 5);
-        CYTHON_FALLTHROUGH;
-        case  5: values[4] = __Pyx_Arg_FASTCALL(__pyx_args, 4);
-        CYTHON_FALLTHROUGH;
-        case  4: values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
-        CYTHON_FALLTHROUGH;
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
-        values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        break;
-        default: goto __pyx_L5_argtuple_error;
-      }
+      values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
+      values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
+      values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
     }
-    __pyx_v_self = values[0];
-    __pyx_v_X = values[1];
-    __pyx_v_Y = values[2];
-    __pyx_v_feature_indices = values[3];
-    __pyx_v_sample_indices = values[4];
-    __pyx_v_sample_weight = values[5];
+    __pyx_v_X = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_X.memview)) __PYX_ERR(0, 84, __pyx_L3_error)
+    __pyx_v_Y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_Y.memview)) __PYX_ERR(0, 84, __pyx_L3_error)
+    __pyx_v_root = values[2];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("fit", 0, 3, 6, __pyx_nargs); __PYX_ERR(0, 92, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 84, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.fit", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
-  return NULL;
+  return -1;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_8fit(__pyx_self, __pyx_v_self, __pyx_v_X, __pyx_v_Y, __pyx_v_feature_indices, __pyx_v_sample_indices, __pyx_v_sample_weight);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":92
- *         return X
- * 
- *     def fit(             # <<<<<<<<<<<<<<
- *             self,
- *             X,
- */
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_21PredictClassification___cinit__(((struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *)__pyx_v_self), __pyx_v_X, __pyx_v_Y, __pyx_v_root, __pyx_v_kwargs);
 
   /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
-      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+      __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_8fit(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_X, PyObject *__pyx_v_Y, PyObject *__pyx_v_feature_indices, PyObject *__pyx_v_sample_indices, PyObject *__pyx_v_sample_weight) {
-  PyObject *__pyx_v_row = NULL;
-  PyObject *__pyx_v_col = NULL;
-  PyObject *__pyx_v_builder = NULL;
-  PyObject *__pyx_r = NULL;
+static int __pyx_pf_5adaXT_7predict_7predict_21PredictClassification___cinit__(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, CYTHON_UNUSED __Pyx_memviewslice __pyx_v_X, __Pyx_memviewslice __pyx_v_Y, CYTHON_UNUSED PyObject *__pyx_v_root, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
+  int __pyx_r;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
-  int __pyx_t_4;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *(*__pyx_t_6)(PyObject *);
-  int __pyx_t_7;
-  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  __Pyx_memviewslice __pyx_t_6 = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("fit", 0);
-  __Pyx_INCREF(__pyx_v_X);
-  __Pyx_INCREF(__pyx_v_Y);
-  __Pyx_INCREF(__pyx_v_feature_indices);
-  __Pyx_INCREF(__pyx_v_sample_weight);
+  __Pyx_RefNannySetupContext("__cinit__", 1);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":100
- *             sample_weight: np.ndarray | None = None,) -> None:
- * 
- *         X, Y = self.__check_input(X, Y)             # <<<<<<<<<<<<<<
- *         row, col = X.shape
+  /* "adaXT/predict/predict.pyx":85
+ * cdef class PredictClassification(Predict):
+ *     def __cinit__(self, double[:, ::1] X, double[::1] Y, object root, **kwargs):
+ *         self.classes = np.unique(Y)             # <<<<<<<<<<<<<<
  * 
+ *     cdef int __find_max_index(self, double[::1] lst):
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_DecisionTree__check_input); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 85, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = NULL;
-  __pyx_t_4 = 0;
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 85, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 85, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = NULL;
+  __pyx_t_5 = 0;
   #if CYTHON_UNPACK_METHODS
-  if (likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_3)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_3);
+  if (unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-      __pyx_t_4 = 1;
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __pyx_t_5 = 1;
     }
   }
   #endif
   {
-    PyObject *__pyx_callargs[3] = {__pyx_t_3, __pyx_v_X, __pyx_v_Y};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_2, __pyx_callargs+1-__pyx_t_4, 2+__pyx_t_4);
-    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 100, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_t_2};
+    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 85, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
-  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
-    PyObject* sequence = __pyx_t_1;
-    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
-    if (unlikely(size != 2)) {
-      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 100, __pyx_L1_error)
-    }
-    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    if (likely(PyTuple_CheckExact(sequence))) {
-      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
-      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
-    } else {
-      __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
-      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
-    }
-    __Pyx_INCREF(__pyx_t_2);
-    __Pyx_INCREF(__pyx_t_3);
-    #else
-    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 100, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 100, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    #endif
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  } else {
-    Py_ssize_t index = -1;
-    __pyx_t_5 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 100, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_6 = __Pyx_PyObject_GetIterNextFunc(__pyx_t_5);
-    index = 0; __pyx_t_2 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_2);
-    index = 1; __pyx_t_3 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_3);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_5), 2) < 0) __PYX_ERR(0, 100, __pyx_L1_error)
-    __pyx_t_6 = NULL;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    goto __pyx_L4_unpacking_done;
-    __pyx_L3_unpacking_failed:;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_6 = NULL;
-    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 100, __pyx_L1_error)
-    __pyx_L4_unpacking_done:;
-  }
-  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_2);
-  __pyx_t_2 = 0;
-  __Pyx_DECREF_SET(__pyx_v_Y, __pyx_t_3);
-  __pyx_t_3 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":101
- * 
- *         X, Y = self.__check_input(X, Y)
- *         row, col = X.shape             # <<<<<<<<<<<<<<
- * 
- *         # If sample_weight is valid it is simply passed through check_sample_weight, if it is None all entries are set to 1
- */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 101, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
-    PyObject* sequence = __pyx_t_1;
-    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
-    if (unlikely(size != 2)) {
-      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
-      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 101, __pyx_L1_error)
-    }
-    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    if (likely(PyTuple_CheckExact(sequence))) {
-      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
-      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 1); 
-    } else {
-      __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
-      __pyx_t_2 = PyList_GET_ITEM(sequence, 1); 
-    }
-    __Pyx_INCREF(__pyx_t_3);
-    __Pyx_INCREF(__pyx_t_2);
-    #else
-    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 101, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 101, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    #endif
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  } else {
-    Py_ssize_t index = -1;
-    __pyx_t_5 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 101, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_6 = __Pyx_PyObject_GetIterNextFunc(__pyx_t_5);
-    index = 0; __pyx_t_3 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_3)) goto __pyx_L5_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_3);
-    index = 1; __pyx_t_2 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_2)) goto __pyx_L5_unpacking_failed;
-    __Pyx_GOTREF(__pyx_t_2);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_5), 2) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
-    __pyx_t_6 = NULL;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    goto __pyx_L6_unpacking_done;
-    __pyx_L5_unpacking_failed:;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_6 = NULL;
-    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 101, __pyx_L1_error)
-    __pyx_L6_unpacking_done:;
-  }
-  __pyx_v_row = __pyx_t_3;
-  __pyx_t_3 = 0;
-  __pyx_v_col = __pyx_t_2;
-  __pyx_t_2 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":104
- * 
- *         # If sample_weight is valid it is simply passed through check_sample_weight, if it is None all entries are set to 1
- *         sample_weight = self.__check_sample_weight(sample_weight=sample_weight, n_samples=row)             # <<<<<<<<<<<<<<
- * 
- *         if feature_indices is None:
- */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_DecisionTree__check_sample_weig); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 104, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 104, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_sample_weight, __pyx_v_sample_weight) < 0) __PYX_ERR(0, 104, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_n_samples, __pyx_v_row) < 0) __PYX_ERR(0, 104, __pyx_L1_error)
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_empty_tuple, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 104, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_6 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_6.memview)) __PYX_ERR(0, 85, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF_SET(__pyx_v_sample_weight, __pyx_t_3);
-  __pyx_t_3 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":106
- *         sample_weight = self.__check_sample_weight(sample_weight=sample_weight, n_samples=row)
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->classes, 0);
+  __pyx_v_self->classes = __pyx_t_6;
+  __pyx_t_6.memview = NULL;
+  __pyx_t_6.data = NULL;
+
+  /* "adaXT/predict/predict.pyx":84
+ * 
+ * cdef class PredictClassification(Predict):
+ *     def __cinit__(self, double[:, ::1] X, double[::1] Y, object root, **kwargs):             # <<<<<<<<<<<<<<
+ *         self.classes = np.unique(Y)
  * 
- *         if feature_indices is None:             # <<<<<<<<<<<<<<
- *             feature_indices = np.arange(col, dtype=np.int32)
- *         builder = DepthTreeBuilder(
  */
-  __pyx_t_7 = (__pyx_v_feature_indices == Py_None);
-  if (__pyx_t_7) {
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":107
- * 
- *         if feature_indices is None:
- *             feature_indices = np.arange(col, dtype=np.int32)             # <<<<<<<<<<<<<<
- *         builder = DepthTreeBuilder(
- *             X=X,
- */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 107, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_arange); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 107, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 107, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_INCREF(__pyx_v_col);
-    __Pyx_GIVEREF(__pyx_v_col);
-    if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_col)) __PYX_ERR(0, 107, __pyx_L1_error);
-    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 107, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 107, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_int32); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 107, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_t_8) < 0) __PYX_ERR(0, 107, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-    __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_3, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 107, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_8);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __Pyx_DECREF_SET(__pyx_v_feature_indices, __pyx_t_8);
-    __pyx_t_8 = 0;
+  /* function exit code */
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_6, 1);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = -1;
+  __pyx_L0:;
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":106
- *         sample_weight = self.__check_sample_weight(sample_weight=sample_weight, n_samples=row)
+/* "adaXT/predict/predict.pyx":87
+ *         self.classes = np.unique(Y)
  * 
- *         if feature_indices is None:             # <<<<<<<<<<<<<<
- *             feature_indices = np.arange(col, dtype=np.int32)
- *         builder = DepthTreeBuilder(
+ *     cdef int __find_max_index(self, double[::1] lst):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int cur_max, i
  */
-  }
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":108
- *         if feature_indices is None:
- *             feature_indices = np.arange(col, dtype=np.int32)
- *         builder = DepthTreeBuilder(             # <<<<<<<<<<<<<<
- *             X=X,
- *             Y=Y,
+static int __pyx_f_5adaXT_7predict_7predict_21PredictClassification__PredictClassification__find_max_index(CYTHON_UNUSED struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, __Pyx_memviewslice __pyx_v_lst) {
+  int __pyx_v_cur_max;
+  int __pyx_v_i;
+  int __pyx_r;
+  Py_ssize_t __pyx_t_1;
+  Py_ssize_t __pyx_t_2;
+  int __pyx_t_3;
+  Py_ssize_t __pyx_t_4;
+  Py_ssize_t __pyx_t_5;
+  int __pyx_t_6;
+
+  /* "adaXT/predict/predict.pyx":90
+ *         cdef:
+ *             int cur_max, i
+ *         cur_max = 0             # <<<<<<<<<<<<<<
+ *         for i in range(1, len(lst)):
+ *             if lst[cur_max] < lst[i]:
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_DepthTreeBuilder); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 108, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_8);
+  __pyx_v_cur_max = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":109
- *             feature_indices = np.arange(col, dtype=np.int32)
- *         builder = DepthTreeBuilder(
- *             X=X,             # <<<<<<<<<<<<<<
- *             Y=Y,
- *             sample_indices=sample_indices,
+  /* "adaXT/predict/predict.pyx":91
+ *             int cur_max, i
+ *         cur_max = 0
+ *         for i in range(1, len(lst)):             # <<<<<<<<<<<<<<
+ *             if lst[cur_max] < lst[i]:
+ *                 cur_max = i
  */
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 109, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_X, __pyx_v_X) < 0) __PYX_ERR(0, 109, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_MemoryView_Len(__pyx_v_lst); 
+  __pyx_t_2 = __pyx_t_1;
+  for (__pyx_t_3 = 1; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
+    __pyx_v_i = __pyx_t_3;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":110
- *         builder = DepthTreeBuilder(
- *             X=X,
- *             Y=Y,             # <<<<<<<<<<<<<<
- *             sample_indices=sample_indices,
- *             feature_indices=feature_indices,
- */
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_Y, __pyx_v_Y) < 0) __PYX_ERR(0, 109, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":111
- *             X=X,
- *             Y=Y,
- *             sample_indices=sample_indices,             # <<<<<<<<<<<<<<
- *             feature_indices=feature_indices,
- *             sample_weight=sample_weight,
- */
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_sample_indices, __pyx_v_sample_indices) < 0) __PYX_ERR(0, 109, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":112
- *             Y=Y,
- *             sample_indices=sample_indices,
- *             feature_indices=feature_indices,             # <<<<<<<<<<<<<<
- *             sample_weight=sample_weight,
- *             criteria=self.criteria(X, Y, sample_weight),
- */
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_feature_indices, __pyx_v_feature_indices) < 0) __PYX_ERR(0, 109, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":113
- *             sample_indices=sample_indices,
- *             feature_indices=feature_indices,
- *             sample_weight=sample_weight,             # <<<<<<<<<<<<<<
- *             criteria=self.criteria(X, Y, sample_weight),
- *             splitter=self.splitter)
- */
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_sample_weight, __pyx_v_sample_weight) < 0) __PYX_ERR(0, 109, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":114
- *             feature_indices=feature_indices,
- *             sample_weight=sample_weight,
- *             criteria=self.criteria(X, Y, sample_weight),             # <<<<<<<<<<<<<<
- *             splitter=self.splitter)
- *         builder.build_tree(self)
+    /* "adaXT/predict/predict.pyx":92
+ *         cur_max = 0
+ *         for i in range(1, len(lst)):
+ *             if lst[cur_max] < lst[i]:             # <<<<<<<<<<<<<<
+ *                 cur_max = i
+ *         return cur_max
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_criteria); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 114, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = NULL;
-  __pyx_t_4 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (likely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_5);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-      __pyx_t_4 = 1;
-    }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[4] = {__pyx_t_5, __pyx_v_X, __pyx_v_Y, __pyx_v_sample_weight};
-    __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_2, __pyx_callargs+1-__pyx_t_4, 3+__pyx_t_4);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 114, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  }
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_criteria, __pyx_t_3) < 0) __PYX_ERR(0, 109, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_4 = __pyx_v_cur_max;
+    __pyx_t_5 = __pyx_v_i;
+    __pyx_t_6 = ((*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_lst.data) + __pyx_t_4)) ))) < (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_lst.data) + __pyx_t_5)) ))));
+    if (__pyx_t_6) {
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":115
- *             sample_weight=sample_weight,
- *             criteria=self.criteria(X, Y, sample_weight),
- *             splitter=self.splitter)             # <<<<<<<<<<<<<<
- *         builder.build_tree(self)
+      /* "adaXT/predict/predict.pyx":93
+ *         for i in range(1, len(lst)):
+ *             if lst[cur_max] < lst[i]:
+ *                 cur_max = i             # <<<<<<<<<<<<<<
+ *         return cur_max
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_splitter); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 115, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_splitter, __pyx_t_3) < 0) __PYX_ERR(0, 109, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_v_cur_max = __pyx_v_i;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":108
- *         if feature_indices is None:
- *             feature_indices = np.arange(col, dtype=np.int32)
- *         builder = DepthTreeBuilder(             # <<<<<<<<<<<<<<
- *             X=X,
- *             Y=Y,
+      /* "adaXT/predict/predict.pyx":92
+ *         cur_max = 0
+ *         for i in range(1, len(lst)):
+ *             if lst[cur_max] < lst[i]:             # <<<<<<<<<<<<<<
+ *                 cur_max = i
+ *         return cur_max
  */
-  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 108, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v_builder = __pyx_t_3;
-  __pyx_t_3 = 0;
+    }
+  }
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":116
- *             criteria=self.criteria(X, Y, sample_weight),
- *             splitter=self.splitter)
- *         builder.build_tree(self)             # <<<<<<<<<<<<<<
+  /* "adaXT/predict/predict.pyx":94
+ *             if lst[cur_max] < lst[i]:
+ *                 cur_max = i
+ *         return cur_max             # <<<<<<<<<<<<<<
  * 
- *     def predict(self, X: np.ndarray):
+ *     def predict(self, object X, **kwargs):
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_builder, __pyx_n_s_build_tree); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 116, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_8 = NULL;
-  __pyx_t_4 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (likely(PyMethod_Check(__pyx_t_1))) {
-    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_1);
-    if (likely(__pyx_t_8)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-      __Pyx_INCREF(__pyx_t_8);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_1, function);
-      __pyx_t_4 = 1;
-    }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_8, __pyx_v_self};
-    __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_1, __pyx_callargs+1-__pyx_t_4, 1+__pyx_t_4);
-    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 116, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  }
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_v_cur_max;
+  goto __pyx_L0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":92
- *         return X
+  /* "adaXT/predict/predict.pyx":87
+ *         self.classes = np.unique(Y)
  * 
- *     def fit(             # <<<<<<<<<<<<<<
- *             self,
- *             X,
+ *     cdef int __find_max_index(self, double[::1] lst):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int cur_max, i
  */
 
   /* function exit code */
-  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
-  goto __pyx_L0;
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_8);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.fit", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_row);
-  __Pyx_XDECREF(__pyx_v_col);
-  __Pyx_XDECREF(__pyx_v_builder);
-  __Pyx_XDECREF(__pyx_v_X);
-  __Pyx_XDECREF(__pyx_v_Y);
-  __Pyx_XDECREF(__pyx_v_feature_indices);
-  __Pyx_XDECREF(__pyx_v_sample_weight);
-  __Pyx_XGIVEREF(__pyx_r);
-  __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":118
- *         builder.build_tree(self)
+/* "adaXT/predict/predict.pyx":96
+ *         return cur_max
  * 
- *     def predict(self, X: np.ndarray):             # <<<<<<<<<<<<<<
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
  *         cdef:
  *             int i, cur_split_idx, idx, n_obs
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_11predict(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_3predict(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_11predict = {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_11predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_11predict(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_3predict = {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_3predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_3predict(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  PyObject *__pyx_v_self = 0;
   PyObject *__pyx_v_X = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
+  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("predict (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
   #if CYTHON_ASSUME_SAFE_MACROS
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_X,0};
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
         case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 118, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 96, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 118, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("predict", 1, 2, 2, 1); __PYX_ERR(0, 118, __pyx_L3_error)
-        }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "predict") < 0)) __PYX_ERR(0, 118, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "predict") < 0)) __PYX_ERR(0, 96, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 2)) {
+    } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_self = values[0];
-    __pyx_v_X = values[1];
+    __pyx_v_X = values[0];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("predict", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 118, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("predict", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 96, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_10predict(__pyx_self, __pyx_v_self, __pyx_v_X);
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_21PredictClassification_2predict(((struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *)__pyx_v_self), __pyx_v_X, __pyx_v_kwargs);
 
   /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_10predict(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_X) {
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_2predict(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
   int __pyx_v_i;
   int __pyx_v_cur_split_idx;
   int __pyx_v_idx;
   int __pyx_v_n_obs;
   double __pyx_v_cur_threshold;
   PyObject *__pyx_v_cur_node = 0;
   __Pyx_memviewslice __pyx_v_Y = { 0, 0, { 0 }, { 0 }, { 0 } };
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
+  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
-  int __pyx_t_6;
-  PyObject *__pyx_t_7 = NULL;
-  __Pyx_memviewslice __pyx_t_8 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  PyObject *__pyx_t_6 = NULL;
+  __Pyx_memviewslice __pyx_t_7 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_t_8;
   int __pyx_t_9;
   int __pyx_t_10;
   int __pyx_t_11;
   double __pyx_t_12;
-  Py_ssize_t __pyx_t_13;
+  __Pyx_memviewslice __pyx_t_13 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  Py_ssize_t __pyx_t_14;
+  Py_ssize_t __pyx_t_15;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("predict", 0);
   __Pyx_INCREF(__pyx_v_X);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":124
- *             object cur_node
- *             double[:] Y
- *         if not self.root:             # <<<<<<<<<<<<<<
- *             raise AttributeError("The tree has not been fitted before trying to call predict")
- * 
- */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_root); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 124, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 124, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = (!__pyx_t_2);
-  if (unlikely(__pyx_t_3)) {
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":125
- *             double[:] Y
- *         if not self.root:
- *             raise AttributeError("The tree has not been fitted before trying to call predict")             # <<<<<<<<<<<<<<
+  /* "adaXT/predict/predict.pyx":104
  * 
  *         # Make sure that x fits the dimensions.
- */
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_AttributeError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 125, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 125, __pyx_L1_error)
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":124
- *             object cur_node
- *             double[:] Y
- *         if not self.root:             # <<<<<<<<<<<<<<
- *             raise AttributeError("The tree has not been fitted before trying to call predict")
- * 
- */
-  }
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":128
- * 
- *         # Make sure that x fits the dimensions.
- *         X = self.__check_dimensions(X)             # <<<<<<<<<<<<<<
+ *         X = Predict.__check_dimensions(self, X)             # <<<<<<<<<<<<<<
  *         n_obs = X.shape[0]
  *         Y = np.empty(n_obs)
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_DecisionTree__check_dimensions); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 128, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = NULL;
-  __pyx_t_6 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (likely(PyMethod_Check(__pyx_t_4))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-      __Pyx_INCREF(__pyx_t_5);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_4, function);
-      __pyx_t_6 = 1;
-    }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_v_X};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 128, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  }
-  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_1);
-  __pyx_t_1 = 0;
+  __pyx_t_1 = __pyx_f_5adaXT_7predict_7predict_7Predict__Predict__check_dimensions(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self), __pyx_v_X); if (unlikely(!__pyx_t_1.memview)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_t_1, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_t_1.memview = NULL; __pyx_t_1.data = NULL;
+  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_2);
+  __pyx_t_2 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":129
+  /* "adaXT/predict/predict.pyx":105
  *         # Make sure that x fits the dimensions.
- *         X = self.__check_dimensions(X)
+ *         X = Predict.__check_dimensions(self, X)
  *         n_obs = X.shape[0]             # <<<<<<<<<<<<<<
  *         Y = np.empty(n_obs)
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 129, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_4); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 129, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_v_n_obs = __pyx_t_6;
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 105, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_2, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 105, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 105, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_n_obs = __pyx_t_4;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":130
- *         X = self.__check_dimensions(X)
+  /* "adaXT/predict/predict.pyx":106
+ *         X = Predict.__check_dimensions(self, X)
  *         n_obs = X.shape[0]
  *         Y = np.empty(n_obs)             # <<<<<<<<<<<<<<
  * 
  *         for i in range(n_obs):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_empty); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 130, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 106, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_empty); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 106, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_n_obs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = NULL;
-  __pyx_t_6 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_n_obs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 106, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_6 = NULL;
+  __pyx_t_4 = 0;
   #if CYTHON_UNPACK_METHODS
   if (unlikely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_7)) {
+    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
+    if (likely(__pyx_t_6)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_7);
+      __Pyx_INCREF(__pyx_t_6);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
-      __pyx_t_6 = 1;
+      __pyx_t_4 = 1;
     }
   }
   #endif
   {
-    PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_t_1};
-    __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 130, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
+    PyObject *__pyx_callargs[2] = {__pyx_t_6, __pyx_t_2};
+    __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_4, 1+__pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 106, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
-  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_t_4, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 130, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_v_Y = __pyx_t_8;
-  __pyx_t_8.memview = NULL;
-  __pyx_t_8.data = NULL;
+  __pyx_t_7 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_t_3, PyBUF_WRITABLE); if (unlikely(!__pyx_t_7.memview)) __PYX_ERR(0, 106, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_Y = __pyx_t_7;
+  __pyx_t_7.memview = NULL;
+  __pyx_t_7.data = NULL;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":132
+  /* "adaXT/predict/predict.pyx":108
  *         Y = np.empty(n_obs)
  * 
  *         for i in range(n_obs):             # <<<<<<<<<<<<<<
  *             cur_node = self.root
  *             while isinstance(cur_node, DecisionNode):
  */
-  __pyx_t_6 = __pyx_v_n_obs;
-  __pyx_t_9 = __pyx_t_6;
-  for (__pyx_t_10 = 0; __pyx_t_10 < __pyx_t_9; __pyx_t_10+=1) {
-    __pyx_v_i = __pyx_t_10;
+  __pyx_t_4 = __pyx_v_n_obs;
+  __pyx_t_8 = __pyx_t_4;
+  for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
+    __pyx_v_i = __pyx_t_9;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":133
+    /* "adaXT/predict/predict.pyx":109
  * 
  *         for i in range(n_obs):
  *             cur_node = self.root             # <<<<<<<<<<<<<<
  *             while isinstance(cur_node, DecisionNode):
  *                 cur_split_idx = cur_node.split_idx
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_root); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 133, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_XDECREF_SET(__pyx_v_cur_node, __pyx_t_4);
-    __pyx_t_4 = 0;
+    __pyx_t_3 = __pyx_v_self->__pyx_base.root;
+    __Pyx_INCREF(__pyx_t_3);
+    __Pyx_XDECREF_SET(__pyx_v_cur_node, __pyx_t_3);
+    __pyx_t_3 = 0;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":134
+    /* "adaXT/predict/predict.pyx":110
  *         for i in range(n_obs):
  *             cur_node = self.root
  *             while isinstance(cur_node, DecisionNode):             # <<<<<<<<<<<<<<
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold
  */
     while (1) {
-      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 134, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_IsInstance(__pyx_v_cur_node, __pyx_t_4); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 134, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (!__pyx_t_3) break;
+      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 110, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_10 = PyObject_IsInstance(__pyx_v_cur_node, __pyx_t_3); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 110, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (!__pyx_t_10) break;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":135
+      /* "adaXT/predict/predict.pyx":111
  *             cur_node = self.root
  *             while isinstance(cur_node, DecisionNode):
  *                 cur_split_idx = cur_node.split_idx             # <<<<<<<<<<<<<<
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_split_idx); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 135, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_11 = __Pyx_PyInt_As_int(__pyx_t_4); if (unlikely((__pyx_t_11 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 135, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_split_idx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 111, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_11 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_11 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 111, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __pyx_v_cur_split_idx = __pyx_t_11;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":136
+      /* "adaXT/predict/predict.pyx":112
  *             while isinstance(cur_node, DecisionNode):
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold             # <<<<<<<<<<<<<<
  *                 if X[i, cur_split_idx] < cur_threshold:
  *                     cur_node = cur_node.left_child
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_threshold); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 136, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 136, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_threshold); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 112, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_t_3); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 112, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __pyx_v_cur_threshold = __pyx_t_12;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":137
+      /* "adaXT/predict/predict.pyx":113
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
  *                     cur_node = cur_node.left_child
  *                 else:
  */
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 137, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_cur_split_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 137, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 113, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_cur_split_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 113, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_GIVEREF(__pyx_t_4);
-      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_4)) __PYX_ERR(0, 137, __pyx_L1_error);
+      __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 113, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_3);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3)) __PYX_ERR(0, 113, __pyx_L1_error);
       __Pyx_GIVEREF(__pyx_t_5);
-      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_5)) __PYX_ERR(0, 137, __pyx_L1_error);
-      __pyx_t_4 = 0;
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_5)) __PYX_ERR(0, 113, __pyx_L1_error);
+      __pyx_t_3 = 0;
       __pyx_t_5 = 0;
-      __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 137, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 113, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_1 = PyFloat_FromDouble(__pyx_v_cur_threshold); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_t_5, __pyx_t_1, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 137, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_t_2 = PyFloat_FromDouble(__pyx_v_cur_threshold); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 113, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_t_2, Py_LT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 113, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 137, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (__pyx_t_3) {
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_10 < 0))) __PYX_ERR(0, 113, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (__pyx_t_10) {
 
-        /* "adaXT/decision_tree/DecisionTree.pyx":138
+        /* "adaXT/predict/predict.pyx":114
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:
  *                     cur_node = cur_node.left_child             # <<<<<<<<<<<<<<
  *                 else:
  *                     cur_node = cur_node.right_child
  */
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_left_child); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 138, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_4);
-        __pyx_t_4 = 0;
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_left_child); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 114, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_3);
+        __pyx_t_3 = 0;
 
-        /* "adaXT/decision_tree/DecisionTree.pyx":137
+        /* "adaXT/predict/predict.pyx":113
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
  *                     cur_node = cur_node.left_child
  *                 else:
  */
-        goto __pyx_L8;
+        goto __pyx_L7;
       }
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":140
+      /* "adaXT/predict/predict.pyx":116
  *                     cur_node = cur_node.left_child
  *                 else:
  *                     cur_node = cur_node.right_child             # <<<<<<<<<<<<<<
- *             if self.tree_type == "Regression":
- *                 Y[i] = cur_node.value[0]
+ * 
+ *             idx = self.__find_max_index(cur_node.value)
  */
       /*else*/ {
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_right_child); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 140, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_4);
-        __pyx_t_4 = 0;
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_right_child); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 116, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_3);
+        __pyx_t_3 = 0;
       }
-      __pyx_L8:;
+      __pyx_L7:;
     }
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":141
- *                 else:
+    /* "adaXT/predict/predict.pyx":118
  *                     cur_node = cur_node.right_child
- *             if self.tree_type == "Regression":             # <<<<<<<<<<<<<<
- *                 Y[i] = cur_node.value[0]
- *             elif self.tree_type == "Classification":
+ * 
+ *             idx = self.__find_max_index(cur_node.value)             # <<<<<<<<<<<<<<
+ *             if self.classes is not None:
+ *                 Y[i] = self.classes[idx]
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_tree_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 141, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_4, __pyx_n_s_Regression, Py_EQ)); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 141, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (__pyx_t_3) {
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 118, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_13 = __Pyx_PyObject_to_MemoryviewSlice_dc_double(__pyx_t_3, PyBUF_WRITABLE); if (unlikely(!__pyx_t_13.memview)) __PYX_ERR(0, 118, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_11 = ((struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictClassification *)__pyx_v_self->__pyx_base.__pyx_vtab)->_PredictClassification__find_max_index(__pyx_v_self, __pyx_t_13); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 118, __pyx_L1_error)
+    __PYX_XCLEAR_MEMVIEW(&__pyx_t_13, 1);
+    __pyx_t_13.memview = NULL; __pyx_t_13.data = NULL;
+    __pyx_v_idx = __pyx_t_11;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":142
- *                     cur_node = cur_node.right_child
- *             if self.tree_type == "Regression":
- *                 Y[i] = cur_node.value[0]             # <<<<<<<<<<<<<<
- *             elif self.tree_type == "Classification":
- *                 idx = self.__find_max_index(cur_node.value)
+    /* "adaXT/predict/predict.pyx":119
+ * 
+ *             idx = self.__find_max_index(cur_node.value)
+ *             if self.classes is not None:             # <<<<<<<<<<<<<<
+ *                 Y[i] = self.classes[idx]
+ *         return Y
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 142, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_4, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 142, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 142, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_t_13 = __pyx_v_i;
-      *((double *) ( /* dim=0 */ (__pyx_v_Y.data + __pyx_t_13 * __pyx_v_Y.strides[0]) )) = __pyx_t_12;
+    __pyx_t_10 = (((PyObject *) __pyx_v_self->classes.memview) != Py_None);
+    if (__pyx_t_10) {
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":141
- *                 else:
- *                     cur_node = cur_node.right_child
- *             if self.tree_type == "Regression":             # <<<<<<<<<<<<<<
- *                 Y[i] = cur_node.value[0]
- *             elif self.tree_type == "Classification":
+      /* "adaXT/predict/predict.pyx":120
+ *             idx = self.__find_max_index(cur_node.value)
+ *             if self.classes is not None:
+ *                 Y[i] = self.classes[idx]             # <<<<<<<<<<<<<<
+ *         return Y
+ * 
+ */
+      __pyx_t_14 = __pyx_v_idx;
+      __pyx_t_15 = __pyx_v_i;
+      *((double *) ( /* dim=0 */ (__pyx_v_Y.data + __pyx_t_15 * __pyx_v_Y.strides[0]) )) = (*((double *) ( /* dim=0 */ ((char *) (((double *) __pyx_v_self->classes.data) + __pyx_t_14)) )));
+
+      /* "adaXT/predict/predict.pyx":119
+ * 
+ *             idx = self.__find_max_index(cur_node.value)
+ *             if self.classes is not None:             # <<<<<<<<<<<<<<
+ *                 Y[i] = self.classes[idx]
+ *         return Y
  */
-      goto __pyx_L9;
     }
+  }
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":143
- *             if self.tree_type == "Regression":
- *                 Y[i] = cur_node.value[0]
- *             elif self.tree_type == "Classification":             # <<<<<<<<<<<<<<
- *                 idx = self.__find_max_index(cur_node.value)
- *                 if self.classes is not None:
+  /* "adaXT/predict/predict.pyx":121
+ *             if self.classes is not None:
+ *                 Y[i] = self.classes[idx]
+ *         return Y             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef list predict_proba(self, object X):
  */
-    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_tree_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 143, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_Classification, Py_EQ)); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 143, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (__pyx_t_3) {
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 121, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":144
- *                 Y[i] = cur_node.value[0]
- *             elif self.tree_type == "Classification":
- *                 idx = self.__find_max_index(cur_node.value)             # <<<<<<<<<<<<<<
- *                 if self.classes is not None:
- *                     Y[i] = self.classes[idx]
+  /* "adaXT/predict/predict.pyx":96
+ *         return cur_max
+ * 
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, idx, n_obs
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_DecisionTree__find_max_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 144, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 144, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_7 = NULL;
-      __pyx_t_11 = 0;
-      #if CYTHON_UNPACK_METHODS
-      if (likely(PyMethod_Check(__pyx_t_4))) {
-        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
-        if (likely(__pyx_t_7)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-          __Pyx_INCREF(__pyx_t_7);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_4, function);
-          __pyx_t_11 = 1;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_7, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_13, 1);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_cur_node);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
+  __Pyx_XDECREF(__pyx_v_X);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/predict/predict.pyx":123
+ *         return Y
+ * 
+ *     cpdef list predict_proba(self, object X):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, n_obs
+ */
+
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_5predict_proba(PyObject *__pyx_v_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyObject *__pyx_f_5adaXT_7predict_7predict_21PredictClassification_predict_proba(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, PyObject *__pyx_v_X, int __pyx_skip_dispatch) {
+  int __pyx_v_i;
+  int __pyx_v_cur_split_idx;
+  int __pyx_v_n_obs;
+  double __pyx_v_cur_threshold;
+  PyObject *__pyx_v_cur_node = 0;
+  PyObject *__pyx_v_ret_val = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  __Pyx_memviewslice __pyx_t_6 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_t_7;
+  int __pyx_t_8;
+  int __pyx_t_9;
+  int __pyx_t_10;
+  double __pyx_t_11;
+  int __pyx_t_12;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("predict_proba", 0);
+  __Pyx_INCREF(__pyx_v_X);
+  /* Check if called by wrapper */
+  if (unlikely(__pyx_skip_dispatch)) ;
+  /* Check if overridden in Python */
+  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || __Pyx_PyType_HasFeature(Py_TYPE(((PyObject *)__pyx_v_self)), (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
+    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
+    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
+      PY_UINT64_T __pyx_typedict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      #endif
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_predict_proba); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 123, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_7predict_7predict_21PredictClassification_5predict_proba)) {
+        __Pyx_XDECREF(__pyx_r);
+        __Pyx_INCREF(__pyx_t_1);
+        __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
+        __pyx_t_5 = 0;
+        #if CYTHON_UNPACK_METHODS
+        if (unlikely(PyMethod_Check(__pyx_t_3))) {
+          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+          if (likely(__pyx_t_4)) {
+            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+            __Pyx_INCREF(__pyx_t_4);
+            __Pyx_INCREF(function);
+            __Pyx_DECREF_SET(__pyx_t_3, function);
+            __pyx_t_5 = 1;
+          }
         }
+        #endif
+        {
+          PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_v_X};
+          __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
+          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+          if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 123, __pyx_L1_error)
+          __Pyx_GOTREF(__pyx_t_2);
+          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        }
+        if (!(likely(PyList_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None) || __Pyx_RaiseUnexpectedTypeError("list", __pyx_t_2))) __PYX_ERR(0, 123, __pyx_L1_error)
+        __pyx_r = ((PyObject*)__pyx_t_2);
+        __pyx_t_2 = 0;
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        goto __pyx_L0;
       }
-      #endif
-      {
-        PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_t_5};
-        __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_11, 1+__pyx_t_11);
-        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 144, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+      __pyx_tp_dict_version = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
+      __pyx_obj_dict_version = __Pyx_get_object_dict_version(((PyObject *)__pyx_v_self));
+      if (unlikely(__pyx_typedict_guard != __pyx_tp_dict_version)) {
+        __pyx_tp_dict_version = __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
       }
-      __pyx_t_11 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_11 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 144, __pyx_L1_error)
+      #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __pyx_v_idx = __pyx_t_11;
+      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
+    }
+    #endif
+  }
+
+  /* "adaXT/predict/predict.pyx":131
+ * 
+ *         # Make sure that x fits the dimensions.
+ *         X = Predict.__check_dimensions(self, X)             # <<<<<<<<<<<<<<
+ *         n_obs = X.shape[0]
+ *         ret_val = []
+ */
+  __pyx_t_6 = __pyx_f_5adaXT_7predict_7predict_7Predict__Predict__check_dimensions(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self), __pyx_v_X); if (unlikely(!__pyx_t_6.memview)) __PYX_ERR(0, 131, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_fromslice(__pyx_t_6, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 131, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_6, 1);
+  __pyx_t_6.memview = NULL; __pyx_t_6.data = NULL;
+  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "adaXT/predict/predict.pyx":132
+ *         # Make sure that x fits the dimensions.
+ *         X = Predict.__check_dimensions(self, X)
+ *         n_obs = X.shape[0]             # <<<<<<<<<<<<<<
+ *         ret_val = []
+ *         for i in range(n_obs):
+ */
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 132, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 132, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_5 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 132, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_v_n_obs = __pyx_t_5;
+
+  /* "adaXT/predict/predict.pyx":133
+ *         X = Predict.__check_dimensions(self, X)
+ *         n_obs = X.shape[0]
+ *         ret_val = []             # <<<<<<<<<<<<<<
+ *         for i in range(n_obs):
+ *             cur_node = self.root
+ */
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 133, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_v_ret_val = ((PyObject*)__pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "adaXT/predict/predict.pyx":134
+ *         n_obs = X.shape[0]
+ *         ret_val = []
+ *         for i in range(n_obs):             # <<<<<<<<<<<<<<
+ *             cur_node = self.root
+ *             while isinstance(cur_node, DecisionNode):
+ */
+  __pyx_t_5 = __pyx_v_n_obs;
+  __pyx_t_7 = __pyx_t_5;
+  for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
+    __pyx_v_i = __pyx_t_8;
+
+    /* "adaXT/predict/predict.pyx":135
+ *         ret_val = []
+ *         for i in range(n_obs):
+ *             cur_node = self.root             # <<<<<<<<<<<<<<
+ *             while isinstance(cur_node, DecisionNode):
+ *                 cur_split_idx = cur_node.split_idx
+ */
+    __pyx_t_2 = __pyx_v_self->__pyx_base.root;
+    __Pyx_INCREF(__pyx_t_2);
+    __Pyx_XDECREF_SET(__pyx_v_cur_node, __pyx_t_2);
+    __pyx_t_2 = 0;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":145
- *             elif self.tree_type == "Classification":
- *                 idx = self.__find_max_index(cur_node.value)
- *                 if self.classes is not None:             # <<<<<<<<<<<<<<
- *                     Y[i] = self.classes[idx]
- *         return np.asarray(Y)
+    /* "adaXT/predict/predict.pyx":136
+ *         for i in range(n_obs):
+ *             cur_node = self.root
+ *             while isinstance(cur_node, DecisionNode):             # <<<<<<<<<<<<<<
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold
  */
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_classes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 145, __pyx_L1_error)
+    while (1) {
+      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 136, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_9 = PyObject_IsInstance(__pyx_v_cur_node, __pyx_t_2); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 136, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      if (!__pyx_t_9) break;
+
+      /* "adaXT/predict/predict.pyx":137
+ *             cur_node = self.root
+ *             while isinstance(cur_node, DecisionNode):
+ *                 cur_split_idx = cur_node.split_idx             # <<<<<<<<<<<<<<
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:
+ */
+      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_split_idx); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_10 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_10 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 137, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_v_cur_split_idx = __pyx_t_10;
+
+      /* "adaXT/predict/predict.pyx":138
+ *             while isinstance(cur_node, DecisionNode):
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold             # <<<<<<<<<<<<<<
+ *                 if X[i, cur_split_idx] < cur_threshold:
+ *                     cur_node = cur_node.left_child
+ */
+      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_threshold); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 138, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_11 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_11 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 138, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_v_cur_threshold = __pyx_t_11;
+
+      /* "adaXT/predict/predict.pyx":139
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
+ *                     cur_node = cur_node.left_child
+ *                 else:
+ */
+      __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 139, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_cur_split_idx); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 139, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 139, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_2);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2)) __PYX_ERR(0, 139, __pyx_L1_error);
+      __Pyx_GIVEREF(__pyx_t_1);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1)) __PYX_ERR(0, 139, __pyx_L1_error);
+      __pyx_t_2 = 0;
+      __pyx_t_1 = 0;
+      __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 139, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_3 = (__pyx_t_1 != Py_None);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_3 = PyFloat_FromDouble(__pyx_v_cur_threshold); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 139, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_2 = PyObject_RichCompare(__pyx_t_1, __pyx_t_3, Py_LT); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 139, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      if (__pyx_t_3) {
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_9 < 0))) __PYX_ERR(0, 139, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      if (__pyx_t_9) {
 
-        /* "adaXT/decision_tree/DecisionTree.pyx":146
- *                 idx = self.__find_max_index(cur_node.value)
- *                 if self.classes is not None:
- *                     Y[i] = self.classes[idx]             # <<<<<<<<<<<<<<
- *         return np.asarray(Y)
- * 
+        /* "adaXT/predict/predict.pyx":140
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:
+ *                     cur_node = cur_node.left_child             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     cur_node = cur_node.right_child
  */
-        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_classes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 146, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_1);
-        __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, __pyx_v_idx, int, 1, __Pyx_PyInt_From_int, 0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 146, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-        __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 146, __pyx_L1_error)
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __pyx_t_13 = __pyx_v_i;
-        *((double *) ( /* dim=0 */ (__pyx_v_Y.data + __pyx_t_13 * __pyx_v_Y.strides[0]) )) = __pyx_t_12;
+        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_left_child); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 140, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_2);
+        __pyx_t_2 = 0;
 
-        /* "adaXT/decision_tree/DecisionTree.pyx":145
- *             elif self.tree_type == "Classification":
- *                 idx = self.__find_max_index(cur_node.value)
- *                 if self.classes is not None:             # <<<<<<<<<<<<<<
- *                     Y[i] = self.classes[idx]
- *         return np.asarray(Y)
+        /* "adaXT/predict/predict.pyx":139
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
+ *                     cur_node = cur_node.left_child
+ *                 else:
  */
+        goto __pyx_L7;
       }
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":143
- *             if self.tree_type == "Regression":
- *                 Y[i] = cur_node.value[0]
- *             elif self.tree_type == "Classification":             # <<<<<<<<<<<<<<
- *                 idx = self.__find_max_index(cur_node.value)
- *                 if self.classes is not None:
+      /* "adaXT/predict/predict.pyx":142
+ *                     cur_node = cur_node.left_child
+ *                 else:
+ *                     cur_node = cur_node.right_child             # <<<<<<<<<<<<<<
+ *             if self.classes is not None:
+ *                 ret_val.append(cur_node.value)
  */
+      /*else*/ {
+        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_right_child); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 142, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_2);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_2);
+        __pyx_t_2 = 0;
+      }
+      __pyx_L7:;
     }
-    __pyx_L9:;
-  }
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":147
- *                 if self.classes is not None:
- *                     Y[i] = self.classes[idx]
- *         return np.asarray(Y)             # <<<<<<<<<<<<<<
+    /* "adaXT/predict/predict.pyx":143
+ *                 else:
+ *                     cur_node = cur_node.right_child
+ *             if self.classes is not None:             # <<<<<<<<<<<<<<
+ *                 ret_val.append(cur_node.value)
+ *         return ret_val
+ */
+    __pyx_t_9 = (((PyObject *) __pyx_v_self->classes.memview) != Py_None);
+    if (__pyx_t_9) {
+
+      /* "adaXT/predict/predict.pyx":144
+ *                     cur_node = cur_node.right_child
+ *             if self.classes is not None:
+ *                 ret_val.append(cur_node.value)             # <<<<<<<<<<<<<<
+ *         return ret_val
  * 
- *     def predict_proba(self, X: np.ndarray):
  */
-  __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 147, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 147, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __pyx_memoryview_fromslice(__pyx_v_Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 147, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = NULL;
-  __pyx_t_6 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_5))) {
-    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
-    if (likely(__pyx_t_7)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-      __Pyx_INCREF(__pyx_t_7);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_5, function);
-      __pyx_t_6 = 1;
+      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 144, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_12 = __Pyx_PyList_Append(__pyx_v_ret_val, __pyx_t_2); if (unlikely(__pyx_t_12 == ((int)-1))) __PYX_ERR(0, 144, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+      /* "adaXT/predict/predict.pyx":143
+ *                 else:
+ *                     cur_node = cur_node.right_child
+ *             if self.classes is not None:             # <<<<<<<<<<<<<<
+ *                 ret_val.append(cur_node.value)
+ *         return ret_val
+ */
     }
   }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_7, __pyx_t_1};
-    __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 147, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  }
-  __pyx_r = __pyx_t_4;
-  __pyx_t_4 = 0;
+
+  /* "adaXT/predict/predict.pyx":145
+ *             if self.classes is not None:
+ *                 ret_val.append(cur_node.value)
+ *         return ret_val             # <<<<<<<<<<<<<<
+ * 
+ *     @staticmethod
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_ret_val);
+  __pyx_r = __pyx_v_ret_val;
   goto __pyx_L0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":118
- *         builder.build_tree(self)
+  /* "adaXT/predict/predict.pyx":123
+ *         return Y
  * 
- *     def predict(self, X: np.ndarray):             # <<<<<<<<<<<<<<
+ *     cpdef list predict_proba(self, object X):             # <<<<<<<<<<<<<<
  *         cdef:
- *             int i, cur_split_idx, idx, n_obs
+ *             int i, cur_split_idx, n_obs
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_7);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_8, 1);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = NULL;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_6, 1);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_cur_node);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
+  __Pyx_XDECREF(__pyx_v_ret_val);
   __Pyx_XDECREF(__pyx_v_X);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":149
- *         return np.asarray(Y)
- * 
- *     def predict_proba(self, X: np.ndarray):             # <<<<<<<<<<<<<<
- *         cdef:
- *             int i, cur_split_idx, n_obs
- */
-
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_13predict_proba(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_5predict_proba(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_13predict_proba = {"predict_proba", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_13predict_proba, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_13predict_proba(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_5predict_proba = {"predict_proba", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_5predict_proba, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_5predict_proba(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  PyObject *__pyx_v_self = 0;
   PyObject *__pyx_v_X = 0;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
+  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("predict_proba (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
@@ -21296,1926 +21354,3171 @@
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_X,0};
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 123, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "predict_proba") < 0)) __PYX_ERR(0, 123, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 1)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+    }
+    __pyx_v_X = values[0];
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("predict_proba", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 123, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_21PredictClassification_4predict_proba(((struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *)__pyx_v_self), __pyx_v_X);
+
+  /* function exit code */
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_4predict_proba(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *__pyx_v_self, PyObject *__pyx_v_X) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("predict_proba", 1);
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = __pyx_f_5adaXT_7predict_7predict_21PredictClassification_predict_proba(__pyx_v_self, __pyx_v_X, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 123, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/predict/predict.pyx":147
+ *         return ret_val
+ * 
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_7forest_predict(CYTHON_UNUSED PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_7forest_predict = {"forest_predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_7forest_predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_7forest_predict(CYTHON_UNUSED PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  PyObject *__pyx_v_predictions = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[1] = {0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("forest_predict (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_predictions,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
         case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_predictions)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 149, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 147, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "forest_predict") < 0)) __PYX_ERR(0, 147, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 1)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+    }
+    __pyx_v_predictions = values[0];
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("forest_predict", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 147, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.forest_predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_21PredictClassification_6forest_predict(__pyx_v_predictions, __pyx_v_kwargs);
+
+  /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/predict/predict.pyx":149
+ *     @staticmethod
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):             # <<<<<<<<<<<<<<
+ *             values, counts = np.unique(arr, return_counts=True)
+ *             return values[np.argmax(counts)]
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_14forest_predict_1__most_frequent_element(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_14forest_predict_1__most_frequent_element = {"__most_frequent_element", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_14forest_predict_1__most_frequent_element, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_14forest_predict_1__most_frequent_element(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  PyObject *__pyx_v_arr = 0;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[1] = {0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__most_frequent_element (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_arr)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
         else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 149, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("predict_proba", 1, 2, 2, 1); __PYX_ERR(0, 149, __pyx_L3_error)
-        }
+        else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "predict_proba") < 0)) __PYX_ERR(0, 149, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__most_frequent_element") < 0)) __PYX_ERR(0, 149, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 2)) {
+    } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_self = values[0];
-    __pyx_v_X = values[1];
+    __pyx_v_arr = values[0];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("predict_proba", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 149, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__most_frequent_element", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 149, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.forest_predict.__most_frequent_element", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_12predict_proba(__pyx_self, __pyx_v_self, __pyx_v_X);
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_21PredictClassification_14forest_predict___most_frequent_element(__pyx_self, __pyx_v_arr);
 
   /* function exit code */
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_12predict_proba(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_X) {
-  int __pyx_v_i;
-  int __pyx_v_cur_split_idx;
-  int __pyx_v_n_obs;
-  double __pyx_v_cur_threshold;
-  PyObject *__pyx_v_cur_node = 0;
-  PyObject *__pyx_v_ret_val = 0;
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_14forest_predict___most_frequent_element(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr) {
+  PyObject *__pyx_v_values = NULL;
+  PyObject *__pyx_v_counts = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_t_3;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
+  PyObject *(*__pyx_t_5)(PyObject *);
   int __pyx_t_6;
-  int __pyx_t_7;
-  int __pyx_t_8;
-  int __pyx_t_9;
-  double __pyx_t_10;
-  int __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("predict_proba", 0);
-  __Pyx_INCREF(__pyx_v_X);
+  __Pyx_RefNannySetupContext("__most_frequent_element", 1);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":154
- *             double cur_threshold
- *             object cur_node
- *             list ret_val = []             # <<<<<<<<<<<<<<
- * 
- *         if not self.root:
+  /* "adaXT/predict/predict.pyx":150
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):
+ *             values, counts = np.unique(arr, return_counts=True)             # <<<<<<<<<<<<<<
+ *             return values[np.argmax(counts)]
+ *         return np.apply_along_axis(
  */
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 154, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 150, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_unique); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 150, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 150, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_ret_val = ((PyObject*)__pyx_t_1);
+  __Pyx_INCREF(__pyx_v_arr);
+  __Pyx_GIVEREF(__pyx_v_arr);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_arr)) __PYX_ERR(0, 150, __pyx_L1_error);
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 150, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_return_counts, Py_True) < 0) __PYX_ERR(0, 150, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 150, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if ((likely(PyTuple_CheckExact(__pyx_t_4))) || (PyList_CheckExact(__pyx_t_4))) {
+    PyObject* sequence = __pyx_t_4;
+    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
+    if (unlikely(size != 2)) {
+      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
+      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
+      __PYX_ERR(0, 150, __pyx_L1_error)
+    }
+    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    if (likely(PyTuple_CheckExact(sequence))) {
+      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
+      __pyx_t_1 = PyTuple_GET_ITEM(sequence, 1); 
+    } else {
+      __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
+      __pyx_t_1 = PyList_GET_ITEM(sequence, 1); 
+    }
+    __Pyx_INCREF(__pyx_t_3);
+    __Pyx_INCREF(__pyx_t_1);
+    #else
+    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_1 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    #endif
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  } else {
+    Py_ssize_t index = -1;
+    __pyx_t_2 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 150, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_5 = __Pyx_PyObject_GetIterNextFunc(__pyx_t_2);
+    index = 0; __pyx_t_3 = __pyx_t_5(__pyx_t_2); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
+    __Pyx_GOTREF(__pyx_t_3);
+    index = 1; __pyx_t_1 = __pyx_t_5(__pyx_t_2); if (unlikely(!__pyx_t_1)) goto __pyx_L3_unpacking_failed;
+    __Pyx_GOTREF(__pyx_t_1);
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_2), 2) < 0) __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_t_5 = NULL;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    goto __pyx_L4_unpacking_done;
+    __pyx_L3_unpacking_failed:;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_5 = NULL;
+    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
+    __PYX_ERR(0, 150, __pyx_L1_error)
+    __pyx_L4_unpacking_done:;
+  }
+  __pyx_v_values = __pyx_t_3;
+  __pyx_t_3 = 0;
+  __pyx_v_counts = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":156
- *             list ret_val = []
- * 
- *         if not self.root:             # <<<<<<<<<<<<<<
- *             raise AttributeError("The tree has not been fitted before trying to call predict_proba")
- * 
+  /* "adaXT/predict/predict.pyx":151
+ *         def __most_frequent_element(arr):
+ *             values, counts = np.unique(arr, return_counts=True)
+ *             return values[np.argmax(counts)]             # <<<<<<<<<<<<<<
+ *         return np.apply_along_axis(
+ *             __most_frequent_element, 1, predictions
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_root); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 156, __pyx_L1_error)
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 151, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 156, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_argmax); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 151, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = (!__pyx_t_2);
-  if (unlikely(__pyx_t_3)) {
+  __pyx_t_1 = NULL;
+  __pyx_t_6 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_1)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_1);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __pyx_t_6 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_1, __pyx_v_counts};
+    __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 151, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  }
+  __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_values, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 151, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
+
+  /* "adaXT/predict/predict.pyx":149
+ *     @staticmethod
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):             # <<<<<<<<<<<<<<
+ *             values, counts = np.unique(arr, return_counts=True)
+ *             return values[np.argmax(counts)]
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.forest_predict.__most_frequent_element", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_values);
+  __Pyx_XDECREF(__pyx_v_counts);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":157
+/* "adaXT/predict/predict.pyx":147
+ *         return ret_val
  * 
- *         if not self.root:
- *             raise AttributeError("The tree has not been fitted before trying to call predict_proba")             # <<<<<<<<<<<<<<
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):
+ */
+
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_6forest_predict(PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
+  PyObject *__pyx_v__PredictClassification__most_frequent_element = 0;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("forest_predict", 1);
+
+  /* "adaXT/predict/predict.pyx":149
+ *     @staticmethod
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):             # <<<<<<<<<<<<<<
+ *             values, counts = np.unique(arr, return_counts=True)
+ *             return values[np.argmax(counts)]
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_14forest_predict_1__most_frequent_element, 0, __pyx_n_s_forest_predict_locals___most_fre, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__13)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 149, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_v__PredictClassification__most_frequent_element = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "adaXT/predict/predict.pyx":152
+ *             values, counts = np.unique(arr, return_counts=True)
+ *             return values[np.argmax(counts)]
+ *         return np.apply_along_axis(             # <<<<<<<<<<<<<<
+ *             __most_frequent_element, 1, predictions
+ *         )
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 152, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_apply_along_axis); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 152, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "adaXT/predict/predict.pyx":153
+ *             return values[np.argmax(counts)]
+ *         return np.apply_along_axis(
+ *             __most_frequent_element, 1, predictions             # <<<<<<<<<<<<<<
+ *         )
  * 
- *         if self.tree_type != "Classification":
  */
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_AttributeError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 157, __pyx_L1_error)
+  __pyx_t_2 = NULL;
+  __pyx_t_4 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __pyx_t_4 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[4] = {__pyx_t_2, __pyx_v__PredictClassification__most_frequent_element, __pyx_int_1, __pyx_v_predictions};
+    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_4, 3+__pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 152, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 157, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  }
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":156
- *             list ret_val = []
+  /* "adaXT/predict/predict.pyx":147
+ *         return ret_val
  * 
- *         if not self.root:             # <<<<<<<<<<<<<<
- *             raise AttributeError("The tree has not been fitted before trying to call predict_proba")
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.forest_predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v__PredictClassification__most_frequent_element);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/predict/predict.pyx":156
+ *         )
  * 
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         # Stack the predict_probas
  */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_9forest_predict_proba(CYTHON_UNUSED PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_9forest_predict_proba = {"forest_predict_proba", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_9forest_predict_proba, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_9forest_predict_proba(CYTHON_UNUSED PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  PyObject *__pyx_v_predictions = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[1] = {0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("forest_predict_proba (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_predictions,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_predictions)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 156, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "forest_predict_proba") < 0)) __PYX_ERR(0, 156, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 1)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+    }
+    __pyx_v_predictions = values[0];
   }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("forest_predict_proba", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 156, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.forest_predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_21PredictClassification_8forest_predict_proba(__pyx_v_predictions, __pyx_v_kwargs);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":159
- *             raise AttributeError("The tree has not been fitted before trying to call predict_proba")
- * 
- *         if self.tree_type != "Classification":             # <<<<<<<<<<<<<<
- *             raise ValueError("predict_proba can only be called on a Classification tree")
+  /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_21PredictClassification_8forest_predict_proba(PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
+  PyObject *__pyx_v_stacked_tree_predictions = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("forest_predict_proba", 1);
+
+  /* "adaXT/predict/predict.pyx":159
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         # Stack the predict_probas
+ *         stacked_tree_predictions = np.stack(predictions, axis=0)             # <<<<<<<<<<<<<<
  * 
+ *         # Return the mean along the newly created axis
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_tree_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 159, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 159, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_t_1, __pyx_n_s_Classification, Py_NE)); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 159, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_stack); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 159, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(__pyx_t_3)) {
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 159, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_v_predictions);
+  __Pyx_GIVEREF(__pyx_v_predictions);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_predictions)) __PYX_ERR(0, 159, __pyx_L1_error);
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 159, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_axis, __pyx_int_0) < 0) __PYX_ERR(0, 159, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 159, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_stacked_tree_predictions = __pyx_t_4;
+  __pyx_t_4 = 0;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":160
+  /* "adaXT/predict/predict.pyx":162
+ * 
+ *         # Return the mean along the newly created axis
+ *         return np.mean(stacked_tree_predictions, axis=0)             # <<<<<<<<<<<<<<
  * 
- *         if self.tree_type != "Classification":
- *             raise ValueError("predict_proba can only be called on a Classification tree")             # <<<<<<<<<<<<<<
  * 
- *         # Make sure that x fits the dimensions.
  */
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 160, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 160, __pyx_L1_error)
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_mean); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_INCREF(__pyx_v_stacked_tree_predictions);
+  __Pyx_GIVEREF(__pyx_v_stacked_tree_predictions);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_stacked_tree_predictions)) __PYX_ERR(0, 162, __pyx_L1_error);
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_axis, __pyx_int_0) < 0) __PYX_ERR(0, 162, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
+  goto __pyx_L0;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":159
- *             raise AttributeError("The tree has not been fitted before trying to call predict_proba")
+  /* "adaXT/predict/predict.pyx":156
+ *         )
  * 
- *         if self.tree_type != "Classification":             # <<<<<<<<<<<<<<
- *             raise ValueError("predict_proba can only be called on a Classification tree")
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         # Stack the predict_probas
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictClassification.forest_predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_stacked_tree_predictions);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/predict/predict.pyx":166
  * 
+ * cdef class PredictRegression(Predict):
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, n_obs
  */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_17PredictRegression_1predict(PyObject *__pyx_v_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_17PredictRegression_1predict = {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_17PredictRegression_1predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_17PredictRegression_1predict(PyObject *__pyx_v_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  PyObject *__pyx_v_X = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[1] = {0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("predict (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 166, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "predict") < 0)) __PYX_ERR(0, 166, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 1)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+    }
+    __pyx_v_X = values[0];
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("predict", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 166, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
   }
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictRegression.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_17PredictRegression_predict(((struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression *)__pyx_v_self), __pyx_v_X, __pyx_v_kwargs);
+
+  /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_17PredictRegression_predict(struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression *__pyx_v_self, PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
+  int __pyx_v_i;
+  int __pyx_v_cur_split_idx;
+  int __pyx_v_n_obs;
+  double __pyx_v_cur_threshold;
+  PyObject *__pyx_v_cur_node = 0;
+  __Pyx_memviewslice __pyx_v_Y = { 0, 0, { 0 }, { 0 }, { 0 } };
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  __Pyx_memviewslice __pyx_t_7 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_t_8;
+  int __pyx_t_9;
+  int __pyx_t_10;
+  int __pyx_t_11;
+  double __pyx_t_12;
+  Py_ssize_t __pyx_t_13;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("predict", 0);
+  __Pyx_INCREF(__pyx_v_X);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":163
+  /* "adaXT/predict/predict.pyx":174
  * 
  *         # Make sure that x fits the dimensions.
- *         X = self.__check_dimensions(X)             # <<<<<<<<<<<<<<
+ *         X = Predict.__check_dimensions(self, X)             # <<<<<<<<<<<<<<
  *         n_obs = X.shape[0]
+ *         Y = np.empty(n_obs)
+ */
+  __pyx_t_1 = __pyx_f_5adaXT_7predict_7predict_7Predict__Predict__check_dimensions(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self), __pyx_v_X); if (unlikely(!__pyx_t_1.memview)) __PYX_ERR(0, 174, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_t_1, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 174, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_t_1.memview = NULL; __pyx_t_1.data = NULL;
+  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "adaXT/predict/predict.pyx":175
+ *         # Make sure that x fits the dimensions.
+ *         X = Predict.__check_dimensions(self, X)
+ *         n_obs = X.shape[0]             # <<<<<<<<<<<<<<
+ *         Y = np.empty(n_obs)
  * 
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_DecisionTree__check_dimensions); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 163, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = NULL;
-  __pyx_t_6 = 0;
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 175, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_2, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 175, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 175, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_n_obs = __pyx_t_4;
+
+  /* "adaXT/predict/predict.pyx":176
+ *         X = Predict.__check_dimensions(self, X)
+ *         n_obs = X.shape[0]
+ *         Y = np.empty(n_obs)             # <<<<<<<<<<<<<<
+ * 
+ *         for i in range(n_obs):
+ */
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 176, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_empty); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 176, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_n_obs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 176, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_6 = NULL;
+  __pyx_t_4 = 0;
   #if CYTHON_UNPACK_METHODS
-  if (likely(PyMethod_Check(__pyx_t_4))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-      __Pyx_INCREF(__pyx_t_5);
+  if (unlikely(PyMethod_Check(__pyx_t_5))) {
+    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
+    if (likely(__pyx_t_6)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+      __Pyx_INCREF(__pyx_t_6);
       __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_4, function);
-      __pyx_t_6 = 1;
+      __Pyx_DECREF_SET(__pyx_t_5, function);
+      __pyx_t_4 = 1;
     }
   }
   #endif
   {
-    PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_v_X};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 163, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    PyObject *__pyx_callargs[2] = {__pyx_t_6, __pyx_t_2};
+    __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_4, 1+__pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 176, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
-  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":164
- *         # Make sure that x fits the dimensions.
- *         X = self.__check_dimensions(X)
- *         n_obs = X.shape[0]             # <<<<<<<<<<<<<<
- * 
- *         for i in range(n_obs):
- */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 164, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 164, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_4); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 164, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_v_n_obs = __pyx_t_6;
+  __pyx_t_7 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_t_3, PyBUF_WRITABLE); if (unlikely(!__pyx_t_7.memview)) __PYX_ERR(0, 176, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_Y = __pyx_t_7;
+  __pyx_t_7.memview = NULL;
+  __pyx_t_7.data = NULL;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":166
- *         n_obs = X.shape[0]
+  /* "adaXT/predict/predict.pyx":178
+ *         Y = np.empty(n_obs)
  * 
  *         for i in range(n_obs):             # <<<<<<<<<<<<<<
  *             cur_node = self.root
  *             while isinstance(cur_node, DecisionNode):
  */
-  __pyx_t_6 = __pyx_v_n_obs;
-  __pyx_t_7 = __pyx_t_6;
-  for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
-    __pyx_v_i = __pyx_t_8;
+  __pyx_t_4 = __pyx_v_n_obs;
+  __pyx_t_8 = __pyx_t_4;
+  for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
+    __pyx_v_i = __pyx_t_9;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":167
+    /* "adaXT/predict/predict.pyx":179
  * 
  *         for i in range(n_obs):
  *             cur_node = self.root             # <<<<<<<<<<<<<<
  *             while isinstance(cur_node, DecisionNode):
  *                 cur_split_idx = cur_node.split_idx
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_root); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 167, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_XDECREF_SET(__pyx_v_cur_node, __pyx_t_4);
-    __pyx_t_4 = 0;
+    __pyx_t_3 = __pyx_v_self->__pyx_base.root;
+    __Pyx_INCREF(__pyx_t_3);
+    __Pyx_XDECREF_SET(__pyx_v_cur_node, __pyx_t_3);
+    __pyx_t_3 = 0;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":168
+    /* "adaXT/predict/predict.pyx":180
  *         for i in range(n_obs):
  *             cur_node = self.root
  *             while isinstance(cur_node, DecisionNode):             # <<<<<<<<<<<<<<
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold
  */
     while (1) {
-      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 168, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_IsInstance(__pyx_v_cur_node, __pyx_t_4); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 168, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (!__pyx_t_3) break;
+      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 180, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_10 = PyObject_IsInstance(__pyx_v_cur_node, __pyx_t_3); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 180, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (!__pyx_t_10) break;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":169
+      /* "adaXT/predict/predict.pyx":181
  *             cur_node = self.root
  *             while isinstance(cur_node, DecisionNode):
  *                 cur_split_idx = cur_node.split_idx             # <<<<<<<<<<<<<<
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_split_idx); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 169, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_9 = __Pyx_PyInt_As_int(__pyx_t_4); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 169, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_v_cur_split_idx = __pyx_t_9;
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_split_idx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 181, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_11 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_11 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 181, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_v_cur_split_idx = __pyx_t_11;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":170
+      /* "adaXT/predict/predict.pyx":182
  *             while isinstance(cur_node, DecisionNode):
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold             # <<<<<<<<<<<<<<
  *                 if X[i, cur_split_idx] < cur_threshold:
  *                     cur_node = cur_node.left_child
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_threshold); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 170, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_10 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_10 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 170, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_v_cur_threshold = __pyx_t_10;
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_threshold); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 182, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_t_3); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 182, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_v_cur_threshold = __pyx_t_12;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":171
+      /* "adaXT/predict/predict.pyx":183
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
  *                     cur_node = cur_node.left_child
  *                 else:
  */
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 171, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_cur_split_idx); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 171, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 183, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_cur_split_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 183, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_GIVEREF(__pyx_t_4);
-      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4)) __PYX_ERR(0, 171, __pyx_L1_error);
-      __Pyx_GIVEREF(__pyx_t_1);
-      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error);
-      __pyx_t_4 = 0;
-      __pyx_t_1 = 0;
-      __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 171, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_5 = PyFloat_FromDouble(__pyx_v_cur_threshold); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 171, __pyx_L1_error)
+      __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 183, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_3);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3)) __PYX_ERR(0, 183, __pyx_L1_error);
+      __Pyx_GIVEREF(__pyx_t_5);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_5)) __PYX_ERR(0, 183, __pyx_L1_error);
+      __pyx_t_3 = 0;
+      __pyx_t_5 = 0;
+      __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 183, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_t_1, __pyx_t_5, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 171, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_t_2 = PyFloat_FromDouble(__pyx_v_cur_threshold); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 183, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_t_2, Py_LT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 183, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 171, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      if (__pyx_t_3) {
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_10 < 0))) __PYX_ERR(0, 183, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (__pyx_t_10) {
 
-        /* "adaXT/decision_tree/DecisionTree.pyx":172
+        /* "adaXT/predict/predict.pyx":184
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:
  *                     cur_node = cur_node.left_child             # <<<<<<<<<<<<<<
  *                 else:
  *                     cur_node = cur_node.right_child
  */
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_left_child); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 172, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_4);
-        __pyx_t_4 = 0;
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_left_child); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 184, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_3);
+        __pyx_t_3 = 0;
 
-        /* "adaXT/decision_tree/DecisionTree.pyx":171
+        /* "adaXT/predict/predict.pyx":183
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
  *                     cur_node = cur_node.left_child
  *                 else:
  */
-        goto __pyx_L9;
+        goto __pyx_L7;
       }
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":174
+      /* "adaXT/predict/predict.pyx":186
  *                     cur_node = cur_node.left_child
  *                 else:
  *                     cur_node = cur_node.right_child             # <<<<<<<<<<<<<<
- *             if self.classes is not None:
- *                 ret_val.append(cur_node.value)
+ *             Y[i] = cur_node.value[0]
+ *         return Y
  */
       /*else*/ {
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_right_child); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 174, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_4);
-        __pyx_t_4 = 0;
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_right_child); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 186, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_3);
+        __pyx_t_3 = 0;
       }
-      __pyx_L9:;
+      __pyx_L7:;
     }
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":175
+    /* "adaXT/predict/predict.pyx":187
  *                 else:
  *                     cur_node = cur_node.right_child
- *             if self.classes is not None:             # <<<<<<<<<<<<<<
- *                 ret_val.append(cur_node.value)
+ *             Y[i] = cur_node.value[0]             # <<<<<<<<<<<<<<
+ *         return Y
  * 
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_classes); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 175, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = (__pyx_t_4 != Py_None);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (__pyx_t_3) {
-
-      /* "adaXT/decision_tree/DecisionTree.pyx":176
- *                     cur_node = cur_node.right_child
- *             if self.classes is not None:
- *                 ret_val.append(cur_node.value)             # <<<<<<<<<<<<<<
- * 
- *         return np.asarray(ret_val)
- */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 176, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_11 = __Pyx_PyList_Append(__pyx_v_ret_val, __pyx_t_4); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 176, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-      /* "adaXT/decision_tree/DecisionTree.pyx":175
- *                 else:
- *                     cur_node = cur_node.right_child
- *             if self.classes is not None:             # <<<<<<<<<<<<<<
- *                 ret_val.append(cur_node.value)
- * 
- */
-    }
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_value); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 187, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_3, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 187, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 187, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_13 = __pyx_v_i;
+    *((double *) ( /* dim=0 */ (__pyx_v_Y.data + __pyx_t_13 * __pyx_v_Y.strides[0]) )) = __pyx_t_12;
   }
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":178
- *                 ret_val.append(cur_node.value)
- * 
- *         return np.asarray(ret_val)             # <<<<<<<<<<<<<<
+  /* "adaXT/predict/predict.pyx":188
+ *                     cur_node = cur_node.right_child
+ *             Y[i] = cur_node.value[0]
+ *         return Y             # <<<<<<<<<<<<<<
  * 
- *     def __find_max_index(self, lst):
+ *     @staticmethod
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 178, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_asarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 178, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = NULL;
-  __pyx_t_6 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_1))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
-      __Pyx_INCREF(__pyx_t_5);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_1, function);
-      __pyx_t_6 = 1;
-    }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_v_ret_val};
-    __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_1, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 178, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  }
-  __pyx_r = __pyx_t_4;
-  __pyx_t_4 = 0;
+  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 188, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_r = __pyx_t_2;
+  __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":149
- *         return np.asarray(Y)
+  /* "adaXT/predict/predict.pyx":166
  * 
- *     def predict_proba(self, X: np.ndarray):             # <<<<<<<<<<<<<<
+ * cdef class PredictRegression(Predict):
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
  *         cdef:
  *             int i, cur_split_idx, n_obs
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_4);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.predict_proba", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_XDECREF(__pyx_t_6);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_7, 1);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictRegression.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_cur_node);
-  __Pyx_XDECREF(__pyx_v_ret_val);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
   __Pyx_XDECREF(__pyx_v_X);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":180
- *         return np.asarray(ret_val)
+/* "adaXT/predict/predict.pyx":190
+ *         return Y
  * 
- *     def __find_max_index(self, lst):             # <<<<<<<<<<<<<<
- *         cur_max = 0
- *         for i in range(1, len(lst)):
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         return np.mean(predictions, axis=1)
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_15__find_max_index(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_17PredictRegression_3forest_predict(CYTHON_UNUSED PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_15__find_max_index = {"__find_max_index", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_15__find_max_index, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_15__find_max_index(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_17PredictRegression_3forest_predict = {"forest_predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_17PredictRegression_3forest_predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_17PredictRegression_3forest_predict(CYTHON_UNUSED PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  CYTHON_UNUSED PyObject *__pyx_v_self = 0;
-  PyObject *__pyx_v_lst = 0;
+  PyObject *__pyx_v_predictions = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
+  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("__find_max_index (wrapper)", 0);
+  __Pyx_RefNannySetupContext("forest_predict (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
   #if CYTHON_ASSUME_SAFE_MACROS
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_lst,0};
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_predictions,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
         case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_predictions)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 180, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 190, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_lst)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 180, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("__find_max_index", 1, 2, 2, 1); __PYX_ERR(0, 180, __pyx_L3_error)
-        }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__find_max_index") < 0)) __PYX_ERR(0, 180, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "forest_predict") < 0)) __PYX_ERR(0, 190, __pyx_L3_error)
       }
-    } else if (unlikely(__pyx_nargs != 2)) {
+    } else if (unlikely(__pyx_nargs != 1)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_self = values[0];
-    __pyx_v_lst = values[1];
+    __pyx_v_predictions = values[0];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__find_max_index", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 180, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("forest_predict", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 190, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__find_max_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictRegression.forest_predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_14__find_max_index(__pyx_self, __pyx_v_self, __pyx_v_lst);
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_17PredictRegression_2forest_predict(__pyx_v_predictions, __pyx_v_kwargs);
 
   /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_14__find_max_index(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_self, PyObject *__pyx_v_lst) {
-  Py_ssize_t __pyx_v_cur_max;
-  Py_ssize_t __pyx_v_i;
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_17PredictRegression_2forest_predict(PyObject *__pyx_v_predictions, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  Py_ssize_t __pyx_t_1;
-  Py_ssize_t __pyx_t_2;
-  Py_ssize_t __pyx_t_3;
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
-  PyObject *__pyx_t_5 = NULL;
-  PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("__find_max_index", 1);
+  __Pyx_RefNannySetupContext("forest_predict", 1);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":181
+  /* "adaXT/predict/predict.pyx":192
+ *     @staticmethod
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         return np.mean(predictions, axis=1)             # <<<<<<<<<<<<<<
  * 
- *     def __find_max_index(self, lst):
- *         cur_max = 0             # <<<<<<<<<<<<<<
- *         for i in range(1, len(lst)):
- *             if lst[cur_max] < lst[i]:
- */
-  __pyx_v_cur_max = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":182
- *     def __find_max_index(self, lst):
- *         cur_max = 0
- *         for i in range(1, len(lst)):             # <<<<<<<<<<<<<<
- *             if lst[cur_max] < lst[i]:
- *                 cur_max = i
- */
-  __pyx_t_1 = PyObject_Length(__pyx_v_lst); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 182, __pyx_L1_error)
-  __pyx_t_2 = __pyx_t_1;
-  for (__pyx_t_3 = 1; __pyx_t_3 < __pyx_t_2; __pyx_t_3+=1) {
-    __pyx_v_i = __pyx_t_3;
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":183
- *         cur_max = 0
- *         for i in range(1, len(lst)):
- *             if lst[cur_max] < lst[i]:             # <<<<<<<<<<<<<<
- *                 cur_max = i
- *         return cur_max
- */
-    __pyx_t_4 = __Pyx_GetItemInt(__pyx_v_lst, __pyx_v_cur_max, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 183, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_GetItemInt(__pyx_v_lst, __pyx_v_i, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 0, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 183, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = PyObject_RichCompare(__pyx_t_4, __pyx_t_5, Py_LT); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 183, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely((__pyx_t_7 < 0))) __PYX_ERR(0, 183, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    if (__pyx_t_7) {
-
-      /* "adaXT/decision_tree/DecisionTree.pyx":184
- *         for i in range(1, len(lst)):
- *             if lst[cur_max] < lst[i]:
- *                 cur_max = i             # <<<<<<<<<<<<<<
- *         return cur_max
- * 
- */
-      __pyx_v_cur_max = __pyx_v_i;
-
-      /* "adaXT/decision_tree/DecisionTree.pyx":183
- *         cur_max = 0
- *         for i in range(1, len(lst)):
- *             if lst[cur_max] < lst[i]:             # <<<<<<<<<<<<<<
- *                 cur_max = i
- *         return cur_max
- */
-    }
-  }
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":185
- *             if lst[cur_max] < lst[i]:
- *                 cur_max = i
- *         return cur_max             # <<<<<<<<<<<<<<
- * 
- *     def get_leaf_matrix(self, scale: bool = False) -> np.ndarray:
+ * cdef class PredictLinearRegression(PredictRegression):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_6 = PyInt_FromSsize_t(__pyx_v_cur_max); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 185, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_6);
-  __pyx_r = __pyx_t_6;
-  __pyx_t_6 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_mean); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_INCREF(__pyx_v_predictions);
+  __Pyx_GIVEREF(__pyx_v_predictions);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_predictions)) __PYX_ERR(0, 192, __pyx_L1_error);
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_axis, __pyx_int_1) < 0) __PYX_ERR(0, 192, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 192, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_r = __pyx_t_4;
+  __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":180
- *         return np.asarray(ret_val)
+  /* "adaXT/predict/predict.pyx":190
+ *         return Y
  * 
- *     def __find_max_index(self, lst):             # <<<<<<<<<<<<<<
- *         cur_max = 0
- *         for i in range(1, len(lst)):
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         return np.mean(predictions, axis=1)
  */
 
   /* function exit code */
   __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.__find_max_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictRegression.forest_predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":187
- *         return cur_max
+/* "adaXT/predict/predict.pyx":195
  * 
- *     def get_leaf_matrix(self, scale: bool = False) -> np.ndarray:             # <<<<<<<<<<<<<<
- *         if not self.root:
- *             raise ValueError("The tree has not been trained before trying to predict")
+ * cdef class PredictLinearRegression(PredictRegression):
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, n_obs
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_17get_leaf_matrix(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_23PredictLinearRegression_1predict(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_17get_leaf_matrix = {"get_leaf_matrix", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_17get_leaf_matrix, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_17get_leaf_matrix(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_23PredictLinearRegression_1predict = {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_23PredictLinearRegression_1predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_23PredictLinearRegression_1predict(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  PyObject *__pyx_v_self = 0;
-  PyObject *__pyx_v_scale = 0;
+  PyObject *__pyx_v_X = 0;
+  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[2] = {0,0};
+  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("get_leaf_matrix (wrapper)", 0);
+  __Pyx_RefNannySetupContext("predict (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
   #if CYTHON_ASSUME_SAFE_MACROS
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_scale,0};
-    values[1] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)((PyObject *)Py_False)));
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
         case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 187, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 195, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_scale);
-          if (value) { values[1] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 187, __pyx_L3_error)
-        }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "get_leaf_matrix") < 0)) __PYX_ERR(0, 187, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "predict") < 0)) __PYX_ERR(0, 195, __pyx_L3_error)
       }
+    } else if (unlikely(__pyx_nargs != 1)) {
+      goto __pyx_L5_argtuple_error;
     } else {
-      switch (__pyx_nargs) {
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
-        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        break;
-        default: goto __pyx_L5_argtuple_error;
-      }
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_self = values[0];
-    __pyx_v_scale = values[1];
+    __pyx_v_X = values[0];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("get_leaf_matrix", 0, 1, 2, __pyx_nargs); __PYX_ERR(0, 187, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("predict", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 195, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.get_leaf_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictLinearRegression.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_16get_leaf_matrix(__pyx_self, __pyx_v_self, __pyx_v_scale);
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_23PredictLinearRegression_predict(((struct __pyx_obj_5adaXT_7predict_7predict_PredictLinearRegression *)__pyx_v_self), __pyx_v_X, __pyx_v_kwargs);
 
   /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_16get_leaf_matrix(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_scale) {
-  PyObject *__pyx_v_leaf_nodes = NULL;
-  PyObject *__pyx_v_n_obs = NULL;
-  PyObject *__pyx_v_matrix = NULL;
-  PyObject *__pyx_v_node = NULL;
-  PyObject *__pyx_v_n_node = NULL;
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_23PredictLinearRegression_predict(struct __pyx_obj_5adaXT_7predict_7predict_PredictLinearRegression *__pyx_v_self, PyObject *__pyx_v_X, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
+  int __pyx_v_i;
+  int __pyx_v_cur_split_idx;
+  int __pyx_v_n_obs;
+  double __pyx_v_cur_threshold;
+  PyObject *__pyx_v_cur_node = 0;
+  __Pyx_memviewslice __pyx_v_Y = { 0, 0, { 0 }, { 0 }, { 0 } };
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
-  int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
+  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
-  int __pyx_t_7;
-  Py_ssize_t __pyx_t_8;
-  PyObject *(*__pyx_t_9)(PyObject *);
-  PyObject *__pyx_t_10 = NULL;
-  PyObject *__pyx_t_11 = NULL;
-  PyObject *__pyx_t_12 = NULL;
+  __Pyx_memviewslice __pyx_t_7 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_t_8;
+  int __pyx_t_9;
+  int __pyx_t_10;
+  int __pyx_t_11;
+  double __pyx_t_12;
+  Py_ssize_t __pyx_t_13;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("get_leaf_matrix", 1);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":188
- * 
- *     def get_leaf_matrix(self, scale: bool = False) -> np.ndarray:
- *         if not self.root:             # <<<<<<<<<<<<<<
- *             raise ValueError("The tree has not been trained before trying to predict")
- * 
- */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_root); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 188, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 188, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = (!__pyx_t_2);
-  if (unlikely(__pyx_t_3)) {
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":189
- *     def get_leaf_matrix(self, scale: bool = False) -> np.ndarray:
- *         if not self.root:
- *             raise ValueError("The tree has not been trained before trying to predict")             # <<<<<<<<<<<<<<
- * 
- *         leaf_nodes = self.leaf_nodes
- */
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
-    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 189, __pyx_L1_error)
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":188
- * 
- *     def get_leaf_matrix(self, scale: bool = False) -> np.ndarray:
- *         if not self.root:             # <<<<<<<<<<<<<<
- *             raise ValueError("The tree has not been trained before trying to predict")
- * 
- */
-  }
+  __Pyx_RefNannySetupContext("predict", 0);
+  __Pyx_INCREF(__pyx_v_X);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":191
- *             raise ValueError("The tree has not been trained before trying to predict")
- * 
- *         leaf_nodes = self.leaf_nodes             # <<<<<<<<<<<<<<
- *         n_obs = self.n_obs
+  /* "adaXT/predict/predict.pyx":202
+ *             double[:] Y
  * 
+ *         X = Predict.__check_dimensions(self, X)             # <<<<<<<<<<<<<<
+ *         n_obs = X.shape[0]
+ *         Y = np.empty(n_obs)
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_leaf_nodes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_leaf_nodes = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_1 = __pyx_f_5adaXT_7predict_7predict_7Predict__Predict__check_dimensions(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self), __pyx_v_X); if (unlikely(!__pyx_t_1.memview)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_t_1, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_t_1.memview = NULL; __pyx_t_1.data = NULL;
+  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_2);
+  __pyx_t_2 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":192
+  /* "adaXT/predict/predict.pyx":203
  * 
- *         leaf_nodes = self.leaf_nodes
- *         n_obs = self.n_obs             # <<<<<<<<<<<<<<
+ *         X = Predict.__check_dimensions(self, X)
+ *         n_obs = X.shape[0]             # <<<<<<<<<<<<<<
+ *         Y = np.empty(n_obs)
  * 
- *         matrix = np.zeros((n_obs, n_obs))
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_n_obs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_n_obs = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 203, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_2, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 203, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_4 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 203, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_n_obs = __pyx_t_4;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":194
- *         n_obs = self.n_obs
+  /* "adaXT/predict/predict.pyx":204
+ *         X = Predict.__check_dimensions(self, X)
+ *         n_obs = X.shape[0]
+ *         Y = np.empty(n_obs)             # <<<<<<<<<<<<<<
  * 
- *         matrix = np.zeros((n_obs, n_obs))             # <<<<<<<<<<<<<<
- *         if (not leaf_nodes):  # make sure that there are calculated observations
- *             return matrix
+ *         for i in range(n_obs):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 194, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_zeros); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 194, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 204, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_empty); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 204, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 194, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_INCREF(__pyx_v_n_obs);
-  __Pyx_GIVEREF(__pyx_v_n_obs);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_n_obs)) __PYX_ERR(0, 194, __pyx_L1_error);
-  __Pyx_INCREF(__pyx_v_n_obs);
-  __Pyx_GIVEREF(__pyx_v_n_obs);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_n_obs)) __PYX_ERR(0, 194, __pyx_L1_error);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_n_obs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 204, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_6 = NULL;
-  __pyx_t_7 = 0;
+  __pyx_t_4 = 0;
   #if CYTHON_UNPACK_METHODS
   if (unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_6)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_6);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
-      __pyx_t_7 = 1;
+      __pyx_t_4 = 1;
     }
   }
   #endif
   {
-    PyObject *__pyx_callargs[2] = {__pyx_t_6, __pyx_t_4};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_7, 1+__pyx_t_7);
+    PyObject *__pyx_callargs[2] = {__pyx_t_6, __pyx_t_2};
+    __pyx_t_3 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_4, 1+__pyx_t_4);
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 204, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
-  __pyx_v_matrix = __pyx_t_1;
-  __pyx_t_1 = 0;
+  __pyx_t_7 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_t_3, PyBUF_WRITABLE); if (unlikely(!__pyx_t_7.memview)) __PYX_ERR(0, 204, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_v_Y = __pyx_t_7;
+  __pyx_t_7.memview = NULL;
+  __pyx_t_7.data = NULL;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":195
+  /* "adaXT/predict/predict.pyx":206
+ *         Y = np.empty(n_obs)
  * 
- *         matrix = np.zeros((n_obs, n_obs))
- *         if (not leaf_nodes):  # make sure that there are calculated observations             # <<<<<<<<<<<<<<
- *             return matrix
- *         for node in leaf_nodes:
+ *         for i in range(n_obs):             # <<<<<<<<<<<<<<
+ *             cur_node = self.root
+ *             while isinstance(cur_node, DecisionNode):
  */
-  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_leaf_nodes); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 195, __pyx_L1_error)
-  __pyx_t_2 = (!__pyx_t_3);
-  if (__pyx_t_2) {
+  __pyx_t_4 = __pyx_v_n_obs;
+  __pyx_t_8 = __pyx_t_4;
+  for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
+    __pyx_v_i = __pyx_t_9;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":196
- *         matrix = np.zeros((n_obs, n_obs))
- *         if (not leaf_nodes):  # make sure that there are calculated observations
- *             return matrix             # <<<<<<<<<<<<<<
- *         for node in leaf_nodes:
- *             if scale:
+    /* "adaXT/predict/predict.pyx":207
+ * 
+ *         for i in range(n_obs):
+ *             cur_node = self.root             # <<<<<<<<<<<<<<
+ *             while isinstance(cur_node, DecisionNode):
+ *                 cur_split_idx = cur_node.split_idx
  */
-    __Pyx_XDECREF(__pyx_r);
-    __Pyx_INCREF(__pyx_v_matrix);
-    __pyx_r = __pyx_v_matrix;
-    goto __pyx_L0;
+    __pyx_t_3 = __pyx_v_self->__pyx_base.__pyx_base.root;
+    __Pyx_INCREF(__pyx_t_3);
+    __Pyx_XDECREF_SET(__pyx_v_cur_node, __pyx_t_3);
+    __pyx_t_3 = 0;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":195
- * 
- *         matrix = np.zeros((n_obs, n_obs))
- *         if (not leaf_nodes):  # make sure that there are calculated observations             # <<<<<<<<<<<<<<
- *             return matrix
- *         for node in leaf_nodes:
+    /* "adaXT/predict/predict.pyx":208
+ *         for i in range(n_obs):
+ *             cur_node = self.root
+ *             while isinstance(cur_node, DecisionNode):             # <<<<<<<<<<<<<<
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold
  */
-  }
+    while (1) {
+      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 208, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_10 = PyObject_IsInstance(__pyx_v_cur_node, __pyx_t_3); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 208, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (!__pyx_t_10) break;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":197
- *         if (not leaf_nodes):  # make sure that there are calculated observations
- *             return matrix
- *         for node in leaf_nodes:             # <<<<<<<<<<<<<<
- *             if scale:
- *                 n_node = node.indices.shape[0]
+      /* "adaXT/predict/predict.pyx":209
+ *             cur_node = self.root
+ *             while isinstance(cur_node, DecisionNode):
+ *                 cur_split_idx = cur_node.split_idx             # <<<<<<<<<<<<<<
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:
  */
-  if (likely(PyList_CheckExact(__pyx_v_leaf_nodes)) || PyTuple_CheckExact(__pyx_v_leaf_nodes)) {
-    __pyx_t_1 = __pyx_v_leaf_nodes; __Pyx_INCREF(__pyx_t_1);
-    __pyx_t_8 = 0;
-    __pyx_t_9 = NULL;
-  } else {
-    __pyx_t_8 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_leaf_nodes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 197, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_9 = __Pyx_PyObject_GetIterNextFunc(__pyx_t_1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 197, __pyx_L1_error)
-  }
-  for (;;) {
-    if (likely(!__pyx_t_9)) {
-      if (likely(PyList_CheckExact(__pyx_t_1))) {
-        {
-          Py_ssize_t __pyx_temp = __Pyx_PyList_GET_SIZE(__pyx_t_1);
-          #if !CYTHON_ASSUME_SAFE_MACROS
-          if (unlikely((__pyx_temp < 0))) __PYX_ERR(0, 197, __pyx_L1_error)
-          #endif
-          if (__pyx_t_8 >= __pyx_temp) break;
-        }
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely((0 < 0))) __PYX_ERR(0, 197, __pyx_L1_error)
-        #else
-        __pyx_t_5 = __Pyx_PySequence_ITEM(__pyx_t_1, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 197, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        #endif
-      } else {
-        {
-          Py_ssize_t __pyx_temp = __Pyx_PyTuple_GET_SIZE(__pyx_t_1);
-          #if !CYTHON_ASSUME_SAFE_MACROS
-          if (unlikely((__pyx_temp < 0))) __PYX_ERR(0, 197, __pyx_L1_error)
-          #endif
-          if (__pyx_t_8 >= __pyx_temp) break;
-        }
-        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely((0 < 0))) __PYX_ERR(0, 197, __pyx_L1_error)
-        #else
-        __pyx_t_5 = __Pyx_PySequence_ITEM(__pyx_t_1, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 197, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        #endif
-      }
-    } else {
-      __pyx_t_5 = __pyx_t_9(__pyx_t_1);
-      if (unlikely(!__pyx_t_5)) {
-        PyObject* exc_type = PyErr_Occurred();
-        if (exc_type) {
-          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
-          else __PYX_ERR(0, 197, __pyx_L1_error)
-        }
-        break;
-      }
-      __Pyx_GOTREF(__pyx_t_5);
-    }
-    __Pyx_XDECREF_SET(__pyx_v_node, __pyx_t_5);
-    __pyx_t_5 = 0;
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_split_idx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 209, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_11 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_11 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 209, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_v_cur_split_idx = __pyx_t_11;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":198
- *             return matrix
- *         for node in leaf_nodes:
- *             if scale:             # <<<<<<<<<<<<<<
- *                 n_node = node.indices.shape[0]
- *                 matrix[np.ix_(node.indices, node.indices)] = 1/n_node
+      /* "adaXT/predict/predict.pyx":210
+ *             while isinstance(cur_node, DecisionNode):
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold             # <<<<<<<<<<<<<<
+ *                 if X[i, cur_split_idx] < cur_threshold:
+ *                     cur_node = cur_node.left_child
  */
-    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_scale); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 198, __pyx_L1_error)
-    if (__pyx_t_2) {
+      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_threshold); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 210, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_t_3); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 210, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_v_cur_threshold = __pyx_t_12;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":199
- *         for node in leaf_nodes:
- *             if scale:
- *                 n_node = node.indices.shape[0]             # <<<<<<<<<<<<<<
- *                 matrix[np.ix_(node.indices, node.indices)] = 1/n_node
- *             else:
+      /* "adaXT/predict/predict.pyx":211
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
+ *                     cur_node = cur_node.left_child
+ *                 else:
  */
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_node, __pyx_n_s_indices); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 199, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_shape); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 199, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_5 = __Pyx_GetItemInt(__pyx_t_4, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 199, __pyx_L1_error)
+      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 211, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_cur_split_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 211, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __Pyx_XDECREF_SET(__pyx_v_n_node, __pyx_t_5);
+      __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 211, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_3);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3)) __PYX_ERR(0, 211, __pyx_L1_error);
+      __Pyx_GIVEREF(__pyx_t_5);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_5)) __PYX_ERR(0, 211, __pyx_L1_error);
+      __pyx_t_3 = 0;
       __pyx_t_5 = 0;
-
-      /* "adaXT/decision_tree/DecisionTree.pyx":200
- *             if scale:
- *                 n_node = node.indices.shape[0]
- *                 matrix[np.ix_(node.indices, node.indices)] = 1/n_node             # <<<<<<<<<<<<<<
- *             else:
- *                 matrix[np.ix_(node.indices, node.indices)] = 1
- */
-      __pyx_t_5 = __Pyx_PyNumber_Divide(__pyx_int_1, __pyx_v_n_node); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 200, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 211, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 200, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_ix); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 200, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_10);
-      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_node, __pyx_n_s_indices); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 200, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_6);
-      __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_node, __pyx_n_s_indices); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 200, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_11);
-      __pyx_t_12 = NULL;
-      __pyx_t_7 = 0;
-      #if CYTHON_UNPACK_METHODS
-      if (unlikely(PyMethod_Check(__pyx_t_10))) {
-        __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_10);
-        if (likely(__pyx_t_12)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
-          __Pyx_INCREF(__pyx_t_12);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_10, function);
-          __pyx_t_7 = 1;
-        }
-      }
-      #endif
-      {
-        PyObject *__pyx_callargs[3] = {__pyx_t_12, __pyx_t_6, __pyx_t_11};
-        __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_10, __pyx_callargs+1-__pyx_t_7, 2+__pyx_t_7);
-        __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
-        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 200, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-      }
-      if (unlikely((PyObject_SetItem(__pyx_v_matrix, __pyx_t_4, __pyx_t_5) < 0))) __PYX_ERR(0, 200, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_t_2 = PyFloat_FromDouble(__pyx_v_cur_threshold); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 211, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_3 = PyObject_RichCompare(__pyx_t_5, __pyx_t_2, Py_LT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 211, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_10 < 0))) __PYX_ERR(0, 211, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      if (__pyx_t_10) {
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":198
- *             return matrix
- *         for node in leaf_nodes:
- *             if scale:             # <<<<<<<<<<<<<<
- *                 n_node = node.indices.shape[0]
- *                 matrix[np.ix_(node.indices, node.indices)] = 1/n_node
+        /* "adaXT/predict/predict.pyx":212
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:
+ *                     cur_node = cur_node.left_child             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     cur_node = cur_node.right_child
  */
-      goto __pyx_L7;
-    }
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_left_child); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 212, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_3);
+        __pyx_t_3 = 0;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":202
- *                 matrix[np.ix_(node.indices, node.indices)] = 1/n_node
- *             else:
- *                 matrix[np.ix_(node.indices, node.indices)] = 1             # <<<<<<<<<<<<<<
- * 
- *         return matrix
+        /* "adaXT/predict/predict.pyx":211
+ *                 cur_split_idx = cur_node.split_idx
+ *                 cur_threshold = cur_node.threshold
+ *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
+ *                     cur_node = cur_node.left_child
+ *                 else:
  */
-    /*else*/ {
-      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 202, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_ix); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 202, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_10);
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_node, __pyx_n_s_indices); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 202, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_node, __pyx_n_s_indices); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 202, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_11);
-      __pyx_t_6 = NULL;
-      __pyx_t_7 = 0;
-      #if CYTHON_UNPACK_METHODS
-      if (unlikely(PyMethod_Check(__pyx_t_10))) {
-        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_10);
-        if (likely(__pyx_t_6)) {
-          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
-          __Pyx_INCREF(__pyx_t_6);
-          __Pyx_INCREF(function);
-          __Pyx_DECREF_SET(__pyx_t_10, function);
-          __pyx_t_7 = 1;
-        }
+        goto __pyx_L7;
       }
-      #endif
-      {
-        PyObject *__pyx_callargs[3] = {__pyx_t_6, __pyx_t_4, __pyx_t_11};
-        __pyx_t_5 = __Pyx_PyObject_FastCall(__pyx_t_10, __pyx_callargs+1-__pyx_t_7, 2+__pyx_t_7);
-        __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
-        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-        if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 202, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_5);
-        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
+
+      /* "adaXT/predict/predict.pyx":214
+ *                     cur_node = cur_node.left_child
+ *                 else:
+ *                     cur_node = cur_node.right_child             # <<<<<<<<<<<<<<
+ *             Y[i] = cur_node.theta0 + cur_node.theta1*X[i, 0]
+ *         return Y
+ */
+      /*else*/ {
+        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_right_child); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 214, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_3);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_3);
+        __pyx_t_3 = 0;
       }
-      if (unlikely((PyObject_SetItem(__pyx_v_matrix, __pyx_t_5, __pyx_int_1) < 0))) __PYX_ERR(0, 202, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_L7:;
     }
-    __pyx_L7:;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":197
- *         if (not leaf_nodes):  # make sure that there are calculated observations
- *             return matrix
- *         for node in leaf_nodes:             # <<<<<<<<<<<<<<
- *             if scale:
- *                 n_node = node.indices.shape[0]
+    /* "adaXT/predict/predict.pyx":215
+ *                 else:
+ *                     cur_node = cur_node.right_child
+ *             Y[i] = cur_node.theta0 + cur_node.theta1*X[i, 0]             # <<<<<<<<<<<<<<
+ *         return Y
+ * 
  */
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_theta0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 215, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_theta1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 215, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 215, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 215, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_GIVEREF(__pyx_t_5);
+    if (__Pyx_PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5)) __PYX_ERR(0, 215, __pyx_L1_error);
+    __Pyx_INCREF(__pyx_int_0);
+    __Pyx_GIVEREF(__pyx_int_0);
+    if (__Pyx_PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_int_0)) __PYX_ERR(0, 215, __pyx_L1_error);
+    __pyx_t_5 = 0;
+    __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 215, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_t_6 = PyNumber_Multiply(__pyx_t_2, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 215, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_6);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_5 = PyNumber_Add(__pyx_t_3, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 215, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+    __pyx_t_12 = __pyx_PyFloat_AsDouble(__pyx_t_5); if (unlikely((__pyx_t_12 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 215, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_13 = __pyx_v_i;
+    *((double *) ( /* dim=0 */ (__pyx_v_Y.data + __pyx_t_13 * __pyx_v_Y.strides[0]) )) = __pyx_t_12;
   }
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":204
- *                 matrix[np.ix_(node.indices, node.indices)] = 1
+  /* "adaXT/predict/predict.pyx":216
+ *                     cur_node = cur_node.right_child
+ *             Y[i] = cur_node.theta0 + cur_node.theta1*X[i, 0]
+ *         return Y             # <<<<<<<<<<<<<<
  * 
- *         return matrix             # <<<<<<<<<<<<<<
  * 
- *     def predict_leaf_matrix(self, X: np.ndarray, scale: bool = False):
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_matrix);
-  __pyx_r = __pyx_v_matrix;
+  __pyx_t_5 = __pyx_memoryview_fromslice(__pyx_v_Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 216, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __pyx_r = __pyx_t_5;
+  __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":187
- *         return cur_max
+  /* "adaXT/predict/predict.pyx":195
  * 
- *     def get_leaf_matrix(self, scale: bool = False) -> np.ndarray:             # <<<<<<<<<<<<<<
- *         if not self.root:
- *             raise ValueError("The tree has not been trained before trying to predict")
+ * cdef class PredictLinearRegression(PredictRegression):
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, n_obs
  */
 
   /* function exit code */
   __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_4);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
-  __Pyx_XDECREF(__pyx_t_10);
-  __Pyx_XDECREF(__pyx_t_11);
-  __Pyx_XDECREF(__pyx_t_12);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.get_leaf_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_7, 1);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictLinearRegression.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_leaf_nodes);
-  __Pyx_XDECREF(__pyx_v_n_obs);
-  __Pyx_XDECREF(__pyx_v_matrix);
-  __Pyx_XDECREF(__pyx_v_node);
-  __Pyx_XDECREF(__pyx_v_n_node);
+  __Pyx_XDECREF(__pyx_v_cur_node);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
+  __Pyx_XDECREF(__pyx_v_X);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/DecisionTree.pyx":206
- *         return matrix
+/* "adaXT/predict/predict.pyx":221
+ * cdef class PredictQuantile(Predict):
  * 
- *     def predict_leaf_matrix(self, X: np.ndarray, scale: bool = False):             # <<<<<<<<<<<<<<
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
  *         cdef:
- *             int i
+ *             int i, cur_split_idx, n_obs
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_19predict_leaf_matrix(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_15PredictQuantile_1predict(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_19predict_leaf_matrix = {"predict_leaf_matrix", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_19predict_leaf_matrix, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_19predict_leaf_matrix(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_15PredictQuantile_1predict = {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_15PredictQuantile_1predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_15PredictQuantile_1predict(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
-  PyObject *__pyx_v_self = 0;
   PyObject *__pyx_v_X = 0;
-  PyObject *__pyx_v_scale = 0;
+  PyObject *__pyx_v_kwargs = 0;
   #if !CYTHON_METH_FASTCALL
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   #endif
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
-  PyObject* values[3] = {0,0,0};
+  PyObject* values[1] = {0};
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
-  __Pyx_RefNannySetupContext("predict_leaf_matrix (wrapper)", 0);
+  __Pyx_RefNannySetupContext("predict (wrapper)", 0);
   #if !CYTHON_METH_FASTCALL
   #if CYTHON_ASSUME_SAFE_MACROS
   __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
   #else
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
   {
-    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_X,&__pyx_n_s_scale,0};
-    values[2] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)((PyObject *)Py_False)));
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,0};
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        CYTHON_FALLTHROUGH;
         case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
         CYTHON_FALLTHROUGH;
         case  0: break;
         default: goto __pyx_L5_argtuple_error;
       }
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
-        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 206, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 221, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
-        CYTHON_FALLTHROUGH;
-        case  1:
-        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
-          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
-          kw_args--;
-        }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 206, __pyx_L3_error)
-        else {
-          __Pyx_RaiseArgtupleInvalid("predict_leaf_matrix", 0, 2, 3, 1); __PYX_ERR(0, 206, __pyx_L3_error)
-        }
-        CYTHON_FALLTHROUGH;
-        case  2:
-        if (kw_args > 0) {
-          PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_scale);
-          if (value) { values[2] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 206, __pyx_L3_error)
-        }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "predict_leaf_matrix") < 0)) __PYX_ERR(0, 206, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "predict") < 0)) __PYX_ERR(0, 221, __pyx_L3_error)
       }
+    } else if (unlikely(__pyx_nargs != 1)) {
+      goto __pyx_L5_argtuple_error;
     } else {
-      switch (__pyx_nargs) {
-        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
-        CYTHON_FALLTHROUGH;
-        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
-        values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
-        break;
-        default: goto __pyx_L5_argtuple_error;
-      }
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    __pyx_v_self = values[0];
-    __pyx_v_X = values[1];
-    __pyx_v_scale = values[2];
+    __pyx_v_X = values[0];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("predict_leaf_matrix", 0, 2, 3, __pyx_nargs); __PYX_ERR(0, 206, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("predict", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 221, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.predict_leaf_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictQuantile.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_18predict_leaf_matrix(__pyx_self, __pyx_v_self, __pyx_v_X, __pyx_v_scale);
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_15PredictQuantile_predict(((struct __pyx_obj_5adaXT_7predict_7predict_PredictQuantile *)__pyx_v_self), __pyx_v_X, __pyx_v_kwargs);
 
   /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_18predict_leaf_matrix(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_X, PyObject *__pyx_v_scale) {
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_15PredictQuantile_predict(struct __pyx_obj_5adaXT_7predict_7predict_PredictQuantile *__pyx_v_self, PyObject *__pyx_v_X, PyObject *__pyx_v_kwargs) {
   int __pyx_v_i;
-  int __pyx_v_row;
-  PyObject *__pyx_v_ht = 0;
   int __pyx_v_cur_split_idx;
+  int __pyx_v_n_obs;
   double __pyx_v_cur_threshold;
-  PyObject *__pyx_v_cur_node = NULL;
-  PyObject *__pyx_v_matrix = NULL;
-  PyObject *__pyx_v_key = NULL;
-  PyObject *__pyx_v_indices = NULL;
-  PyObject *__pyx_v_val = NULL;
-  PyObject *__pyx_v_count = NULL;
+  PyObject *__pyx_v_cur_node = 0;
+  __Pyx_memviewslice __pyx_v_Y = { 0, 0, { 0 }, { 0 }, { 0 } };
+  double __pyx_v_quantile;
+  int __pyx_v_save_indices;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
-  int __pyx_t_2;
+  double __pyx_t_2;
   int __pyx_t_3;
-  PyObject *__pyx_t_4 = NULL;
+  __Pyx_memviewslice __pyx_t_4 = { 0, 0, { 0 }, { 0 }, { 0 } };
   PyObject *__pyx_t_5 = NULL;
   int __pyx_t_6;
-  int __pyx_t_7;
-  int __pyx_t_8;
-  int __pyx_t_9;
-  double __pyx_t_10;
-  PyObject *__pyx_t_11 = NULL;
-  PyObject *__pyx_t_12 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  __Pyx_memviewslice __pyx_t_9 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  int __pyx_t_10;
+  int __pyx_t_11;
+  int __pyx_t_12;
   Py_ssize_t __pyx_t_13;
-  Py_ssize_t __pyx_t_14;
-  Py_ssize_t __pyx_t_15;
+  PyObject *__pyx_t_14 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("predict_leaf_matrix", 0);
+  __Pyx_RefNannySetupContext("predict", 0);
   __Pyx_INCREF(__pyx_v_X);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":214
- *             double cur_threshold
- * 
- *         if not self.root:             # <<<<<<<<<<<<<<
- *             raise ValueError("The tree has not been trained before trying to predict")
+  /* "adaXT/predict/predict.pyx":230
+ *             bint save_indices
  * 
+ *         quantile = <double> kwargs['quantile']             # <<<<<<<<<<<<<<
+ *         if "save_indices" in kwargs.keys():
+ *             save_indices = <bint> kwargs['save_indices']
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_root); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 214, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_GetItem(__pyx_v_kwargs, __pyx_n_u_quantile); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 230, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_2 < 0))) __PYX_ERR(0, 214, __pyx_L1_error)
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 230, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_3 = (!__pyx_t_2);
-  if (unlikely(__pyx_t_3)) {
+  __pyx_v_quantile = ((double)__pyx_t_2);
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":215
- * 
- *         if not self.root:
- *             raise ValueError("The tree has not been trained before trying to predict")             # <<<<<<<<<<<<<<
+  /* "adaXT/predict/predict.pyx":231
  * 
- *         # Make sure that x fits the dimensions.
+ *         quantile = <double> kwargs['quantile']
+ *         if "save_indices" in kwargs.keys():             # <<<<<<<<<<<<<<
+ *             save_indices = <bint> kwargs['save_indices']
+ *         else:
  */
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 215, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_Keys(__pyx_v_kwargs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 231, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = (__Pyx_PySequence_ContainsTF(__pyx_n_u_save_indices, __pyx_t_1, Py_EQ)); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 231, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_3) {
+
+    /* "adaXT/predict/predict.pyx":232
+ *         quantile = <double> kwargs['quantile']
+ *         if "save_indices" in kwargs.keys():
+ *             save_indices = <bint> kwargs['save_indices']             # <<<<<<<<<<<<<<
+ *         else:
+ *             save_indices = False
+ */
+    __pyx_t_1 = __Pyx_PyDict_GetItem(__pyx_v_kwargs, __pyx_n_u_save_indices); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 232, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
+    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 232, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_ERR(0, 215, __pyx_L1_error)
+    __pyx_v_save_indices = __pyx_t_3;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":214
- *             double cur_threshold
- * 
- *         if not self.root:             # <<<<<<<<<<<<<<
- *             raise ValueError("The tree has not been trained before trying to predict")
+    /* "adaXT/predict/predict.pyx":231
  * 
+ *         quantile = <double> kwargs['quantile']
+ *         if "save_indices" in kwargs.keys():             # <<<<<<<<<<<<<<
+ *             save_indices = <bint> kwargs['save_indices']
+ *         else:
  */
+    goto __pyx_L3;
   }
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":218
- * 
+  /* "adaXT/predict/predict.pyx":234
+ *             save_indices = <bint> kwargs['save_indices']
+ *         else:
+ *             save_indices = False             # <<<<<<<<<<<<<<
  *         # Make sure that x fits the dimensions.
- *         X = self.__check_dimensions(X)             # <<<<<<<<<<<<<<
- *         row = X.shape[0]
- * 
+ *         X = Predict.__check_dimensions(self, X)
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_DecisionTree__check_dimensions); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 218, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = NULL;
-  __pyx_t_6 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (likely(PyMethod_Check(__pyx_t_4))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
-      __Pyx_INCREF(__pyx_t_5);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_4, function);
-      __pyx_t_6 = 1;
-    }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_v_X};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_4, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 218, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  /*else*/ {
+    __pyx_v_save_indices = 0;
   }
+  __pyx_L3:;
+
+  /* "adaXT/predict/predict.pyx":236
+ *             save_indices = False
+ *         # Make sure that x fits the dimensions.
+ *         X = Predict.__check_dimensions(self, X)             # <<<<<<<<<<<<<<
+ *         n_obs = X.shape[0]
+ *         Y = np.empty(n_obs)
+ */
+  __pyx_t_4 = __pyx_f_5adaXT_7predict_7predict_7Predict__Predict__check_dimensions(((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)__pyx_v_self), __pyx_v_X); if (unlikely(!__pyx_t_4.memview)) __PYX_ERR(0, 236, __pyx_L1_error)
+  __pyx_t_1 = __pyx_memoryview_fromslice(__pyx_t_4, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 236, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_4, 1);
+  __pyx_t_4.memview = NULL; __pyx_t_4.data = NULL;
   __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":219
+  /* "adaXT/predict/predict.pyx":237
  *         # Make sure that x fits the dimensions.
- *         X = self.__check_dimensions(X)
- *         row = X.shape[0]             # <<<<<<<<<<<<<<
+ *         X = Predict.__check_dimensions(self, X)
+ *         n_obs = X.shape[0]             # <<<<<<<<<<<<<<
+ *         Y = np.empty(n_obs)
  * 
- *         ht = {}
  */
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 219, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 219, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 237, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_4); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 219, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_v_row = __pyx_t_6;
+  __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_5); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 237, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_v_n_obs = __pyx_t_6;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":221
- *         row = X.shape[0]
+  /* "adaXT/predict/predict.pyx":238
+ *         X = Predict.__check_dimensions(self, X)
+ *         n_obs = X.shape[0]
+ *         Y = np.empty(n_obs)             # <<<<<<<<<<<<<<
  * 
- *         ht = {}             # <<<<<<<<<<<<<<
- *         for i in range(row):
- *             cur_node = self.root
+ *         for i in range(n_obs):
  */
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 221, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_v_ht = ((PyObject*)__pyx_t_4);
-  __pyx_t_4 = 0;
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_empty); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_n_obs); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_8 = NULL;
+  __pyx_t_6 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_7))) {
+    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
+    if (likely(__pyx_t_8)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
+      __Pyx_INCREF(__pyx_t_8);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_7, function);
+      __pyx_t_6 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_8, __pyx_t_1};
+    __pyx_t_5 = __Pyx_PyObject_FastCall(__pyx_t_7, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
+    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 238, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  }
+  __pyx_t_9 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_t_5, PyBUF_WRITABLE); if (unlikely(!__pyx_t_9.memview)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_v_Y = __pyx_t_9;
+  __pyx_t_9.memview = NULL;
+  __pyx_t_9.data = NULL;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":222
+  /* "adaXT/predict/predict.pyx":240
+ *         Y = np.empty(n_obs)
  * 
- *         ht = {}
- *         for i in range(row):             # <<<<<<<<<<<<<<
+ *         for i in range(n_obs):             # <<<<<<<<<<<<<<
  *             cur_node = self.root
  *             while isinstance(cur_node, DecisionNode):
  */
-  __pyx_t_6 = __pyx_v_row;
-  __pyx_t_7 = __pyx_t_6;
-  for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
-    __pyx_v_i = __pyx_t_8;
+  __pyx_t_6 = __pyx_v_n_obs;
+  __pyx_t_10 = __pyx_t_6;
+  for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_10; __pyx_t_11+=1) {
+    __pyx_v_i = __pyx_t_11;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":223
- *         ht = {}
- *         for i in range(row):
+    /* "adaXT/predict/predict.pyx":241
+ * 
+ *         for i in range(n_obs):
  *             cur_node = self.root             # <<<<<<<<<<<<<<
  *             while isinstance(cur_node, DecisionNode):
  *                 cur_split_idx = cur_node.split_idx
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_self, __pyx_n_s_root); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 223, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_XDECREF_SET(__pyx_v_cur_node, __pyx_t_4);
-    __pyx_t_4 = 0;
+    __pyx_t_5 = __pyx_v_self->__pyx_base.root;
+    __Pyx_INCREF(__pyx_t_5);
+    __Pyx_XDECREF_SET(__pyx_v_cur_node, __pyx_t_5);
+    __pyx_t_5 = 0;
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":224
- *         for i in range(row):
+    /* "adaXT/predict/predict.pyx":242
+ *         for i in range(n_obs):
  *             cur_node = self.root
  *             while isinstance(cur_node, DecisionNode):             # <<<<<<<<<<<<<<
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold
  */
     while (1) {
-      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 224, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_3 = PyObject_IsInstance(__pyx_v_cur_node, __pyx_t_4); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 224, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 242, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_3 = PyObject_IsInstance(__pyx_v_cur_node, __pyx_t_5); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 242, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       if (!__pyx_t_3) break;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":225
+      /* "adaXT/predict/predict.pyx":243
  *             cur_node = self.root
  *             while isinstance(cur_node, DecisionNode):
  *                 cur_split_idx = cur_node.split_idx             # <<<<<<<<<<<<<<
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_split_idx); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 225, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_9 = __Pyx_PyInt_As_int(__pyx_t_4); if (unlikely((__pyx_t_9 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 225, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_v_cur_split_idx = __pyx_t_9;
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_split_idx); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 243, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_12 = __Pyx_PyInt_As_int(__pyx_t_5); if (unlikely((__pyx_t_12 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 243, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_v_cur_split_idx = __pyx_t_12;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":226
+      /* "adaXT/predict/predict.pyx":244
  *             while isinstance(cur_node, DecisionNode):
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold             # <<<<<<<<<<<<<<
  *                 if X[i, cur_split_idx] < cur_threshold:
  *                     cur_node = cur_node.left_child
  */
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_threshold); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 226, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_10 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_10 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 226, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_v_cur_threshold = __pyx_t_10;
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_threshold); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 244, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_5); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 244, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_v_cur_threshold = __pyx_t_2;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":227
+      /* "adaXT/predict/predict.pyx":245
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
  *                     cur_node = cur_node.left_child
  *                 else:
  */
-      __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 227, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_cur_split_idx); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 227, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 227, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 245, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __Pyx_GIVEREF(__pyx_t_4);
-      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4)) __PYX_ERR(0, 227, __pyx_L1_error);
-      __Pyx_GIVEREF(__pyx_t_1);
-      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1)) __PYX_ERR(0, 227, __pyx_L1_error);
-      __pyx_t_4 = 0;
-      __pyx_t_1 = 0;
-      __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 227, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_cur_split_idx); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 245, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 245, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_5 = PyFloat_FromDouble(__pyx_v_cur_threshold); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 227, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_4 = PyObject_RichCompare(__pyx_t_1, __pyx_t_5, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 227, __pyx_L1_error)
+      __Pyx_GIVEREF(__pyx_t_5);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_5)) __PYX_ERR(0, 245, __pyx_L1_error);
+      __Pyx_GIVEREF(__pyx_t_7);
+      if (__Pyx_PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_7)) __PYX_ERR(0, 245, __pyx_L1_error);
+      __pyx_t_5 = 0;
+      __pyx_t_7 = 0;
+      __pyx_t_7 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 245, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_1 = PyFloat_FromDouble(__pyx_v_cur_threshold); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 245, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_t_7, __pyx_t_1, Py_LT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 245, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 245, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 227, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_3) {
 
-        /* "adaXT/decision_tree/DecisionTree.pyx":228
+        /* "adaXT/predict/predict.pyx":246
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:
  *                     cur_node = cur_node.left_child             # <<<<<<<<<<<<<<
  *                 else:
  *                     cur_node = cur_node.right_child
  */
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_left_child); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 228, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_4);
-        __pyx_t_4 = 0;
+        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_left_child); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 246, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_5);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_5);
+        __pyx_t_5 = 0;
 
-        /* "adaXT/decision_tree/DecisionTree.pyx":227
+        /* "adaXT/predict/predict.pyx":245
  *                 cur_split_idx = cur_node.split_idx
  *                 cur_threshold = cur_node.threshold
  *                 if X[i, cur_split_idx] < cur_threshold:             # <<<<<<<<<<<<<<
  *                     cur_node = cur_node.left_child
  *                 else:
  */
         goto __pyx_L8;
       }
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":230
+      /* "adaXT/predict/predict.pyx":248
  *                     cur_node = cur_node.left_child
  *                 else:
  *                     cur_node = cur_node.right_child             # <<<<<<<<<<<<<<
  * 
- *             if cur_node.id not in ht.keys():
+ *             if save_indices:
  */
       /*else*/ {
-        __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_right_child); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 230, __pyx_L1_error)
-        __Pyx_GOTREF(__pyx_t_4);
-        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_4);
-        __pyx_t_4 = 0;
+        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_right_child); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 248, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_5);
+        __Pyx_DECREF_SET(__pyx_v_cur_node, __pyx_t_5);
+        __pyx_t_5 = 0;
       }
       __pyx_L8:;
     }
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":232
+    /* "adaXT/predict/predict.pyx":250
  *                     cur_node = cur_node.right_child
  * 
- *             if cur_node.id not in ht.keys():             # <<<<<<<<<<<<<<
- *                 ht[cur_node.id] = [i]
+ *             if save_indices:             # <<<<<<<<<<<<<<
+ *                 Y[i] = self.Y.base[cur_node.indices]
  *             else:
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 232, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyDict_Keys(__pyx_v_ht); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 232, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = (__Pyx_PySequence_ContainsTF(__pyx_t_4, __pyx_t_5, Py_NE)); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 232, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (__pyx_t_3) {
+    if (__pyx_v_save_indices) {
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":233
+      /* "adaXT/predict/predict.pyx":251
  * 
- *             if cur_node.id not in ht.keys():
- *                 ht[cur_node.id] = [i]             # <<<<<<<<<<<<<<
+ *             if save_indices:
+ *                 Y[i] = self.Y.base[cur_node.indices]             # <<<<<<<<<<<<<<
  *             else:
- *                 ht[cur_node.id] += [i]
+ *                 Y[i] = np.quantile(self.Y.base[cur_node.indices], quantile)
  */
-      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 233, __pyx_L1_error)
+      __pyx_t_5 = __pyx_memoryview_fromslice(__pyx_v_self->__pyx_base.Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 251, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 233, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __Pyx_GIVEREF(__pyx_t_5);
-      if (__Pyx_PyList_SET_ITEM(__pyx_t_4, 0, __pyx_t_5)) __PYX_ERR(0, 233, __pyx_L1_error);
-      __pyx_t_5 = 0;
-      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_id); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 233, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_base); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 251, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_indices); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 251, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      if (unlikely((PyDict_SetItem(__pyx_v_ht, __pyx_t_5, __pyx_t_4) < 0))) __PYX_ERR(0, 233, __pyx_L1_error)
+      __pyx_t_7 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_t_5); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 251, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_7);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_7); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 251, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_t_13 = __pyx_v_i;
+      *((double *) ( /* dim=0 */ (__pyx_v_Y.data + __pyx_t_13 * __pyx_v_Y.strides[0]) )) = __pyx_t_2;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":232
+      /* "adaXT/predict/predict.pyx":250
  *                     cur_node = cur_node.right_child
  * 
- *             if cur_node.id not in ht.keys():             # <<<<<<<<<<<<<<
- *                 ht[cur_node.id] = [i]
+ *             if save_indices:             # <<<<<<<<<<<<<<
+ *                 Y[i] = self.Y.base[cur_node.indices]
  *             else:
  */
       goto __pyx_L9;
     }
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":235
- *                 ht[cur_node.id] = [i]
+    /* "adaXT/predict/predict.pyx":253
+ *                 Y[i] = self.Y.base[cur_node.indices]
  *             else:
- *                 ht[cur_node.id] += [i]             # <<<<<<<<<<<<<<
- *         matrix = np.zeros((row, row))
- *         for key in ht.keys():
+ *                 Y[i] = np.quantile(self.Y.base[cur_node.indices], quantile)             # <<<<<<<<<<<<<<
+ *         return Y
+ * 
  */
     /*else*/ {
-      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 235, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_4);
-      __pyx_t_5 = __Pyx_PyDict_GetItem(__pyx_v_ht, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 235, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 253, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_1);
-      __pyx_t_11 = PyList_New(1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 235, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_11);
-      __Pyx_GIVEREF(__pyx_t_1);
-      if (__Pyx_PyList_SET_ITEM(__pyx_t_11, 0, __pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error);
-      __pyx_t_1 = 0;
-      __pyx_t_1 = PyNumber_InPlaceAdd(__pyx_t_5, __pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_quantile); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 253, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-      if (unlikely((PyDict_SetItem(__pyx_v_ht, __pyx_t_4, __pyx_t_1) < 0))) __PYX_ERR(0, 235, __pyx_L1_error)
-      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_5 = __pyx_memoryview_fromslice(__pyx_v_self->__pyx_base.Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 253, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_base); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 253, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_8);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_cur_node, __pyx_n_s_indices); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 253, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_14 = __Pyx_PyObject_GetItem(__pyx_t_8, __pyx_t_5); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 253, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_14);
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_5 = PyFloat_FromDouble(__pyx_v_quantile); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 253, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_8 = NULL;
+      __pyx_t_12 = 0;
+      #if CYTHON_UNPACK_METHODS
+      if (unlikely(PyMethod_Check(__pyx_t_1))) {
+        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_1);
+        if (likely(__pyx_t_8)) {
+          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
+          __Pyx_INCREF(__pyx_t_8);
+          __Pyx_INCREF(function);
+          __Pyx_DECREF_SET(__pyx_t_1, function);
+          __pyx_t_12 = 1;
+        }
+      }
+      #endif
+      {
+        PyObject *__pyx_callargs[3] = {__pyx_t_8, __pyx_t_14, __pyx_t_5};
+        __pyx_t_7 = __Pyx_PyObject_FastCall(__pyx_t_1, __pyx_callargs+1-__pyx_t_12, 2+__pyx_t_12);
+        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
+        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 253, __pyx_L1_error)
+        __Pyx_GOTREF(__pyx_t_7);
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      }
+      __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_7); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 253, __pyx_L1_error)
+      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+      __pyx_t_13 = __pyx_v_i;
+      *((double *) ( /* dim=0 */ (__pyx_v_Y.data + __pyx_t_13 * __pyx_v_Y.strides[0]) )) = __pyx_t_2;
     }
     __pyx_L9:;
   }
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":236
+  /* "adaXT/predict/predict.pyx":254
  *             else:
- *                 ht[cur_node.id] += [i]
- *         matrix = np.zeros((row, row))             # <<<<<<<<<<<<<<
- *         for key in ht.keys():
- *             indices = ht[key]
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 236, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_zeros); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 236, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_11);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_row); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 236, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_row); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 236, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_12 = PyTuple_New(2); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 236, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_12);
-  __Pyx_GIVEREF(__pyx_t_1);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_1)) __PYX_ERR(0, 236, __pyx_L1_error);
-  __Pyx_GIVEREF(__pyx_t_5);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_12, 1, __pyx_t_5)) __PYX_ERR(0, 236, __pyx_L1_error);
-  __pyx_t_1 = 0;
-  __pyx_t_5 = 0;
-  __pyx_t_5 = NULL;
-  __pyx_t_6 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_11))) {
-    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_11);
-    if (likely(__pyx_t_5)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
-      __Pyx_INCREF(__pyx_t_5);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_11, function);
-      __pyx_t_6 = 1;
-    }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_5, __pyx_t_12};
-    __pyx_t_4 = __Pyx_PyObject_FastCall(__pyx_t_11, __pyx_callargs+1-__pyx_t_6, 1+__pyx_t_6);
-    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 236, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_4);
-    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
-  }
-  __pyx_v_matrix = __pyx_t_4;
-  __pyx_t_4 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":237
- *                 ht[cur_node.id] += [i]
- *         matrix = np.zeros((row, row))
- *         for key in ht.keys():             # <<<<<<<<<<<<<<
- *             indices = ht[key]
- *             val = 1
- */
-  __pyx_t_13 = 0;
-  __pyx_t_11 = __Pyx_dict_iterator(__pyx_v_ht, 1, __pyx_n_s_keys, (&__pyx_t_14), (&__pyx_t_6)); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 237, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_11);
-  __Pyx_XDECREF(__pyx_t_4);
-  __pyx_t_4 = __pyx_t_11;
-  __pyx_t_11 = 0;
-  while (1) {
-    __pyx_t_7 = __Pyx_dict_iter_next(__pyx_t_4, __pyx_t_14, &__pyx_t_13, &__pyx_t_11, NULL, NULL, __pyx_t_6);
-    if (unlikely(__pyx_t_7 == 0)) break;
-    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 237, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_11);
-    __Pyx_XDECREF_SET(__pyx_v_key, __pyx_t_11);
-    __pyx_t_11 = 0;
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":238
- *         matrix = np.zeros((row, row))
- *         for key in ht.keys():
- *             indices = ht[key]             # <<<<<<<<<<<<<<
- *             val = 1
- *             count = len(indices)
- */
-    __pyx_t_11 = __Pyx_PyDict_GetItem(__pyx_v_ht, __pyx_v_key); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 238, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_11);
-    __Pyx_XDECREF_SET(__pyx_v_indices, __pyx_t_11);
-    __pyx_t_11 = 0;
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":239
- *         for key in ht.keys():
- *             indices = ht[key]
- *             val = 1             # <<<<<<<<<<<<<<
- *             count = len(indices)
- *             if scale:
- */
-    __Pyx_INCREF(__pyx_int_1);
-    __Pyx_XDECREF_SET(__pyx_v_val, __pyx_int_1);
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":240
- *             indices = ht[key]
- *             val = 1
- *             count = len(indices)             # <<<<<<<<<<<<<<
- *             if scale:
- *                 val = 1/count
- */
-    __pyx_t_15 = PyObject_Length(__pyx_v_indices); if (unlikely(__pyx_t_15 == ((Py_ssize_t)-1))) __PYX_ERR(0, 240, __pyx_L1_error)
-    __pyx_t_11 = PyInt_FromSsize_t(__pyx_t_15); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 240, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_11);
-    __Pyx_XDECREF_SET(__pyx_v_count, __pyx_t_11);
-    __pyx_t_11 = 0;
-
-    /* "adaXT/decision_tree/DecisionTree.pyx":241
- *             val = 1
- *             count = len(indices)
- *             if scale:             # <<<<<<<<<<<<<<
- *                 val = 1/count
- *             matrix[np.ix_(indices, indices)] = val
+ *                 Y[i] = np.quantile(self.Y.base[cur_node.indices], quantile)
+ *         return Y             # <<<<<<<<<<<<<<
+ * 
+ *     @staticmethod
  */
-    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_scale); if (unlikely((__pyx_t_3 < 0))) __PYX_ERR(0, 241, __pyx_L1_error)
-    if (__pyx_t_3) {
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_7 = __pyx_memoryview_fromslice(__pyx_v_Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 254, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_r = __pyx_t_7;
+  __pyx_t_7 = 0;
+  goto __pyx_L0;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":242
- *             count = len(indices)
- *             if scale:
- *                 val = 1/count             # <<<<<<<<<<<<<<
- *             matrix[np.ix_(indices, indices)] = val
+  /* "adaXT/predict/predict.pyx":221
+ * cdef class PredictQuantile(Predict):
  * 
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, n_obs
  */
-      __pyx_t_11 = __Pyx_PyNumber_Divide(__pyx_int_1, __pyx_v_count); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 242, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_11);
-      __Pyx_DECREF_SET(__pyx_v_val, __pyx_t_11);
-      __pyx_t_11 = 0;
 
-      /* "adaXT/decision_tree/DecisionTree.pyx":241
- *             val = 1
- *             count = len(indices)
- *             if scale:             # <<<<<<<<<<<<<<
- *                 val = 1/count
- *             matrix[np.ix_(indices, indices)] = val
- */
-    }
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_4, 1);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_9, 1);
+  __Pyx_XDECREF(__pyx_t_14);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictQuantile.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_cur_node);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
+  __Pyx_XDECREF(__pyx_v_X);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
 
-    /* "adaXT/decision_tree/DecisionTree.pyx":243
- *             if scale:
- *                 val = 1/count
- *             matrix[np.ix_(indices, indices)] = val             # <<<<<<<<<<<<<<
+/* "adaXT/predict/predict.pyx":256
+ *         return Y
  * 
- *         return matrix
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         quantile = <double> kwargs['quantile']
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_12, __pyx_n_s_np); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 243, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_12);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_12, __pyx_n_s_ix); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 243, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-    __pyx_t_12 = NULL;
-    __pyx_t_7 = 0;
-    #if CYTHON_UNPACK_METHODS
-    if (unlikely(PyMethod_Check(__pyx_t_5))) {
-      __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_5);
-      if (likely(__pyx_t_12)) {
-        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
-        __Pyx_INCREF(__pyx_t_12);
-        __Pyx_INCREF(function);
-        __Pyx_DECREF_SET(__pyx_t_5, function);
-        __pyx_t_7 = 1;
+
+/* Python wrapper */
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_15PredictQuantile_3forest_predict(CYTHON_UNUSED PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyMethodDef __pyx_mdef_5adaXT_7predict_7predict_15PredictQuantile_3forest_predict = {"forest_predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_15PredictQuantile_3forest_predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_7predict_7predict_15PredictQuantile_3forest_predict(CYTHON_UNUSED PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  PyObject *__pyx_v_predictions = 0;
+  PyObject *__pyx_v_kwargs = 0;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[1] = {0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("forest_predict (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
+  __Pyx_GOTREF(__pyx_v_kwargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_predictions,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
       }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_predictions)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 256, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, __pyx_v_kwargs, values + 0, kwd_pos_args, "forest_predict") < 0)) __PYX_ERR(0, 256, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 1)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
     }
-    #endif
-    {
-      PyObject *__pyx_callargs[3] = {__pyx_t_12, __pyx_v_indices, __pyx_v_indices};
-      __pyx_t_11 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_7, 2+__pyx_t_7);
-      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
-      if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 243, __pyx_L1_error)
-      __Pyx_GOTREF(__pyx_t_11);
-      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_v_predictions = values[0];
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("forest_predict", 1, 1, 1, __pyx_nargs); __PYX_ERR(0, 256, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
-    if (unlikely((PyObject_SetItem(__pyx_v_matrix, __pyx_t_11, __pyx_v_val) < 0))) __PYX_ERR(0, 243, __pyx_L1_error)
-    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   }
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictQuantile.forest_predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_r = __pyx_pf_5adaXT_7predict_7predict_15PredictQuantile_2forest_predict(__pyx_v_predictions, __pyx_v_kwargs);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":245
- *             matrix[np.ix_(indices, indices)] = val
- * 
- *         return matrix             # <<<<<<<<<<<<<<
+  /* function exit code */
+  __Pyx_DECREF(__pyx_v_kwargs);
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_5adaXT_7predict_7predict_15PredictQuantile_2forest_predict(PyObject *__pyx_v_predictions, PyObject *__pyx_v_kwargs) {
+  double __pyx_v_quantile;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  double __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("forest_predict", 1);
+
+  /* "adaXT/predict/predict.pyx":258
+ *     @staticmethod
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         quantile = <double> kwargs['quantile']             # <<<<<<<<<<<<<<
+ *         return np.quantile(predictions, quantile, axis=1)
+ */
+  __pyx_t_1 = __Pyx_PyDict_GetItem(__pyx_v_kwargs, __pyx_n_u_quantile); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 258, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely((__pyx_t_2 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 258, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_quantile = ((double)__pyx_t_2);
+
+  /* "adaXT/predict/predict.pyx":259
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         quantile = <double> kwargs['quantile']
+ *         return np.quantile(predictions, quantile, axis=1)             # <<<<<<<<<<<<<<
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_INCREF(__pyx_v_matrix);
-  __pyx_r = __pyx_v_matrix;
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 259, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_quantile); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 259, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_quantile); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 259, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 259, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_INCREF(__pyx_v_predictions);
+  __Pyx_GIVEREF(__pyx_v_predictions);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_predictions)) __PYX_ERR(0, 259, __pyx_L1_error);
+  __Pyx_GIVEREF(__pyx_t_1);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1)) __PYX_ERR(0, 259, __pyx_L1_error);
+  __pyx_t_1 = 0;
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 259, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_axis, __pyx_int_1) < 0) __PYX_ERR(0, 259, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 259, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_r = __pyx_t_5;
+  __pyx_t_5 = 0;
   goto __pyx_L0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":206
- *         return matrix
+  /* "adaXT/predict/predict.pyx":256
+ *         return Y
  * 
- *     def predict_leaf_matrix(self, X: np.ndarray, scale: bool = False):             # <<<<<<<<<<<<<<
- *         cdef:
- *             int i
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         quantile = <double> kwargs['quantile']
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
-  __Pyx_XDECREF(__pyx_t_11);
-  __Pyx_XDECREF(__pyx_t_12);
-  __Pyx_AddTraceback("adaXT.decision_tree.DecisionTree.DecisionTree.predict_leaf_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.predict.predict.PredictQuantile.forest_predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
-  __Pyx_XDECREF(__pyx_v_ht);
-  __Pyx_XDECREF(__pyx_v_cur_node);
-  __Pyx_XDECREF(__pyx_v_matrix);
-  __Pyx_XDECREF(__pyx_v_key);
-  __Pyx_XDECREF(__pyx_v_indices);
-  __Pyx_XDECREF(__pyx_v_val);
-  __Pyx_XDECREF(__pyx_v_count);
-  __Pyx_XDECREF(__pyx_v_X);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict __pyx_vtable_5adaXT_7predict_7predict_Predict;
+
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_Predict(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_5adaXT_7predict_7predict_Predict *p;
+  PyObject *o;
+  #if CYTHON_COMPILING_IN_LIMITED_API
+  allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
+  o = alloc_func(t, 0);
+  #else
+  if (likely(!__Pyx_PyType_HasFeature(t, Py_TPFLAGS_IS_ABSTRACT))) {
+    o = (*t->tp_alloc)(t, 0);
+  } else {
+    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
+  }
+  if (unlikely(!o)) return 0;
+  #endif
+  p = ((struct __pyx_obj_5adaXT_7predict_7predict_Predict *)o);
+  p->__pyx_vtab = __pyx_vtabptr_5adaXT_7predict_7predict_Predict;
+  p->root = Py_None; Py_INCREF(Py_None);
+  p->X.data = NULL;
+  p->X.memview = NULL;
+  p->Y.data = NULL;
+  p->Y.memview = NULL;
+  if (unlikely(__pyx_pw_5adaXT_7predict_7predict_7Predict_1__cinit__(o, a, k) < 0)) goto bad;
+  return o;
+  bad:
+  Py_DECREF(o); o = 0;
+  return NULL;
+}
+
+static void __pyx_tp_dealloc_5adaXT_7predict_7predict_Predict(PyObject *o) {
+  struct __pyx_obj_5adaXT_7predict_7predict_Predict *p = (struct __pyx_obj_5adaXT_7predict_7predict_Predict *)o;
+  #if CYTHON_USE_TP_FINALIZE
+  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && !__Pyx_PyObject_GC_IsFinalized(o)) {
+    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_5adaXT_7predict_7predict_Predict) {
+      if (PyObject_CallFinalizerFromDealloc(o)) return;
+    }
+  }
+  #endif
+  PyObject_GC_UnTrack(o);
+  Py_CLEAR(p->root);
+  __PYX_XCLEAR_MEMVIEW(&p->X, 1);
+  p->X.memview = NULL; p->X.data = NULL;
+  __PYX_XCLEAR_MEMVIEW(&p->Y, 1);
+  p->Y.memview = NULL; p->Y.data = NULL;
+  #if CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY
+  (*Py_TYPE(o)->tp_free)(o);
+  #else
+  {
+    freefunc tp_free = (freefunc)PyType_GetSlot(Py_TYPE(o), Py_tp_free);
+    if (tp_free) tp_free(o);
+  }
+  #endif
+}
+
+static int __pyx_tp_traverse_5adaXT_7predict_7predict_Predict(PyObject *o, visitproc v, void *a) {
+  int e;
+  struct __pyx_obj_5adaXT_7predict_7predict_Predict *p = (struct __pyx_obj_5adaXT_7predict_7predict_Predict *)o;
+  if (p->root) {
+    e = (*v)(p->root, a); if (e) return e;
+  }
+  return 0;
+}
+
+static int __pyx_tp_clear_5adaXT_7predict_7predict_Predict(PyObject *o) {
+  PyObject* tmp;
+  struct __pyx_obj_5adaXT_7predict_7predict_Predict *p = (struct __pyx_obj_5adaXT_7predict_7predict_Predict *)o;
+  tmp = ((PyObject*)p->root);
+  p->root = Py_None; Py_INCREF(Py_None);
+  Py_XDECREF(tmp);
+  return 0;
+}
+
+static PyMethodDef __pyx_methods_5adaXT_7predict_7predict_Predict[] = {
+  {"__reduce__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_3__reduce__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_5predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"forest_predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_11forest_predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"forest_predict_proba", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_7Predict_13forest_predict_proba, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {0, 0, 0, 0}
+};
+#if CYTHON_USE_TYPE_SPECS
+static PyType_Slot __pyx_type_5adaXT_7predict_7predict_Predict_slots[] = {
+  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_5adaXT_7predict_7predict_Predict},
+  {Py_tp_traverse, (void *)__pyx_tp_traverse_5adaXT_7predict_7predict_Predict},
+  {Py_tp_clear, (void *)__pyx_tp_clear_5adaXT_7predict_7predict_Predict},
+  {Py_tp_methods, (void *)__pyx_methods_5adaXT_7predict_7predict_Predict},
+  {Py_tp_new, (void *)__pyx_tp_new_5adaXT_7predict_7predict_Predict},
+  {0, 0},
+};
+static PyType_Spec __pyx_type_5adaXT_7predict_7predict_Predict_spec = {
+  "adaXT.predict.predict.Predict",
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_Predict),
+  0,
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
+  __pyx_type_5adaXT_7predict_7predict_Predict_slots,
+};
+#else
+
+static PyTypeObject __pyx_type_5adaXT_7predict_7predict_Predict = {
+  PyVarObject_HEAD_INIT(0, 0)
+  "adaXT.predict.predict.""Predict", /*tp_name*/
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_Predict), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_5adaXT_7predict_7predict_Predict, /*tp_dealloc*/
+  #if PY_VERSION_HEX < 0x030800b4
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4
+  0, /*tp_vectorcall_offset*/
+  #endif
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #endif
+  #if PY_MAJOR_VERSION >= 3
+  0, /*tp_as_async*/
+  #endif
+  0, /*tp_repr*/
+  0, /*tp_as_number*/
+  0, /*tp_as_sequence*/
+  0, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  0, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  0, /*tp_doc*/
+  __pyx_tp_traverse_5adaXT_7predict_7predict_Predict, /*tp_traverse*/
+  __pyx_tp_clear_5adaXT_7predict_7predict_Predict, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_5adaXT_7predict_7predict_Predict, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  #if !CYTHON_USE_TYPE_SPECS
+  0, /*tp_dictoffset*/
+  #endif
+  0, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_5adaXT_7predict_7predict_Predict, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  0, /*tp_version_tag*/
+  #if PY_VERSION_HEX >= 0x030400a1
+  #if CYTHON_USE_TP_FINALIZE
+  0, /*tp_finalize*/
+  #else
+  NULL, /*tp_finalize*/
+  #endif
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  0, /*tp_vectorcall*/
+  #endif
+  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030C0000
+  0, /*tp_watched*/
+  #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+  0, /*tp_pypy_flags*/
+  #endif
+};
+#endif
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictClassification __pyx_vtable_5adaXT_7predict_7predict_PredictClassification;
+
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_PredictClassification(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *p;
+  PyObject *o = __pyx_tp_new_5adaXT_7predict_7predict_Predict(t, a, k);
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *)o);
+  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict*)__pyx_vtabptr_5adaXT_7predict_7predict_PredictClassification;
+  p->classes.data = NULL;
+  p->classes.memview = NULL;
+  if (unlikely(__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_1__cinit__(o, a, k) < 0)) goto bad;
+  return o;
+  bad:
+  Py_DECREF(o); o = 0;
+  return NULL;
+}
+
+static void __pyx_tp_dealloc_5adaXT_7predict_7predict_PredictClassification(PyObject *o) {
+  struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *p = (struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *)o;
+  #if CYTHON_USE_TP_FINALIZE
+  if (unlikely((PY_VERSION_HEX >= 0x03080000 || __Pyx_PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE)) && __Pyx_PyObject_GetSlot(o, tp_finalize, destructor)) && !__Pyx_PyObject_GC_IsFinalized(o)) {
+    if (__Pyx_PyObject_GetSlot(o, tp_dealloc, destructor) == __pyx_tp_dealloc_5adaXT_7predict_7predict_PredictClassification) {
+      if (PyObject_CallFinalizerFromDealloc(o)) return;
+    }
+  }
+  #endif
+  PyObject_GC_UnTrack(o);
+  __PYX_XCLEAR_MEMVIEW(&p->classes, 1);
+  p->classes.memview = NULL; p->classes.data = NULL;
+  PyObject_GC_Track(o);
+  __pyx_tp_dealloc_5adaXT_7predict_7predict_Predict(o);
+}
+
+static PyMethodDef __pyx_methods_5adaXT_7predict_7predict_PredictClassification[] = {
+  {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_3predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"forest_predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_7forest_predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"forest_predict_proba", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_21PredictClassification_9forest_predict_proba, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {0, 0, 0, 0}
+};
+#if CYTHON_USE_TYPE_SPECS
+static PyType_Slot __pyx_type_5adaXT_7predict_7predict_PredictClassification_slots[] = {
+  {Py_tp_dealloc, (void *)__pyx_tp_dealloc_5adaXT_7predict_7predict_PredictClassification},
+  {Py_tp_traverse, (void *)__pyx_tp_traverse_5adaXT_7predict_7predict_Predict},
+  {Py_tp_clear, (void *)__pyx_tp_clear_5adaXT_7predict_7predict_Predict},
+  {Py_tp_methods, (void *)__pyx_methods_5adaXT_7predict_7predict_PredictClassification},
+  {Py_tp_new, (void *)__pyx_tp_new_5adaXT_7predict_7predict_PredictClassification},
+  {0, 0},
+};
+static PyType_Spec __pyx_type_5adaXT_7predict_7predict_PredictClassification_spec = {
+  "adaXT.predict.predict.PredictClassification",
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification),
+  0,
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
+  __pyx_type_5adaXT_7predict_7predict_PredictClassification_slots,
+};
+#else
+
+static PyTypeObject __pyx_type_5adaXT_7predict_7predict_PredictClassification = {
+  PyVarObject_HEAD_INIT(0, 0)
+  "adaXT.predict.predict.""PredictClassification", /*tp_name*/
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_5adaXT_7predict_7predict_PredictClassification, /*tp_dealloc*/
+  #if PY_VERSION_HEX < 0x030800b4
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4
+  0, /*tp_vectorcall_offset*/
+  #endif
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #endif
+  #if PY_MAJOR_VERSION >= 3
+  0, /*tp_as_async*/
+  #endif
+  0, /*tp_repr*/
+  0, /*tp_as_number*/
+  0, /*tp_as_sequence*/
+  0, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  0, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  0, /*tp_doc*/
+  __pyx_tp_traverse_5adaXT_7predict_7predict_Predict, /*tp_traverse*/
+  __pyx_tp_clear_5adaXT_7predict_7predict_Predict, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_5adaXT_7predict_7predict_PredictClassification, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  #if !CYTHON_USE_TYPE_SPECS
+  0, /*tp_dictoffset*/
+  #endif
+  0, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_5adaXT_7predict_7predict_PredictClassification, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  0, /*tp_version_tag*/
+  #if PY_VERSION_HEX >= 0x030400a1
+  #if CYTHON_USE_TP_FINALIZE
+  0, /*tp_finalize*/
+  #else
+  NULL, /*tp_finalize*/
+  #endif
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  0, /*tp_vectorcall*/
+  #endif
+  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030C0000
+  0, /*tp_watched*/
+  #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+  0, /*tp_pypy_flags*/
+  #endif
+};
+#endif
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictRegression __pyx_vtable_5adaXT_7predict_7predict_PredictRegression;
+
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_PredictRegression(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression *p;
+  PyObject *o = __pyx_tp_new_5adaXT_7predict_7predict_Predict(t, a, k);
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression *)o);
+  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict*)__pyx_vtabptr_5adaXT_7predict_7predict_PredictRegression;
+  return o;
+}
+
+static PyMethodDef __pyx_methods_5adaXT_7predict_7predict_PredictRegression[] = {
+  {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_17PredictRegression_1predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"forest_predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_17PredictRegression_3forest_predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {0, 0, 0, 0}
+};
+#if CYTHON_USE_TYPE_SPECS
+static PyType_Slot __pyx_type_5adaXT_7predict_7predict_PredictRegression_slots[] = {
+  {Py_tp_traverse, (void *)__pyx_tp_traverse_5adaXT_7predict_7predict_Predict},
+  {Py_tp_clear, (void *)__pyx_tp_clear_5adaXT_7predict_7predict_Predict},
+  {Py_tp_methods, (void *)__pyx_methods_5adaXT_7predict_7predict_PredictRegression},
+  {Py_tp_new, (void *)__pyx_tp_new_5adaXT_7predict_7predict_PredictRegression},
+  {0, 0},
+};
+static PyType_Spec __pyx_type_5adaXT_7predict_7predict_PredictRegression_spec = {
+  "adaXT.predict.predict.PredictRegression",
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression),
+  0,
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
+  __pyx_type_5adaXT_7predict_7predict_PredictRegression_slots,
+};
+#else
+
+static PyTypeObject __pyx_type_5adaXT_7predict_7predict_PredictRegression = {
+  PyVarObject_HEAD_INIT(0, 0)
+  "adaXT.predict.predict.""PredictRegression", /*tp_name*/
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_PredictRegression), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_5adaXT_7predict_7predict_Predict, /*tp_dealloc*/
+  #if PY_VERSION_HEX < 0x030800b4
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4
+  0, /*tp_vectorcall_offset*/
+  #endif
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #endif
+  #if PY_MAJOR_VERSION >= 3
+  0, /*tp_as_async*/
+  #endif
+  0, /*tp_repr*/
+  0, /*tp_as_number*/
+  0, /*tp_as_sequence*/
+  0, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  0, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  0, /*tp_doc*/
+  __pyx_tp_traverse_5adaXT_7predict_7predict_Predict, /*tp_traverse*/
+  __pyx_tp_clear_5adaXT_7predict_7predict_Predict, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_5adaXT_7predict_7predict_PredictRegression, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  #if !CYTHON_USE_TYPE_SPECS
+  0, /*tp_dictoffset*/
+  #endif
+  0, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_5adaXT_7predict_7predict_PredictRegression, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  0, /*tp_version_tag*/
+  #if PY_VERSION_HEX >= 0x030400a1
+  #if CYTHON_USE_TP_FINALIZE
+  0, /*tp_finalize*/
+  #else
+  NULL, /*tp_finalize*/
+  #endif
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  0, /*tp_vectorcall*/
+  #endif
+  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030C0000
+  0, /*tp_watched*/
+  #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+  0, /*tp_pypy_flags*/
+  #endif
+};
+#endif
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictLinearRegression __pyx_vtable_5adaXT_7predict_7predict_PredictLinearRegression;
+
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_PredictLinearRegression(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_5adaXT_7predict_7predict_PredictLinearRegression *p;
+  PyObject *o = __pyx_tp_new_5adaXT_7predict_7predict_PredictRegression(t, a, k);
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_5adaXT_7predict_7predict_PredictLinearRegression *)o);
+  p->__pyx_base.__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict*)__pyx_vtabptr_5adaXT_7predict_7predict_PredictLinearRegression;
+  return o;
+}
+
+static PyMethodDef __pyx_methods_5adaXT_7predict_7predict_PredictLinearRegression[] = {
+  {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_23PredictLinearRegression_1predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {0, 0, 0, 0}
+};
+#if CYTHON_USE_TYPE_SPECS
+static PyType_Slot __pyx_type_5adaXT_7predict_7predict_PredictLinearRegression_slots[] = {
+  {Py_tp_traverse, (void *)__pyx_tp_traverse_5adaXT_7predict_7predict_Predict},
+  {Py_tp_clear, (void *)__pyx_tp_clear_5adaXT_7predict_7predict_Predict},
+  {Py_tp_methods, (void *)__pyx_methods_5adaXT_7predict_7predict_PredictLinearRegression},
+  {Py_tp_new, (void *)__pyx_tp_new_5adaXT_7predict_7predict_PredictLinearRegression},
+  {0, 0},
+};
+static PyType_Spec __pyx_type_5adaXT_7predict_7predict_PredictLinearRegression_spec = {
+  "adaXT.predict.predict.PredictLinearRegression",
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_PredictLinearRegression),
+  0,
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
+  __pyx_type_5adaXT_7predict_7predict_PredictLinearRegression_slots,
+};
+#else
+
+static PyTypeObject __pyx_type_5adaXT_7predict_7predict_PredictLinearRegression = {
+  PyVarObject_HEAD_INIT(0, 0)
+  "adaXT.predict.predict.""PredictLinearRegression", /*tp_name*/
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_PredictLinearRegression), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_5adaXT_7predict_7predict_Predict, /*tp_dealloc*/
+  #if PY_VERSION_HEX < 0x030800b4
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4
+  0, /*tp_vectorcall_offset*/
+  #endif
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #endif
+  #if PY_MAJOR_VERSION >= 3
+  0, /*tp_as_async*/
+  #endif
+  0, /*tp_repr*/
+  0, /*tp_as_number*/
+  0, /*tp_as_sequence*/
+  0, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  0, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  0, /*tp_doc*/
+  __pyx_tp_traverse_5adaXT_7predict_7predict_Predict, /*tp_traverse*/
+  __pyx_tp_clear_5adaXT_7predict_7predict_Predict, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_5adaXT_7predict_7predict_PredictLinearRegression, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  #if !CYTHON_USE_TYPE_SPECS
+  0, /*tp_dictoffset*/
+  #endif
+  0, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_5adaXT_7predict_7predict_PredictLinearRegression, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  0, /*tp_version_tag*/
+  #if PY_VERSION_HEX >= 0x030400a1
+  #if CYTHON_USE_TP_FINALIZE
+  0, /*tp_finalize*/
+  #else
+  NULL, /*tp_finalize*/
+  #endif
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  0, /*tp_vectorcall*/
+  #endif
+  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030C0000
+  0, /*tp_watched*/
+  #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+  0, /*tp_pypy_flags*/
+  #endif
+};
+#endif
+static struct __pyx_vtabstruct_5adaXT_7predict_7predict_PredictQuantile __pyx_vtable_5adaXT_7predict_7predict_PredictQuantile;
+
+static PyObject *__pyx_tp_new_5adaXT_7predict_7predict_PredictQuantile(PyTypeObject *t, PyObject *a, PyObject *k) {
+  struct __pyx_obj_5adaXT_7predict_7predict_PredictQuantile *p;
+  PyObject *o = __pyx_tp_new_5adaXT_7predict_7predict_Predict(t, a, k);
+  if (unlikely(!o)) return 0;
+  p = ((struct __pyx_obj_5adaXT_7predict_7predict_PredictQuantile *)o);
+  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5adaXT_7predict_7predict_Predict*)__pyx_vtabptr_5adaXT_7predict_7predict_PredictQuantile;
+  return o;
+}
+
+static PyMethodDef __pyx_methods_5adaXT_7predict_7predict_PredictQuantile[] = {
+  {"predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_15PredictQuantile_1predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {"forest_predict", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_7predict_7predict_15PredictQuantile_3forest_predict, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
+  {0, 0, 0, 0}
+};
+#if CYTHON_USE_TYPE_SPECS
+static PyType_Slot __pyx_type_5adaXT_7predict_7predict_PredictQuantile_slots[] = {
+  {Py_tp_traverse, (void *)__pyx_tp_traverse_5adaXT_7predict_7predict_Predict},
+  {Py_tp_clear, (void *)__pyx_tp_clear_5adaXT_7predict_7predict_Predict},
+  {Py_tp_methods, (void *)__pyx_methods_5adaXT_7predict_7predict_PredictQuantile},
+  {Py_tp_new, (void *)__pyx_tp_new_5adaXT_7predict_7predict_PredictQuantile},
+  {0, 0},
+};
+static PyType_Spec __pyx_type_5adaXT_7predict_7predict_PredictQuantile_spec = {
+  "adaXT.predict.predict.PredictQuantile",
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_PredictQuantile),
+  0,
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
+  __pyx_type_5adaXT_7predict_7predict_PredictQuantile_slots,
+};
+#else
+
+static PyTypeObject __pyx_type_5adaXT_7predict_7predict_PredictQuantile = {
+  PyVarObject_HEAD_INIT(0, 0)
+  "adaXT.predict.predict.""PredictQuantile", /*tp_name*/
+  sizeof(struct __pyx_obj_5adaXT_7predict_7predict_PredictQuantile), /*tp_basicsize*/
+  0, /*tp_itemsize*/
+  __pyx_tp_dealloc_5adaXT_7predict_7predict_Predict, /*tp_dealloc*/
+  #if PY_VERSION_HEX < 0x030800b4
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b4
+  0, /*tp_vectorcall_offset*/
+  #endif
+  0, /*tp_getattr*/
+  0, /*tp_setattr*/
+  #if PY_MAJOR_VERSION < 3
+  0, /*tp_compare*/
+  #endif
+  #if PY_MAJOR_VERSION >= 3
+  0, /*tp_as_async*/
+  #endif
+  0, /*tp_repr*/
+  0, /*tp_as_number*/
+  0, /*tp_as_sequence*/
+  0, /*tp_as_mapping*/
+  0, /*tp_hash*/
+  0, /*tp_call*/
+  0, /*tp_str*/
+  0, /*tp_getattro*/
+  0, /*tp_setattro*/
+  0, /*tp_as_buffer*/
+  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
+  0, /*tp_doc*/
+  __pyx_tp_traverse_5adaXT_7predict_7predict_Predict, /*tp_traverse*/
+  __pyx_tp_clear_5adaXT_7predict_7predict_Predict, /*tp_clear*/
+  0, /*tp_richcompare*/
+  0, /*tp_weaklistoffset*/
+  0, /*tp_iter*/
+  0, /*tp_iternext*/
+  __pyx_methods_5adaXT_7predict_7predict_PredictQuantile, /*tp_methods*/
+  0, /*tp_members*/
+  0, /*tp_getset*/
+  0, /*tp_base*/
+  0, /*tp_dict*/
+  0, /*tp_descr_get*/
+  0, /*tp_descr_set*/
+  #if !CYTHON_USE_TYPE_SPECS
+  0, /*tp_dictoffset*/
+  #endif
+  0, /*tp_init*/
+  0, /*tp_alloc*/
+  __pyx_tp_new_5adaXT_7predict_7predict_PredictQuantile, /*tp_new*/
+  0, /*tp_free*/
+  0, /*tp_is_gc*/
+  0, /*tp_bases*/
+  0, /*tp_mro*/
+  0, /*tp_cache*/
+  0, /*tp_subclasses*/
+  0, /*tp_weaklist*/
+  0, /*tp_del*/
+  0, /*tp_version_tag*/
+  #if PY_VERSION_HEX >= 0x030400a1
+  #if CYTHON_USE_TP_FINALIZE
+  0, /*tp_finalize*/
+  #else
+  NULL, /*tp_finalize*/
+  #endif
+  #endif
+  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+  0, /*tp_vectorcall*/
+  #endif
+  #if __PYX_NEED_TP_PRINT_SLOT == 1
+  0, /*tp_print*/
+  #endif
+  #if PY_VERSION_HEX >= 0x030C0000
+  0, /*tp_watched*/
+  #endif
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+  0, /*tp_pypy_flags*/
+  #endif
+};
+#endif
 static struct __pyx_vtabstruct_array __pyx_vtable_array;
 
 static PyObject *__pyx_tp_new_array(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_array_obj *p;
   PyObject *o;
   #if CYTHON_COMPILING_IN_LIMITED_API
   allocfunc alloc_func = (allocfunc)PyType_GetSlot(t, Py_tp_alloc);
@@ -23346,15 +24649,15 @@
   #endif
   {Py_tp_methods, (void *)__pyx_methods_array},
   {Py_tp_getset, (void *)__pyx_getsets_array},
   {Py_tp_new, (void *)__pyx_tp_new_array},
   {0, 0},
 };
 static PyType_Spec __pyx_type___pyx_array_spec = {
-  "adaXT.decision_tree.DecisionTree.array",
+  "adaXT.predict.predict.array",
   sizeof(struct __pyx_array_obj),
   0,
   Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_SEQUENCE,
   __pyx_type___pyx_array_slots,
 };
 #else
 
@@ -23392,15 +24695,15 @@
   #endif
   __pyx_array_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_array = {
   PyVarObject_HEAD_INIT(0, 0)
-  "adaXT.decision_tree.DecisionTree.""array", /*tp_name*/
+  "adaXT.predict.predict.""array", /*tp_name*/
   sizeof(struct __pyx_array_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_array, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -23552,25 +24855,25 @@
   {Py_tp_clear, (void *)__pyx_tp_clear_Enum},
   {Py_tp_methods, (void *)__pyx_methods_Enum},
   {Py_tp_init, (void *)__pyx_MemviewEnum___init__},
   {Py_tp_new, (void *)__pyx_tp_new_Enum},
   {0, 0},
 };
 static PyType_Spec __pyx_type___pyx_MemviewEnum_spec = {
-  "adaXT.decision_tree.DecisionTree.Enum",
+  "adaXT.predict.predict.Enum",
   sizeof(struct __pyx_MemviewEnum_obj),
   0,
   Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
   __pyx_type___pyx_MemviewEnum_slots,
 };
 #else
 
 static PyTypeObject __pyx_type___pyx_MemviewEnum = {
   PyVarObject_HEAD_INIT(0, 0)
-  "adaXT.decision_tree.DecisionTree.""Enum", /*tp_name*/
+  "adaXT.predict.predict.""Enum", /*tp_name*/
   sizeof(struct __pyx_MemviewEnum_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_Enum, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -23859,15 +25162,15 @@
   {Py_tp_clear, (void *)__pyx_tp_clear_memoryview},
   {Py_tp_methods, (void *)__pyx_methods_memoryview},
   {Py_tp_getset, (void *)__pyx_getsets_memoryview},
   {Py_tp_new, (void *)__pyx_tp_new_memoryview},
   {0, 0},
 };
 static PyType_Spec __pyx_type___pyx_memoryview_spec = {
-  "adaXT.decision_tree.DecisionTree.memoryview",
+  "adaXT.predict.predict.memoryview",
   sizeof(struct __pyx_memoryview_obj),
   0,
   Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC,
   __pyx_type___pyx_memoryview_slots,
 };
 #else
 
@@ -23905,15 +25208,15 @@
   #endif
   __pyx_memoryview_getbuffer, /*bf_getbuffer*/
   0, /*bf_releasebuffer*/
 };
 
 static PyTypeObject __pyx_type___pyx_memoryview = {
   PyVarObject_HEAD_INIT(0, 0)
-  "adaXT.decision_tree.DecisionTree.""memoryview", /*tp_name*/
+  "adaXT.predict.predict.""memoryview", /*tp_name*/
   sizeof(struct __pyx_memoryview_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc_memoryview, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -24059,25 +25362,25 @@
   {Py_tp_traverse, (void *)__pyx_tp_traverse__memoryviewslice},
   {Py_tp_clear, (void *)__pyx_tp_clear__memoryviewslice},
   {Py_tp_methods, (void *)__pyx_methods__memoryviewslice},
   {Py_tp_new, (void *)__pyx_tp_new__memoryviewslice},
   {0, 0},
 };
 static PyType_Spec __pyx_type___pyx_memoryviewslice_spec = {
-  "adaXT.decision_tree.DecisionTree._memoryviewslice",
+  "adaXT.predict.predict._memoryviewslice",
   sizeof(struct __pyx_memoryviewslice_obj),
   0,
   Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_SEQUENCE,
   __pyx_type___pyx_memoryviewslice_slots,
 };
 #else
 
 static PyTypeObject __pyx_type___pyx_memoryviewslice = {
   PyVarObject_HEAD_INIT(0, 0)
-  "adaXT.decision_tree.DecisionTree.""_memoryviewslice", /*tp_name*/
+  "adaXT.predict.predict.""_memoryviewslice", /*tp_name*/
   sizeof(struct __pyx_memoryviewslice_obj), /*tp_basicsize*/
   0, /*tp_itemsize*/
   __pyx_tp_dealloc__memoryviewslice, /*tp_dealloc*/
   #if PY_VERSION_HEX < 0x030800b4
   0, /*tp_print*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4
@@ -24177,276 +25480,230 @@
 
 static int __Pyx_CreateStringTabAndInitStrings(void) {
   __Pyx_StringTabEntry __pyx_string_tab[] = {
     {&__pyx_kp_u_, __pyx_k_, sizeof(__pyx_k_), 0, 1, 0, 0},
     {&__pyx_n_s_ASCII, __pyx_k_ASCII, sizeof(__pyx_k_ASCII), 0, 0, 1, 1},
     {&__pyx_kp_s_All_dimensions_preceding_dimensi, __pyx_k_All_dimensions_preceding_dimensi, sizeof(__pyx_k_All_dimensions_preceding_dimensi), 0, 0, 1, 0},
     {&__pyx_n_s_AssertionError, __pyx_k_AssertionError, sizeof(__pyx_k_AssertionError), 0, 0, 1, 1},
-    {&__pyx_n_s_AttributeError, __pyx_k_AttributeError, sizeof(__pyx_k_AttributeError), 0, 0, 1, 1},
     {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
     {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
     {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
     {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
     {&__pyx_kp_u_Cannot_index_with_type, __pyx_k_Cannot_index_with_type, sizeof(__pyx_k_Cannot_index_with_type), 0, 1, 0, 0},
     {&__pyx_kp_s_Cannot_transpose_memoryview_with, __pyx_k_Cannot_transpose_memoryview_with, sizeof(__pyx_k_Cannot_transpose_memoryview_with), 0, 0, 1, 0},
-    {&__pyx_n_s_Classification, __pyx_k_Classification, sizeof(__pyx_k_Classification), 0, 0, 1, 1},
-    {&__pyx_n_s_Criteria, __pyx_k_Criteria, sizeof(__pyx_k_Criteria), 0, 0, 1, 1},
     {&__pyx_n_s_DOUBLE, __pyx_k_DOUBLE, sizeof(__pyx_k_DOUBLE), 0, 0, 1, 1},
     {&__pyx_n_s_DecisionNode, __pyx_k_DecisionNode, sizeof(__pyx_k_DecisionNode), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree, __pyx_k_DecisionTree, sizeof(__pyx_k_DecisionTree), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree___check_dimensions, __pyx_k_DecisionTree___check_dimensions, sizeof(__pyx_k_DecisionTree___check_dimensions), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree___check_input, __pyx_k_DecisionTree___check_input, sizeof(__pyx_k_DecisionTree___check_input), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree___check_sample_weig, __pyx_k_DecisionTree___check_sample_weig, sizeof(__pyx_k_DecisionTree___check_sample_weig), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree___find_max_index, __pyx_k_DecisionTree___find_max_index, sizeof(__pyx_k_DecisionTree___find_max_index), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree___init, __pyx_k_DecisionTree___init, sizeof(__pyx_k_DecisionTree___init), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree__check_dimensions, __pyx_k_DecisionTree__check_dimensions, sizeof(__pyx_k_DecisionTree__check_dimensions), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree__check_input, __pyx_k_DecisionTree__check_input, sizeof(__pyx_k_DecisionTree__check_input), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree__check_sample_weig, __pyx_k_DecisionTree__check_sample_weig, sizeof(__pyx_k_DecisionTree__check_sample_weig), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree__find_max_index, __pyx_k_DecisionTree__find_max_index, sizeof(__pyx_k_DecisionTree__find_max_index), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree_fit, __pyx_k_DecisionTree_fit, sizeof(__pyx_k_DecisionTree_fit), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree_get_leaf_matrix, __pyx_k_DecisionTree_get_leaf_matrix, sizeof(__pyx_k_DecisionTree_get_leaf_matrix), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree_predict, __pyx_k_DecisionTree_predict, sizeof(__pyx_k_DecisionTree_predict), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree_predict_leaf_matrix, __pyx_k_DecisionTree_predict_leaf_matrix, sizeof(__pyx_k_DecisionTree_predict_leaf_matrix), 0, 0, 1, 1},
-    {&__pyx_n_s_DecisionTree_predict_proba, __pyx_k_DecisionTree_predict_proba, sizeof(__pyx_k_DecisionTree_predict_proba), 0, 0, 1, 1},
-    {&__pyx_n_s_DepthTreeBuilder, __pyx_k_DepthTreeBuilder, sizeof(__pyx_k_DepthTreeBuilder), 0, 0, 1, 1},
     {&__pyx_kp_s_Dimension_d_is_not_direct, __pyx_k_Dimension_d_is_not_direct, sizeof(__pyx_k_Dimension_d_is_not_direct), 0, 0, 1, 0},
     {&__pyx_kp_u_Dimension_should_be, __pyx_k_Dimension_should_be, sizeof(__pyx_k_Dimension_should_be), 0, 1, 0, 0},
     {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
     {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
-    {&__pyx_kp_u_Expected_Classification_or_Regre, __pyx_k_Expected_Classification_or_Regre, sizeof(__pyx_k_Expected_Classification_or_Regre), 0, 1, 0, 0},
+    {&__pyx_kp_u_Function_predict_is_not_implemen, __pyx_k_Function_predict_is_not_implemen, sizeof(__pyx_k_Function_predict_is_not_implemen), 0, 1, 0, 0},
+    {&__pyx_kp_u_Function_predict_proba_is_not_im, __pyx_k_Function_predict_proba_is_not_im, sizeof(__pyx_k_Function_predict_proba_is_not_im), 0, 1, 0, 0},
     {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
     {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
     {&__pyx_kp_s_Index_out_of_bounds_axis_d, __pyx_k_Index_out_of_bounds_axis_d, sizeof(__pyx_k_Index_out_of_bounds_axis_d), 0, 0, 1, 0},
     {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
     {&__pyx_kp_u_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 1, 0, 0},
     {&__pyx_kp_u_Invalid_shape_in_axis, __pyx_k_Invalid_shape_in_axis, sizeof(__pyx_k_Invalid_shape_in_axis), 0, 1, 0, 0},
     {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
     {&__pyx_kp_s_MemoryView_of_r_at_0x_x, __pyx_k_MemoryView_of_r_at_0x_x, sizeof(__pyx_k_MemoryView_of_r_at_0x_x), 0, 0, 1, 0},
     {&__pyx_kp_s_MemoryView_of_r_object, __pyx_k_MemoryView_of_r_object, sizeof(__pyx_k_MemoryView_of_r_object), 0, 0, 1, 0},
-    {&__pyx_n_s_Nodes, __pyx_k_Nodes, sizeof(__pyx_k_Nodes), 0, 0, 1, 1},
-    {&__pyx_n_s_None, __pyx_k_None, sizeof(__pyx_k_None), 0, 0, 1, 1},
+    {&__pyx_n_s_NotImplementedError, __pyx_k_NotImplementedError, sizeof(__pyx_k_NotImplementedError), 0, 0, 1, 1},
     {&__pyx_kp_u_Number_of_features_should_be, __pyx_k_Number_of_features_should_be, sizeof(__pyx_k_Number_of_features_should_be), 0, 1, 0, 0},
     {&__pyx_n_b_O, __pyx_k_O, sizeof(__pyx_k_O), 0, 0, 0, 1},
     {&__pyx_kp_u_Out_of_bounds_on_buffer_access_a, __pyx_k_Out_of_bounds_on_buffer_access_a, sizeof(__pyx_k_Out_of_bounds_on_buffer_access_a), 0, 1, 0, 0},
     {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
-    {&__pyx_n_s_Regression, __pyx_k_Regression, sizeof(__pyx_k_Regression), 0, 0, 1, 1},
+    {&__pyx_n_s_Predict, __pyx_k_Predict, sizeof(__pyx_k_Predict), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictClassification, __pyx_k_PredictClassification, sizeof(__pyx_k_PredictClassification), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictClassification__most_fre, __pyx_k_PredictClassification__most_fre, sizeof(__pyx_k_PredictClassification__most_fre), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictClassification_forest_pre, __pyx_k_PredictClassification_forest_pre, sizeof(__pyx_k_PredictClassification_forest_pre), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictClassification_forest_pre_2, __pyx_k_PredictClassification_forest_pre_2, sizeof(__pyx_k_PredictClassification_forest_pre_2), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictClassification_predict, __pyx_k_PredictClassification_predict, sizeof(__pyx_k_PredictClassification_predict), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictClassification_predict_pr, __pyx_k_PredictClassification_predict_pr, sizeof(__pyx_k_PredictClassification_predict_pr), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictLinearRegression, __pyx_k_PredictLinearRegression, sizeof(__pyx_k_PredictLinearRegression), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictLinearRegression_predict, __pyx_k_PredictLinearRegression_predict, sizeof(__pyx_k_PredictLinearRegression_predict), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictQuantile, __pyx_k_PredictQuantile, sizeof(__pyx_k_PredictQuantile), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictQuantile_forest_predict, __pyx_k_PredictQuantile_forest_predict, sizeof(__pyx_k_PredictQuantile_forest_predict), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictQuantile_predict, __pyx_k_PredictQuantile_predict, sizeof(__pyx_k_PredictQuantile_predict), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictRegression, __pyx_k_PredictRegression, sizeof(__pyx_k_PredictRegression), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictRegression_forest_predict, __pyx_k_PredictRegression_forest_predict, sizeof(__pyx_k_PredictRegression_forest_predict), 0, 0, 1, 1},
+    {&__pyx_n_s_PredictRegression_predict, __pyx_k_PredictRegression_predict, sizeof(__pyx_k_PredictRegression_predict), 0, 0, 1, 1},
+    {&__pyx_n_s_Predict___reduce, __pyx_k_Predict___reduce, sizeof(__pyx_k_Predict___reduce), 0, 0, 1, 1},
+    {&__pyx_n_s_Predict_forest_predict, __pyx_k_Predict_forest_predict, sizeof(__pyx_k_Predict_forest_predict), 0, 0, 1, 1},
+    {&__pyx_n_s_Predict_forest_predict_proba, __pyx_k_Predict_forest_predict_proba, sizeof(__pyx_k_Predict_forest_predict_proba), 0, 0, 1, 1},
+    {&__pyx_n_s_Predict_predict, __pyx_k_Predict_predict, sizeof(__pyx_k_Predict_predict), 0, 0, 1, 1},
+    {&__pyx_n_s_Predict_predict_leaf_matrix, __pyx_k_Predict_predict_leaf_matrix, sizeof(__pyx_k_Predict_predict_leaf_matrix), 0, 0, 1, 1},
+    {&__pyx_n_s_Predict_predict_proba, __pyx_k_Predict_predict_proba, sizeof(__pyx_k_Predict_predict_proba), 0, 0, 1, 1},
     {&__pyx_n_s_Sequence, __pyx_k_Sequence, sizeof(__pyx_k_Sequence), 0, 0, 1, 1},
-    {&__pyx_n_s_Splitter, __pyx_k_Splitter, sizeof(__pyx_k_Splitter), 0, 0, 1, 1},
-    {&__pyx_kp_s_Splitter_None, __pyx_k_Splitter_None, sizeof(__pyx_k_Splitter_None), 0, 0, 1, 0},
     {&__pyx_kp_s_Step_may_not_be_zero_axis_d, __pyx_k_Step_may_not_be_zero_axis_d, sizeof(__pyx_k_Step_may_not_be_zero_axis_d), 0, 0, 1, 0},
-    {&__pyx_kp_s_The_tree_has_not_been_fitted_bef, __pyx_k_The_tree_has_not_been_fitted_bef, sizeof(__pyx_k_The_tree_has_not_been_fitted_bef), 0, 0, 1, 0},
-    {&__pyx_kp_s_The_tree_has_not_been_fitted_bef_2, __pyx_k_The_tree_has_not_been_fitted_bef_2, sizeof(__pyx_k_The_tree_has_not_been_fitted_bef_2), 0, 0, 1, 0},
-    {&__pyx_kp_s_The_tree_has_not_been_trained_be, __pyx_k_The_tree_has_not_been_trained_be, sizeof(__pyx_k_The_tree_has_not_been_trained_be), 0, 0, 1, 0},
+    {&__pyx_kp_u_The_forest_predict_function_is_n, __pyx_k_The_forest_predict_function_is_n, sizeof(__pyx_k_The_forest_predict_function_is_n), 0, 1, 0, 0},
     {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
     {&__pyx_kp_s_Unable_to_convert_item_to_object, __pyx_k_Unable_to_convert_item_to_object, sizeof(__pyx_k_Unable_to_convert_item_to_object), 0, 0, 1, 0},
     {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
     {&__pyx_n_s_View_MemoryView, __pyx_k_View_MemoryView, sizeof(__pyx_k_View_MemoryView), 0, 0, 1, 1},
     {&__pyx_n_s_X, __pyx_k_X, sizeof(__pyx_k_X), 0, 0, 1, 1},
-    {&__pyx_kp_s_X_and_Y_should_have_the_same_num, __pyx_k_X_and_Y_should_have_the_same_num, sizeof(__pyx_k_X_and_Y_should_have_the_same_num), 0, 0, 1, 0},
     {&__pyx_n_s_Y, __pyx_k_Y, sizeof(__pyx_k_Y), 0, 0, 1, 1},
-    {&__pyx_kp_s_Y_should_have_dimensions_n_1_or, __pyx_k_Y_should_have_dimensions_n_1_or, sizeof(__pyx_k_Y_should_have_dimensions_n_1_or), 0, 0, 1, 0},
     {&__pyx_kp_u__2, __pyx_k__2, sizeof(__pyx_k__2), 0, 1, 0, 0},
     {&__pyx_n_s__3, __pyx_k__3, sizeof(__pyx_k__3), 0, 0, 1, 1},
-    {&__pyx_n_s__51, __pyx_k__51, sizeof(__pyx_k__51), 0, 0, 1, 1},
+    {&__pyx_n_s__52, __pyx_k__52, sizeof(__pyx_k__52), 0, 0, 1, 1},
     {&__pyx_kp_u__6, __pyx_k__6, sizeof(__pyx_k__6), 0, 1, 0, 0},
     {&__pyx_kp_u__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 1, 0, 0},
     {&__pyx_n_s_abc, __pyx_k_abc, sizeof(__pyx_k_abc), 0, 0, 1, 1},
-    {&__pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_k_adaXT_decision_tree_DecisionTree, sizeof(__pyx_k_adaXT_decision_tree_DecisionTree), 0, 0, 1, 1},
+    {&__pyx_n_s_adaXT_predict_predict, __pyx_k_adaXT_predict_predict, sizeof(__pyx_k_adaXT_predict_predict), 0, 0, 1, 1},
     {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
     {&__pyx_kp_u_and, __pyx_k_and, sizeof(__pyx_k_and), 0, 1, 0, 0},
-    {&__pyx_n_s_arange, __pyx_k_arange, sizeof(__pyx_k_arange), 0, 0, 1, 1},
-    {&__pyx_n_s_array, __pyx_k_array, sizeof(__pyx_k_array), 0, 0, 1, 1},
-    {&__pyx_n_s_asarray, __pyx_k_asarray, sizeof(__pyx_k_asarray), 0, 0, 1, 1},
+    {&__pyx_n_s_apply_along_axis, __pyx_k_apply_along_axis, sizeof(__pyx_k_apply_along_axis), 0, 0, 1, 1},
+    {&__pyx_n_s_argmax, __pyx_k_argmax, sizeof(__pyx_k_argmax), 0, 0, 1, 1},
+    {&__pyx_n_s_arr, __pyx_k_arr, sizeof(__pyx_k_arr), 0, 0, 1, 1},
     {&__pyx_n_s_ascontiguousarray, __pyx_k_ascontiguousarray, sizeof(__pyx_k_ascontiguousarray), 0, 0, 1, 1},
     {&__pyx_n_s_asyncio_coroutines, __pyx_k_asyncio_coroutines, sizeof(__pyx_k_asyncio_coroutines), 0, 0, 1, 1},
     {&__pyx_n_s_axis, __pyx_k_axis, sizeof(__pyx_k_axis), 0, 0, 1, 1},
     {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
-    {&__pyx_n_s_bool, __pyx_k_bool, sizeof(__pyx_k_bool), 0, 0, 1, 1},
-    {&__pyx_n_s_build_tree, __pyx_k_build_tree, sizeof(__pyx_k_build_tree), 0, 0, 1, 1},
-    {&__pyx_n_s_builder, __pyx_k_builder, sizeof(__pyx_k_builder), 0, 0, 1, 1},
     {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
     {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
-    {&__pyx_n_s_check_dimensions, __pyx_k_check_dimensions, sizeof(__pyx_k_check_dimensions), 0, 0, 1, 1},
-    {&__pyx_n_s_check_input, __pyx_k_check_input, sizeof(__pyx_k_check_input), 0, 0, 1, 1},
-    {&__pyx_n_s_check_sample_weight, __pyx_k_check_sample_weight, sizeof(__pyx_k_check_sample_weight), 0, 0, 1, 1},
     {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
     {&__pyx_n_s_class_getitem, __pyx_k_class_getitem, sizeof(__pyx_k_class_getitem), 0, 0, 1, 1},
-    {&__pyx_n_s_classes, __pyx_k_classes, sizeof(__pyx_k_classes), 0, 0, 1, 1},
     {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
-    {&__pyx_n_s_col, __pyx_k_col, sizeof(__pyx_k_col), 0, 0, 1, 1},
     {&__pyx_n_s_collections, __pyx_k_collections, sizeof(__pyx_k_collections), 0, 0, 1, 1},
     {&__pyx_kp_s_collections_abc, __pyx_k_collections_abc, sizeof(__pyx_k_collections_abc), 0, 0, 1, 0},
     {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
     {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
     {&__pyx_n_s_count, __pyx_k_count, sizeof(__pyx_k_count), 0, 0, 1, 1},
-    {&__pyx_n_s_criteria, __pyx_k_criteria, sizeof(__pyx_k_criteria), 0, 0, 1, 1},
-    {&__pyx_n_s_cur_max, __pyx_k_cur_max, sizeof(__pyx_k_cur_max), 0, 0, 1, 1},
+    {&__pyx_n_s_counts, __pyx_k_counts, sizeof(__pyx_k_counts), 0, 0, 1, 1},
     {&__pyx_n_s_cur_node, __pyx_k_cur_node, sizeof(__pyx_k_cur_node), 0, 0, 1, 1},
     {&__pyx_n_s_cur_split_idx, __pyx_k_cur_split_idx, sizeof(__pyx_k_cur_split_idx), 0, 0, 1, 1},
     {&__pyx_n_s_cur_threshold, __pyx_k_cur_threshold, sizeof(__pyx_k_cur_threshold), 0, 0, 1, 1},
+    {&__pyx_n_s_decision_tree_nodes, __pyx_k_decision_tree_nodes, sizeof(__pyx_k_decision_tree_nodes), 0, 0, 1, 1},
     {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
     {&__pyx_kp_u_disable, __pyx_k_disable, sizeof(__pyx_k_disable), 0, 1, 0, 0},
-    {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
-    {&__pyx_n_s_double, __pyx_k_double, sizeof(__pyx_k_double), 0, 0, 1, 1},
     {&__pyx_n_s_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 0, 0, 1, 1},
     {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
     {&__pyx_n_s_empty, __pyx_k_empty, sizeof(__pyx_k_empty), 0, 0, 1, 1},
     {&__pyx_kp_u_enable, __pyx_k_enable, sizeof(__pyx_k_enable), 0, 1, 0, 0},
     {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
     {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
-    {&__pyx_n_s_eps, __pyx_k_eps, sizeof(__pyx_k_eps), 0, 0, 1, 1},
     {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
     {&__pyx_n_s_expand_dims, __pyx_k_expand_dims, sizeof(__pyx_k_expand_dims), 0, 0, 1, 1},
-    {&__pyx_n_s_feature_indices, __pyx_k_feature_indices, sizeof(__pyx_k_feature_indices), 0, 0, 1, 1},
-    {&__pyx_n_s_find_max_index, __pyx_k_find_max_index, sizeof(__pyx_k_find_max_index), 0, 0, 1, 1},
-    {&__pyx_n_s_finfo, __pyx_k_finfo, sizeof(__pyx_k_finfo), 0, 0, 1, 1},
-    {&__pyx_n_s_fit, __pyx_k_fit, sizeof(__pyx_k_fit), 0, 0, 1, 1},
     {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
-    {&__pyx_n_s_float, __pyx_k_float, sizeof(__pyx_k_float), 0, 0, 1, 1},
     {&__pyx_n_s_float64, __pyx_k_float64, sizeof(__pyx_k_float64), 0, 0, 1, 1},
+    {&__pyx_n_s_forest_predict, __pyx_k_forest_predict, sizeof(__pyx_k_forest_predict), 0, 0, 1, 1},
+    {&__pyx_n_s_forest_predict_locals___most_fre, __pyx_k_forest_predict_locals___most_fre, sizeof(__pyx_k_forest_predict_locals___most_fre), 0, 0, 1, 1},
+    {&__pyx_n_s_forest_predict_proba, __pyx_k_forest_predict_proba, sizeof(__pyx_k_forest_predict_proba), 0, 0, 1, 1},
     {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
     {&__pyx_n_s_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 0, 1, 1},
     {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
     {&__pyx_kp_u_gc, __pyx_k_gc, sizeof(__pyx_k_gc), 0, 1, 0, 0},
-    {&__pyx_n_s_get_leaf_matrix, __pyx_k_get_leaf_matrix, sizeof(__pyx_k_get_leaf_matrix), 0, 0, 1, 1},
     {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
     {&__pyx_kp_u_got, __pyx_k_got, sizeof(__pyx_k_got), 0, 1, 0, 0},
     {&__pyx_kp_u_got_2, __pyx_k_got_2, sizeof(__pyx_k_got_2), 0, 1, 0, 0},
     {&__pyx_kp_u_got_differing_extents_in_dimensi, __pyx_k_got_differing_extents_in_dimensi, sizeof(__pyx_k_got_differing_extents_in_dimensi), 0, 1, 0, 0},
-    {&__pyx_n_s_ht, __pyx_k_ht, sizeof(__pyx_k_ht), 0, 0, 1, 1},
     {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
     {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
     {&__pyx_n_s_idx, __pyx_k_idx, sizeof(__pyx_k_idx), 0, 0, 1, 1},
     {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
-    {&__pyx_n_s_impurity_tol, __pyx_k_impurity_tol, sizeof(__pyx_k_impurity_tol), 0, 0, 1, 1},
     {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
     {&__pyx_n_s_indices, __pyx_k_indices, sizeof(__pyx_k_indices), 0, 0, 1, 1},
-    {&__pyx_n_s_init, __pyx_k_init, sizeof(__pyx_k_init), 0, 0, 1, 1},
-    {&__pyx_n_s_init_subclass, __pyx_k_init_subclass, sizeof(__pyx_k_init_subclass), 0, 0, 1, 1},
     {&__pyx_n_s_initializing, __pyx_k_initializing, sizeof(__pyx_k_initializing), 0, 0, 1, 1},
-    {&__pyx_n_s_int, __pyx_k_int, sizeof(__pyx_k_int), 0, 0, 1, 1},
-    {&__pyx_n_s_int32, __pyx_k_int32, sizeof(__pyx_k_int32), 0, 0, 1, 1},
     {&__pyx_n_s_is_coroutine, __pyx_k_is_coroutine, sizeof(__pyx_k_is_coroutine), 0, 0, 1, 1},
     {&__pyx_kp_u_isenabled, __pyx_k_isenabled, sizeof(__pyx_k_isenabled), 0, 1, 0, 0},
     {&__pyx_n_s_itemsize, __pyx_k_itemsize, sizeof(__pyx_k_itemsize), 0, 0, 1, 1},
     {&__pyx_kp_s_itemsize_0_for_cython_array, __pyx_k_itemsize_0_for_cython_array, sizeof(__pyx_k_itemsize_0_for_cython_array), 0, 0, 1, 0},
     {&__pyx_n_s_ix, __pyx_k_ix, sizeof(__pyx_k_ix), 0, 0, 1, 1},
-    {&__pyx_n_s_key, __pyx_k_key, sizeof(__pyx_k_key), 0, 0, 1, 1},
     {&__pyx_n_s_keys, __pyx_k_keys, sizeof(__pyx_k_keys), 0, 0, 1, 1},
-    {&__pyx_n_s_leaf_nodes, __pyx_k_leaf_nodes, sizeof(__pyx_k_leaf_nodes), 0, 0, 1, 1},
+    {&__pyx_n_s_kwargs, __pyx_k_kwargs, sizeof(__pyx_k_kwargs), 0, 0, 1, 1},
     {&__pyx_n_s_left_child, __pyx_k_left_child, sizeof(__pyx_k_left_child), 0, 0, 1, 1},
-    {&__pyx_n_s_lst, __pyx_k_lst, sizeof(__pyx_k_lst), 0, 0, 1, 1},
     {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
-    {&__pyx_n_s_matrix, __pyx_k_matrix, sizeof(__pyx_k_matrix), 0, 0, 1, 1},
-    {&__pyx_n_s_max_depth, __pyx_k_max_depth, sizeof(__pyx_k_max_depth), 0, 0, 1, 1},
-    {&__pyx_n_s_maxsize, __pyx_k_maxsize, sizeof(__pyx_k_maxsize), 0, 0, 1, 1},
+    {&__pyx_n_s_mean, __pyx_k_mean, sizeof(__pyx_k_mean), 0, 0, 1, 1},
     {&__pyx_n_s_memview, __pyx_k_memview, sizeof(__pyx_k_memview), 0, 0, 1, 1},
-    {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
-    {&__pyx_n_s_min_improvement, __pyx_k_min_improvement, sizeof(__pyx_k_min_improvement), 0, 0, 1, 1},
-    {&__pyx_n_s_min_samples_leaf, __pyx_k_min_samples_leaf, sizeof(__pyx_k_min_samples_leaf), 0, 0, 1, 1},
-    {&__pyx_n_s_min_samples_split, __pyx_k_min_samples_split, sizeof(__pyx_k_min_samples_split), 0, 0, 1, 1},
     {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
-    {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
-    {&__pyx_n_s_n_classes, __pyx_k_n_classes, sizeof(__pyx_k_n_classes), 0, 0, 1, 1},
-    {&__pyx_n_s_n_features, __pyx_k_n_features, sizeof(__pyx_k_n_features), 0, 0, 1, 1},
-    {&__pyx_n_s_n_node, __pyx_k_n_node, sizeof(__pyx_k_n_node), 0, 0, 1, 1},
-    {&__pyx_n_s_n_nodes, __pyx_k_n_nodes, sizeof(__pyx_k_n_nodes), 0, 0, 1, 1},
+    {&__pyx_n_s_most_frequent_element, __pyx_k_most_frequent_element, sizeof(__pyx_k_most_frequent_element), 0, 0, 1, 1},
     {&__pyx_n_s_n_obs, __pyx_k_n_obs, sizeof(__pyx_k_n_obs), 0, 0, 1, 1},
-    {&__pyx_n_s_n_samples, __pyx_k_n_samples, sizeof(__pyx_k_n_samples), 0, 0, 1, 1},
     {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
     {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
     {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
     {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
     {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
-    {&__pyx_n_s_node, __pyx_k_node, sizeof(__pyx_k_node), 0, 0, 1, 1},
     {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
     {&__pyx_kp_s_np_ndarray, __pyx_k_np_ndarray, sizeof(__pyx_k_np_ndarray), 0, 0, 1, 0},
-    {&__pyx_kp_s_np_ndarray_None, __pyx_k_np_ndarray_None, sizeof(__pyx_k_np_ndarray_None), 0, 0, 1, 0},
     {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
     {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
-    {&__pyx_n_s_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 0, 1, 1},
-    {&__pyx_n_s_ones, __pyx_k_ones, sizeof(__pyx_k_ones), 0, 0, 1, 1},
     {&__pyx_n_s_pack, __pyx_k_pack, sizeof(__pyx_k_pack), 0, 0, 1, 1},
     {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
     {&__pyx_n_s_predict, __pyx_k_predict, sizeof(__pyx_k_predict), 0, 0, 1, 1},
     {&__pyx_n_s_predict_leaf_matrix, __pyx_k_predict_leaf_matrix, sizeof(__pyx_k_predict_leaf_matrix), 0, 0, 1, 1},
     {&__pyx_n_s_predict_proba, __pyx_k_predict_proba, sizeof(__pyx_k_predict_proba), 0, 0, 1, 1},
-    {&__pyx_kp_s_predict_proba_can_only_be_called, __pyx_k_predict_proba_can_only_be_called, sizeof(__pyx_k_predict_proba_can_only_be_called), 0, 0, 1, 0},
-    {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
+    {&__pyx_n_s_predictions, __pyx_k_predictions, sizeof(__pyx_k_predictions), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_PickleError, __pyx_k_pyx_PickleError, sizeof(__pyx_k_pyx_PickleError), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_checksum, __pyx_k_pyx_checksum, sizeof(__pyx_k_pyx_checksum), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_type, __pyx_k_pyx_type, sizeof(__pyx_k_pyx_type), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
-    {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
+    {&__pyx_n_s_quantile, __pyx_k_quantile, sizeof(__pyx_k_quantile), 0, 0, 1, 1},
+    {&__pyx_n_u_quantile, __pyx_k_quantile, sizeof(__pyx_k_quantile), 0, 1, 0, 1},
     {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
     {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
     {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
     {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
     {&__pyx_n_s_register, __pyx_k_register, sizeof(__pyx_k_register), 0, 0, 1, 1},
-    {&__pyx_n_s_reshape, __pyx_k_reshape, sizeof(__pyx_k_reshape), 0, 0, 1, 1},
-    {&__pyx_n_s_ret_val, __pyx_k_ret_val, sizeof(__pyx_k_ret_val), 0, 0, 1, 1},
-    {&__pyx_n_s_return, __pyx_k_return, sizeof(__pyx_k_return), 0, 0, 1, 1},
+    {&__pyx_n_s_return_counts, __pyx_k_return_counts, sizeof(__pyx_k_return_counts), 0, 0, 1, 1},
     {&__pyx_n_s_right_child, __pyx_k_right_child, sizeof(__pyx_k_right_child), 0, 0, 1, 1},
     {&__pyx_n_s_root, __pyx_k_root, sizeof(__pyx_k_root), 0, 0, 1, 1},
-    {&__pyx_n_s_row, __pyx_k_row, sizeof(__pyx_k_row), 0, 0, 1, 1},
-    {&__pyx_n_s_sample_indices, __pyx_k_sample_indices, sizeof(__pyx_k_sample_indices), 0, 0, 1, 1},
-    {&__pyx_n_s_sample_weight, __pyx_k_sample_weight, sizeof(__pyx_k_sample_weight), 0, 0, 1, 1},
-    {&__pyx_kp_s_sample_weight_should_have_as_man, __pyx_k_sample_weight_should_have_as_man, sizeof(__pyx_k_sample_weight_should_have_as_man), 0, 0, 1, 0},
-    {&__pyx_kp_s_sample_weight_should_have_dimens, __pyx_k_sample_weight_should_have_dimens, sizeof(__pyx_k_sample_weight_should_have_dimens), 0, 0, 1, 0},
+    {&__pyx_n_s_save_indices, __pyx_k_save_indices, sizeof(__pyx_k_save_indices), 0, 0, 1, 1},
+    {&__pyx_n_u_save_indices, __pyx_k_save_indices, sizeof(__pyx_k_save_indices), 0, 1, 0, 1},
     {&__pyx_n_s_scale, __pyx_k_scale, sizeof(__pyx_k_scale), 0, 0, 1, 1},
     {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
-    {&__pyx_n_s_set_name, __pyx_k_set_name, sizeof(__pyx_k_set_name), 0, 0, 1, 1},
     {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
     {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
     {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
     {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
     {&__pyx_n_s_spec, __pyx_k_spec, sizeof(__pyx_k_spec), 0, 0, 1, 1},
     {&__pyx_n_s_split_idx, __pyx_k_split_idx, sizeof(__pyx_k_split_idx), 0, 0, 1, 1},
-    {&__pyx_n_s_splitter, __pyx_k_splitter, sizeof(__pyx_k_splitter), 0, 0, 1, 1},
-    {&__pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_k_src_adaXT_decision_tree_Decision, sizeof(__pyx_k_src_adaXT_decision_tree_Decision), 0, 0, 1, 0},
+    {&__pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_k_src_adaXT_predict_predict_pyx, sizeof(__pyx_k_src_adaXT_predict_predict_pyx), 0, 0, 1, 0},
+    {&__pyx_n_s_stack, __pyx_k_stack, sizeof(__pyx_k_stack), 0, 0, 1, 1},
+    {&__pyx_n_s_stacked_tree_predictions, __pyx_k_stacked_tree_predictions, sizeof(__pyx_k_stacked_tree_predictions), 0, 0, 1, 1},
     {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
+    {&__pyx_n_s_staticmethod, __pyx_k_staticmethod, sizeof(__pyx_k_staticmethod), 0, 0, 1, 1},
     {&__pyx_n_s_step, __pyx_k_step, sizeof(__pyx_k_step), 0, 0, 1, 1},
     {&__pyx_n_s_stop, __pyx_k_stop, sizeof(__pyx_k_stop), 0, 0, 1, 1},
-    {&__pyx_n_s_str, __pyx_k_str, sizeof(__pyx_k_str), 0, 0, 1, 1},
     {&__pyx_kp_s_strided_and_direct, __pyx_k_strided_and_direct, sizeof(__pyx_k_strided_and_direct), 0, 0, 1, 0},
     {&__pyx_kp_s_strided_and_direct_or_indirect, __pyx_k_strided_and_direct_or_indirect, sizeof(__pyx_k_strided_and_direct_or_indirect), 0, 0, 1, 0},
     {&__pyx_kp_s_strided_and_indirect, __pyx_k_strided_and_indirect, sizeof(__pyx_k_strided_and_indirect), 0, 0, 1, 0},
     {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
     {&__pyx_n_s_struct, __pyx_k_struct, sizeof(__pyx_k_struct), 0, 0, 1, 1},
-    {&__pyx_n_s_super, __pyx_k_super, sizeof(__pyx_k_super), 0, 0, 1, 1},
     {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
     {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
+    {&__pyx_n_s_theta0, __pyx_k_theta0, sizeof(__pyx_k_theta0), 0, 0, 1, 1},
+    {&__pyx_n_s_theta1, __pyx_k_theta1, sizeof(__pyx_k_theta1), 0, 0, 1, 1},
     {&__pyx_n_s_threshold, __pyx_k_threshold, sizeof(__pyx_k_threshold), 0, 0, 1, 1},
-    {&__pyx_n_s_tree_type, __pyx_k_tree_type, sizeof(__pyx_k_tree_type), 0, 0, 1, 1},
-    {&__pyx_n_s_tree_types, __pyx_k_tree_types, sizeof(__pyx_k_tree_types), 0, 0, 1, 1},
     {&__pyx_kp_s_unable_to_allocate_array_data, __pyx_k_unable_to_allocate_array_data, sizeof(__pyx_k_unable_to_allocate_array_data), 0, 0, 1, 0},
     {&__pyx_kp_s_unable_to_allocate_shape_and_str, __pyx_k_unable_to_allocate_shape_and_str, sizeof(__pyx_k_unable_to_allocate_shape_and_str), 0, 0, 1, 0},
+    {&__pyx_n_s_unique, __pyx_k_unique, sizeof(__pyx_k_unique), 0, 0, 1, 1},
     {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
     {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
-    {&__pyx_n_s_val, __pyx_k_val, sizeof(__pyx_k_val), 0, 0, 1, 1},
     {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
+    {&__pyx_n_s_values, __pyx_k_values, sizeof(__pyx_k_values), 0, 0, 1, 1},
     {&__pyx_n_s_version_info, __pyx_k_version_info, sizeof(__pyx_k_version_info), 0, 0, 1, 1},
     {&__pyx_n_s_zeros, __pyx_k_zeros, sizeof(__pyx_k_zeros), 0, 0, 1, 1},
     {0, 0, 0, 0, 0, 0, 0}
   };
   return __Pyx_InitStrings(__pyx_string_tab);
 }
 /* #### Code section: cached_builtins ### */
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_AssertionError = __Pyx_GetBuiltinName(__pyx_n_s_AssertionError); if (!__pyx_builtin_AssertionError) __PYX_ERR(0, 30, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 54, __pyx_L1_error)
-  __pyx_builtin_AttributeError = __Pyx_GetBuiltinName(__pyx_n_s_AttributeError); if (!__pyx_builtin_AttributeError) __PYX_ERR(0, 125, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 132, __pyx_L1_error)
+  __pyx_builtin_staticmethod = __Pyx_GetBuiltinName(__pyx_n_s_staticmethod); if (!__pyx_builtin_staticmethod) __PYX_ERR(0, 75, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 22, __pyx_L1_error)
+  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 32, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 50, __pyx_L1_error)
   __pyx_builtin___import__ = __Pyx_GetBuiltinName(__pyx_n_s_import); if (!__pyx_builtin___import__) __PYX_ERR(1, 100, __pyx_L1_error)
   __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(1, 156, __pyx_L1_error)
   __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 159, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
+  __pyx_builtin_AssertionError = __Pyx_GetBuiltinName(__pyx_n_s_AssertionError); if (!__pyx_builtin_AssertionError) __PYX_ERR(1, 373, __pyx_L1_error)
   __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 408, __pyx_L1_error)
   __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 618, __pyx_L1_error)
   __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 914, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
@@ -24488,354 +25745,344 @@
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
  */
   __pyx_tuple__8 = PyTuple_Pack(3, __pyx_int_136983863, __pyx_int_112105877, __pyx_int_184977713); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":54
- *         # Check if X and Y has same number of rows
- *         if X.shape[0] != Y.shape[0]:
- *             raise ValueError("X and Y should have the same number of rows")             # <<<<<<<<<<<<<<
+  /* "adaXT/predict/predict.pyx":32
  * 
- *         # Check if Y has dimensions (n, 1) or (n,)
+ *     def predict(self, object X, **kwargs):
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef list predict_proba(self, object X):
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_X_and_Y_should_have_the_same_num); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 54, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_Function_predict_is_not_implemen); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 32, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__9);
   __Pyx_GIVEREF(__pyx_tuple__9);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":58
- *         # Check if Y has dimensions (n, 1) or (n,)
- *         if 2 < Y.ndim:
- *             raise ValueError("Y should have dimensions (n,1) or (n,)")             # <<<<<<<<<<<<<<
- *         elif 2 == Y.ndim:
- *             if 1 < Y.shape[1]:
+  /* "adaXT/predict/predict.pyx":35
+ * 
+ *     cpdef list predict_proba(self, object X):
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")             # <<<<<<<<<<<<<<
+ * 
+ *     cpdef double[:, ::1] predict_leaf_matrix(self, object X, bint scale = False):
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_Y_should_have_dimensions_n_1_or); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 58, __pyx_L1_error)
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_Function_predict_proba_is_not_im); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 35, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__10);
   __Pyx_GIVEREF(__pyx_tuple__10);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":73
- *         sample_weight = np.array(sample_weight, dtype=np.double)
- *         if sample_weight.shape[0] != n_samples:
- *             raise ValueError("sample_weight should have as many elements as X and Y")             # <<<<<<<<<<<<<<
- *         if sample_weight.ndim > 1:
- *             raise ValueError("sample_weight should have dimension (n_samples,)")
+  /* "adaXT/predict/predict.pyx":77
+ *     @staticmethod
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")             # <<<<<<<<<<<<<<
+ * 
+ *     @staticmethod
  */
-  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_s_sample_weight_should_have_as_man); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 73, __pyx_L1_error)
+  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_u_The_forest_predict_function_is_n); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 77, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__11);
   __Pyx_GIVEREF(__pyx_tuple__11);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":75
- *             raise ValueError("sample_weight should have as many elements as X and Y")
- *         if sample_weight.ndim > 1:
- *             raise ValueError("sample_weight should have dimension (n_samples,)")             # <<<<<<<<<<<<<<
- *         return sample_weight
- * 
+  /* "adaXT/predict/predict.pyx":149
+ *     @staticmethod
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):             # <<<<<<<<<<<<<<
+ *             values, counts = np.unique(arr, return_counts=True)
+ *             return values[np.argmax(counts)]
  */
-  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_sample_weight_should_have_dimens); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __pyx_tuple__12 = PyTuple_Pack(3, __pyx_n_s_arr, __pyx_n_s_values, __pyx_n_s_counts); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 149, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__12);
   __Pyx_GIVEREF(__pyx_tuple__12);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":125
- *             double[:] Y
- *         if not self.root:
- *             raise AttributeError("The tree has not been fitted before trying to call predict")             # <<<<<<<<<<<<<<
- * 
- *         # Make sure that x fits the dimensions.
- */
-  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_s_The_tree_has_not_been_fitted_bef); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 125, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__13);
-  __Pyx_GIVEREF(__pyx_tuple__13);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":157
- * 
- *         if not self.root:
- *             raise AttributeError("The tree has not been fitted before trying to call predict_proba")             # <<<<<<<<<<<<<<
- * 
- *         if self.tree_type != "Classification":
- */
-  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_s_The_tree_has_not_been_fitted_bef_2); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 157, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__14);
-  __Pyx_GIVEREF(__pyx_tuple__14);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":160
- * 
- *         if self.tree_type != "Classification":
- *             raise ValueError("predict_proba can only be called on a Classification tree")             # <<<<<<<<<<<<<<
- * 
- *         # Make sure that x fits the dimensions.
- */
-  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_s_predict_proba_can_only_be_called); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(0, 160, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__15);
-  __Pyx_GIVEREF(__pyx_tuple__15);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":189
- *     def get_leaf_matrix(self, scale: bool = False) -> np.ndarray:
- *         if not self.root:
- *             raise ValueError("The tree has not been trained before trying to predict")             # <<<<<<<<<<<<<<
- * 
- *         leaf_nodes = self.leaf_nodes
- */
-  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_The_tree_has_not_been_trained_be); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 189, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__16);
-  __Pyx_GIVEREF(__pyx_tuple__16);
+  __pyx_codeobj__13 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__12, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_most_frequent_element, 149, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__13)) __PYX_ERR(0, 149, __pyx_L1_error)
 
   /* "View.MemoryView":100
  * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
  * try:
  *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
  *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
  *     else:
  */
-  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_n_s_sys); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 100, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__17);
-  __Pyx_GIVEREF(__pyx_tuple__17);
-  __pyx_tuple__18 = PyTuple_Pack(2, __pyx_int_3, __pyx_int_3); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 100, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__18);
-  __Pyx_GIVEREF(__pyx_tuple__18);
+  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_n_s_sys); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(1, 100, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__14);
+  __Pyx_GIVEREF(__pyx_tuple__14);
+  __pyx_tuple__15 = PyTuple_Pack(2, __pyx_int_3, __pyx_int_3); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(1, 100, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__15);
+  __Pyx_GIVEREF(__pyx_tuple__15);
 
   /* "View.MemoryView":101
  * try:
  *     if __import__("sys").version_info >= (3, 3):
  *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence             # <<<<<<<<<<<<<<
  *     else:
  *         __pyx_collections_abc_Sequence = __import__("collections").Sequence
  */
-  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_collections_abc); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 101, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__19);
-  __Pyx_GIVEREF(__pyx_tuple__19);
+  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_collections_abc); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(1, 101, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__16);
+  __Pyx_GIVEREF(__pyx_tuple__16);
 
   /* "View.MemoryView":103
  *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
  *     else:
  *         __pyx_collections_abc_Sequence = __import__("collections").Sequence             # <<<<<<<<<<<<<<
  * except:
  * 
  */
-  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_n_s_collections); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 103, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__20);
-  __Pyx_GIVEREF(__pyx_tuple__20);
+  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_n_s_collections); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(1, 103, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__17);
+  __Pyx_GIVEREF(__pyx_tuple__17);
 
   /* "View.MemoryView":309
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 309, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__21);
-  __Pyx_GIVEREF(__pyx_tuple__21);
+  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(1, 309, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__18);
+  __Pyx_GIVEREF(__pyx_tuple__18);
 
   /* "View.MemoryView":310
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 310, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__22);
-  __Pyx_GIVEREF(__pyx_tuple__22);
+  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(1, 310, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__19);
+  __Pyx_GIVEREF(__pyx_tuple__19);
 
   /* "View.MemoryView":311
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 311, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__23);
-  __Pyx_GIVEREF(__pyx_tuple__23);
+  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 311, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__20);
+  __Pyx_GIVEREF(__pyx_tuple__20);
 
   /* "View.MemoryView":314
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(1, 314, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__24);
-  __Pyx_GIVEREF(__pyx_tuple__24);
+  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(1, 314, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__21);
+  __Pyx_GIVEREF(__pyx_tuple__21);
 
   /* "View.MemoryView":315
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 315, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__25);
-  __Pyx_GIVEREF(__pyx_tuple__25);
+  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(1, 315, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__22);
+  __Pyx_GIVEREF(__pyx_tuple__22);
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__26 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(1, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__26);
-  __Pyx_GIVEREF(__pyx_tuple__26);
-  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__26, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __pyx_tuple__23 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(1, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__23);
+  __Pyx_GIVEREF(__pyx_tuple__23);
+  __pyx_codeobj__24 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__24)) __PYX_ERR(1, 1, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":14
- * from .Nodes import DecisionNode
+  /* "adaXT/predict/predict.pyx":14
+ *         self.root = root
+ * 
+ *     def __reduce__(self):             # <<<<<<<<<<<<<<
+ *         return (self.__class__, (self.X.base, self.Y.base, self.root))
  * 
- * cdef double EPSILON = np.finfo('double').eps             # <<<<<<<<<<<<<<
+ */
+  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 14, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__25);
+  __Pyx_GIVEREF(__pyx_tuple__25);
+  __pyx_codeobj__26 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__25, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_reduce, 14, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__26)) __PYX_ERR(0, 14, __pyx_L1_error)
+
+  /* "adaXT/predict/predict.pyx":31
+ *         return X
  * 
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")
  * 
  */
-  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_n_s_double); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 14, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__28);
-  __Pyx_GIVEREF(__pyx_tuple__28);
+  __pyx_tuple__27 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 31, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__27);
+  __Pyx_GIVEREF(__pyx_tuple__27);
+  __pyx_codeobj__28 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__27, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_predict, 31, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__28)) __PYX_ERR(0, 31, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":18
+  /* "adaXT/predict/predict.pyx":34
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")
+ * 
+ *     cpdef list predict_proba(self, object X):             # <<<<<<<<<<<<<<
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")
  * 
- * class DecisionTree:
- *     def __init__(             # <<<<<<<<<<<<<<
- *             self,
- *             tree_type: str,
  */
-  __pyx_tuple__29 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_tree_type, __pyx_n_s_criteria, __pyx_n_s_max_depth, __pyx_n_s_impurity_tol, __pyx_n_s_min_samples_split, __pyx_n_s_min_samples_leaf, __pyx_n_s_min_improvement, __pyx_n_s_splitter, __pyx_n_s_tree_types); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __pyx_tuple__29 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_X); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 34, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__29);
   __Pyx_GIVEREF(__pyx_tuple__29);
-  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(9, 0, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_init, 18, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_predict_proba, 34, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(0, 34, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":47
- *         self.splitter = splitter
+  /* "adaXT/predict/predict.pyx":37
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")
  * 
- *     def __check_input(self, X: object, Y: object):             # <<<<<<<<<<<<<<
- *         # Make sure input arrays are c contigous
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
+ *     cpdef double[:, ::1] predict_leaf_matrix(self, object X, bint scale = False):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i
  */
-  __pyx_tuple__31 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_Y); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(0, 47, __pyx_L1_error)
+  __pyx_tuple__31 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_scale); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(0, 37, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__31);
   __Pyx_GIVEREF(__pyx_tuple__31);
-  __pyx_codeobj__32 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__31, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_check_input, 47, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__32)) __PYX_ERR(0, 47, __pyx_L1_error)
+  __pyx_codeobj__32 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__31, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_predict_leaf_matrix, 37, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__32)) __PYX_ERR(0, 37, __pyx_L1_error)
+  __pyx_tuple__33 = PyTuple_Pack(1, Py_False); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 37, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__33);
+  __Pyx_GIVEREF(__pyx_tuple__33);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":67
- *         return X, Y
- * 
- *     def __check_sample_weight(self, sample_weight: np.ndarray, n_samples):             # <<<<<<<<<<<<<<
+  /* "adaXT/predict/predict.pyx":75
+ *         return matrix
  * 
- *         if sample_weight is None:
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  */
-  __pyx_tuple__33 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_sample_weight, __pyx_n_s_n_samples); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 67, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__33);
-  __Pyx_GIVEREF(__pyx_tuple__33);
-  __pyx_codeobj__34 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__33, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_check_sample_weight, 67, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__34)) __PYX_ERR(0, 67, __pyx_L1_error)
+  __pyx_tuple__34 = PyTuple_Pack(2, __pyx_n_s_predictions, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__34);
+  __Pyx_GIVEREF(__pyx_tuple__34);
+  __pyx_codeobj__35 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__34, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_forest_predict, 75, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__35)) __PYX_ERR(0, 75, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":78
- *         return sample_weight
+  /* "adaXT/predict/predict.pyx":79
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  * 
- *     def __check_dimensions(self, double[:, :] X):             # <<<<<<<<<<<<<<
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
- *         # If there is only a single point
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  */
-  __pyx_tuple__35 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_X); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 78, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__35);
-  __Pyx_GIVEREF(__pyx_tuple__35);
-  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_check_dimensions, 78, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 78, __pyx_L1_error)
+  __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__34, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_forest_predict_proba, 79, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 79, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":92
- *         return X
+  /* "adaXT/predict/predict.pyx":96
+ *         return cur_max
  * 
- *     def fit(             # <<<<<<<<<<<<<<
- *             self,
- *             X,
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, idx, n_obs
  */
-  __pyx_tuple__37 = PyTuple_Pack(9, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_Y, __pyx_n_s_feature_indices, __pyx_n_s_sample_indices, __pyx_n_s_sample_weight, __pyx_n_s_row, __pyx_n_s_col, __pyx_n_s_builder); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 92, __pyx_L1_error)
+  __pyx_tuple__37 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_kwargs, __pyx_n_s_i, __pyx_n_s_cur_split_idx, __pyx_n_s_idx, __pyx_n_s_n_obs, __pyx_n_s_cur_threshold, __pyx_n_s_cur_node, __pyx_n_s_Y); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 96, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__37);
   __Pyx_GIVEREF(__pyx_tuple__37);
-  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(6, 0, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_fit, 92, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __pyx_tuple__39 = PyTuple_Pack(3, Py_None, Py_None, Py_None); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__39);
-  __Pyx_GIVEREF(__pyx_tuple__39);
+  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_predict, 96, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 96, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":118
- *         builder.build_tree(self)
+  /* "adaXT/predict/predict.pyx":123
+ *         return Y
  * 
- *     def predict(self, X: np.ndarray):             # <<<<<<<<<<<<<<
+ *     cpdef list predict_proba(self, object X):             # <<<<<<<<<<<<<<
  *         cdef:
- *             int i, cur_split_idx, idx, n_obs
+ *             int i, cur_split_idx, n_obs
+ */
+  __pyx_codeobj__39 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_predict_proba, 123, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__39)) __PYX_ERR(0, 123, __pyx_L1_error)
+
+  /* "adaXT/predict/predict.pyx":147
+ *         return ret_val
+ * 
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):
  */
-  __pyx_tuple__40 = PyTuple_Pack(9, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_i, __pyx_n_s_cur_split_idx, __pyx_n_s_idx, __pyx_n_s_n_obs, __pyx_n_s_cur_threshold, __pyx_n_s_cur_node, __pyx_n_s_Y); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 118, __pyx_L1_error)
+  __pyx_tuple__40 = PyTuple_Pack(4, __pyx_n_s_predictions, __pyx_n_s_kwargs, __pyx_n_s_PredictClassification__most_fre, __pyx_n_s_most_frequent_element); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__40);
   __Pyx_GIVEREF(__pyx_tuple__40);
-  __pyx_codeobj__41 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_predict, 118, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__41)) __PYX_ERR(0, 118, __pyx_L1_error)
+  __pyx_codeobj__41 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__40, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_forest_predict, 147, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__41)) __PYX_ERR(0, 147, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":149
- *         return np.asarray(Y)
+  /* "adaXT/predict/predict.pyx":156
+ *         )
  * 
- *     def predict_proba(self, X: np.ndarray):             # <<<<<<<<<<<<<<
- *         cdef:
- *             int i, cur_split_idx, n_obs
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         # Stack the predict_probas
  */
-  __pyx_tuple__42 = PyTuple_Pack(8, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_i, __pyx_n_s_cur_split_idx, __pyx_n_s_n_obs, __pyx_n_s_cur_threshold, __pyx_n_s_cur_node, __pyx_n_s_ret_val); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(0, 149, __pyx_L1_error)
+  __pyx_tuple__42 = PyTuple_Pack(3, __pyx_n_s_predictions, __pyx_n_s_kwargs, __pyx_n_s_stacked_tree_predictions); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(0, 156, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__42);
   __Pyx_GIVEREF(__pyx_tuple__42);
-  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__42, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_predict_proba, 149, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) __PYX_ERR(0, 149, __pyx_L1_error)
+  __pyx_codeobj__43 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__42, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_forest_predict_proba, 156, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__43)) __PYX_ERR(0, 156, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":180
- *         return np.asarray(ret_val)
+  /* "adaXT/predict/predict.pyx":166
  * 
- *     def __find_max_index(self, lst):             # <<<<<<<<<<<<<<
- *         cur_max = 0
- *         for i in range(1, len(lst)):
+ * cdef class PredictRegression(Predict):
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, n_obs
  */
-  __pyx_tuple__44 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_lst, __pyx_n_s_cur_max, __pyx_n_s_i); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 180, __pyx_L1_error)
+  __pyx_tuple__44 = PyTuple_Pack(9, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_kwargs, __pyx_n_s_i, __pyx_n_s_cur_split_idx, __pyx_n_s_n_obs, __pyx_n_s_cur_threshold, __pyx_n_s_cur_node, __pyx_n_s_Y); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 166, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__44);
   __Pyx_GIVEREF(__pyx_tuple__44);
-  __pyx_codeobj__45 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__44, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_find_max_index, 180, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__45)) __PYX_ERR(0, 180, __pyx_L1_error)
+  __pyx_codeobj__45 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__44, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_predict, 166, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__45)) __PYX_ERR(0, 166, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":187
- *         return cur_max
+  /* "adaXT/predict/predict.pyx":190
+ *         return Y
  * 
- *     def get_leaf_matrix(self, scale: bool = False) -> np.ndarray:             # <<<<<<<<<<<<<<
- *         if not self.root:
- *             raise ValueError("The tree has not been trained before trying to predict")
- */
-  __pyx_tuple__46 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_scale, __pyx_n_s_leaf_nodes, __pyx_n_s_n_obs, __pyx_n_s_matrix, __pyx_n_s_node, __pyx_n_s_n_node); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 187, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__46);
-  __Pyx_GIVEREF(__pyx_tuple__46);
-  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__46, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_get_leaf_matrix, 187, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(0, 187, __pyx_L1_error)
-  __pyx_tuple__48 = PyTuple_Pack(1, ((PyObject *)Py_False)); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 187, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__48);
-  __Pyx_GIVEREF(__pyx_tuple__48);
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         return np.mean(predictions, axis=1)
+ */
+  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__34, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_forest_predict, 190, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) __PYX_ERR(0, 190, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":206
- *         return matrix
+  /* "adaXT/predict/predict.pyx":195
  * 
- *     def predict_leaf_matrix(self, X: np.ndarray, scale: bool = False):             # <<<<<<<<<<<<<<
+ * cdef class PredictLinearRegression(PredictRegression):
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
  *         cdef:
- *             int i
+ *             int i, cur_split_idx, n_obs
  */
-  __pyx_tuple__49 = PyTuple_Pack(14, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_scale, __pyx_n_s_i, __pyx_n_s_row, __pyx_n_s_ht, __pyx_n_s_cur_split_idx, __pyx_n_s_cur_threshold, __pyx_n_s_cur_node, __pyx_n_s_matrix, __pyx_n_s_key, __pyx_n_s_indices, __pyx_n_s_val, __pyx_n_s_count); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(0, 206, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__49);
-  __Pyx_GIVEREF(__pyx_tuple__49);
-  __pyx_codeobj__50 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 14, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__49, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Decision, __pyx_n_s_predict_leaf_matrix, 206, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__50)) __PYX_ERR(0, 206, __pyx_L1_error)
+  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__44, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_predict, 195, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(0, 195, __pyx_L1_error)
+
+  /* "adaXT/predict/predict.pyx":221
+ * cdef class PredictQuantile(Predict):
+ * 
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, n_obs
+ */
+  __pyx_tuple__48 = PyTuple_Pack(11, __pyx_n_s_self, __pyx_n_s_X, __pyx_n_s_kwargs, __pyx_n_s_i, __pyx_n_s_cur_split_idx, __pyx_n_s_n_obs, __pyx_n_s_cur_threshold, __pyx_n_s_cur_node, __pyx_n_s_Y, __pyx_n_s_quantile, __pyx_n_s_save_indices); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 221, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__48);
+  __Pyx_GIVEREF(__pyx_tuple__48);
+  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(2, 0, 0, 11, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__48, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_predict, 221, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) __PYX_ERR(0, 221, __pyx_L1_error)
+
+  /* "adaXT/predict/predict.pyx":256
+ *         return Y
+ * 
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         quantile = <double> kwargs['quantile']
+ */
+  __pyx_tuple__50 = PyTuple_Pack(3, __pyx_n_s_predictions, __pyx_n_s_kwargs, __pyx_n_s_quantile); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 256, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__50);
+  __Pyx_GIVEREF(__pyx_tuple__50);
+  __pyx_codeobj__51 = (PyObject*)__Pyx_PyCode_New(1, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__50, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_predict_predict_pyx, __pyx_n_s_forest_predict, 256, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__51)) __PYX_ERR(0, 256, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 /* #### Code section: init_constants ### */
 
 static CYTHON_SMALL_CODE int __Pyx_InitConstants(void) {
   __pyx_umethod_PyDict_Type_keys.type = (PyObject*)&PyDict_Type;
   __pyx_umethod_PyDict_Type_keys.method_name = &__pyx_n_s_keys;
   if (__Pyx_CreateStringTabAndInitStrings() < 0) __PYX_ERR(0, 1, __pyx_L1_error);
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
-  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_112105877 = PyInt_FromLong(112105877L); if (unlikely(!__pyx_int_112105877)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_136983863 = PyInt_FromLong(136983863L); if (unlikely(!__pyx_int_136983863)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
@@ -24897,14 +26144,168 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
+  __pyx_vtabptr_5adaXT_7predict_7predict_Predict = &__pyx_vtable_5adaXT_7predict_7predict_Predict;
+  __pyx_vtable_5adaXT_7predict_7predict_Predict._Predict__check_dimensions = (__Pyx_memviewslice (*)(struct __pyx_obj_5adaXT_7predict_7predict_Predict *, PyObject *))__pyx_f_5adaXT_7predict_7predict_7Predict__Predict__check_dimensions;
+  __pyx_vtable_5adaXT_7predict_7predict_Predict.predict_leaf_matrix = (__Pyx_memviewslice (*)(struct __pyx_obj_5adaXT_7predict_7predict_Predict *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix *__pyx_optional_args))__pyx_f_5adaXT_7predict_7predict_7Predict_predict_leaf_matrix;
+  __pyx_vtable_5adaXT_7predict_7predict_Predict.predict_proba = (PyObject *(*)(struct __pyx_obj_5adaXT_7predict_7predict_Predict *, PyObject *, int __pyx_skip_dispatch))__pyx_f_5adaXT_7predict_7predict_7Predict_predict_proba;
+  #if CYTHON_USE_TYPE_SPECS
+  __pyx_ptype_5adaXT_7predict_7predict_Predict = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_7predict_7predict_Predict_spec, NULL); if (unlikely(!__pyx_ptype_5adaXT_7predict_7predict_Predict)) __PYX_ERR(0, 6, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_7predict_7predict_Predict_spec, __pyx_ptype_5adaXT_7predict_7predict_Predict) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  #else
+  __pyx_ptype_5adaXT_7predict_7predict_Predict = &__pyx_type_5adaXT_7predict_7predict_Predict;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  #endif
+  #if !CYTHON_USE_TYPE_SPECS
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_7predict_7predict_Predict) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  __pyx_ptype_5adaXT_7predict_7predict_Predict->tp_print = 0;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_7predict_7predict_Predict->tp_dictoffset && __pyx_ptype_5adaXT_7predict_7predict_Predict->tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_ptype_5adaXT_7predict_7predict_Predict->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  #endif
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_vtabptr_5adaXT_7predict_7predict_Predict) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_7predict_7predict_Predict) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  #endif
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Predict, (PyObject *) __pyx_ptype_5adaXT_7predict_7predict_Predict) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  __pyx_vtabptr_5adaXT_7predict_7predict_PredictClassification = &__pyx_vtable_5adaXT_7predict_7predict_PredictClassification;
+  __pyx_vtable_5adaXT_7predict_7predict_PredictClassification.__pyx_base = *__pyx_vtabptr_5adaXT_7predict_7predict_Predict;
+  __pyx_vtable_5adaXT_7predict_7predict_PredictClassification.__pyx_base.predict_proba = (PyObject *(*)(struct __pyx_obj_5adaXT_7predict_7predict_Predict *, PyObject *, int __pyx_skip_dispatch))__pyx_f_5adaXT_7predict_7predict_21PredictClassification_predict_proba;
+  __pyx_vtable_5adaXT_7predict_7predict_PredictClassification._PredictClassification__find_max_index = (int (*)(struct __pyx_obj_5adaXT_7predict_7predict_PredictClassification *, __Pyx_memviewslice))__pyx_f_5adaXT_7predict_7predict_21PredictClassification__PredictClassification__find_max_index;
+  #if CYTHON_USE_TYPE_SPECS
+  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_ptype_5adaXT_7predict_7predict_PredictClassification = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_7predict_7predict_PredictClassification_spec, __pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (unlikely(!__pyx_ptype_5adaXT_7predict_7predict_PredictClassification)) __PYX_ERR(0, 83, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_7predict_7predict_PredictClassification_spec, __pyx_ptype_5adaXT_7predict_7predict_PredictClassification) < 0) __PYX_ERR(0, 83, __pyx_L1_error)
+  #else
+  __pyx_ptype_5adaXT_7predict_7predict_PredictClassification = &__pyx_type_5adaXT_7predict_7predict_PredictClassification;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  __pyx_ptype_5adaXT_7predict_7predict_PredictClassification->tp_base = __pyx_ptype_5adaXT_7predict_7predict_Predict;
+  #endif
+  #if !CYTHON_USE_TYPE_SPECS
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_7predict_7predict_PredictClassification) < 0) __PYX_ERR(0, 83, __pyx_L1_error)
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  __pyx_ptype_5adaXT_7predict_7predict_PredictClassification->tp_print = 0;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_7predict_7predict_PredictClassification->tp_dictoffset && __pyx_ptype_5adaXT_7predict_7predict_PredictClassification->tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_ptype_5adaXT_7predict_7predict_PredictClassification->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  #endif
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_7predict_7predict_PredictClassification, __pyx_vtabptr_5adaXT_7predict_7predict_PredictClassification) < 0) __PYX_ERR(0, 83, __pyx_L1_error)
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_7predict_7predict_PredictClassification) < 0) __PYX_ERR(0, 83, __pyx_L1_error)
+  #endif
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_PredictClassification, (PyObject *) __pyx_ptype_5adaXT_7predict_7predict_PredictClassification) < 0) __PYX_ERR(0, 83, __pyx_L1_error)
+  __pyx_vtabptr_5adaXT_7predict_7predict_PredictRegression = &__pyx_vtable_5adaXT_7predict_7predict_PredictRegression;
+  __pyx_vtable_5adaXT_7predict_7predict_PredictRegression.__pyx_base = *__pyx_vtabptr_5adaXT_7predict_7predict_Predict;
+  #if CYTHON_USE_TYPE_SPECS
+  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_ptype_5adaXT_7predict_7predict_PredictRegression = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_7predict_7predict_PredictRegression_spec, __pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (unlikely(!__pyx_ptype_5adaXT_7predict_7predict_PredictRegression)) __PYX_ERR(0, 165, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_7predict_7predict_PredictRegression_spec, __pyx_ptype_5adaXT_7predict_7predict_PredictRegression) < 0) __PYX_ERR(0, 165, __pyx_L1_error)
+  #else
+  __pyx_ptype_5adaXT_7predict_7predict_PredictRegression = &__pyx_type_5adaXT_7predict_7predict_PredictRegression;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  __pyx_ptype_5adaXT_7predict_7predict_PredictRegression->tp_base = __pyx_ptype_5adaXT_7predict_7predict_Predict;
+  #endif
+  #if !CYTHON_USE_TYPE_SPECS
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_7predict_7predict_PredictRegression) < 0) __PYX_ERR(0, 165, __pyx_L1_error)
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  __pyx_ptype_5adaXT_7predict_7predict_PredictRegression->tp_print = 0;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_7predict_7predict_PredictRegression->tp_dictoffset && __pyx_ptype_5adaXT_7predict_7predict_PredictRegression->tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_ptype_5adaXT_7predict_7predict_PredictRegression->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  #endif
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_7predict_7predict_PredictRegression, __pyx_vtabptr_5adaXT_7predict_7predict_PredictRegression) < 0) __PYX_ERR(0, 165, __pyx_L1_error)
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_7predict_7predict_PredictRegression) < 0) __PYX_ERR(0, 165, __pyx_L1_error)
+  #endif
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_PredictRegression, (PyObject *) __pyx_ptype_5adaXT_7predict_7predict_PredictRegression) < 0) __PYX_ERR(0, 165, __pyx_L1_error)
+  __pyx_vtabptr_5adaXT_7predict_7predict_PredictLinearRegression = &__pyx_vtable_5adaXT_7predict_7predict_PredictLinearRegression;
+  __pyx_vtable_5adaXT_7predict_7predict_PredictLinearRegression.__pyx_base = *__pyx_vtabptr_5adaXT_7predict_7predict_PredictRegression;
+  #if CYTHON_USE_TYPE_SPECS
+  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictRegression); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_7predict_7predict_PredictLinearRegression_spec, __pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (unlikely(!__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression)) __PYX_ERR(0, 194, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_7predict_7predict_PredictLinearRegression_spec, __pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression) < 0) __PYX_ERR(0, 194, __pyx_L1_error)
+  #else
+  __pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression = &__pyx_type_5adaXT_7predict_7predict_PredictLinearRegression;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  __pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression->tp_base = __pyx_ptype_5adaXT_7predict_7predict_PredictRegression;
+  #endif
+  #if !CYTHON_USE_TYPE_SPECS
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression) < 0) __PYX_ERR(0, 194, __pyx_L1_error)
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  __pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression->tp_print = 0;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression->tp_dictoffset && __pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression->tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  #endif
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression, __pyx_vtabptr_5adaXT_7predict_7predict_PredictLinearRegression) < 0) __PYX_ERR(0, 194, __pyx_L1_error)
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression) < 0) __PYX_ERR(0, 194, __pyx_L1_error)
+  #endif
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_PredictLinearRegression, (PyObject *) __pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression) < 0) __PYX_ERR(0, 194, __pyx_L1_error)
+  __pyx_vtabptr_5adaXT_7predict_7predict_PredictQuantile = &__pyx_vtable_5adaXT_7predict_7predict_PredictQuantile;
+  __pyx_vtable_5adaXT_7predict_7predict_PredictQuantile.__pyx_base = *__pyx_vtabptr_5adaXT_7predict_7predict_Predict;
+  #if CYTHON_USE_TYPE_SPECS
+  __pyx_t_1 = PyTuple_Pack(1, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 219, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_ptype_5adaXT_7predict_7predict_PredictQuantile = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_7predict_7predict_PredictQuantile_spec, __pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (unlikely(!__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile)) __PYX_ERR(0, 219, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_7predict_7predict_PredictQuantile_spec, __pyx_ptype_5adaXT_7predict_7predict_PredictQuantile) < 0) __PYX_ERR(0, 219, __pyx_L1_error)
+  #else
+  __pyx_ptype_5adaXT_7predict_7predict_PredictQuantile = &__pyx_type_5adaXT_7predict_7predict_PredictQuantile;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  __pyx_ptype_5adaXT_7predict_7predict_PredictQuantile->tp_base = __pyx_ptype_5adaXT_7predict_7predict_Predict;
+  #endif
+  #if !CYTHON_USE_TYPE_SPECS
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile) < 0) __PYX_ERR(0, 219, __pyx_L1_error)
+  #endif
+  #if PY_MAJOR_VERSION < 3
+  __pyx_ptype_5adaXT_7predict_7predict_PredictQuantile->tp_print = 0;
+  #endif
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile->tp_dictoffset && __pyx_ptype_5adaXT_7predict_7predict_PredictQuantile->tp_getattro == PyObject_GenericGetAttr)) {
+    __pyx_ptype_5adaXT_7predict_7predict_PredictQuantile->tp_getattro = __Pyx_PyObject_GenericGetAttr;
+  }
+  #endif
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile, __pyx_vtabptr_5adaXT_7predict_7predict_PredictQuantile) < 0) __PYX_ERR(0, 219, __pyx_L1_error)
+  #if !CYTHON_COMPILING_IN_LIMITED_API
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile) < 0) __PYX_ERR(0, 219, __pyx_L1_error)
+  #endif
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_PredictQuantile, (PyObject *) __pyx_ptype_5adaXT_7predict_7predict_PredictQuantile) < 0) __PYX_ERR(0, 219, __pyx_L1_error)
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
   #if CYTHON_USE_TYPE_SPECS
   __pyx_array_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_array_spec, NULL); if (unlikely(!__pyx_array_type)) __PYX_ERR(1, 114, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
   __pyx_array_type->tp_as_buffer = &__pyx_tp_as_buffer_array;
   if (!__pyx_array_type->tp_as_buffer->bf_releasebuffer && __pyx_array_type->tp_base->tp_as_buffer && __pyx_array_type->tp_base->tp_as_buffer->bf_releasebuffer) {
@@ -25073,31 +26474,31 @@
   return 0;
 }
 
 
 #if PY_MAJOR_VERSION >= 3
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
-static int __pyx_pymod_exec_DecisionTree(PyObject* module); /*proto*/
+static int __pyx_pymod_exec_predict(PyObject* module); /*proto*/
 static PyModuleDef_Slot __pyx_moduledef_slots[] = {
   {Py_mod_create, (void*)__pyx_pymod_create},
-  {Py_mod_exec, (void*)__pyx_pymod_exec_DecisionTree},
+  {Py_mod_exec, (void*)__pyx_pymod_exec_predict},
   {0, NULL}
 };
 #endif
 
 #ifdef __cplusplus
 namespace {
   struct PyModuleDef __pyx_moduledef =
   #else
   static struct PyModuleDef __pyx_moduledef =
   #endif
   {
       PyModuleDef_HEAD_INIT,
-      "DecisionTree",
+      "predict",
       0, /* m_doc */
     #if CYTHON_PEP489_MULTI_PHASE_INIT
       0, /* m_size */
     #elif CYTHON_USE_MODULE_STATE
       sizeof(__pyx_mstate), /* m_size */
     #else
       -1, /* m_size */
@@ -25137,19 +26538,19 @@
 #else
 #define __Pyx_PyMODINIT_FUNC PyObject *
 #endif
 #endif
 
 
 #if PY_MAJOR_VERSION < 3
-__Pyx_PyMODINIT_FUNC initDecisionTree(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC initDecisionTree(void)
+__Pyx_PyMODINIT_FUNC initpredict(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC initpredict(void)
 #else
-__Pyx_PyMODINIT_FUNC PyInit_DecisionTree(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC PyInit_DecisionTree(void)
+__Pyx_PyMODINIT_FUNC PyInit_predict(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC PyInit_predict(void)
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 {
   return PyModuleDef_Init(&__pyx_moduledef);
 }
 static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
     #if PY_VERSION_HEX >= 0x030700A1
     static PY_INT64_T main_interpreter_id = -1;
@@ -25222,15 +26623,15 @@
     return module;
 bad:
     Py_XDECREF(module);
     return NULL;
 }
 
 
-static CYTHON_SMALL_CODE int __pyx_pymod_exec_DecisionTree(PyObject *__pyx_pyinit_module)
+static CYTHON_SMALL_CODE int __pyx_pymod_exec_predict(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
   int stringtab_initialized = 0;
   #if CYTHON_USE_MODULE_STATE
   int pystate_addmodule_run = 0;
   #endif
@@ -25238,43 +26639,40 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_t_6;
   PyObject *__pyx_t_7 = NULL;
   static PyThread_type_lock __pyx_t_8[8];
-  double __pyx_t_9;
-  PyObject *__pyx_t_10 = NULL;
-  PyObject *__pyx_t_11 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   if (__pyx_m) {
     if (__pyx_m == __pyx_pyinit_module) return 0;
-    PyErr_SetString(PyExc_RuntimeError, "Module 'DecisionTree' has already been imported. Re-initialisation is not supported.");
+    PyErr_SetString(PyExc_RuntimeError, "Module 'predict' has already been imported. Re-initialisation is not supported.");
     return -1;
   }
   #elif PY_MAJOR_VERSION >= 3
   if (__pyx_m) return __Pyx_NewRef(__pyx_m);
   #endif
   /*--- Module creation code ---*/
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   __pyx_m = __pyx_pyinit_module;
   Py_INCREF(__pyx_m);
   #else
   #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4("DecisionTree", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  __pyx_m = Py_InitModule4("predict", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
   if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
   #elif CYTHON_USE_MODULE_STATE
   __pyx_t_1 = PyModule_Create(&__pyx_moduledef); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   {
     int add_module_result = PyState_AddModule(__pyx_t_1, &__pyx_moduledef);
-    __pyx_t_1 = 0; /* transfer ownership from __pyx_t_1 to "DecisionTree" pseudovariable */
+    __pyx_t_1 = 0; /* transfer ownership from __pyx_t_1 to "predict" pseudovariable */
     if (unlikely((add_module_result < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
     pystate_addmodule_run = 1;
   }
   #else
   __pyx_m = PyModule_Create(&__pyx_moduledef);
   if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
@@ -25290,15 +26688,15 @@
 if (!__Pyx_RefNanny) {
   PyErr_Clear();
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
   if (!__Pyx_RefNanny)
       Py_FatalError("failed to import 'refnanny' module");
 }
 #endif
-  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_DecisionTree(void)", 0);
+  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_predict(void)", 0);
   if (__Pyx_check_binary_version(__PYX_LIMITED_VERSION_HEX, __Pyx_get_runtime_version(), CYTHON_COMPILING_IN_LIMITED_API) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pxy_PyFrame_Initialize_Offsets
   __Pxy_PyFrame_Initialize_Offsets();
   #endif
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -25328,22 +26726,22 @@
   /*--- Initialize various global constants etc. ---*/
   if (__Pyx_InitConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   stringtab_initialized = 1;
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
-  if (__pyx_module_is_main_adaXT__decision_tree__DecisionTree) {
+  if (__pyx_module_is_main_adaXT__predict__predict) {
     if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name_2, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
     PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
-    if (!PyDict_GetItemString(modules, "adaXT.decision_tree.DecisionTree")) {
-      if (unlikely((PyDict_SetItemString(modules, "adaXT.decision_tree.DecisionTree", __pyx_m) < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
+    if (!PyDict_GetItemString(modules, "adaXT.predict.predict")) {
+      if (unlikely((PyDict_SetItemString(modules, "adaXT.predict.predict", __pyx_m) < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
   if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
   if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -25379,33 +26777,33 @@
       /* "View.MemoryView":100
  * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
  * try:
  *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
  *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
  *     else:
  */
-      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 100, __pyx_L2_error)
+      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 100, __pyx_L2_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_version_info); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 100, __pyx_L2_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-      __pyx_t_4 = PyObject_RichCompare(__pyx_t_5, __pyx_tuple__18, Py_GE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 100, __pyx_L2_error)
+      __pyx_t_4 = PyObject_RichCompare(__pyx_t_5, __pyx_tuple__15, Py_GE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 100, __pyx_L2_error)
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
       __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_6 < 0))) __PYX_ERR(1, 100, __pyx_L2_error)
       __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       if (__pyx_t_6) {
 
         /* "View.MemoryView":101
  * try:
  *     if __import__("sys").version_info >= (3, 3):
  *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence             # <<<<<<<<<<<<<<
  *     else:
  *         __pyx_collections_abc_Sequence = __import__("collections").Sequence
  */
-        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 101, __pyx_L2_error)
+        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 101, __pyx_L2_error)
         __Pyx_GOTREF(__pyx_t_4);
         __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_abc); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 101, __pyx_L2_error)
         __Pyx_GOTREF(__pyx_t_5);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
         __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_Sequence); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 101, __pyx_L2_error)
         __Pyx_GOTREF(__pyx_t_4);
         __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
@@ -25428,15 +26826,15 @@
  *         __pyx_collections_abc_Sequence = __import__("collections.abc").abc.Sequence
  *     else:
  *         __pyx_collections_abc_Sequence = __import__("collections").Sequence             # <<<<<<<<<<<<<<
  * except:
  * 
  */
       /*else*/ {
-        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 103, __pyx_L2_error)
+        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin___import__, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 103, __pyx_L2_error)
         __Pyx_GOTREF(__pyx_t_4);
         __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_Sequence); if (unlikely(!__pyx_t_5)) __PYX_ERR(1, 103, __pyx_L2_error)
         __Pyx_GOTREF(__pyx_t_5);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
         __Pyx_XGOTREF(__pyx_collections_abc_Sequence);
         __Pyx_DECREF_SET(__pyx_collections_abc_Sequence, __pyx_t_5);
         __Pyx_GIVEREF(__pyx_t_5);
@@ -25593,71 +26991,71 @@
   /* "View.MemoryView":309
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 309, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 309, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_XGOTREF(generic);
   __Pyx_DECREF_SET(generic, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
   __pyx_t_7 = 0;
 
   /* "View.MemoryView":310
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 310, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 310, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_XGOTREF(strided);
   __Pyx_DECREF_SET(strided, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
   __pyx_t_7 = 0;
 
   /* "View.MemoryView":311
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 311, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 311, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_XGOTREF(indirect);
   __Pyx_DECREF_SET(indirect, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
   __pyx_t_7 = 0;
 
   /* "View.MemoryView":314
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 314, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 314, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_XGOTREF(contiguous);
   __Pyx_DECREF_SET(contiguous, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
   __pyx_t_7 = 0;
 
   /* "View.MemoryView":315
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 315, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 315, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_XGOTREF(indirect_contiguous);
   __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
   __pyx_t_7 = 0;
 
   /* "View.MemoryView":323
@@ -25869,444 +27267,375 @@
  *     cdef object __pyx_result
  */
   __pyx_t_7 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_7) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":4
- * 
- * # General
+  /* "adaXT/predict/predict.pyx":2
+ * # cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False
  * import numpy as np             # <<<<<<<<<<<<<<
  * from numpy import float64 as DOUBLE
- * import sys
+ * from ..decision_tree.nodes import DecisionNode
  */
-  __pyx_t_7 = __Pyx_ImportDottedModule(__pyx_n_s_numpy, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_ImportDottedModule(__pyx_n_s_numpy, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_7) < 0) __PYX_ERR(0, 4, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_7) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":5
- * # General
+  /* "adaXT/predict/predict.pyx":3
+ * # cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False
  * import numpy as np
  * from numpy import float64 as DOUBLE             # <<<<<<<<<<<<<<
- * import sys
+ * from ..decision_tree.nodes import DecisionNode
  * 
  */
-  __pyx_t_7 = PyList_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 5, __pyx_L1_error)
+  __pyx_t_7 = PyList_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_n_s_float64);
   __Pyx_GIVEREF(__pyx_n_s_float64);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_7, 0, __pyx_n_s_float64)) __PYX_ERR(0, 5, __pyx_L1_error);
-  __pyx_t_4 = __Pyx_Import(__pyx_n_s_numpy, __pyx_t_7, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5, __pyx_L1_error)
+  if (__Pyx_PyList_SET_ITEM(__pyx_t_7, 0, __pyx_n_s_float64)) __PYX_ERR(0, 3, __pyx_L1_error);
+  __pyx_t_4 = __Pyx_Import(__pyx_n_s_numpy, __pyx_t_7, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_float64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 5, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_float64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DOUBLE, __pyx_t_7) < 0) __PYX_ERR(0, 5, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DOUBLE, __pyx_t_7) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":6
+  /* "adaXT/predict/predict.pyx":4
  * import numpy as np
  * from numpy import float64 as DOUBLE
- * import sys             # <<<<<<<<<<<<<<
+ * from ..decision_tree.nodes import DecisionNode             # <<<<<<<<<<<<<<
  * 
- * # Custom
+ * cdef class Predict():
  */
-  __pyx_t_4 = __Pyx_ImportDottedModule(__pyx_n_s_sys, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 6, __pyx_L1_error)
+  __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_INCREF(__pyx_n_s_DecisionNode);
+  __Pyx_GIVEREF(__pyx_n_s_DecisionNode);
+  if (__Pyx_PyList_SET_ITEM(__pyx_t_4, 0, __pyx_n_s_DecisionNode)) __PYX_ERR(0, 4, __pyx_L1_error);
+  __pyx_t_7 = __Pyx_Import(__pyx_n_s_decision_tree_nodes, __pyx_t_4, 2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = __Pyx_ImportFrom(__pyx_t_7, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sys, __pyx_t_4) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DecisionNode, __pyx_t_4) < 0) __PYX_ERR(0, 4, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":9
+  /* "adaXT/predict/predict.pyx":14
+ *         self.root = root
+ * 
+ *     def __reduce__(self):             # <<<<<<<<<<<<<<
+ *         return (self.__class__, (self.X.base, self.Y.base, self.root))
  * 
- * # Custom
- * from .splitter import Splitter             # <<<<<<<<<<<<<<
- * from ..criteria import Criteria
- * from .DepthTreeBuilder import DepthTreeBuilder
  */
-  __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 9, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_INCREF(__pyx_n_s_Splitter);
-  __Pyx_GIVEREF(__pyx_n_s_Splitter);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_4, 0, __pyx_n_s_Splitter)) __PYX_ERR(0, 9, __pyx_L1_error);
-  __pyx_t_7 = __Pyx_Import(__pyx_n_s_splitter, __pyx_t_4, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 9, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_7Predict_3__reduce__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Predict___reduce, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__26)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 14, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_ImportFrom(__pyx_t_7, __pyx_n_s_Splitter); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 9, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Splitter, __pyx_t_4) < 0) __PYX_ERR(0, 9, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_reduce, __pyx_t_7) < 0) __PYX_ERR(0, 14, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_Predict);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":10
- * # Custom
- * from .splitter import Splitter
- * from ..criteria import Criteria             # <<<<<<<<<<<<<<
- * from .DepthTreeBuilder import DepthTreeBuilder
- * from .Nodes import DecisionNode
+  /* "adaXT/predict/predict.pyx":31
+ *         return X
+ * 
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")
+ * 
  */
-  __pyx_t_7 = PyList_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 10, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_7Predict_5predict, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Predict_predict, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__28)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 31, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_INCREF(__pyx_n_s_Criteria);
-  __Pyx_GIVEREF(__pyx_n_s_Criteria);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_7, 0, __pyx_n_s_Criteria)) __PYX_ERR(0, 10, __pyx_L1_error);
-  __pyx_t_4 = __Pyx_Import(__pyx_n_s_criteria, __pyx_t_7, 2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 10, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_predict, __pyx_t_7) < 0) __PYX_ERR(0, 31, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_Criteria); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 10, __pyx_L1_error)
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_Predict);
+
+  /* "adaXT/predict/predict.pyx":34
+ *         raise NotImplementedError("Function predict is not implemented for this Predict class")
+ * 
+ *     cpdef list predict_proba(self, object X):             # <<<<<<<<<<<<<<
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")
+ * 
+ */
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_7Predict_7predict_proba, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Predict_predict_proba, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__30)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 34, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Criteria, __pyx_t_7) < 0) __PYX_ERR(0, 10, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_predict_proba, __pyx_t_7) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_Predict);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":11
- * from .splitter import Splitter
- * from ..criteria import Criteria
- * from .DepthTreeBuilder import DepthTreeBuilder             # <<<<<<<<<<<<<<
- * from .Nodes import DecisionNode
+  /* "adaXT/predict/predict.pyx":37
+ *         raise NotImplementedError("Function predict_proba is not implemented for this Predict class")
  * 
+ *     cpdef double[:, ::1] predict_leaf_matrix(self, object X, bint scale = False):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i
  */
-  __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 11, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_INCREF(__pyx_n_s_DepthTreeBuilder);
-  __Pyx_GIVEREF(__pyx_n_s_DepthTreeBuilder);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_4, 0, __pyx_n_s_DepthTreeBuilder)) __PYX_ERR(0, 11, __pyx_L1_error);
-  __pyx_t_7 = __Pyx_Import(__pyx_n_s_DepthTreeBuilder, __pyx_t_4, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 11, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_7Predict_9predict_leaf_matrix, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Predict_predict_leaf_matrix, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__32)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 37, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_ImportFrom(__pyx_t_7, __pyx_n_s_DepthTreeBuilder); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 11, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DepthTreeBuilder, __pyx_t_4) < 0) __PYX_ERR(0, 11, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_7, __pyx_tuple__33);
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_predict_leaf_matrix, __pyx_t_7) < 0) __PYX_ERR(0, 37, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_Predict);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":12
- * from ..criteria import Criteria
- * from .DepthTreeBuilder import DepthTreeBuilder
- * from .Nodes import DecisionNode             # <<<<<<<<<<<<<<
+  /* "adaXT/predict/predict.pyx":75
+ *         return matrix
  * 
- * cdef double EPSILON = np.finfo('double').eps
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  */
-  __pyx_t_7 = PyList_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 12, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 75, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_INCREF(__pyx_n_s_DecisionNode);
-  __Pyx_GIVEREF(__pyx_n_s_DecisionNode);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_7, 0, __pyx_n_s_DecisionNode)) __PYX_ERR(0, 12, __pyx_L1_error);
-  __pyx_t_4 = __Pyx_Import(__pyx_n_s_Nodes, __pyx_t_7, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 12, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_predictions, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_7Predict_11forest_predict, __Pyx_CYFUNCTION_STATICMETHOD | __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Predict_forest_predict, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__35)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 75, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_7);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_ImportFrom(__pyx_t_4, __pyx_n_s_DecisionNode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 12, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_forest_predict, __pyx_t_4) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_Predict);
+  __Pyx_GetNameInClass(__pyx_t_4, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_forest_predict); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 75, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DecisionNode, __pyx_t_7) < 0) __PYX_ERR(0, 12, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_forest_predict, __pyx_t_7) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_Predict);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":14
- * from .Nodes import DecisionNode
- * 
- * cdef double EPSILON = np.finfo('double').eps             # <<<<<<<<<<<<<<
- * 
+  /* "adaXT/predict/predict.pyx":79
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  * 
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         raise NotImplementedError("The forest predict function is not implemented for this Predict Class")
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 14, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_finfo); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 14, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 79, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 14, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_predictions, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 79, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_7Predict_13forest_predict_proba, __Pyx_CYFUNCTION_STATICMETHOD | __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Predict_forest_predict_proba, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 79, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_7);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_eps); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 14, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_forest_predict_proba, __pyx_t_4) < 0) __PYX_ERR(0, 79, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_Predict);
+  __Pyx_GetNameInClass(__pyx_t_4, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_forest_predict_proba); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 79, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 79, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_9 = __pyx_PyFloat_AsDouble(__pyx_t_7); if (unlikely((__pyx_t_9 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 14, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_Predict, __pyx_n_s_forest_predict_proba, __pyx_t_7) < 0) __PYX_ERR(0, 79, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_v_5adaXT_13decision_tree_12DecisionTree_EPSILON = __pyx_t_9;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_Predict);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":17
- * 
+  /* "adaXT/predict/predict.pyx":96
+ *         return cur_max
  * 
- * class DecisionTree:             # <<<<<<<<<<<<<<
- *     def __init__(
- *             self,
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, idx, n_obs
  */
-  __pyx_t_7 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_DecisionTree, __pyx_n_s_DecisionTree, (PyObject *) NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, (PyObject *) NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 17, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_3predict, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_PredictClassification_predict, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__38)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 96, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictClassification, __pyx_n_s_predict, __pyx_t_7) < 0) __PYX_ERR(0, 96, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictClassification);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":18
+  /* "adaXT/predict/predict.pyx":123
+ *         return Y
  * 
- * class DecisionTree:
- *     def __init__(             # <<<<<<<<<<<<<<
- *             self,
- *             tree_type: str,
+ *     cpdef list predict_proba(self, object X):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, n_obs
  */
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(9); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 18, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_tree_type, __pyx_n_s_str) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_criteria, __pyx_n_s_Criteria) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_max_depth, __pyx_n_s_int) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_impurity_tol, __pyx_n_s_float) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_min_samples_split, __pyx_n_s_int) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_min_samples_leaf, __pyx_n_s_int) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_min_improvement, __pyx_n_s_float) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_splitter, __pyx_kp_s_Splitter_None) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_return, __pyx_n_s_None) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_1__init__, 0, __pyx_n_s_DecisionTree___init, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__30)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 18, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  if (!__Pyx_CyFunction_InitDefaults(__pyx_t_5, sizeof(__pyx_defaults), 3)) __PYX_ERR(0, 18, __pyx_L1_error)
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":22
- *             tree_type: str,
- *             criteria: Criteria,
- *             max_depth: int = sys.maxsize,             # <<<<<<<<<<<<<<
- *             impurity_tol: float = 0,
- *             min_samples_split: int = 1,
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_sys); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 22, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_10);
-  __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_maxsize); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 22, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_11);
-  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-  if (!(likely(__Pyx_Py3Int_CheckExact(__pyx_t_11))||((__pyx_t_11) == Py_None) || __Pyx_RaiseUnexpectedTypeError("int", __pyx_t_11))) __PYX_ERR(0, 22, __pyx_L1_error)
-  __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_t_5)->__pyx_arg_max_depth = ((PyObject*)__pyx_t_11);
-  __Pyx_GIVEREF(__pyx_t_11);
-  __pyx_t_11 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":24
- *             max_depth: int = sys.maxsize,
- *             impurity_tol: float = 0,
- *             min_samples_split: int = 1,             # <<<<<<<<<<<<<<
- *             min_samples_leaf: int = 1,
- *             min_improvement: float = 0,
- */
-  if (!(likely(__Pyx_Py3Int_CheckExact(__pyx_int_1)) || __Pyx_RaiseUnexpectedTypeError("int", __pyx_int_1))) __PYX_ERR(0, 24, __pyx_L1_error)
-  __Pyx_INCREF(__pyx_int_1);
-  __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_t_5)->__pyx_arg_min_samples_split = ((PyObject*)__pyx_int_1);
-  __Pyx_GIVEREF(__pyx_int_1);
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":25
- *             impurity_tol: float = 0,
- *             min_samples_split: int = 1,
- *             min_samples_leaf: int = 1,             # <<<<<<<<<<<<<<
- *             min_improvement: float = 0,
- *             splitter: Splitter | None = None) -> None:
- */
-  if (!(likely(__Pyx_Py3Int_CheckExact(__pyx_int_1)) || __Pyx_RaiseUnexpectedTypeError("int", __pyx_int_1))) __PYX_ERR(0, 25, __pyx_L1_error)
-  __Pyx_INCREF(__pyx_int_1);
-  __Pyx_CyFunction_Defaults(__pyx_defaults, __pyx_t_5)->__pyx_arg_min_samples_leaf = ((PyObject*)__pyx_int_1);
-  __Pyx_GIVEREF(__pyx_int_1);
-  __Pyx_CyFunction_SetDefaultsGetter(__pyx_t_5, __pyx_pf_5adaXT_13decision_tree_12DecisionTree___defaults__);
-  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_5, __pyx_t_4);
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_init, __pyx_t_5) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_5predict_proba, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_PredictClassification_predict_pr, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__39)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 123, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictClassification, __pyx_n_s_predict_proba, __pyx_t_7) < 0) __PYX_ERR(0, 123, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictClassification);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":47
- *         self.splitter = splitter
+  /* "adaXT/predict/predict.pyx":147
+ *         return ret_val
  * 
- *     def __check_input(self, X: object, Y: object):             # <<<<<<<<<<<<<<
- *         # Make sure input arrays are c contigous
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         def __most_frequent_element(arr):
  */
-  __pyx_t_5 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 47, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_X, __pyx_n_s_object) < 0) __PYX_ERR(0, 47, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_Y, __pyx_n_s_object) < 0) __PYX_ERR(0, 47, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_3__check_input, 0, __pyx_n_s_DecisionTree___check_input, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__32)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 47, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 147, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_predictions, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 147, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_7forest_predict, __Pyx_CYFUNCTION_STATICMETHOD | __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_PredictClassification_forest_pre, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__41)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_5);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_DecisionTree__check_input, __pyx_t_4) < 0) __PYX_ERR(0, 47, __pyx_L1_error)
+  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_7);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictClassification, __pyx_n_s_forest_predict, __pyx_t_4) < 0) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":67
- *         return X, Y
- * 
- *     def __check_sample_weight(self, sample_weight: np.ndarray, n_samples):             # <<<<<<<<<<<<<<
- * 
- *         if sample_weight is None:
- */
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 67, __pyx_L1_error)
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictClassification);
+  __Pyx_GetNameInClass(__pyx_t_4, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictClassification, __pyx_n_s_forest_predict); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_sample_weight, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_5__check_sample_weight, 0, __pyx_n_s_DecisionTree___check_sample_weig, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__34)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 67, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_5, __pyx_t_4);
+  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 147, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_DecisionTree__check_sample_weig, __pyx_t_5) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":78
- *         return sample_weight
- * 
- *     def __check_dimensions(self, double[:, :] X):             # <<<<<<<<<<<<<<
- *         X = np.ascontiguousarray(X, dtype=DOUBLE)
- *         # If there is only a single point
- */
-  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_7__check_dimensions, 0, __pyx_n_s_DecisionTree___check_dimensions, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__36)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 78, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_DecisionTree__check_dimensions, __pyx_t_5) < 0) __PYX_ERR(0, 78, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictClassification, __pyx_n_s_forest_predict, __pyx_t_7) < 0) __PYX_ERR(0, 147, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictClassification);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":92
- *         return X
+  /* "adaXT/predict/predict.pyx":156
+ *         )
  * 
- *     def fit(             # <<<<<<<<<<<<<<
- *             self,
- *             X,
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict_proba(predictions: np.ndarray, **kwargs):
+ *         # Stack the predict_probas
  */
-  __pyx_t_5 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 92, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_feature_indices, __pyx_kp_s_np_ndarray_None) < 0) __PYX_ERR(0, 92, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_sample_indices, __pyx_kp_s_np_ndarray_None) < 0) __PYX_ERR(0, 92, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_sample_weight, __pyx_kp_s_np_ndarray_None) < 0) __PYX_ERR(0, 92, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_return, __pyx_n_s_None) < 0) __PYX_ERR(0, 92, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_9fit, 0, __pyx_n_s_DecisionTree_fit, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__38)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 92, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 156, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_predictions, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 156, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_21PredictClassification_9forest_predict_proba, __Pyx_CYFUNCTION_STATICMETHOD | __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_PredictClassification_forest_pre_2, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__43)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 156, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_4, __pyx_tuple__39);
-  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_5);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_fit, __pyx_t_4) < 0) __PYX_ERR(0, 92, __pyx_L1_error)
+  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_7);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictClassification, __pyx_n_s_forest_predict_proba, __pyx_t_4) < 0) __PYX_ERR(0, 156, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":118
- *         builder.build_tree(self)
- * 
- *     def predict(self, X: np.ndarray):             # <<<<<<<<<<<<<<
- *         cdef:
- *             int i, cur_split_idx, idx, n_obs
- */
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 118, __pyx_L1_error)
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictClassification);
+  __Pyx_GetNameInClass(__pyx_t_4, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictClassification, __pyx_n_s_forest_predict_proba); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 156, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_X, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 118, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_11predict, 0, __pyx_n_s_DecisionTree_predict, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__41)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 118, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_5, __pyx_t_4);
+  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 156, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_predict, __pyx_t_5) < 0) __PYX_ERR(0, 118, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictClassification, __pyx_n_s_forest_predict_proba, __pyx_t_7) < 0) __PYX_ERR(0, 156, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictClassification);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":149
- *         return np.asarray(Y)
+  /* "adaXT/predict/predict.pyx":166
  * 
- *     def predict_proba(self, X: np.ndarray):             # <<<<<<<<<<<<<<
+ * cdef class PredictRegression(Predict):
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
  *         cdef:
  *             int i, cur_split_idx, n_obs
  */
-  __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 149, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_X, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 149, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_13predict_proba, 0, __pyx_n_s_DecisionTree_predict_proba, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__43)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 149, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_5);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_predict_proba, __pyx_t_4) < 0) __PYX_ERR(0, 149, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_17PredictRegression_1predict, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_PredictRegression_predict, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__45)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 166, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictRegression, __pyx_n_s_predict, __pyx_t_7) < 0) __PYX_ERR(0, 166, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictRegression);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":180
- *         return np.asarray(ret_val)
+  /* "adaXT/predict/predict.pyx":190
+ *         return Y
  * 
- *     def __find_max_index(self, lst):             # <<<<<<<<<<<<<<
- *         cur_max = 0
- *         for i in range(1, len(lst)):
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         return np.mean(predictions, axis=1)
  */
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_15__find_max_index, 0, __pyx_n_s_DecisionTree___find_max_index, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__45)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 180, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_predictions, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 190, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_17PredictRegression_3forest_predict, __Pyx_CYFUNCTION_STATICMETHOD | __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_PredictRegression_forest_predict, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__46)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 190, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_DecisionTree__find_max_index, __pyx_t_4) < 0) __PYX_ERR(0, 180, __pyx_L1_error)
+  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_7);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictRegression, __pyx_n_s_forest_predict, __pyx_t_4) < 0) __PYX_ERR(0, 190, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-
-  /* "adaXT/decision_tree/DecisionTree.pyx":187
- *         return cur_max
- * 
- *     def get_leaf_matrix(self, scale: bool = False) -> np.ndarray:             # <<<<<<<<<<<<<<
- *         if not self.root:
- *             raise ValueError("The tree has not been trained before trying to predict")
- */
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 187, __pyx_L1_error)
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictRegression);
+  __Pyx_GetNameInClass(__pyx_t_4, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictRegression, __pyx_n_s_forest_predict); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 190, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_scale, __pyx_n_s_bool) < 0) __PYX_ERR(0, 187, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_return, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 187, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_17get_leaf_matrix, 0, __pyx_n_s_DecisionTree_get_leaf_matrix, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__47)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 187, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_5, __pyx_tuple__48);
-  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_5, __pyx_t_4);
+  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 190, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_get_leaf_matrix, __pyx_t_5) < 0) __PYX_ERR(0, 187, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictRegression, __pyx_n_s_forest_predict, __pyx_t_7) < 0) __PYX_ERR(0, 190, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictRegression);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":206
- *         return matrix
+  /* "adaXT/predict/predict.pyx":195
  * 
- *     def predict_leaf_matrix(self, X: np.ndarray, scale: bool = False):             # <<<<<<<<<<<<<<
+ * cdef class PredictLinearRegression(PredictRegression):
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
  *         cdef:
- *             int i
+ *             int i, cur_split_idx, n_obs
  */
-  __pyx_t_5 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 206, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_5);
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_X, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 206, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_scale, __pyx_n_s_bool) < 0) __PYX_ERR(0, 206, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_12DecisionTree_12DecisionTree_19predict_leaf_matrix, 0, __pyx_n_s_DecisionTree_predict_leaf_matrix, NULL, __pyx_n_s_adaXT_decision_tree_DecisionTree, __pyx_d, ((PyObject *)__pyx_codeobj__50)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 206, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_4, __pyx_tuple__48);
-  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_5);
-  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_predict_leaf_matrix, __pyx_t_4) < 0) __PYX_ERR(0, 206, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_23PredictLinearRegression_1predict, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_PredictLinearRegression_predict, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__47)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 195, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression, __pyx_n_s_predict, __pyx_t_7) < 0) __PYX_ERR(0, 195, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictLinearRegression);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":17
+  /* "adaXT/predict/predict.pyx":221
+ * cdef class PredictQuantile(Predict):
  * 
+ *     def predict(self, object X, **kwargs):             # <<<<<<<<<<<<<<
+ *         cdef:
+ *             int i, cur_split_idx, n_obs
+ */
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_15PredictQuantile_1predict, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_PredictQuantile_predict, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__49)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 221, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile, __pyx_n_s_predict, __pyx_t_7) < 0) __PYX_ERR(0, 221, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile);
+
+  /* "adaXT/predict/predict.pyx":256
+ *         return Y
  * 
- * class DecisionTree:             # <<<<<<<<<<<<<<
- *     def __init__(
- *             self,
+ *     @staticmethod             # <<<<<<<<<<<<<<
+ *     def forest_predict(predictions: np.ndarray, **kwargs):
+ *         quantile = <double> kwargs['quantile']
  */
-  __pyx_t_4 = __Pyx_Py3ClassCreate(((PyObject*)&PyType_Type), __pyx_n_s_DecisionTree, __pyx_empty_tuple, __pyx_t_7, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 17, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 256, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_predictions, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 256, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_7predict_7predict_15PredictQuantile_3forest_predict, __Pyx_CYFUNCTION_STATICMETHOD | __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_PredictQuantile_forest_predict, NULL, __pyx_n_s_adaXT_predict_predict, __pyx_d, ((PyObject *)__pyx_codeobj__51)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 256, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_7);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile, __pyx_n_s_forest_predict, __pyx_t_4) < 0) __PYX_ERR(0, 256, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile);
+  __Pyx_GetNameInClass(__pyx_t_4, (PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile, __pyx_n_s_forest_predict); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 256, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DecisionTree, __pyx_t_4) < 0) __PYX_ERR(0, 17, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_staticmethod, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 256, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile, __pyx_n_s_forest_predict, __pyx_t_7) < 0) __PYX_ERR(0, 256, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  PyType_Modified(__pyx_ptype_5adaXT_7predict_7predict_PredictQuantile);
 
-  /* "adaXT/decision_tree/DecisionTree.pyx":1
+  /* "adaXT/predict/predict.pyx":1
  * # cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False             # <<<<<<<<<<<<<<
- * 
- * # General
+ * import numpy as np
+ * from numpy import float64 as DOUBLE
  */
   __pyx_t_7 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_7) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_7);
-  __Pyx_XDECREF(__pyx_t_10);
-  __Pyx_XDECREF(__pyx_t_11);
   if (__pyx_m) {
     if (__pyx_d && stringtab_initialized) {
-      __Pyx_AddTraceback("init adaXT.decision_tree.DecisionTree", __pyx_clineno, __pyx_lineno, __pyx_filename);
+      __Pyx_AddTraceback("init adaXT.predict.predict", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
     #if !CYTHON_USE_MODULE_STATE
     Py_CLEAR(__pyx_m);
     #else
     Py_DECREF(__pyx_m);
     if (pystate_addmodule_run) {
       PyObject *tp, *value, *tb;
       PyErr_Fetch(&tp, &value, &tb);
       PyState_RemoveModule(&__pyx_moduledef);
       PyErr_Restore(tp, value, tb);
     }
     #endif
   } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init adaXT.decision_tree.DecisionTree");
+    PyErr_SetString(PyExc_ImportError, "init adaXT.predict.predict");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
   #elif PY_MAJOR_VERSION >= 3
   return __pyx_m;
@@ -28761,100 +30090,14 @@
     } else {
         Py_DECREF(r);
         return 1;
     }
 }
 #endif
 
-/* PyObjectSetAttrStr */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_setattro))
-        return tp->tp_setattro(obj, attr_name, value);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_setattr))
-        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
-#endif
-    return PyObject_SetAttr(obj, attr_name, value);
-}
-#endif
-
-/* PyIntCompare */
-static CYTHON_INLINE int __Pyx_PyInt_BoolEqCObj(PyObject *op1, PyObject *op2, long intval, long inplace) {
-    CYTHON_MAYBE_UNUSED_VAR(intval);
-    CYTHON_UNUSED_VAR(inplace);
-    if (op1 == op2) {
-        return 1;
-    }
-    #if PY_MAJOR_VERSION < 3
-    if (likely(PyInt_CheckExact(op2))) {
-        const long a = intval;
-        long b = PyInt_AS_LONG(op2);
-        return (a == b);
-    }
-    #endif
-    #if CYTHON_USE_PYLONG_INTERNALS
-    if (likely(PyLong_CheckExact(op2))) {
-        int unequal;
-        unsigned long uintval;
-        Py_ssize_t size = __Pyx_PyLong_DigitCount(op2);
-        const digit* digits = __Pyx_PyLong_Digits(op2);
-        if (intval == 0) {
-            return (__Pyx_PyLong_IsZero(op2) == 1);
-        } else if (intval < 0) {
-            if (__Pyx_PyLong_IsNonNeg(op2))
-                return 0;
-            intval = -intval;
-        } else {
-            if (__Pyx_PyLong_IsNeg(op2))
-                return 0;
-        }
-        uintval = (unsigned long) intval;
-#if PyLong_SHIFT * 4 < SIZEOF_LONG*8
-        if (uintval >> (PyLong_SHIFT * 4)) {
-            unequal = (size != 5) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
-                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[4] != ((uintval >> (4 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
-        } else
-#endif
-#if PyLong_SHIFT * 3 < SIZEOF_LONG*8
-        if (uintval >> (PyLong_SHIFT * 3)) {
-            unequal = (size != 4) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
-                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
-        } else
-#endif
-#if PyLong_SHIFT * 2 < SIZEOF_LONG*8
-        if (uintval >> (PyLong_SHIFT * 2)) {
-            unequal = (size != 3) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
-                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
-        } else
-#endif
-#if PyLong_SHIFT * 1 < SIZEOF_LONG*8
-        if (uintval >> (PyLong_SHIFT * 1)) {
-            unequal = (size != 2) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
-                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
-        } else
-#endif
-            unequal = (size != 1) || (((unsigned long) digits[0]) != (uintval & (unsigned long) PyLong_MASK));
-        return (unequal == 0);
-    }
-    #endif
-    if (PyFloat_CheckExact(op2)) {
-        const long a = intval;
-#if CYTHON_COMPILING_IN_LIMITED_API
-        double b = __pyx_PyFloat_AsDouble(op2);
-#else
-        double b = PyFloat_AS_DOUBLE(op2);
-#endif
-        return ((double)a == (double)b);
-    }
-    return __Pyx_PyObject_IsTrueAndDecref(
-        PyObject_RichCompare(op1, op2, Py_EQ));
-}
-
 /* PyIntCompare */
 static CYTHON_INLINE int __Pyx_PyInt_BoolEqObjC(PyObject *op1, PyObject *op2, long intval, long inplace) {
     CYTHON_MAYBE_UNUSED_VAR(intval);
     CYTHON_UNUSED_VAR(inplace);
     if (op1 == op2) {
         return 1;
     }
@@ -28919,39 +30162,14 @@
 #endif
         return ((double)a == (double)b);
     }
     return __Pyx_PyObject_IsTrueAndDecref(
         PyObject_RichCompare(op1, op2, Py_EQ));
 }
 
-/* IterFinish */
-static CYTHON_INLINE int __Pyx_IterFinish(void) {
-    PyObject* exc_type;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    exc_type = __Pyx_PyErr_CurrentExceptionType();
-    if (unlikely(exc_type)) {
-        if (unlikely(!__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)))
-            return -1;
-        __Pyx_PyErr_Clear();
-        return 0;
-    }
-    return 0;
-}
-
-/* UnpackItemEndCheck */
-static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
-    if (unlikely(retval)) {
-        Py_DECREF(retval);
-        __Pyx_RaiseTooManyValuesError(expected);
-        return -1;
-    }
-    return __Pyx_IterFinish();
-}
-
 /* UnpackUnboundCMethod */
 static PyObject *__Pyx_SelflessCall(PyObject *method, PyObject *args, PyObject *kwargs) {
     PyObject *result;
     PyObject *selfless_args = PyTuple_GetSlice(args, 1, PyTuple_Size(args));
     if (unlikely(!selfless_args)) return NULL;
     result = PyObject_Call(method, selfless_args, kwargs);
     Py_DECREF(selfless_args);
@@ -29057,14 +30275,29 @@
         return NULL;
     }
     Py_INCREF(value);
     return value;
 }
 #endif
 
+/* IterFinish */
+static CYTHON_INLINE int __Pyx_IterFinish(void) {
+    PyObject* exc_type;
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    exc_type = __Pyx_PyErr_CurrentExceptionType();
+    if (unlikely(exc_type)) {
+        if (unlikely(!__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)))
+            return -1;
+        __Pyx_PyErr_Clear();
+        return 0;
+    }
+    return 0;
+}
+
 /* PyObjectCallNoArg */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
     PyObject *arg[2] = {NULL, NULL};
     return __Pyx_PyObject_FastCall(func, arg + 1, 0 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
 }
 
 /* PyObjectGetMethod */
@@ -29180,14 +30413,24 @@
     if (unlikely(!method)) goto bad;
     result = __Pyx_PyObject_CallNoArg(method);
     Py_DECREF(method);
 bad:
     return result;
 }
 
+/* UnpackItemEndCheck */
+static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
+    if (unlikely(retval)) {
+        Py_DECREF(retval);
+        __Pyx_RaiseTooManyValuesError(expected);
+        return -1;
+    }
+    return __Pyx_IterFinish();
+}
+
 /* UnpackTupleError */
 static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
     if (t == Py_None) {
       __Pyx_RaiseNoneNotIterableError();
     } else if (PyTuple_GET_SIZE(t) < index) {
       __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
     } else {
@@ -29359,66 +30602,14 @@
         *pkey = next_item;
     } else {
         *pvalue = next_item;
     }
     return 1;
 }
 
-/* PyObject_GenericGetAttrNoDict */
-#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
-static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
-    __Pyx_TypeName type_name = __Pyx_PyType_GetName(tp);
-    PyErr_Format(PyExc_AttributeError,
-#if PY_MAJOR_VERSION >= 3
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%U'",
-                 type_name, attr_name);
-#else
-                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%.400s'",
-                 type_name, PyString_AS_STRING(attr_name));
-#endif
-    __Pyx_DECREF_TypeName(type_name);
-    return NULL;
-}
-static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
-    PyObject *descr;
-    PyTypeObject *tp = Py_TYPE(obj);
-    if (unlikely(!PyString_Check(attr_name))) {
-        return PyObject_GenericGetAttr(obj, attr_name);
-    }
-    assert(!tp->tp_dictoffset);
-    descr = _PyType_Lookup(tp, attr_name);
-    if (unlikely(!descr)) {
-        return __Pyx_RaiseGenericGetAttributeError(tp, attr_name);
-    }
-    Py_INCREF(descr);
-    #if PY_MAJOR_VERSION < 3
-    if (likely(PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS)))
-    #endif
-    {
-        descrgetfunc f = Py_TYPE(descr)->tp_descr_get;
-        if (unlikely(f)) {
-            PyObject *res = f(descr, obj, (PyObject *)tp);
-            Py_DECREF(descr);
-            return res;
-        }
-    }
-    return descr;
-}
-#endif
-
-/* PyObject_GenericGetAttr */
-#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
-static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name) {
-    if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
-        return PyObject_GenericGetAttr(obj, attr_name);
-    }
-    return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
-}
-#endif
-
 /* FixUpExtensionType */
 #if CYTHON_USE_TYPE_SPECS
 static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type) {
 #if PY_VERSION_HEX > 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
     CYTHON_UNUSED_VAR(spec);
     CYTHON_UNUSED_VAR(type);
 #else
@@ -29484,383 +30675,14 @@
             PyType_Modified(type);
     }
 #endif
     return 0;
 }
 #endif
 
-/* ValidateBasesTuple */
-#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
-static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases) {
-    Py_ssize_t i, n;
-#if CYTHON_ASSUME_SAFE_MACROS
-    n = PyTuple_GET_SIZE(bases);
-#else
-    n = PyTuple_Size(bases);
-    if (n < 0) return -1;
-#endif
-    for (i = 1; i < n; i++)
-    {
-#if CYTHON_AVOID_BORROWED_REFS
-        PyObject *b0 = PySequence_GetItem(bases, i);
-        if (!b0) return -1;
-#elif CYTHON_ASSUME_SAFE_MACROS
-        PyObject *b0 = PyTuple_GET_ITEM(bases, i);
-#else
-        PyObject *b0 = PyTuple_GetItem(bases, i);
-        if (!b0) return -1;
-#endif
-        PyTypeObject *b;
-#if PY_MAJOR_VERSION < 3
-        if (PyClass_Check(b0))
-        {
-            PyErr_Format(PyExc_TypeError, "base class '%.200s' is an old-style class",
-                         PyString_AS_STRING(((PyClassObject*)b0)->cl_name));
-#if CYTHON_AVOID_BORROWED_REFS
-            Py_DECREF(b0);
-#endif
-            return -1;
-        }
-#endif
-        b = (PyTypeObject*) b0;
-        if (!__Pyx_PyType_HasFeature(b, Py_TPFLAGS_HEAPTYPE))
-        {
-            __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
-            PyErr_Format(PyExc_TypeError,
-                "base class '" __Pyx_FMT_TYPENAME "' is not a heap type", b_name);
-            __Pyx_DECREF_TypeName(b_name);
-#if CYTHON_AVOID_BORROWED_REFS
-            Py_DECREF(b0);
-#endif
-            return -1;
-        }
-        if (dictoffset == 0)
-        {
-            Py_ssize_t b_dictoffset = 0;
-#if CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY
-            b_dictoffset = b->tp_dictoffset;
-#else
-            PyObject *py_b_dictoffset = PyObject_GetAttrString((PyObject*)b, "__dictoffset__");
-            if (!py_b_dictoffset) goto dictoffset_return;
-            b_dictoffset = PyLong_AsSsize_t(py_b_dictoffset);
-            Py_DECREF(py_b_dictoffset);
-            if (b_dictoffset == -1 && PyErr_Occurred()) goto dictoffset_return;
-#endif
-            if (b_dictoffset) {
-                {
-                    __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
-                    PyErr_Format(PyExc_TypeError,
-                        "extension type '%.200s' has no __dict__ slot, "
-                        "but base type '" __Pyx_FMT_TYPENAME "' has: "
-                        "either add 'cdef dict __dict__' to the extension type "
-                        "or add '__slots__ = [...]' to the base type",
-                        type_name, b_name);
-                    __Pyx_DECREF_TypeName(b_name);
-                }
-#if !(CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY)
-              dictoffset_return:
-#endif
-#if CYTHON_AVOID_BORROWED_REFS
-                Py_DECREF(b0);
-#endif
-                return -1;
-            }
-        }
-#if CYTHON_AVOID_BORROWED_REFS
-        Py_DECREF(b0);
-#endif
-    }
-    return 0;
-}
-#endif
-
-/* PyType_Ready */
-static int __Pyx_PyType_Ready(PyTypeObject *t) {
-#if CYTHON_USE_TYPE_SPECS || !(CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API) || defined(PYSTON_MAJOR_VERSION)
-    (void)__Pyx_PyObject_CallMethod0;
-#if CYTHON_USE_TYPE_SPECS
-    (void)__Pyx_validate_bases_tuple;
-#endif
-    return PyType_Ready(t);
-#else
-    int r;
-    PyObject *bases = __Pyx_PyType_GetSlot(t, tp_bases, PyObject*);
-    if (bases && unlikely(__Pyx_validate_bases_tuple(t->tp_name, t->tp_dictoffset, bases) == -1))
-        return -1;
-#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
-    {
-        int gc_was_enabled;
-    #if PY_VERSION_HEX >= 0x030A00b1
-        gc_was_enabled = PyGC_Disable();
-        (void)__Pyx_PyObject_CallMethod0;
-    #else
-        PyObject *ret, *py_status;
-        PyObject *gc = NULL;
-        #if PY_VERSION_HEX >= 0x030700a1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM+0 >= 0x07030400)
-        gc = PyImport_GetModule(__pyx_kp_u_gc);
-        #endif
-        if (unlikely(!gc)) gc = PyImport_Import(__pyx_kp_u_gc);
-        if (unlikely(!gc)) return -1;
-        py_status = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_isenabled);
-        if (unlikely(!py_status)) {
-            Py_DECREF(gc);
-            return -1;
-        }
-        gc_was_enabled = __Pyx_PyObject_IsTrue(py_status);
-        Py_DECREF(py_status);
-        if (gc_was_enabled > 0) {
-            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_disable);
-            if (unlikely(!ret)) {
-                Py_DECREF(gc);
-                return -1;
-            }
-            Py_DECREF(ret);
-        } else if (unlikely(gc_was_enabled == -1)) {
-            Py_DECREF(gc);
-            return -1;
-        }
-    #endif
-        t->tp_flags |= Py_TPFLAGS_HEAPTYPE;
-#if PY_VERSION_HEX >= 0x030A0000
-        t->tp_flags |= Py_TPFLAGS_IMMUTABLETYPE;
-#endif
-#else
-        (void)__Pyx_PyObject_CallMethod0;
-#endif
-    r = PyType_Ready(t);
-#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
-        t->tp_flags &= ~Py_TPFLAGS_HEAPTYPE;
-    #if PY_VERSION_HEX >= 0x030A00b1
-        if (gc_was_enabled)
-            PyGC_Enable();
-    #else
-        if (gc_was_enabled) {
-            PyObject *tp, *v, *tb;
-            PyErr_Fetch(&tp, &v, &tb);
-            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_enable);
-            if (likely(ret || r == -1)) {
-                Py_XDECREF(ret);
-                PyErr_Restore(tp, v, tb);
-            } else {
-                Py_XDECREF(tp);
-                Py_XDECREF(v);
-                Py_XDECREF(tb);
-                r = -1;
-            }
-        }
-        Py_DECREF(gc);
-    #endif
-    }
-#endif
-    return r;
-#endif
-}
-
-/* SetVTable */
-static int __Pyx_SetVtable(PyTypeObject *type, void *vtable) {
-    PyObject *ob = PyCapsule_New(vtable, 0, 0);
-    if (unlikely(!ob))
-        goto bad;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    if (unlikely(PyObject_SetAttr((PyObject *) type, __pyx_n_s_pyx_vtable, ob) < 0))
-#else
-    if (unlikely(PyDict_SetItem(type->tp_dict, __pyx_n_s_pyx_vtable, ob) < 0))
-#endif
-        goto bad;
-    Py_DECREF(ob);
-    return 0;
-bad:
-    Py_XDECREF(ob);
-    return -1;
-}
-
-/* GetVTable */
-static void* __Pyx_GetVtable(PyTypeObject *type) {
-    void* ptr;
-#if CYTHON_COMPILING_IN_LIMITED_API
-    PyObject *ob = PyObject_GetAttr((PyObject *)type, __pyx_n_s_pyx_vtable);
-#else
-    PyObject *ob = PyObject_GetItem(type->tp_dict, __pyx_n_s_pyx_vtable);
-#endif
-    if (!ob)
-        goto bad;
-    ptr = PyCapsule_GetPointer(ob, 0);
-    if (!ptr && !PyErr_Occurred())
-        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
-    Py_DECREF(ob);
-    return ptr;
-bad:
-    Py_XDECREF(ob);
-    return NULL;
-}
-
-/* MergeVTables */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_MergeVtables(PyTypeObject *type) {
-    int i;
-    void** base_vtables;
-    __Pyx_TypeName tp_base_name;
-    __Pyx_TypeName base_name;
-    void* unknown = (void*)-1;
-    PyObject* bases = type->tp_bases;
-    int base_depth = 0;
-    {
-        PyTypeObject* base = type->tp_base;
-        while (base) {
-            base_depth += 1;
-            base = base->tp_base;
-        }
-    }
-    base_vtables = (void**) malloc(sizeof(void*) * (size_t)(base_depth + 1));
-    base_vtables[0] = unknown;
-    for (i = 1; i < PyTuple_GET_SIZE(bases); i++) {
-        void* base_vtable = __Pyx_GetVtable(((PyTypeObject*)PyTuple_GET_ITEM(bases, i)));
-        if (base_vtable != NULL) {
-            int j;
-            PyTypeObject* base = type->tp_base;
-            for (j = 0; j < base_depth; j++) {
-                if (base_vtables[j] == unknown) {
-                    base_vtables[j] = __Pyx_GetVtable(base);
-                    base_vtables[j + 1] = unknown;
-                }
-                if (base_vtables[j] == base_vtable) {
-                    break;
-                } else if (base_vtables[j] == NULL) {
-                    goto bad;
-                }
-                base = base->tp_base;
-            }
-        }
-    }
-    PyErr_Clear();
-    free(base_vtables);
-    return 0;
-bad:
-    tp_base_name = __Pyx_PyType_GetName(type->tp_base);
-    base_name = __Pyx_PyType_GetName((PyTypeObject*)PyTuple_GET_ITEM(bases, i));
-    PyErr_Format(PyExc_TypeError,
-        "multiple bases have vtable conflict: '" __Pyx_FMT_TYPENAME "' and '" __Pyx_FMT_TYPENAME "'", tp_base_name, base_name);
-    __Pyx_DECREF_TypeName(tp_base_name);
-    __Pyx_DECREF_TypeName(base_name);
-    free(base_vtables);
-    return -1;
-}
-#endif
-
-/* SetupReduce */
-#if !CYTHON_COMPILING_IN_LIMITED_API
-static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
-  int ret;
-  PyObject *name_attr;
-  name_attr = __Pyx_PyObject_GetAttrStrNoError(meth, __pyx_n_s_name_2);
-  if (likely(name_attr)) {
-      ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
-  } else {
-      ret = -1;
-  }
-  if (unlikely(ret < 0)) {
-      PyErr_Clear();
-      ret = 0;
-  }
-  Py_XDECREF(name_attr);
-  return ret;
-}
-static int __Pyx_setup_reduce(PyObject* type_obj) {
-    int ret = 0;
-    PyObject *object_reduce = NULL;
-    PyObject *object_getstate = NULL;
-    PyObject *object_reduce_ex = NULL;
-    PyObject *reduce = NULL;
-    PyObject *reduce_ex = NULL;
-    PyObject *reduce_cython = NULL;
-    PyObject *setstate = NULL;
-    PyObject *setstate_cython = NULL;
-    PyObject *getstate = NULL;
-#if CYTHON_USE_PYTYPE_LOOKUP
-    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
-#else
-    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
-    if (!getstate && PyErr_Occurred()) {
-        goto __PYX_BAD;
-    }
-#endif
-    if (getstate) {
-#if CYTHON_USE_PYTYPE_LOOKUP
-        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
-#else
-        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
-        if (!object_getstate && PyErr_Occurred()) {
-            goto __PYX_BAD;
-        }
-#endif
-        if (object_getstate != getstate) {
-            goto __PYX_GOOD;
-        }
-    }
-#if CYTHON_USE_PYTYPE_LOOKUP
-    object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
-#else
-    object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
-#endif
-    reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
-    if (reduce_ex == object_reduce_ex) {
-#if CYTHON_USE_PYTYPE_LOOKUP
-        object_reduce = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
-#else
-        object_reduce = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
-#endif
-        reduce = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce); if (unlikely(!reduce)) goto __PYX_BAD;
-        if (reduce == object_reduce || __Pyx_setup_reduce_is_named(reduce, __pyx_n_s_reduce_cython)) {
-            reduce_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_reduce_cython);
-            if (likely(reduce_cython)) {
-                ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
-                ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
-            } else if (reduce == object_reduce || PyErr_Occurred()) {
-                goto __PYX_BAD;
-            }
-            setstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate);
-            if (!setstate) PyErr_Clear();
-            if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
-                setstate_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate_cython);
-                if (likely(setstate_cython)) {
-                    ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
-                    ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
-                } else if (!setstate || PyErr_Occurred()) {
-                    goto __PYX_BAD;
-                }
-            }
-            PyType_Modified((PyTypeObject*)type_obj);
-        }
-    }
-    goto __PYX_GOOD;
-__PYX_BAD:
-    if (!PyErr_Occurred()) {
-        __Pyx_TypeName type_obj_name =
-            __Pyx_PyType_GetName((PyTypeObject*)type_obj);
-        PyErr_Format(PyExc_RuntimeError,
-            "Unable to initialize pickling for " __Pyx_FMT_TYPENAME, type_obj_name);
-        __Pyx_DECREF_TypeName(type_obj_name);
-    }
-    ret = -1;
-__PYX_GOOD:
-#if !CYTHON_USE_PYTYPE_LOOKUP
-    Py_XDECREF(object_reduce);
-    Py_XDECREF(object_reduce_ex);
-    Py_XDECREF(object_getstate);
-    Py_XDECREF(getstate);
-#endif
-    Py_XDECREF(reduce);
-    Py_XDECREF(reduce_ex);
-    Py_XDECREF(reduce_cython);
-    Py_XDECREF(setstate);
-    Py_XDECREF(setstate_cython);
-    return ret;
-}
-#endif
-
 /* FetchSharedCythonModule */
 static PyObject *__Pyx_FetchSharedCythonABIModule(void) {
     return __Pyx_PyImport_AddModuleRef((char*) __PYX_ABI_MODULE_NAME);
 }
 
 /* FetchCommonType */
 static int __Pyx_VerifyCachedType(PyObject *cached_type,
@@ -30839,15 +31661,15 @@
         break;
     case 0:
         self = ((PyCFunctionObject*)cyfunc)->m_self;
         break;
     default:
         return NULL;
     }
-    return ((_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
+    return ((__Pyx_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
 }
 static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
 {
     __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
     PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
     PyTypeObject *cls = (PyTypeObject *) __Pyx_CyFunction_GetClassObj(cyfunc);
 #if CYTHON_BACKPORT_VECTORCALL
@@ -31030,298 +31852,455 @@
     );
     if (likely(op)) {
         PyObject_GC_Track(op);
     }
     return op;
 }
 
-/* CalculateMetaclass */
-static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases) {
-    Py_ssize_t i, nbases;
-#if CYTHON_ASSUME_SAFE_MACROS
-    nbases = PyTuple_GET_SIZE(bases);
+/* PyObject_GenericGetAttrNoDict */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
+    __Pyx_TypeName type_name = __Pyx_PyType_GetName(tp);
+    PyErr_Format(PyExc_AttributeError,
+#if PY_MAJOR_VERSION >= 3
+                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%U'",
+                 type_name, attr_name);
 #else
-    nbases = PyTuple_Size(bases);
-    if (nbases < 0) return NULL;
+                 "'" __Pyx_FMT_TYPENAME "' object has no attribute '%.400s'",
+                 type_name, PyString_AS_STRING(attr_name));
+#endif
+    __Pyx_DECREF_TypeName(type_name);
+    return NULL;
+}
+static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
+    PyObject *descr;
+    PyTypeObject *tp = Py_TYPE(obj);
+    if (unlikely(!PyString_Check(attr_name))) {
+        return PyObject_GenericGetAttr(obj, attr_name);
+    }
+    assert(!tp->tp_dictoffset);
+    descr = _PyType_Lookup(tp, attr_name);
+    if (unlikely(!descr)) {
+        return __Pyx_RaiseGenericGetAttributeError(tp, attr_name);
+    }
+    Py_INCREF(descr);
+    #if PY_MAJOR_VERSION < 3
+    if (likely(PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS)))
+    #endif
+    {
+        descrgetfunc f = Py_TYPE(descr)->tp_descr_get;
+        if (unlikely(f)) {
+            PyObject *res = f(descr, obj, (PyObject *)tp);
+            Py_DECREF(descr);
+            return res;
+        }
+    }
+    return descr;
+}
+#endif
+
+/* PyObject_GenericGetAttr */
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name) {
+    if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
+        return PyObject_GenericGetAttr(obj, attr_name);
+    }
+    return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
+}
 #endif
-    for (i=0; i < nbases; i++) {
-        PyTypeObject *tmptype;
+
+/* ValidateBasesTuple */
+#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
+static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases) {
+    Py_ssize_t i, n;
 #if CYTHON_ASSUME_SAFE_MACROS
-        PyObject *tmp = PyTuple_GET_ITEM(bases, i);
+    n = PyTuple_GET_SIZE(bases);
 #else
-        PyObject *tmp = PyTuple_GetItem(bases, i);
-        if (!tmp) return NULL;
+    n = PyTuple_Size(bases);
+    if (n < 0) return -1;
 #endif
-        tmptype = Py_TYPE(tmp);
+    for (i = 1; i < n; i++)
+    {
+#if CYTHON_AVOID_BORROWED_REFS
+        PyObject *b0 = PySequence_GetItem(bases, i);
+        if (!b0) return -1;
+#elif CYTHON_ASSUME_SAFE_MACROS
+        PyObject *b0 = PyTuple_GET_ITEM(bases, i);
+#else
+        PyObject *b0 = PyTuple_GetItem(bases, i);
+        if (!b0) return -1;
+#endif
+        PyTypeObject *b;
 #if PY_MAJOR_VERSION < 3
-        if (tmptype == &PyClass_Type)
-            continue;
+        if (PyClass_Check(b0))
+        {
+            PyErr_Format(PyExc_TypeError, "base class '%.200s' is an old-style class",
+                         PyString_AS_STRING(((PyClassObject*)b0)->cl_name));
+#if CYTHON_AVOID_BORROWED_REFS
+            Py_DECREF(b0);
 #endif
-        if (!metaclass) {
-            metaclass = tmptype;
-            continue;
+            return -1;
         }
-        if (PyType_IsSubtype(metaclass, tmptype))
-            continue;
-        if (PyType_IsSubtype(tmptype, metaclass)) {
-            metaclass = tmptype;
-            continue;
+#endif
+        b = (PyTypeObject*) b0;
+        if (!__Pyx_PyType_HasFeature(b, Py_TPFLAGS_HEAPTYPE))
+        {
+            __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
+            PyErr_Format(PyExc_TypeError,
+                "base class '" __Pyx_FMT_TYPENAME "' is not a heap type", b_name);
+            __Pyx_DECREF_TypeName(b_name);
+#if CYTHON_AVOID_BORROWED_REFS
+            Py_DECREF(b0);
+#endif
+            return -1;
         }
-        PyErr_SetString(PyExc_TypeError,
-                        "metaclass conflict: "
-                        "the metaclass of a derived class "
-                        "must be a (non-strict) subclass "
-                        "of the metaclasses of all its bases");
-        return NULL;
-    }
-    if (!metaclass) {
-#if PY_MAJOR_VERSION < 3
-        metaclass = &PyClass_Type;
+        if (dictoffset == 0)
+        {
+            Py_ssize_t b_dictoffset = 0;
+#if CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY
+            b_dictoffset = b->tp_dictoffset;
 #else
-        metaclass = &PyType_Type;
+            PyObject *py_b_dictoffset = PyObject_GetAttrString((PyObject*)b, "__dictoffset__");
+            if (!py_b_dictoffset) goto dictoffset_return;
+            b_dictoffset = PyLong_AsSsize_t(py_b_dictoffset);
+            Py_DECREF(py_b_dictoffset);
+            if (b_dictoffset == -1 && PyErr_Occurred()) goto dictoffset_return;
+#endif
+            if (b_dictoffset) {
+                {
+                    __Pyx_TypeName b_name = __Pyx_PyType_GetName(b);
+                    PyErr_Format(PyExc_TypeError,
+                        "extension type '%.200s' has no __dict__ slot, "
+                        "but base type '" __Pyx_FMT_TYPENAME "' has: "
+                        "either add 'cdef dict __dict__' to the extension type "
+                        "or add '__slots__ = [...]' to the base type",
+                        type_name, b_name);
+                    __Pyx_DECREF_TypeName(b_name);
+                }
+#if !(CYTHON_USE_TYPE_SLOTS || CYTHON_COMPILING_IN_PYPY)
+              dictoffset_return:
+#endif
+#if CYTHON_AVOID_BORROWED_REFS
+                Py_DECREF(b0);
+#endif
+                return -1;
+            }
+        }
+#if CYTHON_AVOID_BORROWED_REFS
+        Py_DECREF(b0);
 #endif
     }
-    Py_INCREF((PyObject*) metaclass);
-    return (PyObject*) metaclass;
-}
-
-/* PyObjectCall2Args */
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
-    PyObject *args[3] = {NULL, arg1, arg2};
-    return __Pyx_PyObject_FastCall(function, args+1, 2 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
+    return 0;
 }
+#endif
 
-/* PyObjectLookupSpecial */
-#if CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PyObject* __Pyx__PyObject_LookupSpecial(PyObject* obj, PyObject* attr_name, int with_error) {
-    PyObject *res;
-    PyTypeObject *tp = Py_TYPE(obj);
-#if PY_MAJOR_VERSION < 3
-    if (unlikely(PyInstance_Check(obj)))
-        return with_error ? __Pyx_PyObject_GetAttrStr(obj, attr_name) : __Pyx_PyObject_GetAttrStrNoError(obj, attr_name);
+/* PyType_Ready */
+static int __Pyx_PyType_Ready(PyTypeObject *t) {
+#if CYTHON_USE_TYPE_SPECS || !(CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API) || defined(PYSTON_MAJOR_VERSION)
+    (void)__Pyx_PyObject_CallMethod0;
+#if CYTHON_USE_TYPE_SPECS
+    (void)__Pyx_validate_bases_tuple;
 #endif
-    res = _PyType_Lookup(tp, attr_name);
-    if (likely(res)) {
-        descrgetfunc f = Py_TYPE(res)->tp_descr_get;
-        if (!f) {
-            Py_INCREF(res);
-        } else {
-            res = f(res, obj, (PyObject *)tp);
+    return PyType_Ready(t);
+#else
+    int r;
+    PyObject *bases = __Pyx_PyType_GetSlot(t, tp_bases, PyObject*);
+    if (bases && unlikely(__Pyx_validate_bases_tuple(t->tp_name, t->tp_dictoffset, bases) == -1))
+        return -1;
+#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
+    {
+        int gc_was_enabled;
+    #if PY_VERSION_HEX >= 0x030A00b1
+        gc_was_enabled = PyGC_Disable();
+        (void)__Pyx_PyObject_CallMethod0;
+    #else
+        PyObject *ret, *py_status;
+        PyObject *gc = NULL;
+        #if PY_VERSION_HEX >= 0x030700a1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM+0 >= 0x07030400)
+        gc = PyImport_GetModule(__pyx_kp_u_gc);
+        #endif
+        if (unlikely(!gc)) gc = PyImport_Import(__pyx_kp_u_gc);
+        if (unlikely(!gc)) return -1;
+        py_status = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_isenabled);
+        if (unlikely(!py_status)) {
+            Py_DECREF(gc);
+            return -1;
         }
-    } else if (with_error) {
-        PyErr_SetObject(PyExc_AttributeError, attr_name);
+        gc_was_enabled = __Pyx_PyObject_IsTrue(py_status);
+        Py_DECREF(py_status);
+        if (gc_was_enabled > 0) {
+            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_disable);
+            if (unlikely(!ret)) {
+                Py_DECREF(gc);
+                return -1;
+            }
+            Py_DECREF(ret);
+        } else if (unlikely(gc_was_enabled == -1)) {
+            Py_DECREF(gc);
+            return -1;
+        }
+    #endif
+        t->tp_flags |= Py_TPFLAGS_HEAPTYPE;
+#if PY_VERSION_HEX >= 0x030A0000
+        t->tp_flags |= Py_TPFLAGS_IMMUTABLETYPE;
+#endif
+#else
+        (void)__Pyx_PyObject_CallMethod0;
+#endif
+    r = PyType_Ready(t);
+#if PY_VERSION_HEX >= 0x03050000 && !defined(PYSTON_MAJOR_VERSION)
+        t->tp_flags &= ~Py_TPFLAGS_HEAPTYPE;
+    #if PY_VERSION_HEX >= 0x030A00b1
+        if (gc_was_enabled)
+            PyGC_Enable();
+    #else
+        if (gc_was_enabled) {
+            PyObject *tp, *v, *tb;
+            PyErr_Fetch(&tp, &v, &tb);
+            ret = __Pyx_PyObject_CallMethod0(gc, __pyx_kp_u_enable);
+            if (likely(ret || r == -1)) {
+                Py_XDECREF(ret);
+                PyErr_Restore(tp, v, tb);
+            } else {
+                Py_XDECREF(tp);
+                Py_XDECREF(v);
+                Py_XDECREF(tb);
+                r = -1;
+            }
+        }
+        Py_DECREF(gc);
+    #endif
     }
-    return res;
+#endif
+    return r;
+#endif
 }
+
+/* SetVTable */
+static int __Pyx_SetVtable(PyTypeObject *type, void *vtable) {
+    PyObject *ob = PyCapsule_New(vtable, 0, 0);
+    if (unlikely(!ob))
+        goto bad;
+#if CYTHON_COMPILING_IN_LIMITED_API
+    if (unlikely(PyObject_SetAttr((PyObject *) type, __pyx_n_s_pyx_vtable, ob) < 0))
+#else
+    if (unlikely(PyDict_SetItem(type->tp_dict, __pyx_n_s_pyx_vtable, ob) < 0))
 #endif
+        goto bad;
+    Py_DECREF(ob);
+    return 0;
+bad:
+    Py_XDECREF(ob);
+    return -1;
+}
 
-/* Py3ClassCreate */
-static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name,
-                                           PyObject *qualname, PyObject *mkw, PyObject *modname, PyObject *doc) {
-    PyObject *ns;
-    if (metaclass) {
-        PyObject *prep = __Pyx_PyObject_GetAttrStrNoError(metaclass, __pyx_n_s_prepare);
-        if (prep) {
-            PyObject *pargs[3] = {NULL, name, bases};
-            ns = __Pyx_PyObject_FastCallDict(prep, pargs+1, 2 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET, mkw);
-            Py_DECREF(prep);
-        } else {
-            if (unlikely(PyErr_Occurred()))
-                return NULL;
-            ns = PyDict_New();
-        }
-    } else {
-        ns = PyDict_New();
-    }
-    if (unlikely(!ns))
-        return NULL;
-    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_module, modname) < 0)) goto bad;
-#if PY_VERSION_HEX >= 0x03030000
-    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_qualname, qualname) < 0)) goto bad;
+/* GetVTable */
+static void* __Pyx_GetVtable(PyTypeObject *type) {
+    void* ptr;
+#if CYTHON_COMPILING_IN_LIMITED_API
+    PyObject *ob = PyObject_GetAttr((PyObject *)type, __pyx_n_s_pyx_vtable);
 #else
-    CYTHON_MAYBE_UNUSED_VAR(qualname);
+    PyObject *ob = PyObject_GetItem(type->tp_dict, __pyx_n_s_pyx_vtable);
 #endif
-    if (unlikely(doc && PyObject_SetItem(ns, __pyx_n_s_doc, doc) < 0)) goto bad;
-    return ns;
+    if (!ob)
+        goto bad;
+    ptr = PyCapsule_GetPointer(ob, 0);
+    if (!ptr && !PyErr_Occurred())
+        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
+    Py_DECREF(ob);
+    return ptr;
 bad:
-    Py_DECREF(ns);
+    Py_XDECREF(ob);
     return NULL;
 }
-#if PY_VERSION_HEX < 0x030600A4 && CYTHON_PEP487_INIT_SUBCLASS
-static int __Pyx_SetNamesPEP487(PyObject *type_obj) {
-    PyTypeObject *type = (PyTypeObject*) type_obj;
-    PyObject *names_to_set, *key, *value, *set_name, *tmp;
-    Py_ssize_t i = 0;
-#if CYTHON_USE_TYPE_SLOTS
-    names_to_set = PyDict_Copy(type->tp_dict);
-#else
+
+/* MergeVTables */
+#if !CYTHON_COMPILING_IN_LIMITED_API
+static int __Pyx_MergeVtables(PyTypeObject *type) {
+    int i;
+    void** base_vtables;
+    __Pyx_TypeName tp_base_name;
+    __Pyx_TypeName base_name;
+    void* unknown = (void*)-1;
+    PyObject* bases = type->tp_bases;
+    int base_depth = 0;
     {
-        PyObject *d = PyObject_GetAttr(type_obj, __pyx_n_s_dict);
-        names_to_set = NULL;
-        if (likely(d)) {
-            PyObject *names_to_set = PyDict_New();
-            int ret = likely(names_to_set) ? PyDict_Update(names_to_set, d) : -1;
-            Py_DECREF(d);
-            if (unlikely(ret < 0))
-                Py_CLEAR(names_to_set);
+        PyTypeObject* base = type->tp_base;
+        while (base) {
+            base_depth += 1;
+            base = base->tp_base;
         }
     }
-#endif
-    if (unlikely(names_to_set == NULL))
-        goto bad;
-    while (PyDict_Next(names_to_set, &i, &key, &value)) {
-        set_name = __Pyx_PyObject_LookupSpecialNoError(value, __pyx_n_s_set_name);
-        if (unlikely(set_name != NULL)) {
-            tmp = __Pyx_PyObject_Call2Args(set_name, type_obj, key);
-            Py_DECREF(set_name);
-            if (unlikely(tmp == NULL)) {
-                __Pyx_TypeName value_type_name =
-                    __Pyx_PyType_GetName(Py_TYPE(value));
-                __Pyx_TypeName type_name = __Pyx_PyType_GetName(type);
-                PyErr_Format(PyExc_RuntimeError,
-#if PY_MAJOR_VERSION >= 3
-                    "Error calling __set_name__ on '" __Pyx_FMT_TYPENAME "' instance %R " "in '" __Pyx_FMT_TYPENAME "'",
-                    value_type_name, key, type_name);
-#else
-                    "Error calling __set_name__ on '" __Pyx_FMT_TYPENAME "' instance %.100s in '" __Pyx_FMT_TYPENAME "'",
-                    value_type_name,
-                    PyString_Check(key) ? PyString_AS_STRING(key) : "?",
-                    type_name);
-#endif
-                goto bad;
-            } else {
-                Py_DECREF(tmp);
+    base_vtables = (void**) malloc(sizeof(void*) * (size_t)(base_depth + 1));
+    base_vtables[0] = unknown;
+    for (i = 1; i < PyTuple_GET_SIZE(bases); i++) {
+        void* base_vtable = __Pyx_GetVtable(((PyTypeObject*)PyTuple_GET_ITEM(bases, i)));
+        if (base_vtable != NULL) {
+            int j;
+            PyTypeObject* base = type->tp_base;
+            for (j = 0; j < base_depth; j++) {
+                if (base_vtables[j] == unknown) {
+                    base_vtables[j] = __Pyx_GetVtable(base);
+                    base_vtables[j + 1] = unknown;
+                }
+                if (base_vtables[j] == base_vtable) {
+                    break;
+                } else if (base_vtables[j] == NULL) {
+                    goto bad;
+                }
+                base = base->tp_base;
             }
         }
-        else if (unlikely(PyErr_Occurred())) {
-            goto bad;
-        }
     }
-    Py_DECREF(names_to_set);
+    PyErr_Clear();
+    free(base_vtables);
     return 0;
 bad:
-    Py_XDECREF(names_to_set);
+    tp_base_name = __Pyx_PyType_GetName(type->tp_base);
+    base_name = __Pyx_PyType_GetName((PyTypeObject*)PyTuple_GET_ITEM(bases, i));
+    PyErr_Format(PyExc_TypeError,
+        "multiple bases have vtable conflict: '" __Pyx_FMT_TYPENAME "' and '" __Pyx_FMT_TYPENAME "'", tp_base_name, base_name);
+    __Pyx_DECREF_TypeName(tp_base_name);
+    __Pyx_DECREF_TypeName(base_name);
+    free(base_vtables);
     return -1;
 }
-static PyObject *__Pyx_InitSubclassPEP487(PyObject *type_obj, PyObject *mkw) {
-#if CYTHON_USE_TYPE_SLOTS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    PyTypeObject *type = (PyTypeObject*) type_obj;
-    PyObject *mro = type->tp_mro;
-    Py_ssize_t i, nbases;
-    if (unlikely(!mro)) goto done;
-    (void) &__Pyx_GetBuiltinName;
-    Py_INCREF(mro);
-    nbases = PyTuple_GET_SIZE(mro);
-    assert(PyTuple_GET_ITEM(mro, 0) == type_obj);
-    for (i = 1; i < nbases-1; i++) {
-        PyObject *base, *dict, *meth;
-        base = PyTuple_GET_ITEM(mro, i);
-        dict = ((PyTypeObject *)base)->tp_dict;
-        meth = __Pyx_PyDict_GetItemStrWithError(dict, __pyx_n_s_init_subclass);
-        if (unlikely(meth)) {
-            descrgetfunc f = Py_TYPE(meth)->tp_descr_get;
-            PyObject *res;
-            Py_INCREF(meth);
-            if (likely(f)) {
-                res = f(meth, NULL, type_obj);
-                Py_DECREF(meth);
-                if (unlikely(!res)) goto bad;
-                meth = res;
-            }
-            res = __Pyx_PyObject_FastCallDict(meth, NULL, 0, mkw);
-            Py_DECREF(meth);
-            if (unlikely(!res)) goto bad;
-            Py_DECREF(res);
-            goto done;
-        } else if (unlikely(PyErr_Occurred())) {
-            goto bad;
+#endif
+
+/* SetupReduce */
+#if !CYTHON_COMPILING_IN_LIMITED_API
+static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
+  int ret;
+  PyObject *name_attr;
+  name_attr = __Pyx_PyObject_GetAttrStrNoError(meth, __pyx_n_s_name_2);
+  if (likely(name_attr)) {
+      ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
+  } else {
+      ret = -1;
+  }
+  if (unlikely(ret < 0)) {
+      PyErr_Clear();
+      ret = 0;
+  }
+  Py_XDECREF(name_attr);
+  return ret;
+}
+static int __Pyx_setup_reduce(PyObject* type_obj) {
+    int ret = 0;
+    PyObject *object_reduce = NULL;
+    PyObject *object_getstate = NULL;
+    PyObject *object_reduce_ex = NULL;
+    PyObject *reduce = NULL;
+    PyObject *reduce_ex = NULL;
+    PyObject *reduce_cython = NULL;
+    PyObject *setstate = NULL;
+    PyObject *setstate_cython = NULL;
+    PyObject *getstate = NULL;
+#if CYTHON_USE_PYTYPE_LOOKUP
+    getstate = _PyType_Lookup((PyTypeObject*)type_obj, __pyx_n_s_getstate);
+#else
+    getstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_getstate);
+    if (!getstate && PyErr_Occurred()) {
+        goto __PYX_BAD;
+    }
+#endif
+    if (getstate) {
+#if CYTHON_USE_PYTYPE_LOOKUP
+        object_getstate = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_getstate);
+#else
+        object_getstate = __Pyx_PyObject_GetAttrStrNoError((PyObject*)&PyBaseObject_Type, __pyx_n_s_getstate);
+        if (!object_getstate && PyErr_Occurred()) {
+            goto __PYX_BAD;
+        }
+#endif
+        if (object_getstate != getstate) {
+            goto __PYX_GOOD;
         }
     }
-done:
-    Py_XDECREF(mro);
-    return type_obj;
-bad:
-    Py_XDECREF(mro);
-    Py_DECREF(type_obj);
-    return NULL;
+#if CYTHON_USE_PYTYPE_LOOKUP
+    object_reduce_ex = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #else
-    PyObject *super_type, *super, *func, *res;
-#if CYTHON_COMPILING_IN_PYPY && !defined(PySuper_Type)
-    super_type = __Pyx_GetBuiltinName(__pyx_n_s_super);
-#else
-    super_type = (PyObject*) &PySuper_Type;
-    (void) &__Pyx_GetBuiltinName;
-#endif
-    super = likely(super_type) ? __Pyx_PyObject_Call2Args(super_type, type_obj, type_obj) : NULL;
-#if CYTHON_COMPILING_IN_PYPY && !defined(PySuper_Type)
-    Py_XDECREF(super_type);
+    object_reduce_ex = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce_ex); if (!object_reduce_ex) goto __PYX_BAD;
 #endif
-    if (unlikely(!super)) {
-        Py_CLEAR(type_obj);
-        goto done;
+    reduce_ex = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce_ex); if (unlikely(!reduce_ex)) goto __PYX_BAD;
+    if (reduce_ex == object_reduce_ex) {
+#if CYTHON_USE_PYTYPE_LOOKUP
+        object_reduce = _PyType_Lookup(&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
+#else
+        object_reduce = __Pyx_PyObject_GetAttrStr((PyObject*)&PyBaseObject_Type, __pyx_n_s_reduce); if (!object_reduce) goto __PYX_BAD;
+#endif
+        reduce = __Pyx_PyObject_GetAttrStr(type_obj, __pyx_n_s_reduce); if (unlikely(!reduce)) goto __PYX_BAD;
+        if (reduce == object_reduce || __Pyx_setup_reduce_is_named(reduce, __pyx_n_s_reduce_cython)) {
+            reduce_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_reduce_cython);
+            if (likely(reduce_cython)) {
+                ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce, reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
+                ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_reduce_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
+            } else if (reduce == object_reduce || PyErr_Occurred()) {
+                goto __PYX_BAD;
+            }
+            setstate = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate);
+            if (!setstate) PyErr_Clear();
+            if (!setstate || __Pyx_setup_reduce_is_named(setstate, __pyx_n_s_setstate_cython)) {
+                setstate_cython = __Pyx_PyObject_GetAttrStrNoError(type_obj, __pyx_n_s_setstate_cython);
+                if (likely(setstate_cython)) {
+                    ret = PyDict_SetItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate, setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
+                    ret = PyDict_DelItem(((PyTypeObject*)type_obj)->tp_dict, __pyx_n_s_setstate_cython); if (unlikely(ret < 0)) goto __PYX_BAD;
+                } else if (!setstate || PyErr_Occurred()) {
+                    goto __PYX_BAD;
+                }
+            }
+            PyType_Modified((PyTypeObject*)type_obj);
+        }
     }
-    func = __Pyx_PyObject_GetAttrStrNoError(super, __pyx_n_s_init_subclass);
-    Py_DECREF(super);
-    if (likely(!func)) {
-        if (unlikely(PyErr_Occurred()))
-            Py_CLEAR(type_obj);
-        goto done;
+    goto __PYX_GOOD;
+__PYX_BAD:
+    if (!PyErr_Occurred()) {
+        __Pyx_TypeName type_obj_name =
+            __Pyx_PyType_GetName((PyTypeObject*)type_obj);
+        PyErr_Format(PyExc_RuntimeError,
+            "Unable to initialize pickling for " __Pyx_FMT_TYPENAME, type_obj_name);
+        __Pyx_DECREF_TypeName(type_obj_name);
     }
-    res = __Pyx_PyObject_FastCallDict(func, NULL, 0, mkw);
-    Py_DECREF(func);
-    if (unlikely(!res))
-        Py_CLEAR(type_obj);
-    Py_XDECREF(res);
-done:
-    return type_obj;
+    ret = -1;
+__PYX_GOOD:
+#if !CYTHON_USE_PYTYPE_LOOKUP
+    Py_XDECREF(object_reduce);
+    Py_XDECREF(object_reduce_ex);
+    Py_XDECREF(object_getstate);
+    Py_XDECREF(getstate);
 #endif
+    Py_XDECREF(reduce);
+    Py_XDECREF(reduce_ex);
+    Py_XDECREF(reduce_cython);
+    Py_XDECREF(setstate);
+    Py_XDECREF(setstate_cython);
+    return ret;
 }
 #endif
-static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases,
-                                      PyObject *dict, PyObject *mkw,
-                                      int calculate_metaclass, int allow_py2_metaclass) {
+
+/* GetNameInClass */
+static PyObject *__Pyx__GetNameInClass(PyObject *nmspace, PyObject *name) {
     PyObject *result;
-    PyObject *owned_metaclass = NULL;
-    PyObject *margs[4] = {NULL, name, bases, dict};
-    if (allow_py2_metaclass) {
-        owned_metaclass = PyObject_GetItem(dict, __pyx_n_s_metaclass);
-        if (owned_metaclass) {
-            metaclass = owned_metaclass;
-        } else if (likely(PyErr_ExceptionMatches(PyExc_KeyError))) {
-            PyErr_Clear();
-        } else {
-            return NULL;
-        }
-    }
-    if (calculate_metaclass && (!metaclass || PyType_Check(metaclass))) {
-        metaclass = __Pyx_CalculateMetaclass((PyTypeObject*) metaclass, bases);
-        Py_XDECREF(owned_metaclass);
-        if (unlikely(!metaclass))
-            return NULL;
-        owned_metaclass = metaclass;
-    }
-    result = __Pyx_PyObject_FastCallDict(metaclass, margs+1, 3 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET,
-#if PY_VERSION_HEX < 0x030600A4
-        (metaclass == (PyObject*)&PyType_Type) ? NULL : mkw
+    PyObject *dict;
+    assert(PyType_Check(nmspace));
+#if CYTHON_USE_TYPE_SLOTS
+    dict = ((PyTypeObject*)nmspace)->tp_dict;
+    Py_XINCREF(dict);
 #else
-        mkw
+    dict = PyObject_GetAttr(nmspace, __pyx_n_s_dict);
 #endif
-    );
-    Py_XDECREF(owned_metaclass);
-#if PY_VERSION_HEX < 0x030600A4 && CYTHON_PEP487_INIT_SUBCLASS
-    if (likely(result) && likely(PyType_Check(result))) {
-        if (unlikely(__Pyx_SetNamesPEP487(result) < 0)) {
-            Py_CLEAR(result);
-        } else {
-            result = __Pyx_InitSubclassPEP487(result, mkw);
+    if (likely(dict)) {
+        result = PyObject_GetItem(dict, name);
+        Py_DECREF(dict);
+        if (result) {
+            return result;
         }
     }
-#else
-    (void) &__Pyx_GetBuiltinName;
-#endif
+    PyErr_Clear();
+    __Pyx_GetModuleGlobalNameUncached(result, name);
     return result;
 }
 
 /* CLineInTraceback */
 #ifndef CYTHON_CLINE_IN_TRACEBACK
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
@@ -32464,25 +33443,48 @@
     retval = -1;
 no_fail:
     __Pyx_RefNannyFinishContext();
     return retval;
 }
 
 /* ObjectToMemviewSlice */
-  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dsds_double(PyObject *obj, int writable_flag) {
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(PyObject *obj, int writable_flag) {
     __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
     __Pyx_BufFmt_StackElem stack[1];
-    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_STRIDED), (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_STRIDED) };
+    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_FOLLOW), (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
     int retcode;
     if (obj == Py_None) {
         result.memview = (struct __pyx_memoryview_obj *) Py_None;
         return result;
     }
-    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, 0,
-                                                 PyBUF_RECORDS_RO | writable_flag, 2,
+    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
+                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 2,
+                                                 &__Pyx_TypeInfo_double, stack,
+                                                 &result, obj);
+    if (unlikely(retcode == -1))
+        goto __pyx_fail;
+    return result;
+__pyx_fail:
+    result.memview = NULL;
+    result.data = NULL;
+    return result;
+}
+
+/* ObjectToMemviewSlice */
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_double(PyObject *obj, int writable_flag) {
+    __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
+    __Pyx_BufFmt_StackElem stack[1];
+    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
+    int retcode;
+    if (obj == Py_None) {
+        result.memview = (struct __pyx_memoryview_obj *) Py_None;
+        return result;
+    }
+    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
+                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
                                                  &__Pyx_TypeInfo_double, stack,
                                                  &result, obj);
     if (unlikely(retcode == -1))
         goto __pyx_fail;
     return result;
 __pyx_fail:
     result.memview = NULL;
@@ -32809,14 +33811,78 @@
         Py_XDECREF(py_bytes);
         Py_XDECREF(from_bytes);
         return result;
 #endif
     }
 }
 
+/* CIntToPy */
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const int neg_one = (int) -1, const_zero = (int) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+    if (is_unsigned) {
+        if (sizeof(int) < sizeof(long)) {
+            return PyInt_FromLong((long) value);
+        } else if (sizeof(int) <= sizeof(unsigned long)) {
+            return PyLong_FromUnsignedLong((unsigned long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
+            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
+#endif
+        }
+    } else {
+        if (sizeof(int) <= sizeof(long)) {
+            return PyInt_FromLong((long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
+            return PyLong_FromLongLong((PY_LONG_LONG) value);
+#endif
+        }
+    }
+    {
+        int one = 1; int little = (int)*(unsigned char *)&one;
+        unsigned char *bytes = (unsigned char *)&value;
+#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
+        return _PyLong_FromByteArray(bytes, sizeof(int),
+                                     little, !is_unsigned);
+#else
+        PyObject *from_bytes, *result = NULL;
+        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
+        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
+        if (!from_bytes) return NULL;
+        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(int));
+        if (!py_bytes) goto limited_bad;
+        order_str = PyUnicode_FromString(little ? "little" : "big");
+        if (!order_str) goto limited_bad;
+        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
+        if (!arg_tuple) goto limited_bad;
+        if (!is_unsigned) {
+            kwds = PyDict_New();
+            if (!kwds) goto limited_bad;
+            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
+        }
+        result = PyObject_Call(from_bytes, arg_tuple, kwds);
+        limited_bad:
+        Py_XDECREF(kwds);
+        Py_XDECREF(arg_tuple);
+        Py_XDECREF(order_str);
+        Py_XDECREF(py_bytes);
+        Py_XDECREF(from_bytes);
+        return result;
+#endif
+    }
+}
+
 /* CIntFromPy */
   static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const int neg_one = (int) -1, const_zero = (int) 0;
@@ -33082,78 +34148,14 @@
     return (int) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to int");
     return (int) -1;
 }
 
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const int neg_one = (int) -1, const_zero = (int) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(int) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(int) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(int) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
-        return _PyLong_FromByteArray(bytes, sizeof(int),
-                                     little, !is_unsigned);
-#else
-        PyObject *from_bytes, *result = NULL;
-        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
-        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
-        if (!from_bytes) return NULL;
-        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(int));
-        if (!py_bytes) goto limited_bad;
-        order_str = PyUnicode_FromString(little ? "little" : "big");
-        if (!order_str) goto limited_bad;
-        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
-        if (!arg_tuple) goto limited_bad;
-        if (!is_unsigned) {
-            kwds = PyDict_New();
-            if (!kwds) goto limited_bad;
-            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
-        }
-        result = PyObject_Call(from_bytes, arg_tuple, kwds);
-        limited_bad:
-        Py_XDECREF(kwds);
-        Py_XDECREF(arg_tuple);
-        Py_XDECREF(order_str);
-        Py_XDECREF(py_bytes);
-        Py_XDECREF(from_bytes);
-        return result;
-#endif
-    }
-}
-
 /* CIntFromPy */
   static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const long neg_one = (long) -1, const_zero = (long) 0;
@@ -33702,15 +34704,15 @@
 __Pyx_PyType_GetName(PyTypeObject* tp)
 {
     PyObject *name = __Pyx_PyObject_GetAttrStr((PyObject *)tp,
                                                __pyx_n_s_name_2);
     if (unlikely(name == NULL) || unlikely(!PyUnicode_Check(name))) {
         PyErr_Clear();
         Py_XDECREF(name);
-        name = __Pyx_NewRef(__pyx_n_s__51);
+        name = __Pyx_NewRef(__pyx_n_s__52);
     }
     return name;
 }
 #endif
 
 /* CheckBinaryVersion */
   static unsigned long __Pyx_get_runtime_version(void) {
```

### Comparing `adaXT-1.0.1/src/adaXT/decision_tree/Nodes.cpp` & `adaxt-1.1.0/src/adaXT/decision_tree/nodes.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,31 @@
-/* Generated by Cython 3.0.8 */
+/* Generated by Cython 3.0.10 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
+        "define_macros": [
+            [
+                "NPY_NO_DEPRECATED_API",
+                "NPY_1_7_API_VERSION"
+            ]
+        ],
         "extra_compile_args": [
             "-O3"
         ],
         "include_dirs": [
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include"
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include"
         ],
         "language": "c++",
-        "name": "adaXT.decision_tree.Nodes",
+        "name": "adaXT.decision_tree.nodes",
         "sources": [
-            "src/adaXT/decision_tree/Nodes.pyx"
+            "src/adaXT/decision_tree/nodes.pyx"
         ]
     },
-    "module_name": "adaXT.decision_tree.Nodes"
+    "module_name": "adaXT.decision_tree.nodes"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
 #define PY_SSIZE_T_CLEAN
 #endif /* PY_SSIZE_T_CLEAN */
 #if defined(CYTHON_LIMITED_API) && 0
@@ -39,18 +45,18 @@
     #error Cython requires Python 2.7+ or Python 3.3+.
 #else
 #if defined(CYTHON_LIMITED_API) && CYTHON_LIMITED_API
 #define __PYX_EXTRA_ABI_MODULE_NAME "limited"
 #else
 #define __PYX_EXTRA_ABI_MODULE_NAME ""
 #endif
-#define CYTHON_ABI "3_0_8" __PYX_EXTRA_ABI_MODULE_NAME
+#define CYTHON_ABI "3_0_10" __PYX_EXTRA_ABI_MODULE_NAME
 #define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
 #define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
-#define CYTHON_HEX_VERSION 0x030008F0
+#define CYTHON_HEX_VERSION 0x03000AF0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -134,14 +140,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(PYPY_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
@@ -195,14 +203,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(CYTHON_LIMITED_API)
   #ifdef Py_LIMITED_API
     #undef __PYX_LIMITED_VERSION_HEX
     #define __PYX_LIMITED_VERSION_HEX Py_LIMITED_API
   #endif
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
@@ -256,60 +266,83 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(Py_GIL_DISABLED) || defined(Py_NOGIL)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_TYPE_SPECS
+    #define CYTHON_USE_TYPE_SPECS 0
+  #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #ifndef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #endif
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #ifndef CYTHON_METH_FASTCALL
+    #define CYTHON_METH_FASTCALL 1
+  #endif
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT 1
   #endif
+  #ifndef CYTHON_USE_MODULE_STATE
+    #define CYTHON_USE_MODULE_STATE 0
+  #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE 1
   #endif
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 0
+  #endif
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
@@ -392,14 +425,17 @@
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK 1
   #endif
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
   #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 1
+  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if !defined(CYTHON_VECTORCALL)
 #define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
 #endif
@@ -751,16 +787,21 @@
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
   typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
   typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
-  #define __Pyx_PyCFunctionFast _PyCFunctionFast
-  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #if PY_VERSION_HEX >= 0x030d00A4
+  #  define __Pyx_PyCFunctionFast PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords PyCFunctionFastWithKeywords
+  #else
+  #  define __Pyx_PyCFunctionFast _PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #endif
 #endif
 #if CYTHON_METH_FASTCALL
   #define __Pyx_METH_FASTCALL METH_FASTCALL
   #define __Pyx_PyCFunction_FastCall __Pyx_PyCFunctionFast
   #define __Pyx_PyCFunction_FastCallWithKeywords __Pyx_PyCFunctionFastWithKeywords
 #else
   #define __Pyx_METH_FASTCALL METH_VARARGS
@@ -1104,15 +1145,15 @@
   #define __Pyx_PyList_SET_ITEM(o, i, v) PyList_SetItem(o, i, v)
   #define __Pyx_PyTuple_GET_SIZE(o) PyTuple_Size(o)
   #define __Pyx_PyList_GET_SIZE(o) PyList_Size(o)
   #define __Pyx_PySet_GET_SIZE(o) PySet_Size(o)
   #define __Pyx_PyBytes_GET_SIZE(o) PyBytes_Size(o)
   #define __Pyx_PyByteArray_GET_SIZE(o) PyByteArray_Size(o)
 #endif
-#if PY_VERSION_HEX >= 0x030d00A1
+#if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
   #define __Pyx_PyImport_AddModuleRef(name) PyImport_AddModuleRef(name)
 #else
   static CYTHON_INLINE PyObject *__Pyx_PyImport_AddModuleRef(const char *name) {
       PyObject *module = PyImport_AddModule(name);
       Py_XINCREF(module);
       return module;
   }
@@ -1191,15 +1232,15 @@
 #if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
 #define __Pyx_truncl trunc
 #else
 #define __Pyx_truncl truncl
 #endif
 
 #define __PYX_MARK_ERR_POS(f_index, lineno) \
-    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
+    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__;  (void)__pyx_clineno; }
 #define __PYX_ERR(f_index, lineno, Ln_error) \
     { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
 
 #ifdef CYTHON_EXTERN_C
     #undef __PYX_EXTERN_C
     #define __PYX_EXTERN_C CYTHON_EXTERN_C
 #elif defined(__PYX_EXTERN_C)
@@ -1208,16 +1249,16 @@
     #else
     #warning Please do not define the '__PYX_EXTERN_C' macro externally. Use 'CYTHON_EXTERN_C' instead.
     #endif
 #else
     #define __PYX_EXTERN_C extern "C++"
 #endif
 
-#define __PYX_HAVE__adaXT__decision_tree__Nodes
-#define __PYX_HAVE_API__adaXT__decision_tree__Nodes
+#define __PYX_HAVE__adaXT__decision_tree__nodes
+#define __PYX_HAVE_API__adaXT__decision_tree__nodes
 /* Early includes */
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
 
 #if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
 #define CYTHON_WITHOUT_ASSERTIONS
@@ -1290,32 +1331,15 @@
 #define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
 #define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
 #define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
 #define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
 #define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const wchar_t *u)
-{
-    const wchar_t *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#else
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
-    const Py_UNICODE *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#endif
 #define __Pyx_PyUnicode_FromOrdinal(o)       PyUnicode_FromOrdinal((int)o)
-#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
-#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
@@ -1476,15 +1500,15 @@
 static int __pyx_clineno = 0;
 static const char * __pyx_cfilenm = __FILE__;
 static const char *__pyx_filename;
 
 /* #### Code section: filename_table ### */
 
 static const char *__pyx_f[] = {
-  "src/adaXT/decision_tree/Nodes.pyx",
+  "src/adaXT/decision_tree/nodes.pyx",
 };
 /* #### Code section: utility_code_proto_before_types ### */
 /* ForceInitThreads.proto */
 #ifndef __PYX_FORCE_INIT_THREADS
   #define __PYX_FORCE_INIT_THREADS 0
 #endif
 
@@ -1718,28 +1742,59 @@
 
 /* ArgTypeTest.proto */
 #define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
     ((likely(__Pyx_IS_TYPE(obj, type) | (none_allowed && (obj == Py_None)))) ? 1 :\
         __Pyx__ArgTypeTest(obj, type, name, exact))
 static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);
 
-/* PyObjectSetAttrStr.proto */
-#if CYTHON_USE_TYPE_SLOTS
-#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
-static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
+/* PyDictVersioning.proto */
+#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
+#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
+#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
+#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
+    (version_var) = __PYX_GET_DICT_VERSION(dict);\
+    (cache_var) = (value);
+#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
+    static PY_UINT64_T __pyx_dict_version = 0;\
+    static PyObject *__pyx_dict_cached_value = NULL;\
+    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
+        (VAR) = __pyx_dict_cached_value;\
+    } else {\
+        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
+        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
+    }\
+}
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
+static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
 #else
-#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
-#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
+#define __PYX_GET_DICT_VERSION(dict)  (0)
+#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
+#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
 #endif
 
-/* PyObjectCall.proto */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+/* GetModuleGlobalName.proto */
+#if CYTHON_USE_DICT_VERSIONS
+#define __Pyx_GetModuleGlobalName(var, name)  do {\
+    static PY_UINT64_T __pyx_dict_version = 0;\
+    static PyObject *__pyx_dict_cached_value = NULL;\
+    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
+        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
+        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
+} while(0)
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
+    PY_UINT64_T __pyx_dict_version;\
+    PyObject *__pyx_dict_cached_value;\
+    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
+} while(0)
+static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
 #else
-#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
+#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
+static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
 #endif
 
 /* PyFunctionFastCall.proto */
 #if CYTHON_FAST_PYCALL
 #if !CYTHON_VECTORCALL
 #define __Pyx_PyFunction_FastCall(func, args, nargs)\
     __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
@@ -1769,35 +1824,48 @@
      (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
   #define __Pyx_PyFrame_GetLocalsplus(frame)\
     (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
 #endif
 #endif
 #endif
 
+/* PyObjectCall.proto */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
+#else
+#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
+#endif
+
 /* PyObjectCallMethO.proto */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
 #endif
 
 /* PyObjectFastCall.proto */
 #define __Pyx_PyObject_FastCall(func, args, nargs)  __Pyx_PyObject_FastCallDict(func, args, (size_t)(nargs), NULL)
 static CYTHON_INLINE PyObject* __Pyx_PyObject_FastCallDict(PyObject *func, PyObject **args, size_t nargs, PyObject *kwargs);
 
+/* PyObjectSetAttrStr.proto */
+#if CYTHON_USE_TYPE_SLOTS
+#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
+static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
+#else
+#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
+#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
+#endif
+
 /* Import.proto */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);
 
 /* ImportDottedModule.proto */
 static PyObject *__Pyx_ImportDottedModule(PyObject *name, PyObject *parts_tuple);
 #if PY_MAJOR_VERSION >= 3
 static PyObject *__Pyx_ImportDottedModule_WalkParts(PyObject *module, PyObject *name, PyObject *parts_tuple);
 #endif
 
-/* ImportFrom.proto */
-static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);
-
 /* IncludeStructmemberH.proto */
 #include <structmember.h>
 
 /* FixUpExtensionType.proto */
 #if CYTHON_USE_TYPE_SPECS
 static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type);
 #endif
@@ -1971,61 +2039,14 @@
 
 /* Py3ClassCreate.proto */
 static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name, PyObject *qualname,
                                            PyObject *mkw, PyObject *modname, PyObject *doc);
 static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases, PyObject *dict,
                                       PyObject *mkw, int calculate_metaclass, int allow_py2_metaclass);
 
-/* PyDictVersioning.proto */
-#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
-#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
-#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
-#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
-    (version_var) = __PYX_GET_DICT_VERSION(dict);\
-    (cache_var) = (value);
-#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
-    static PY_UINT64_T __pyx_dict_version = 0;\
-    static PyObject *__pyx_dict_cached_value = NULL;\
-    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
-        (VAR) = __pyx_dict_cached_value;\
-    } else {\
-        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
-        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
-    }\
-}
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
-static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
-#else
-#define __PYX_GET_DICT_VERSION(dict)  (0)
-#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
-#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
-#endif
-
-/* GetModuleGlobalName.proto */
-#if CYTHON_USE_DICT_VERSIONS
-#define __Pyx_GetModuleGlobalName(var, name)  do {\
-    static PY_UINT64_T __pyx_dict_version = 0;\
-    static PyObject *__pyx_dict_cached_value = NULL;\
-    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
-        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
-        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
-    PY_UINT64_T __pyx_dict_version;\
-    PyObject *__pyx_dict_cached_value;\
-    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
-} while(0)
-static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
-#else
-#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
-#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
-static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
-#endif
-
 /* PyObjectCallOneArg.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);
 
 /* Py3UpdateBases.proto */
 static PyObject* __Pyx_PEP560_update_bases(PyObject *bases);
 
 /* CyFunctionClassCell.proto */
@@ -2108,33 +2129,31 @@
 static int __Pyx_check_binary_version(unsigned long ct_version, unsigned long rt_version, int allow_newer);
 
 /* InitStrings.proto */
 static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);
 
 /* #### Code section: module_declarations ### */
 
-/* Module declarations from "adaXT.decision_tree.Nodes" */
+/* Module declarations from "adaXT.decision_tree.nodes" */
 /* #### Code section: typeinfo ### */
 /* #### Code section: before_global_var ### */
-#define __Pyx_MODULE_NAME "adaXT.decision_tree.Nodes"
-extern int __pyx_module_is_main_adaXT__decision_tree__Nodes;
-int __pyx_module_is_main_adaXT__decision_tree__Nodes = 0;
+#define __Pyx_MODULE_NAME "adaXT.decision_tree.nodes"
+extern int __pyx_module_is_main_adaXT__decision_tree__nodes;
+int __pyx_module_is_main_adaXT__decision_tree__nodes = 0;
 
-/* Implementation of "adaXT.decision_tree.Nodes" */
+/* Implementation of "adaXT.decision_tree.nodes" */
 /* #### Code section: global_var ### */
 static PyObject *__pyx_builtin_super;
 /* #### Code section: string_decls ### */
 static const char __pyx_k_[] = "*";
-static const char __pyx_k__2[] = ".";
 static const char __pyx_k_id[] = "id";
 static const char __pyx_k_np[] = "np";
-static const char __pyx_k__10[] = "?";
+static const char __pyx_k__11[] = "?";
 static const char __pyx_k_doc[] = "__doc__";
 static const char __pyx_k_int[] = "int";
-static const char __pyx_k_List[] = "List";
 static const char __pyx_k_Node[] = "Node";
 static const char __pyx_k_None[] = "None";
 static const char __pyx_k_dict[] = "__dict__";
 static const char __pyx_k_init[] = "__init__";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_name[] = "__name__";
 static const char __pyx_k_self[] = "self";
@@ -2143,49 +2162,54 @@
 static const char __pyx_k_depth[] = "depth";
 static const char __pyx_k_float[] = "float";
 static const char __pyx_k_numpy[] = "numpy";
 static const char __pyx_k_super[] = "super";
 static const char __pyx_k_value[] = "value";
 static const char __pyx_k_import[] = "__import__";
 static const char __pyx_k_module[] = "__module__";
+static const char __pyx_k_object[] = "object";
 static const char __pyx_k_parent[] = "parent";
 static const char __pyx_k_return[] = "return";
-static const char __pyx_k_typing[] = "typing";
+static const char __pyx_k_theta0[] = "theta0";
+static const char __pyx_k_theta1[] = "theta1";
+static const char __pyx_k_asarray[] = "asarray";
 static const char __pyx_k_indices[] = "indices";
 static const char __pyx_k_prepare[] = "__prepare__";
 static const char __pyx_k_LeafNode[] = "LeafNode";
 static const char __pyx_k_impurity[] = "impurity";
 static const char __pyx_k_qualname[] = "__qualname__";
 static const char __pyx_k_set_name[] = "__set_name__";
 static const char __pyx_k_metaclass[] = "__metaclass__";
 static const char __pyx_k_n_samples[] = "n_samples";
 static const char __pyx_k_split_idx[] = "split_idx";
 static const char __pyx_k_threshold[] = "threshold";
-static const char __pyx_k_List_float[] = "List[float]";
 static const char __pyx_k_left_child[] = "left_child";
 static const char __pyx_k_np_ndarray[] = "np.ndarray";
 static const char __pyx_k_Node___init[] = "Node.__init__";
 static const char __pyx_k_mro_entries[] = "__mro_entries__";
 static const char __pyx_k_right_child[] = "right_child";
 static const char __pyx_k_DecisionNode[] = "DecisionNode";
 static const char __pyx_k_initializing[] = "_initializing";
 static const char __pyx_k_is_coroutine[] = "_is_coroutine";
 static const char __pyx_k_init_subclass[] = "__init_subclass__";
 static const char __pyx_k_LeafNode___init[] = "LeafNode.__init__";
 static const char __pyx_k_DecisionNode_None[] = "'DecisionNode|None'";
 static const char __pyx_k_asyncio_coroutines[] = "asyncio.coroutines";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_DecisionNode___init[] = "DecisionNode.__init__";
-static const char __pyx_k_adaXT_decision_tree_Nodes[] = "adaXT.decision_tree.Nodes";
+static const char __pyx_k_LinearRegressionLeafNode[] = "LinearRegressionLeafNode";
+static const char __pyx_k_adaXT_decision_tree_nodes[] = "adaXT.decision_tree.nodes";
 static const char __pyx_k_DecisionNode_LeafNode_None[] = "'DecisionNode|LeafNode|None'";
-static const char __pyx_k_src_adaXT_decision_tree_Nodes_py[] = "src/adaXT/decision_tree/Nodes.pyx";
+static const char __pyx_k_LinearRegressionLeafNode___init[] = "LinearRegressionLeafNode.__init__";
+static const char __pyx_k_src_adaXT_decision_tree_nodes_py[] = "src/adaXT/decision_tree/nodes.pyx";
 /* #### Code section: decls ### */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_5Nodes_4Node___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_5Nodes_12DecisionNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, double __pyx_v_threshold, PyObject *__pyx_v_split_idx, PyObject *__pyx_v_left_child, PyObject *__pyx_v_right_child, PyObject *__pyx_v_parent); /* proto */
-static PyObject *__pyx_pf_5adaXT_13decision_tree_5Nodes_8LeafNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, PyObject *__pyx_v_value, PyObject *__pyx_v_parent); /* proto */
+static PyObject *__pyx_pf_5adaXT_13decision_tree_5nodes_4Node___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples); /* proto */
+static PyObject *__pyx_pf_5adaXT_13decision_tree_5nodes_12DecisionNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, double __pyx_v_threshold, PyObject *__pyx_v_split_idx, PyObject *__pyx_v_left_child, PyObject *__pyx_v_right_child, PyObject *__pyx_v_parent); /* proto */
+static PyObject *__pyx_pf_5adaXT_13decision_tree_5nodes_8LeafNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, PyObject *__pyx_v_value, PyObject *__pyx_v_parent); /* proto */
+static PyObject *__pyx_pf_5adaXT_13decision_tree_5nodes_24LinearRegressionLeafNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, PyObject *__pyx_v_value, PyObject *__pyx_v_parent, double __pyx_v_theta0, double __pyx_v_theta1); /* proto */
 /* #### Code section: late_includes ### */
 /* #### Code section: module_state ### */
 typedef struct {
   PyObject *__pyx_d;
   PyObject *__pyx_b;
   PyObject *__pyx_cython_runtime;
   PyObject *__pyx_empty_tuple;
@@ -2214,22 +2238,22 @@
   PyObject *__pyx_n_s_;
   PyObject *__pyx_n_s_DecisionNode;
   PyObject *__pyx_kp_s_DecisionNode_LeafNode_None;
   PyObject *__pyx_kp_s_DecisionNode_None;
   PyObject *__pyx_n_s_DecisionNode___init;
   PyObject *__pyx_n_s_LeafNode;
   PyObject *__pyx_n_s_LeafNode___init;
-  PyObject *__pyx_n_s_List;
-  PyObject *__pyx_kp_s_List_float;
+  PyObject *__pyx_n_s_LinearRegressionLeafNode;
+  PyObject *__pyx_n_s_LinearRegressionLeafNode___init;
   PyObject *__pyx_n_s_Node;
   PyObject *__pyx_n_s_Node___init;
   PyObject *__pyx_n_s_None;
-  PyObject *__pyx_n_s__10;
-  PyObject *__pyx_kp_u__2;
-  PyObject *__pyx_n_s_adaXT_decision_tree_Nodes;
+  PyObject *__pyx_n_s__11;
+  PyObject *__pyx_n_s_adaXT_decision_tree_nodes;
+  PyObject *__pyx_n_s_asarray;
   PyObject *__pyx_n_s_asyncio_coroutines;
   PyObject *__pyx_n_s_cline_in_traceback;
   PyObject *__pyx_n_s_depth;
   PyObject *__pyx_n_s_dict;
   PyObject *__pyx_n_s_doc;
   PyObject *__pyx_n_s_float;
   PyObject *__pyx_n_s_id;
@@ -2247,36 +2271,40 @@
   PyObject *__pyx_n_s_module;
   PyObject *__pyx_n_s_mro_entries;
   PyObject *__pyx_n_s_n_samples;
   PyObject *__pyx_n_s_name;
   PyObject *__pyx_n_s_np;
   PyObject *__pyx_kp_s_np_ndarray;
   PyObject *__pyx_n_s_numpy;
+  PyObject *__pyx_n_s_object;
   PyObject *__pyx_n_s_parent;
   PyObject *__pyx_n_s_prepare;
   PyObject *__pyx_n_s_qualname;
   PyObject *__pyx_n_s_return;
   PyObject *__pyx_n_s_right_child;
   PyObject *__pyx_n_s_self;
   PyObject *__pyx_n_s_set_name;
   PyObject *__pyx_n_s_spec;
   PyObject *__pyx_n_s_split_idx;
-  PyObject *__pyx_kp_s_src_adaXT_decision_tree_Nodes_py;
+  PyObject *__pyx_kp_s_src_adaXT_decision_tree_nodes_py;
   PyObject *__pyx_n_s_super;
   PyObject *__pyx_n_s_test;
+  PyObject *__pyx_n_s_theta0;
+  PyObject *__pyx_n_s_theta1;
   PyObject *__pyx_n_s_threshold;
-  PyObject *__pyx_n_s_typing;
   PyObject *__pyx_n_s_value;
-  PyObject *__pyx_tuple__3;
-  PyObject *__pyx_tuple__5;
+  PyObject *__pyx_tuple__2;
+  PyObject *__pyx_tuple__4;
+  PyObject *__pyx_tuple__6;
   PyObject *__pyx_tuple__7;
-  PyObject *__pyx_tuple__8;
-  PyObject *__pyx_codeobj__4;
-  PyObject *__pyx_codeobj__6;
-  PyObject *__pyx_codeobj__9;
+  PyObject *__pyx_tuple__9;
+  PyObject *__pyx_codeobj__3;
+  PyObject *__pyx_codeobj__5;
+  PyObject *__pyx_codeobj__8;
+  PyObject *__pyx_codeobj__10;
 } __pyx_mstate;
 
 #if CYTHON_USE_MODULE_STATE
 #ifdef __cplusplus
 namespace {
   extern struct PyModuleDef __pyx_moduledef;
 } /* anonymous namespace */
@@ -2318,22 +2346,22 @@
   Py_CLEAR(clear_module_state->__pyx_n_s_);
   Py_CLEAR(clear_module_state->__pyx_n_s_DecisionNode);
   Py_CLEAR(clear_module_state->__pyx_kp_s_DecisionNode_LeafNode_None);
   Py_CLEAR(clear_module_state->__pyx_kp_s_DecisionNode_None);
   Py_CLEAR(clear_module_state->__pyx_n_s_DecisionNode___init);
   Py_CLEAR(clear_module_state->__pyx_n_s_LeafNode);
   Py_CLEAR(clear_module_state->__pyx_n_s_LeafNode___init);
-  Py_CLEAR(clear_module_state->__pyx_n_s_List);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_List_float);
+  Py_CLEAR(clear_module_state->__pyx_n_s_LinearRegressionLeafNode);
+  Py_CLEAR(clear_module_state->__pyx_n_s_LinearRegressionLeafNode___init);
   Py_CLEAR(clear_module_state->__pyx_n_s_Node);
   Py_CLEAR(clear_module_state->__pyx_n_s_Node___init);
   Py_CLEAR(clear_module_state->__pyx_n_s_None);
-  Py_CLEAR(clear_module_state->__pyx_n_s__10);
-  Py_CLEAR(clear_module_state->__pyx_kp_u__2);
-  Py_CLEAR(clear_module_state->__pyx_n_s_adaXT_decision_tree_Nodes);
+  Py_CLEAR(clear_module_state->__pyx_n_s__11);
+  Py_CLEAR(clear_module_state->__pyx_n_s_adaXT_decision_tree_nodes);
+  Py_CLEAR(clear_module_state->__pyx_n_s_asarray);
   Py_CLEAR(clear_module_state->__pyx_n_s_asyncio_coroutines);
   Py_CLEAR(clear_module_state->__pyx_n_s_cline_in_traceback);
   Py_CLEAR(clear_module_state->__pyx_n_s_depth);
   Py_CLEAR(clear_module_state->__pyx_n_s_dict);
   Py_CLEAR(clear_module_state->__pyx_n_s_doc);
   Py_CLEAR(clear_module_state->__pyx_n_s_float);
   Py_CLEAR(clear_module_state->__pyx_n_s_id);
@@ -2351,36 +2379,40 @@
   Py_CLEAR(clear_module_state->__pyx_n_s_module);
   Py_CLEAR(clear_module_state->__pyx_n_s_mro_entries);
   Py_CLEAR(clear_module_state->__pyx_n_s_n_samples);
   Py_CLEAR(clear_module_state->__pyx_n_s_name);
   Py_CLEAR(clear_module_state->__pyx_n_s_np);
   Py_CLEAR(clear_module_state->__pyx_kp_s_np_ndarray);
   Py_CLEAR(clear_module_state->__pyx_n_s_numpy);
+  Py_CLEAR(clear_module_state->__pyx_n_s_object);
   Py_CLEAR(clear_module_state->__pyx_n_s_parent);
   Py_CLEAR(clear_module_state->__pyx_n_s_prepare);
   Py_CLEAR(clear_module_state->__pyx_n_s_qualname);
   Py_CLEAR(clear_module_state->__pyx_n_s_return);
   Py_CLEAR(clear_module_state->__pyx_n_s_right_child);
   Py_CLEAR(clear_module_state->__pyx_n_s_self);
   Py_CLEAR(clear_module_state->__pyx_n_s_set_name);
   Py_CLEAR(clear_module_state->__pyx_n_s_spec);
   Py_CLEAR(clear_module_state->__pyx_n_s_split_idx);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_src_adaXT_decision_tree_Nodes_py);
+  Py_CLEAR(clear_module_state->__pyx_kp_s_src_adaXT_decision_tree_nodes_py);
   Py_CLEAR(clear_module_state->__pyx_n_s_super);
   Py_CLEAR(clear_module_state->__pyx_n_s_test);
+  Py_CLEAR(clear_module_state->__pyx_n_s_theta0);
+  Py_CLEAR(clear_module_state->__pyx_n_s_theta1);
   Py_CLEAR(clear_module_state->__pyx_n_s_threshold);
-  Py_CLEAR(clear_module_state->__pyx_n_s_typing);
   Py_CLEAR(clear_module_state->__pyx_n_s_value);
-  Py_CLEAR(clear_module_state->__pyx_tuple__3);
-  Py_CLEAR(clear_module_state->__pyx_tuple__5);
+  Py_CLEAR(clear_module_state->__pyx_tuple__2);
+  Py_CLEAR(clear_module_state->__pyx_tuple__4);
+  Py_CLEAR(clear_module_state->__pyx_tuple__6);
   Py_CLEAR(clear_module_state->__pyx_tuple__7);
-  Py_CLEAR(clear_module_state->__pyx_tuple__8);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__4);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__6);
-  Py_CLEAR(clear_module_state->__pyx_codeobj__9);
+  Py_CLEAR(clear_module_state->__pyx_tuple__9);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__3);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__5);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__8);
+  Py_CLEAR(clear_module_state->__pyx_codeobj__10);
   return 0;
 }
 #endif
 /* #### Code section: module_state_traverse ### */
 #if CYTHON_USE_MODULE_STATE
 static int __pyx_m_traverse(PyObject *m, visitproc visit, void *arg) {
   __pyx_mstate *traverse_module_state = __pyx_mstate(m);
@@ -2400,22 +2432,22 @@
   Py_VISIT(traverse_module_state->__pyx_n_s_);
   Py_VISIT(traverse_module_state->__pyx_n_s_DecisionNode);
   Py_VISIT(traverse_module_state->__pyx_kp_s_DecisionNode_LeafNode_None);
   Py_VISIT(traverse_module_state->__pyx_kp_s_DecisionNode_None);
   Py_VISIT(traverse_module_state->__pyx_n_s_DecisionNode___init);
   Py_VISIT(traverse_module_state->__pyx_n_s_LeafNode);
   Py_VISIT(traverse_module_state->__pyx_n_s_LeafNode___init);
-  Py_VISIT(traverse_module_state->__pyx_n_s_List);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_List_float);
+  Py_VISIT(traverse_module_state->__pyx_n_s_LinearRegressionLeafNode);
+  Py_VISIT(traverse_module_state->__pyx_n_s_LinearRegressionLeafNode___init);
   Py_VISIT(traverse_module_state->__pyx_n_s_Node);
   Py_VISIT(traverse_module_state->__pyx_n_s_Node___init);
   Py_VISIT(traverse_module_state->__pyx_n_s_None);
-  Py_VISIT(traverse_module_state->__pyx_n_s__10);
-  Py_VISIT(traverse_module_state->__pyx_kp_u__2);
-  Py_VISIT(traverse_module_state->__pyx_n_s_adaXT_decision_tree_Nodes);
+  Py_VISIT(traverse_module_state->__pyx_n_s__11);
+  Py_VISIT(traverse_module_state->__pyx_n_s_adaXT_decision_tree_nodes);
+  Py_VISIT(traverse_module_state->__pyx_n_s_asarray);
   Py_VISIT(traverse_module_state->__pyx_n_s_asyncio_coroutines);
   Py_VISIT(traverse_module_state->__pyx_n_s_cline_in_traceback);
   Py_VISIT(traverse_module_state->__pyx_n_s_depth);
   Py_VISIT(traverse_module_state->__pyx_n_s_dict);
   Py_VISIT(traverse_module_state->__pyx_n_s_doc);
   Py_VISIT(traverse_module_state->__pyx_n_s_float);
   Py_VISIT(traverse_module_state->__pyx_n_s_id);
@@ -2433,36 +2465,40 @@
   Py_VISIT(traverse_module_state->__pyx_n_s_module);
   Py_VISIT(traverse_module_state->__pyx_n_s_mro_entries);
   Py_VISIT(traverse_module_state->__pyx_n_s_n_samples);
   Py_VISIT(traverse_module_state->__pyx_n_s_name);
   Py_VISIT(traverse_module_state->__pyx_n_s_np);
   Py_VISIT(traverse_module_state->__pyx_kp_s_np_ndarray);
   Py_VISIT(traverse_module_state->__pyx_n_s_numpy);
+  Py_VISIT(traverse_module_state->__pyx_n_s_object);
   Py_VISIT(traverse_module_state->__pyx_n_s_parent);
   Py_VISIT(traverse_module_state->__pyx_n_s_prepare);
   Py_VISIT(traverse_module_state->__pyx_n_s_qualname);
   Py_VISIT(traverse_module_state->__pyx_n_s_return);
   Py_VISIT(traverse_module_state->__pyx_n_s_right_child);
   Py_VISIT(traverse_module_state->__pyx_n_s_self);
   Py_VISIT(traverse_module_state->__pyx_n_s_set_name);
   Py_VISIT(traverse_module_state->__pyx_n_s_spec);
   Py_VISIT(traverse_module_state->__pyx_n_s_split_idx);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_src_adaXT_decision_tree_Nodes_py);
+  Py_VISIT(traverse_module_state->__pyx_kp_s_src_adaXT_decision_tree_nodes_py);
   Py_VISIT(traverse_module_state->__pyx_n_s_super);
   Py_VISIT(traverse_module_state->__pyx_n_s_test);
+  Py_VISIT(traverse_module_state->__pyx_n_s_theta0);
+  Py_VISIT(traverse_module_state->__pyx_n_s_theta1);
   Py_VISIT(traverse_module_state->__pyx_n_s_threshold);
-  Py_VISIT(traverse_module_state->__pyx_n_s_typing);
   Py_VISIT(traverse_module_state->__pyx_n_s_value);
-  Py_VISIT(traverse_module_state->__pyx_tuple__3);
-  Py_VISIT(traverse_module_state->__pyx_tuple__5);
+  Py_VISIT(traverse_module_state->__pyx_tuple__2);
+  Py_VISIT(traverse_module_state->__pyx_tuple__4);
+  Py_VISIT(traverse_module_state->__pyx_tuple__6);
   Py_VISIT(traverse_module_state->__pyx_tuple__7);
-  Py_VISIT(traverse_module_state->__pyx_tuple__8);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__4);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__6);
-  Py_VISIT(traverse_module_state->__pyx_codeobj__9);
+  Py_VISIT(traverse_module_state->__pyx_tuple__9);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__3);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__5);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__8);
+  Py_VISIT(traverse_module_state->__pyx_codeobj__10);
   return 0;
 }
 #endif
 /* #### Code section: module_state_defines ### */
 #define __pyx_d __pyx_mstate_global->__pyx_d
 #define __pyx_b __pyx_mstate_global->__pyx_b
 #define __pyx_cython_runtime __pyx_mstate_global->__pyx_cython_runtime
@@ -2492,22 +2528,22 @@
 #define __pyx_n_s_ __pyx_mstate_global->__pyx_n_s_
 #define __pyx_n_s_DecisionNode __pyx_mstate_global->__pyx_n_s_DecisionNode
 #define __pyx_kp_s_DecisionNode_LeafNode_None __pyx_mstate_global->__pyx_kp_s_DecisionNode_LeafNode_None
 #define __pyx_kp_s_DecisionNode_None __pyx_mstate_global->__pyx_kp_s_DecisionNode_None
 #define __pyx_n_s_DecisionNode___init __pyx_mstate_global->__pyx_n_s_DecisionNode___init
 #define __pyx_n_s_LeafNode __pyx_mstate_global->__pyx_n_s_LeafNode
 #define __pyx_n_s_LeafNode___init __pyx_mstate_global->__pyx_n_s_LeafNode___init
-#define __pyx_n_s_List __pyx_mstate_global->__pyx_n_s_List
-#define __pyx_kp_s_List_float __pyx_mstate_global->__pyx_kp_s_List_float
+#define __pyx_n_s_LinearRegressionLeafNode __pyx_mstate_global->__pyx_n_s_LinearRegressionLeafNode
+#define __pyx_n_s_LinearRegressionLeafNode___init __pyx_mstate_global->__pyx_n_s_LinearRegressionLeafNode___init
 #define __pyx_n_s_Node __pyx_mstate_global->__pyx_n_s_Node
 #define __pyx_n_s_Node___init __pyx_mstate_global->__pyx_n_s_Node___init
 #define __pyx_n_s_None __pyx_mstate_global->__pyx_n_s_None
-#define __pyx_n_s__10 __pyx_mstate_global->__pyx_n_s__10
-#define __pyx_kp_u__2 __pyx_mstate_global->__pyx_kp_u__2
-#define __pyx_n_s_adaXT_decision_tree_Nodes __pyx_mstate_global->__pyx_n_s_adaXT_decision_tree_Nodes
+#define __pyx_n_s__11 __pyx_mstate_global->__pyx_n_s__11
+#define __pyx_n_s_adaXT_decision_tree_nodes __pyx_mstate_global->__pyx_n_s_adaXT_decision_tree_nodes
+#define __pyx_n_s_asarray __pyx_mstate_global->__pyx_n_s_asarray
 #define __pyx_n_s_asyncio_coroutines __pyx_mstate_global->__pyx_n_s_asyncio_coroutines
 #define __pyx_n_s_cline_in_traceback __pyx_mstate_global->__pyx_n_s_cline_in_traceback
 #define __pyx_n_s_depth __pyx_mstate_global->__pyx_n_s_depth
 #define __pyx_n_s_dict __pyx_mstate_global->__pyx_n_s_dict
 #define __pyx_n_s_doc __pyx_mstate_global->__pyx_n_s_doc
 #define __pyx_n_s_float __pyx_mstate_global->__pyx_n_s_float
 #define __pyx_n_s_id __pyx_mstate_global->__pyx_n_s_id
@@ -2525,56 +2561,60 @@
 #define __pyx_n_s_module __pyx_mstate_global->__pyx_n_s_module
 #define __pyx_n_s_mro_entries __pyx_mstate_global->__pyx_n_s_mro_entries
 #define __pyx_n_s_n_samples __pyx_mstate_global->__pyx_n_s_n_samples
 #define __pyx_n_s_name __pyx_mstate_global->__pyx_n_s_name
 #define __pyx_n_s_np __pyx_mstate_global->__pyx_n_s_np
 #define __pyx_kp_s_np_ndarray __pyx_mstate_global->__pyx_kp_s_np_ndarray
 #define __pyx_n_s_numpy __pyx_mstate_global->__pyx_n_s_numpy
+#define __pyx_n_s_object __pyx_mstate_global->__pyx_n_s_object
 #define __pyx_n_s_parent __pyx_mstate_global->__pyx_n_s_parent
 #define __pyx_n_s_prepare __pyx_mstate_global->__pyx_n_s_prepare
 #define __pyx_n_s_qualname __pyx_mstate_global->__pyx_n_s_qualname
 #define __pyx_n_s_return __pyx_mstate_global->__pyx_n_s_return
 #define __pyx_n_s_right_child __pyx_mstate_global->__pyx_n_s_right_child
 #define __pyx_n_s_self __pyx_mstate_global->__pyx_n_s_self
 #define __pyx_n_s_set_name __pyx_mstate_global->__pyx_n_s_set_name
 #define __pyx_n_s_spec __pyx_mstate_global->__pyx_n_s_spec
 #define __pyx_n_s_split_idx __pyx_mstate_global->__pyx_n_s_split_idx
-#define __pyx_kp_s_src_adaXT_decision_tree_Nodes_py __pyx_mstate_global->__pyx_kp_s_src_adaXT_decision_tree_Nodes_py
+#define __pyx_kp_s_src_adaXT_decision_tree_nodes_py __pyx_mstate_global->__pyx_kp_s_src_adaXT_decision_tree_nodes_py
 #define __pyx_n_s_super __pyx_mstate_global->__pyx_n_s_super
 #define __pyx_n_s_test __pyx_mstate_global->__pyx_n_s_test
+#define __pyx_n_s_theta0 __pyx_mstate_global->__pyx_n_s_theta0
+#define __pyx_n_s_theta1 __pyx_mstate_global->__pyx_n_s_theta1
 #define __pyx_n_s_threshold __pyx_mstate_global->__pyx_n_s_threshold
-#define __pyx_n_s_typing __pyx_mstate_global->__pyx_n_s_typing
 #define __pyx_n_s_value __pyx_mstate_global->__pyx_n_s_value
-#define __pyx_tuple__3 __pyx_mstate_global->__pyx_tuple__3
-#define __pyx_tuple__5 __pyx_mstate_global->__pyx_tuple__5
+#define __pyx_tuple__2 __pyx_mstate_global->__pyx_tuple__2
+#define __pyx_tuple__4 __pyx_mstate_global->__pyx_tuple__4
+#define __pyx_tuple__6 __pyx_mstate_global->__pyx_tuple__6
 #define __pyx_tuple__7 __pyx_mstate_global->__pyx_tuple__7
-#define __pyx_tuple__8 __pyx_mstate_global->__pyx_tuple__8
-#define __pyx_codeobj__4 __pyx_mstate_global->__pyx_codeobj__4
-#define __pyx_codeobj__6 __pyx_mstate_global->__pyx_codeobj__6
-#define __pyx_codeobj__9 __pyx_mstate_global->__pyx_codeobj__9
+#define __pyx_tuple__9 __pyx_mstate_global->__pyx_tuple__9
+#define __pyx_codeobj__3 __pyx_mstate_global->__pyx_codeobj__3
+#define __pyx_codeobj__5 __pyx_mstate_global->__pyx_codeobj__5
+#define __pyx_codeobj__8 __pyx_mstate_global->__pyx_codeobj__8
+#define __pyx_codeobj__10 __pyx_mstate_global->__pyx_codeobj__10
 /* #### Code section: module_code ### */
 
-/* "adaXT/decision_tree/Nodes.pyx":8
+/* "adaXT/decision_tree/nodes.pyx":6
  * 
  * class Node:
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             indices: np.ndarray,
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_5Nodes_4Node_1__init__(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_13decision_tree_5nodes_4Node_1__init__(PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_5Nodes_4Node_1__init__ = {"__init__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_5Nodes_4Node_1__init__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_5Nodes_4Node_1__init__(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_5nodes_4Node_1__init__ = {"__init__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_5nodes_4Node_1__init__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_13decision_tree_5nodes_4Node_1__init__(PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
   PyObject *__pyx_v_self = 0;
@@ -2622,95 +2662,95 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 6, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 6, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, 1); __PYX_ERR(0, 8, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, 1); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_depth)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 6, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, 2); __PYX_ERR(0, 8, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, 2); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_impurity)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[3]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 6, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, 3); __PYX_ERR(0, 8, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, 3); __PYX_ERR(0, 6, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
         if (likely((values[4] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_n_samples)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[4]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 6, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, 4); __PYX_ERR(0, 8, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, 4); __PYX_ERR(0, 6, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 8, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 6, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 5)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
       values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
       values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
       values[4] = __Pyx_Arg_FASTCALL(__pyx_args, 4);
     }
     __pyx_v_self = values[0];
     __pyx_v_indices = values[1];
     __pyx_v_depth = ((PyObject*)values[2]);
-    __pyx_v_impurity = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_impurity == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 12, __pyx_L3_error)
+    __pyx_v_impurity = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_impurity == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 10, __pyx_L3_error)
     __pyx_v_n_samples = ((PyObject*)values[4]);
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, __pyx_nargs); __PYX_ERR(0, 8, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 5, 5, __pyx_nargs); __PYX_ERR(0, 6, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.Nodes.Node.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.decision_tree.nodes.Node.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_depth), (&PyInt_Type), 0, "depth", 1))) __PYX_ERR(0, 11, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_n_samples), (&PyInt_Type), 0, "n_samples", 1))) __PYX_ERR(0, 13, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_5Nodes_4Node___init__(__pyx_self, __pyx_v_self, __pyx_v_indices, __pyx_v_depth, __pyx_v_impurity, __pyx_v_n_samples);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_depth), (&PyInt_Type), 0, "depth", 1))) __PYX_ERR(0, 9, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_n_samples), (&PyInt_Type), 0, "n_samples", 1))) __PYX_ERR(0, 11, __pyx_L1_error)
+  __pyx_r = __pyx_pf_5adaXT_13decision_tree_5nodes_4Node___init__(__pyx_self, __pyx_v_self, __pyx_v_indices, __pyx_v_depth, __pyx_v_impurity, __pyx_v_n_samples);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
   {
@@ -2719,101 +2759,134 @@
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_5Nodes_4Node___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples) {
+static PyObject *__pyx_pf_5adaXT_13decision_tree_5nodes_4Node___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 1);
 
-  /* "adaXT/decision_tree/Nodes.pyx":14
+  /* "adaXT/decision_tree/nodes.pyx":12
  *             impurity: float,
  *             n_samples: int) -> None:
- *         self.indices = indices             # <<<<<<<<<<<<<<
+ *         self.indices = np.asarray(indices)             # <<<<<<<<<<<<<<
  *         self.depth = depth
  *         self.impurity = impurity
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_indices, __pyx_v_indices) < 0) __PYX_ERR(0, 14, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_asarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 12, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = NULL;
+  __pyx_t_4 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_2)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_2);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __pyx_t_4 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_2, __pyx_v_indices};
+    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_4, 1+__pyx_t_4);
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  }
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_indices, __pyx_t_1) < 0) __PYX_ERR(0, 12, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":15
+  /* "adaXT/decision_tree/nodes.pyx":13
  *             n_samples: int) -> None:
- *         self.indices = indices
+ *         self.indices = np.asarray(indices)
  *         self.depth = depth             # <<<<<<<<<<<<<<
  *         self.impurity = impurity
  *         self.n_samples = n_samples
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_depth, __pyx_v_depth) < 0) __PYX_ERR(0, 15, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_depth, __pyx_v_depth) < 0) __PYX_ERR(0, 13, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":16
- *         self.indices = indices
+  /* "adaXT/decision_tree/nodes.pyx":14
+ *         self.indices = np.asarray(indices)
  *         self.depth = depth
  *         self.impurity = impurity             # <<<<<<<<<<<<<<
  *         self.n_samples = n_samples
  * 
  */
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 16, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_impurity); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 14, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_impurity, __pyx_t_1) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_impurity, __pyx_t_1) < 0) __PYX_ERR(0, 14, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":17
+  /* "adaXT/decision_tree/nodes.pyx":15
  *         self.depth = depth
  *         self.impurity = impurity
  *         self.n_samples = n_samples             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_n_samples, __pyx_v_n_samples) < 0) __PYX_ERR(0, 17, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_n_samples, __pyx_v_n_samples) < 0) __PYX_ERR(0, 15, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":8
+  /* "adaXT/decision_tree/nodes.pyx":6
  * 
  * class Node:
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             indices: np.ndarray,
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_AddTraceback("adaXT.decision_tree.Nodes.Node.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("adaXT.decision_tree.nodes.Node.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/Nodes.pyx":21
+/* "adaXT/decision_tree/nodes.pyx":19
  * 
  * class DecisionNode(Node):
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             indices: np.ndarray,
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_5Nodes_12DecisionNode_1__init__(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_13decision_tree_5nodes_12DecisionNode_1__init__(PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_5Nodes_12DecisionNode_1__init__ = {"__init__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_5Nodes_12DecisionNode_1__init__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_5Nodes_12DecisionNode_1__init__(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_5nodes_12DecisionNode_1__init__ = {"__init__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_5nodes_12DecisionNode_1__init__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_13decision_tree_5nodes_12DecisionNode_1__init__(PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
   PyObject *__pyx_v_self = 0;
@@ -2844,38 +2917,38 @@
   __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
   #endif
   #endif
   __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
   {
     PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_indices,&__pyx_n_s_depth,&__pyx_n_s_impurity,&__pyx_n_s_n_samples,&__pyx_n_s_threshold,&__pyx_n_s_split_idx,&__pyx_n_s_left_child,&__pyx_n_s_right_child,&__pyx_n_s_parent,0};
 
-    /* "adaXT/decision_tree/Nodes.pyx":29
+    /* "adaXT/decision_tree/nodes.pyx":27
  *             threshold: float,
  *             split_idx: int,
  *             left_child: "DecisionNode|LeafNode|None" = None,             # <<<<<<<<<<<<<<
  *             right_child: "DecisionNode|LeafNode|None" = None,
  *             parent: "DecisionNode|None" = None) -> None:
  */
     values[7] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)Py_None));
 
-    /* "adaXT/decision_tree/Nodes.pyx":30
+    /* "adaXT/decision_tree/nodes.pyx":28
  *             split_idx: int,
  *             left_child: "DecisionNode|LeafNode|None" = None,
  *             right_child: "DecisionNode|LeafNode|None" = None,             # <<<<<<<<<<<<<<
  *             parent: "DecisionNode|None" = None) -> None:
- * 
+ *         super().__init__(indices, depth, impurity, n_samples)
  */
     values[8] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)Py_None));
 
-    /* "adaXT/decision_tree/Nodes.pyx":31
+    /* "adaXT/decision_tree/nodes.pyx":29
  *             left_child: "DecisionNode|LeafNode|None" = None,
  *             right_child: "DecisionNode|LeafNode|None" = None,
  *             parent: "DecisionNode|None" = None) -> None:             # <<<<<<<<<<<<<<
- * 
  *         super().__init__(indices, depth, impurity, n_samples)
+ *         self.threshold = threshold
  */
     values[9] = __Pyx_Arg_NewRef_FASTCALL(((PyObject *)Py_None));
     if (__pyx_kwds) {
       Py_ssize_t kw_args;
       switch (__pyx_nargs) {
         case 10: values[9] = __Pyx_Arg_FASTCALL(__pyx_args, 9);
         CYTHON_FALLTHROUGH;
@@ -2903,101 +2976,101 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 1); __PYX_ERR(0, 21, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 1); __PYX_ERR(0, 19, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_depth)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 2); __PYX_ERR(0, 21, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 2); __PYX_ERR(0, 19, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_impurity)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[3]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 3); __PYX_ERR(0, 21, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 3); __PYX_ERR(0, 19, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
         if (likely((values[4] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_n_samples)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[4]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 4); __PYX_ERR(0, 21, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 4); __PYX_ERR(0, 19, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  5:
         if (likely((values[5] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_threshold)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[5]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 5); __PYX_ERR(0, 21, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 5); __PYX_ERR(0, 19, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  6:
         if (likely((values[6] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_split_idx)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[6]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 6); __PYX_ERR(0, 21, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, 6); __PYX_ERR(0, 19, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  7:
         if (kw_args > 0) {
           PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_left_child);
           if (value) { values[7] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  8:
         if (kw_args > 0) {
           PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_right_child);
           if (value) { values[8] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  9:
         if (kw_args > 0) {
           PyObject* value = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_parent);
           if (value) { values[9] = __Pyx_Arg_NewRef_FASTCALL(value); kw_args--; }
-          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 21, __pyx_L3_error)
+          else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 19, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 21, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 19, __pyx_L3_error)
       }
     } else {
       switch (__pyx_nargs) {
         case 10: values[9] = __Pyx_Arg_FASTCALL(__pyx_args, 9);
         CYTHON_FALLTHROUGH;
         case  9: values[8] = __Pyx_Arg_FASTCALL(__pyx_args, 8);
         CYTHON_FALLTHROUGH;
@@ -3013,44 +3086,44 @@
         break;
         default: goto __pyx_L5_argtuple_error;
       }
     }
     __pyx_v_self = values[0];
     __pyx_v_indices = values[1];
     __pyx_v_depth = ((PyObject*)values[2]);
-    __pyx_v_impurity = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_impurity == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 25, __pyx_L3_error)
+    __pyx_v_impurity = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_impurity == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 23, __pyx_L3_error)
     __pyx_v_n_samples = ((PyObject*)values[4]);
-    __pyx_v_threshold = __pyx_PyFloat_AsDouble(values[5]); if (unlikely((__pyx_v_threshold == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 27, __pyx_L3_error)
+    __pyx_v_threshold = __pyx_PyFloat_AsDouble(values[5]); if (unlikely((__pyx_v_threshold == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 25, __pyx_L3_error)
     __pyx_v_split_idx = ((PyObject*)values[6]);
     __pyx_v_left_child = values[7];
     __pyx_v_right_child = values[8];
     __pyx_v_parent = values[9];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, __pyx_nargs); __PYX_ERR(0, 21, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 0, 7, 10, __pyx_nargs); __PYX_ERR(0, 19, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.Nodes.DecisionNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.decision_tree.nodes.DecisionNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_depth), (&PyInt_Type), 0, "depth", 1))) __PYX_ERR(0, 24, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_n_samples), (&PyInt_Type), 0, "n_samples", 1))) __PYX_ERR(0, 26, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_split_idx), (&PyInt_Type), 0, "split_idx", 1))) __PYX_ERR(0, 28, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_5Nodes_12DecisionNode___init__(__pyx_self, __pyx_v_self, __pyx_v_indices, __pyx_v_depth, __pyx_v_impurity, __pyx_v_n_samples, __pyx_v_threshold, __pyx_v_split_idx, __pyx_v_left_child, __pyx_v_right_child, __pyx_v_parent);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_depth), (&PyInt_Type), 0, "depth", 1))) __PYX_ERR(0, 22, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_n_samples), (&PyInt_Type), 0, "n_samples", 1))) __PYX_ERR(0, 24, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_split_idx), (&PyInt_Type), 0, "split_idx", 1))) __PYX_ERR(0, 26, __pyx_L1_error)
+  __pyx_r = __pyx_pf_5adaXT_13decision_tree_5nodes_12DecisionNode___init__(__pyx_self, __pyx_v_self, __pyx_v_indices, __pyx_v_depth, __pyx_v_impurity, __pyx_v_n_samples, __pyx_v_threshold, __pyx_v_split_idx, __pyx_v_left_child, __pyx_v_right_child, __pyx_v_parent);
 
-  /* "adaXT/decision_tree/Nodes.pyx":21
+  /* "adaXT/decision_tree/nodes.pyx":19
  * 
  * class DecisionNode(Node):
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             indices: np.ndarray,
  */
 
@@ -3065,52 +3138,52 @@
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_5Nodes_12DecisionNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, double __pyx_v_threshold, PyObject *__pyx_v_split_idx, PyObject *__pyx_v_left_child, PyObject *__pyx_v_right_child, PyObject *__pyx_v_parent) {
+static PyObject *__pyx_pf_5adaXT_13decision_tree_5nodes_12DecisionNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, double __pyx_v_threshold, PyObject *__pyx_v_split_idx, PyObject *__pyx_v_left_child, PyObject *__pyx_v_right_child, PyObject *__pyx_v_parent) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 1);
 
-  /* "adaXT/decision_tree/Nodes.pyx":33
+  /* "adaXT/decision_tree/nodes.pyx":30
+ *             right_child: "DecisionNode|LeafNode|None" = None,
  *             parent: "DecisionNode|None" = None) -> None:
- * 
  *         super().__init__(indices, depth, impurity, n_samples)             # <<<<<<<<<<<<<<
  *         self.threshold = threshold
  *         self.split_idx = split_idx
  */
   __pyx_t_2 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 33, __pyx_L1_error) }
+  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 30, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 33, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2)) __PYX_ERR(0, 33, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2)) __PYX_ERR(0, 30, __pyx_L1_error);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self)) __PYX_ERR(0, 33, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self)) __PYX_ERR(0, 30, __pyx_L1_error);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 33, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 33, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_impurity); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 33, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_impurity); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 30, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   #if CYTHON_UNPACK_METHODS
   if (likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
@@ -3123,69 +3196,69 @@
   }
   #endif
   {
     PyObject *__pyx_callargs[5] = {__pyx_t_4, __pyx_v_indices, __pyx_v_depth, __pyx_t_2, __pyx_v_n_samples};
     __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 4+__pyx_t_5);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 33, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 30, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":34
- * 
+  /* "adaXT/decision_tree/nodes.pyx":31
+ *             parent: "DecisionNode|None" = None) -> None:
  *         super().__init__(indices, depth, impurity, n_samples)
  *         self.threshold = threshold             # <<<<<<<<<<<<<<
  *         self.split_idx = split_idx
  *         self.left_child = left_child
  */
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_threshold); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_threshold); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 31, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_threshold, __pyx_t_1) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_threshold, __pyx_t_1) < 0) __PYX_ERR(0, 31, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":35
+  /* "adaXT/decision_tree/nodes.pyx":32
  *         super().__init__(indices, depth, impurity, n_samples)
  *         self.threshold = threshold
  *         self.split_idx = split_idx             # <<<<<<<<<<<<<<
  *         self.left_child = left_child
  *         self.right_child = right_child
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_split_idx, __pyx_v_split_idx) < 0) __PYX_ERR(0, 35, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_split_idx, __pyx_v_split_idx) < 0) __PYX_ERR(0, 32, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":36
+  /* "adaXT/decision_tree/nodes.pyx":33
  *         self.threshold = threshold
  *         self.split_idx = split_idx
  *         self.left_child = left_child             # <<<<<<<<<<<<<<
  *         self.right_child = right_child
  *         self.parent = parent
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_left_child, __pyx_v_left_child) < 0) __PYX_ERR(0, 36, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_left_child, __pyx_v_left_child) < 0) __PYX_ERR(0, 33, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":37
+  /* "adaXT/decision_tree/nodes.pyx":34
  *         self.split_idx = split_idx
  *         self.left_child = left_child
  *         self.right_child = right_child             # <<<<<<<<<<<<<<
  *         self.parent = parent
  * 
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_right_child, __pyx_v_right_child) < 0) __PYX_ERR(0, 37, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_right_child, __pyx_v_right_child) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":38
+  /* "adaXT/decision_tree/nodes.pyx":35
  *         self.left_child = left_child
  *         self.right_child = right_child
  *         self.parent = parent             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_parent, __pyx_v_parent) < 0) __PYX_ERR(0, 38, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_parent, __pyx_v_parent) < 0) __PYX_ERR(0, 35, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":21
+  /* "adaXT/decision_tree/nodes.pyx":19
  * 
  * class DecisionNode(Node):
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             indices: np.ndarray,
  */
 
@@ -3193,40 +3266,40 @@
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("adaXT.decision_tree.Nodes.DecisionNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.decision_tree.nodes.DecisionNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/Nodes.pyx":42
+/* "adaXT/decision_tree/nodes.pyx":39
  * 
  * class LeafNode(Node):
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             id: int,
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5adaXT_13decision_tree_5Nodes_8LeafNode_1__init__(PyObject *__pyx_self, 
+static PyObject *__pyx_pw_5adaXT_13decision_tree_5nodes_8LeafNode_1__init__(PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_5Nodes_8LeafNode_1__init__ = {"__init__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_5Nodes_8LeafNode_1__init__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
-static PyObject *__pyx_pw_5adaXT_13decision_tree_5Nodes_8LeafNode_1__init__(PyObject *__pyx_self, 
+static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_5nodes_8LeafNode_1__init__ = {"__init__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_5nodes_8LeafNode_1__init__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_13decision_tree_5nodes_8LeafNode_1__init__(PyObject *__pyx_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
   PyObject *__pyx_v_self = 0;
@@ -3283,90 +3356,90 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 39, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_id)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 39, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 1); __PYX_ERR(0, 42, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 1); __PYX_ERR(0, 39, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 39, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 2); __PYX_ERR(0, 42, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 2); __PYX_ERR(0, 39, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_depth)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[3]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 39, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 3); __PYX_ERR(0, 42, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 3); __PYX_ERR(0, 39, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
         if (likely((values[4] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_impurity)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[4]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 39, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 4); __PYX_ERR(0, 42, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 4); __PYX_ERR(0, 39, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  5:
         if (likely((values[5] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_n_samples)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[5]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 39, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 5); __PYX_ERR(0, 42, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 5); __PYX_ERR(0, 39, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  6:
         if (likely((values[6] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_value)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[6]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 39, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 6); __PYX_ERR(0, 42, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 6); __PYX_ERR(0, 39, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  7:
         if (likely((values[7] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_parent)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[7]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 42, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 39, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 7); __PYX_ERR(0, 42, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, 7); __PYX_ERR(0, 39, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 42, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 39, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 8)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
       values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
@@ -3376,40 +3449,39 @@
       values[6] = __Pyx_Arg_FASTCALL(__pyx_args, 6);
       values[7] = __Pyx_Arg_FASTCALL(__pyx_args, 7);
     }
     __pyx_v_self = values[0];
     __pyx_v_id = ((PyObject*)values[1]);
     __pyx_v_indices = values[2];
     __pyx_v_depth = ((PyObject*)values[3]);
-    __pyx_v_impurity = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_impurity == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 47, __pyx_L3_error)
+    __pyx_v_impurity = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_impurity == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 44, __pyx_L3_error)
     __pyx_v_n_samples = ((PyObject*)values[5]);
-    __pyx_v_value = ((PyObject*)values[6]);
+    __pyx_v_value = values[6];
     __pyx_v_parent = values[7];
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, __pyx_nargs); __PYX_ERR(0, 42, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 8, 8, __pyx_nargs); __PYX_ERR(0, 39, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
-  __Pyx_AddTraceback("adaXT.decision_tree.Nodes.LeafNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.decision_tree.nodes.LeafNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_id), (&PyInt_Type), 0, "id", 1))) __PYX_ERR(0, 44, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_depth), (&PyInt_Type), 0, "depth", 1))) __PYX_ERR(0, 46, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_n_samples), (&PyInt_Type), 0, "n_samples", 1))) __PYX_ERR(0, 48, __pyx_L1_error)
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_value), (&PyList_Type), 0, "value", 1))) __PYX_ERR(0, 49, __pyx_L1_error)
-  __pyx_r = __pyx_pf_5adaXT_13decision_tree_5Nodes_8LeafNode___init__(__pyx_self, __pyx_v_self, __pyx_v_id, __pyx_v_indices, __pyx_v_depth, __pyx_v_impurity, __pyx_v_n_samples, __pyx_v_value, __pyx_v_parent);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_id), (&PyInt_Type), 0, "id", 1))) __PYX_ERR(0, 41, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_depth), (&PyInt_Type), 0, "depth", 1))) __PYX_ERR(0, 43, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_n_samples), (&PyInt_Type), 0, "n_samples", 1))) __PYX_ERR(0, 45, __pyx_L1_error)
+  __pyx_r = __pyx_pf_5adaXT_13decision_tree_5nodes_8LeafNode___init__(__pyx_self, __pyx_v_self, __pyx_v_id, __pyx_v_indices, __pyx_v_depth, __pyx_v_impurity, __pyx_v_n_samples, __pyx_v_value, __pyx_v_parent);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = NULL;
   __pyx_L0:;
   {
@@ -3418,52 +3490,52 @@
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
     }
   }
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5adaXT_13decision_tree_5Nodes_8LeafNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, PyObject *__pyx_v_value, PyObject *__pyx_v_parent) {
+static PyObject *__pyx_pf_5adaXT_13decision_tree_5nodes_8LeafNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, PyObject *__pyx_v_value, PyObject *__pyx_v_parent) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 1);
 
-  /* "adaXT/decision_tree/Nodes.pyx":52
- *             parent: DecisionNode) -> None:
- * 
+  /* "adaXT/decision_tree/nodes.pyx":48
+ *             value: np.ndarray,
+ *             parent: object) -> None:
  *         super().__init__(indices, depth, impurity, n_samples)             # <<<<<<<<<<<<<<
- *         self.value = value
  *         self.parent = parent
+ *         self.id = id
  */
   __pyx_t_2 = __Pyx_CyFunction_GetClassObj(__pyx_self);
-  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 52, __pyx_L1_error) }
+  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 48, __pyx_L1_error) }
   __Pyx_INCREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 52, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 48, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2)) __PYX_ERR(0, 52, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2)) __PYX_ERR(0, 48, __pyx_L1_error);
   __Pyx_INCREF(__pyx_v_self);
   __Pyx_GIVEREF(__pyx_v_self);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self)) __PYX_ERR(0, 52, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self)) __PYX_ERR(0, 48, __pyx_L1_error);
   __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 52, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 48, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 52, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 48, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_impurity); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 52, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_impurity); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 48, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   #if CYTHON_UNPACK_METHODS
   if (likely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
@@ -3476,45 +3548,76 @@
   }
   #endif
   {
     PyObject *__pyx_callargs[5] = {__pyx_t_4, __pyx_v_indices, __pyx_v_depth, __pyx_t_2, __pyx_v_n_samples};
     __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 4+__pyx_t_5);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 52, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 48, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":53
- * 
+  /* "adaXT/decision_tree/nodes.pyx":49
+ *             parent: object) -> None:
  *         super().__init__(indices, depth, impurity, n_samples)
- *         self.value = value             # <<<<<<<<<<<<<<
- *         self.parent = parent
+ *         self.parent = parent             # <<<<<<<<<<<<<<
  *         self.id = id
+ *         self.value = np.asarray(value)
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_value, __pyx_v_value) < 0) __PYX_ERR(0, 53, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_parent, __pyx_v_parent) < 0) __PYX_ERR(0, 49, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":54
+  /* "adaXT/decision_tree/nodes.pyx":50
  *         super().__init__(indices, depth, impurity, n_samples)
- *         self.value = value
- *         self.parent = parent             # <<<<<<<<<<<<<<
- *         self.id = id
+ *         self.parent = parent
+ *         self.id = id             # <<<<<<<<<<<<<<
+ *         self.value = np.asarray(value)
+ * 
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_parent, __pyx_v_parent) < 0) __PYX_ERR(0, 54, __pyx_L1_error)
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_id, __pyx_v_id) < 0) __PYX_ERR(0, 50, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":55
- *         self.value = value
+  /* "adaXT/decision_tree/nodes.pyx":51
  *         self.parent = parent
- *         self.id = id             # <<<<<<<<<<<<<<
+ *         self.id = id
+ *         self.value = np.asarray(value)             # <<<<<<<<<<<<<<
+ * 
+ * 
  */
-  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_id, __pyx_v_id) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 51, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_asarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 51, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = NULL;
+  __pyx_t_5 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (unlikely(PyMethod_Check(__pyx_t_2))) {
+    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
+    if (likely(__pyx_t_3)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
+      __Pyx_INCREF(__pyx_t_3);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_2, function);
+      __pyx_t_5 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[2] = {__pyx_t_3, __pyx_v_value};
+    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_2, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
+    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 51, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  }
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_value, __pyx_t_1) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":42
+  /* "adaXT/decision_tree/nodes.pyx":39
  * 
  * class LeafNode(Node):
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             id: int,
  */
 
@@ -3522,15 +3625,370 @@
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
-  __Pyx_AddTraceback("adaXT.decision_tree.Nodes.LeafNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_AddTraceback("adaXT.decision_tree.nodes.LeafNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "adaXT/decision_tree/nodes.pyx":55
+ * 
+ * class LinearRegressionLeafNode(LeafNode):
+ *     def __init__(             # <<<<<<<<<<<<<<
+ *             self,
+ *             id: int,
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_5adaXT_13decision_tree_5nodes_24LinearRegressionLeafNode_1__init__(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+); /*proto*/
+static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_5nodes_24LinearRegressionLeafNode_1__init__ = {"__init__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_5nodes_24LinearRegressionLeafNode_1__init__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
+static PyObject *__pyx_pw_5adaXT_13decision_tree_5nodes_24LinearRegressionLeafNode_1__init__(PyObject *__pyx_self, 
+#if CYTHON_METH_FASTCALL
+PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
+#else
+PyObject *__pyx_args, PyObject *__pyx_kwds
+#endif
+) {
+  PyObject *__pyx_v_self = 0;
+  PyObject *__pyx_v_id = 0;
+  PyObject *__pyx_v_indices = 0;
+  PyObject *__pyx_v_depth = 0;
+  double __pyx_v_impurity;
+  PyObject *__pyx_v_n_samples = 0;
+  PyObject *__pyx_v_value = 0;
+  PyObject *__pyx_v_parent = 0;
+  double __pyx_v_theta0;
+  double __pyx_v_theta1;
+  #if !CYTHON_METH_FASTCALL
+  CYTHON_UNUSED Py_ssize_t __pyx_nargs;
+  #endif
+  CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
+  PyObject* values[10] = {0,0,0,0,0,0,0,0,0,0};
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
+  #if !CYTHON_METH_FASTCALL
+  #if CYTHON_ASSUME_SAFE_MACROS
+  __pyx_nargs = PyTuple_GET_SIZE(__pyx_args);
+  #else
+  __pyx_nargs = PyTuple_Size(__pyx_args); if (unlikely(__pyx_nargs < 0)) return NULL;
+  #endif
+  #endif
+  __pyx_kwvalues = __Pyx_KwValues_FASTCALL(__pyx_args, __pyx_nargs);
+  {
+    PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_id,&__pyx_n_s_indices,&__pyx_n_s_depth,&__pyx_n_s_impurity,&__pyx_n_s_n_samples,&__pyx_n_s_value,&__pyx_n_s_parent,&__pyx_n_s_theta0,&__pyx_n_s_theta1,0};
+    if (__pyx_kwds) {
+      Py_ssize_t kw_args;
+      switch (__pyx_nargs) {
+        case 10: values[9] = __Pyx_Arg_FASTCALL(__pyx_args, 9);
+        CYTHON_FALLTHROUGH;
+        case  9: values[8] = __Pyx_Arg_FASTCALL(__pyx_args, 8);
+        CYTHON_FALLTHROUGH;
+        case  8: values[7] = __Pyx_Arg_FASTCALL(__pyx_args, 7);
+        CYTHON_FALLTHROUGH;
+        case  7: values[6] = __Pyx_Arg_FASTCALL(__pyx_args, 6);
+        CYTHON_FALLTHROUGH;
+        case  6: values[5] = __Pyx_Arg_FASTCALL(__pyx_args, 5);
+        CYTHON_FALLTHROUGH;
+        case  5: values[4] = __Pyx_Arg_FASTCALL(__pyx_args, 4);
+        CYTHON_FALLTHROUGH;
+        case  4: values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
+        CYTHON_FALLTHROUGH;
+        case  3: values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+        CYTHON_FALLTHROUGH;
+        case  2: values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+        CYTHON_FALLTHROUGH;
+        case  1: values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+        CYTHON_FALLTHROUGH;
+        case  0: break;
+        default: goto __pyx_L5_argtuple_error;
+      }
+      kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
+      switch (__pyx_nargs) {
+        case  0:
+        if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_self)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else goto __pyx_L5_argtuple_error;
+        CYTHON_FALLTHROUGH;
+        case  1:
+        if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_id)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, 1); __PYX_ERR(0, 55, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  2:
+        if (likely((values[2] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[2]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, 2); __PYX_ERR(0, 55, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  3:
+        if (likely((values[3] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_depth)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[3]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, 3); __PYX_ERR(0, 55, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  4:
+        if (likely((values[4] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_impurity)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[4]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, 4); __PYX_ERR(0, 55, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  5:
+        if (likely((values[5] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_n_samples)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[5]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, 5); __PYX_ERR(0, 55, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  6:
+        if (likely((values[6] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_value)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[6]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, 6); __PYX_ERR(0, 55, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  7:
+        if (likely((values[7] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_parent)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[7]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, 7); __PYX_ERR(0, 55, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  8:
+        if (likely((values[8] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_theta0)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[8]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, 8); __PYX_ERR(0, 55, __pyx_L3_error)
+        }
+        CYTHON_FALLTHROUGH;
+        case  9:
+        if (likely((values[9] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_theta1)) != 0)) {
+          (void)__Pyx_Arg_NewRef_FASTCALL(values[9]);
+          kw_args--;
+        }
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 55, __pyx_L3_error)
+        else {
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, 9); __PYX_ERR(0, 55, __pyx_L3_error)
+        }
+      }
+      if (unlikely(kw_args > 0)) {
+        const Py_ssize_t kwd_pos_args = __pyx_nargs;
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 55, __pyx_L3_error)
+      }
+    } else if (unlikely(__pyx_nargs != 10)) {
+      goto __pyx_L5_argtuple_error;
+    } else {
+      values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
+      values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
+      values[2] = __Pyx_Arg_FASTCALL(__pyx_args, 2);
+      values[3] = __Pyx_Arg_FASTCALL(__pyx_args, 3);
+      values[4] = __Pyx_Arg_FASTCALL(__pyx_args, 4);
+      values[5] = __Pyx_Arg_FASTCALL(__pyx_args, 5);
+      values[6] = __Pyx_Arg_FASTCALL(__pyx_args, 6);
+      values[7] = __Pyx_Arg_FASTCALL(__pyx_args, 7);
+      values[8] = __Pyx_Arg_FASTCALL(__pyx_args, 8);
+      values[9] = __Pyx_Arg_FASTCALL(__pyx_args, 9);
+    }
+    __pyx_v_self = values[0];
+    __pyx_v_id = ((PyObject*)values[1]);
+    __pyx_v_indices = values[2];
+    __pyx_v_depth = ((PyObject*)values[3]);
+    __pyx_v_impurity = __pyx_PyFloat_AsDouble(values[4]); if (unlikely((__pyx_v_impurity == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 60, __pyx_L3_error)
+    __pyx_v_n_samples = ((PyObject*)values[5]);
+    __pyx_v_value = values[6];
+    __pyx_v_parent = values[7];
+    __pyx_v_theta0 = __pyx_PyFloat_AsDouble(values[8]); if (unlikely((__pyx_v_theta0 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 64, __pyx_L3_error)
+    __pyx_v_theta1 = __pyx_PyFloat_AsDouble(values[9]); if (unlikely((__pyx_v_theta1 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 65, __pyx_L3_error)
+  }
+  goto __pyx_L6_skip;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 10, 10, __pyx_nargs); __PYX_ERR(0, 55, __pyx_L3_error)
+  __pyx_L6_skip:;
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L3_error:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_AddTraceback("adaXT.decision_tree.nodes.LinearRegressionLeafNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __Pyx_RefNannyFinishContext();
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_id), (&PyInt_Type), 0, "id", 1))) __PYX_ERR(0, 57, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_depth), (&PyInt_Type), 0, "depth", 1))) __PYX_ERR(0, 59, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_n_samples), (&PyInt_Type), 0, "n_samples", 1))) __PYX_ERR(0, 61, __pyx_L1_error)
+  __pyx_r = __pyx_pf_5adaXT_13decision_tree_5nodes_24LinearRegressionLeafNode___init__(__pyx_self, __pyx_v_self, __pyx_v_id, __pyx_v_indices, __pyx_v_depth, __pyx_v_impurity, __pyx_v_n_samples, __pyx_v_value, __pyx_v_parent, __pyx_v_theta0, __pyx_v_theta1);
+
+  /* function exit code */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __pyx_r = NULL;
+  __pyx_L0:;
+  {
+    Py_ssize_t __pyx_temp;
+    for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
+      __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
+    }
+  }
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_5adaXT_13decision_tree_5nodes_24LinearRegressionLeafNode___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_id, PyObject *__pyx_v_indices, PyObject *__pyx_v_depth, double __pyx_v_impurity, PyObject *__pyx_v_n_samples, PyObject *__pyx_v_value, PyObject *__pyx_v_parent, double __pyx_v_theta0, double __pyx_v_theta1) {
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("__init__", 1);
+
+  /* "adaXT/decision_tree/nodes.pyx":66
+ *             theta0: float,
+ *             theta1: float) -> None:
+ *         super().__init__(id, indices, depth, impurity, n_samples, value, parent)             # <<<<<<<<<<<<<<
+ *         self.theta0 = theta0
+ *         self.theta1 = theta1
+ */
+  __pyx_t_2 = __Pyx_CyFunction_GetClassObj(__pyx_self);
+  if (!__pyx_t_2) { PyErr_SetString(PyExc_SystemError, "super(): empty __class__ cell"); __PYX_ERR(0, 66, __pyx_L1_error) }
+  __Pyx_INCREF(__pyx_t_2);
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 66, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_2);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2)) __PYX_ERR(0, 66, __pyx_L1_error);
+  __Pyx_INCREF(__pyx_v_self);
+  __Pyx_GIVEREF(__pyx_v_self);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_self)) __PYX_ERR(0, 66, __pyx_L1_error);
+  __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_super, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 66, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 66, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_impurity); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 66, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = NULL;
+  __pyx_t_5 = 0;
+  #if CYTHON_UNPACK_METHODS
+  if (likely(PyMethod_Check(__pyx_t_3))) {
+    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
+    if (likely(__pyx_t_4)) {
+      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
+      __Pyx_INCREF(__pyx_t_4);
+      __Pyx_INCREF(function);
+      __Pyx_DECREF_SET(__pyx_t_3, function);
+      __pyx_t_5 = 1;
+    }
+  }
+  #endif
+  {
+    PyObject *__pyx_callargs[8] = {__pyx_t_4, __pyx_v_id, __pyx_v_indices, __pyx_v_depth, __pyx_t_2, __pyx_v_n_samples, __pyx_v_value, __pyx_v_parent};
+    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 7+__pyx_t_5);
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 66, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  }
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "adaXT/decision_tree/nodes.pyx":67
+ *             theta1: float) -> None:
+ *         super().__init__(id, indices, depth, impurity, n_samples, value, parent)
+ *         self.theta0 = theta0             # <<<<<<<<<<<<<<
+ *         self.theta1 = theta1
+ */
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_theta0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_theta0, __pyx_t_1) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "adaXT/decision_tree/nodes.pyx":68
+ *         super().__init__(id, indices, depth, impurity, n_samples, value, parent)
+ *         self.theta0 = theta0
+ *         self.theta1 = theta1             # <<<<<<<<<<<<<<
+ */
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_theta1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (__Pyx_PyObject_SetAttrStr(__pyx_v_self, __pyx_n_s_theta1, __pyx_t_1) < 0) __PYX_ERR(0, 68, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "adaXT/decision_tree/nodes.pyx":55
+ * 
+ * class LinearRegressionLeafNode(LeafNode):
+ *     def __init__(             # <<<<<<<<<<<<<<
+ *             self,
+ *             id: int,
+ */
+
+  /* function exit code */
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("adaXT.decision_tree.nodes.LinearRegressionLeafNode.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -3553,22 +4011,22 @@
     {&__pyx_n_s_, __pyx_k_, sizeof(__pyx_k_), 0, 0, 1, 1},
     {&__pyx_n_s_DecisionNode, __pyx_k_DecisionNode, sizeof(__pyx_k_DecisionNode), 0, 0, 1, 1},
     {&__pyx_kp_s_DecisionNode_LeafNode_None, __pyx_k_DecisionNode_LeafNode_None, sizeof(__pyx_k_DecisionNode_LeafNode_None), 0, 0, 1, 0},
     {&__pyx_kp_s_DecisionNode_None, __pyx_k_DecisionNode_None, sizeof(__pyx_k_DecisionNode_None), 0, 0, 1, 0},
     {&__pyx_n_s_DecisionNode___init, __pyx_k_DecisionNode___init, sizeof(__pyx_k_DecisionNode___init), 0, 0, 1, 1},
     {&__pyx_n_s_LeafNode, __pyx_k_LeafNode, sizeof(__pyx_k_LeafNode), 0, 0, 1, 1},
     {&__pyx_n_s_LeafNode___init, __pyx_k_LeafNode___init, sizeof(__pyx_k_LeafNode___init), 0, 0, 1, 1},
-    {&__pyx_n_s_List, __pyx_k_List, sizeof(__pyx_k_List), 0, 0, 1, 1},
-    {&__pyx_kp_s_List_float, __pyx_k_List_float, sizeof(__pyx_k_List_float), 0, 0, 1, 0},
+    {&__pyx_n_s_LinearRegressionLeafNode, __pyx_k_LinearRegressionLeafNode, sizeof(__pyx_k_LinearRegressionLeafNode), 0, 0, 1, 1},
+    {&__pyx_n_s_LinearRegressionLeafNode___init, __pyx_k_LinearRegressionLeafNode___init, sizeof(__pyx_k_LinearRegressionLeafNode___init), 0, 0, 1, 1},
     {&__pyx_n_s_Node, __pyx_k_Node, sizeof(__pyx_k_Node), 0, 0, 1, 1},
     {&__pyx_n_s_Node___init, __pyx_k_Node___init, sizeof(__pyx_k_Node___init), 0, 0, 1, 1},
     {&__pyx_n_s_None, __pyx_k_None, sizeof(__pyx_k_None), 0, 0, 1, 1},
-    {&__pyx_n_s__10, __pyx_k__10, sizeof(__pyx_k__10), 0, 0, 1, 1},
-    {&__pyx_kp_u__2, __pyx_k__2, sizeof(__pyx_k__2), 0, 1, 0, 0},
-    {&__pyx_n_s_adaXT_decision_tree_Nodes, __pyx_k_adaXT_decision_tree_Nodes, sizeof(__pyx_k_adaXT_decision_tree_Nodes), 0, 0, 1, 1},
+    {&__pyx_n_s__11, __pyx_k__11, sizeof(__pyx_k__11), 0, 0, 1, 1},
+    {&__pyx_n_s_adaXT_decision_tree_nodes, __pyx_k_adaXT_decision_tree_nodes, sizeof(__pyx_k_adaXT_decision_tree_nodes), 0, 0, 1, 1},
+    {&__pyx_n_s_asarray, __pyx_k_asarray, sizeof(__pyx_k_asarray), 0, 0, 1, 1},
     {&__pyx_n_s_asyncio_coroutines, __pyx_k_asyncio_coroutines, sizeof(__pyx_k_asyncio_coroutines), 0, 0, 1, 1},
     {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
     {&__pyx_n_s_depth, __pyx_k_depth, sizeof(__pyx_k_depth), 0, 0, 1, 1},
     {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
     {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
     {&__pyx_n_s_float, __pyx_k_float, sizeof(__pyx_k_float), 0, 0, 1, 1},
     {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
@@ -3586,84 +4044,98 @@
     {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
     {&__pyx_n_s_mro_entries, __pyx_k_mro_entries, sizeof(__pyx_k_mro_entries), 0, 0, 1, 1},
     {&__pyx_n_s_n_samples, __pyx_k_n_samples, sizeof(__pyx_k_n_samples), 0, 0, 1, 1},
     {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
     {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
     {&__pyx_kp_s_np_ndarray, __pyx_k_np_ndarray, sizeof(__pyx_k_np_ndarray), 0, 0, 1, 0},
     {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
+    {&__pyx_n_s_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 0, 1, 1},
     {&__pyx_n_s_parent, __pyx_k_parent, sizeof(__pyx_k_parent), 0, 0, 1, 1},
     {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
     {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
     {&__pyx_n_s_return, __pyx_k_return, sizeof(__pyx_k_return), 0, 0, 1, 1},
     {&__pyx_n_s_right_child, __pyx_k_right_child, sizeof(__pyx_k_right_child), 0, 0, 1, 1},
     {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
     {&__pyx_n_s_set_name, __pyx_k_set_name, sizeof(__pyx_k_set_name), 0, 0, 1, 1},
     {&__pyx_n_s_spec, __pyx_k_spec, sizeof(__pyx_k_spec), 0, 0, 1, 1},
     {&__pyx_n_s_split_idx, __pyx_k_split_idx, sizeof(__pyx_k_split_idx), 0, 0, 1, 1},
-    {&__pyx_kp_s_src_adaXT_decision_tree_Nodes_py, __pyx_k_src_adaXT_decision_tree_Nodes_py, sizeof(__pyx_k_src_adaXT_decision_tree_Nodes_py), 0, 0, 1, 0},
+    {&__pyx_kp_s_src_adaXT_decision_tree_nodes_py, __pyx_k_src_adaXT_decision_tree_nodes_py, sizeof(__pyx_k_src_adaXT_decision_tree_nodes_py), 0, 0, 1, 0},
     {&__pyx_n_s_super, __pyx_k_super, sizeof(__pyx_k_super), 0, 0, 1, 1},
     {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
+    {&__pyx_n_s_theta0, __pyx_k_theta0, sizeof(__pyx_k_theta0), 0, 0, 1, 1},
+    {&__pyx_n_s_theta1, __pyx_k_theta1, sizeof(__pyx_k_theta1), 0, 0, 1, 1},
     {&__pyx_n_s_threshold, __pyx_k_threshold, sizeof(__pyx_k_threshold), 0, 0, 1, 1},
-    {&__pyx_n_s_typing, __pyx_k_typing, sizeof(__pyx_k_typing), 0, 0, 1, 1},
     {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
     {0, 0, 0, 0, 0, 0, 0}
   };
   return __Pyx_InitStrings(__pyx_string_tab);
 }
 /* #### Code section: cached_builtins ### */
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_super = __Pyx_GetBuiltinName(__pyx_n_s_super); if (!__pyx_builtin_super) __PYX_ERR(0, 33, __pyx_L1_error)
+  __pyx_builtin_super = __Pyx_GetBuiltinName(__pyx_n_s_super); if (!__pyx_builtin_super) __PYX_ERR(0, 30, __pyx_L1_error)
   return 0;
   __pyx_L1_error:;
   return -1;
 }
 /* #### Code section: cached_constants ### */
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "adaXT/decision_tree/Nodes.pyx":8
+  /* "adaXT/decision_tree/nodes.pyx":6
  * 
  * class Node:
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             indices: np.ndarray,
  */
-  __pyx_tuple__3 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_indices, __pyx_n_s_depth, __pyx_n_s_impurity, __pyx_n_s_n_samples); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 8, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__3);
-  __Pyx_GIVEREF(__pyx_tuple__3);
-  __pyx_codeobj__4 = (PyObject*)__Pyx_PyCode_New(5, 0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__3, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Nodes_py, __pyx_n_s_init, 8, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__4)) __PYX_ERR(0, 8, __pyx_L1_error)
+  __pyx_tuple__2 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_indices, __pyx_n_s_depth, __pyx_n_s_impurity, __pyx_n_s_n_samples); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__2);
+  __Pyx_GIVEREF(__pyx_tuple__2);
+  __pyx_codeobj__3 = (PyObject*)__Pyx_PyCode_New(5, 0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__2, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_nodes_py, __pyx_n_s_init, 6, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__3)) __PYX_ERR(0, 6, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":21
+  /* "adaXT/decision_tree/nodes.pyx":19
  * 
  * class DecisionNode(Node):
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             indices: np.ndarray,
  */
-  __pyx_tuple__5 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_indices, __pyx_n_s_depth, __pyx_n_s_impurity, __pyx_n_s_n_samples, __pyx_n_s_threshold, __pyx_n_s_split_idx, __pyx_n_s_left_child, __pyx_n_s_right_child, __pyx_n_s_parent); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 21, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__5);
-  __Pyx_GIVEREF(__pyx_tuple__5);
-  __pyx_codeobj__6 = (PyObject*)__Pyx_PyCode_New(10, 0, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__5, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Nodes_py, __pyx_n_s_init, 21, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__6)) __PYX_ERR(0, 21, __pyx_L1_error)
-  __pyx_tuple__7 = PyTuple_Pack(3, Py_None, Py_None, Py_None); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 21, __pyx_L1_error)
+  __pyx_tuple__4 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_indices, __pyx_n_s_depth, __pyx_n_s_impurity, __pyx_n_s_n_samples, __pyx_n_s_threshold, __pyx_n_s_split_idx, __pyx_n_s_left_child, __pyx_n_s_right_child, __pyx_n_s_parent); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 19, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__4);
+  __Pyx_GIVEREF(__pyx_tuple__4);
+  __pyx_codeobj__5 = (PyObject*)__Pyx_PyCode_New(10, 0, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__4, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_nodes_py, __pyx_n_s_init, 19, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__5)) __PYX_ERR(0, 19, __pyx_L1_error)
+  __pyx_tuple__6 = PyTuple_Pack(3, Py_None, Py_None, Py_None); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 19, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__6);
+  __Pyx_GIVEREF(__pyx_tuple__6);
+
+  /* "adaXT/decision_tree/nodes.pyx":39
+ * 
+ * class LeafNode(Node):
+ *     def __init__(             # <<<<<<<<<<<<<<
+ *             self,
+ *             id: int,
+ */
+  __pyx_tuple__7 = PyTuple_Pack(8, __pyx_n_s_self, __pyx_n_s_id, __pyx_n_s_indices, __pyx_n_s_depth, __pyx_n_s_impurity, __pyx_n_s_n_samples, __pyx_n_s_value, __pyx_n_s_parent); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 39, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__7);
   __Pyx_GIVEREF(__pyx_tuple__7);
+  __pyx_codeobj__8 = (PyObject*)__Pyx_PyCode_New(8, 0, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__7, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_nodes_py, __pyx_n_s_init, 39, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__8)) __PYX_ERR(0, 39, __pyx_L1_error)
 
-  /* "adaXT/decision_tree/Nodes.pyx":42
+  /* "adaXT/decision_tree/nodes.pyx":55
  * 
- * class LeafNode(Node):
+ * class LinearRegressionLeafNode(LeafNode):
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             id: int,
  */
-  __pyx_tuple__8 = PyTuple_Pack(8, __pyx_n_s_self, __pyx_n_s_id, __pyx_n_s_indices, __pyx_n_s_depth, __pyx_n_s_impurity, __pyx_n_s_n_samples, __pyx_n_s_value, __pyx_n_s_parent); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 42, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__8);
-  __Pyx_GIVEREF(__pyx_tuple__8);
-  __pyx_codeobj__9 = (PyObject*)__Pyx_PyCode_New(8, 0, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__8, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_Nodes_py, __pyx_n_s_init, 42, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__9)) __PYX_ERR(0, 42, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(10, __pyx_n_s_self, __pyx_n_s_id, __pyx_n_s_indices, __pyx_n_s_depth, __pyx_n_s_impurity, __pyx_n_s_n_samples, __pyx_n_s_value, __pyx_n_s_parent, __pyx_n_s_theta0, __pyx_n_s_theta1); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 55, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__9);
+  __Pyx_GIVEREF(__pyx_tuple__9);
+  __pyx_codeobj__10 = (PyObject*)__Pyx_PyCode_New(10, 0, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__9, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_nodes_py, __pyx_n_s_init, 55, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__10)) __PYX_ERR(0, 55, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 /* #### Code section: init_constants ### */
@@ -3745,31 +4217,31 @@
   return 0;
 }
 
 
 #if PY_MAJOR_VERSION >= 3
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
-static int __pyx_pymod_exec_Nodes(PyObject* module); /*proto*/
+static int __pyx_pymod_exec_nodes(PyObject* module); /*proto*/
 static PyModuleDef_Slot __pyx_moduledef_slots[] = {
   {Py_mod_create, (void*)__pyx_pymod_create},
-  {Py_mod_exec, (void*)__pyx_pymod_exec_Nodes},
+  {Py_mod_exec, (void*)__pyx_pymod_exec_nodes},
   {0, NULL}
 };
 #endif
 
 #ifdef __cplusplus
 namespace {
   struct PyModuleDef __pyx_moduledef =
   #else
   static struct PyModuleDef __pyx_moduledef =
   #endif
   {
       PyModuleDef_HEAD_INIT,
-      "Nodes",
+      "nodes",
       0, /* m_doc */
     #if CYTHON_PEP489_MULTI_PHASE_INIT
       0, /* m_size */
     #elif CYTHON_USE_MODULE_STATE
       sizeof(__pyx_mstate), /* m_size */
     #else
       -1, /* m_size */
@@ -3809,19 +4281,19 @@
 #else
 #define __Pyx_PyMODINIT_FUNC PyObject *
 #endif
 #endif
 
 
 #if PY_MAJOR_VERSION < 3
-__Pyx_PyMODINIT_FUNC initNodes(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC initNodes(void)
+__Pyx_PyMODINIT_FUNC initnodes(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC initnodes(void)
 #else
-__Pyx_PyMODINIT_FUNC PyInit_Nodes(void) CYTHON_SMALL_CODE; /*proto*/
-__Pyx_PyMODINIT_FUNC PyInit_Nodes(void)
+__Pyx_PyMODINIT_FUNC PyInit_nodes(void) CYTHON_SMALL_CODE; /*proto*/
+__Pyx_PyMODINIT_FUNC PyInit_nodes(void)
 #if CYTHON_PEP489_MULTI_PHASE_INIT
 {
   return PyModuleDef_Init(&__pyx_moduledef);
 }
 static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
     #if PY_VERSION_HEX >= 0x030700A1
     static PY_INT64_T main_interpreter_id = -1;
@@ -3894,15 +4366,15 @@
     return module;
 bad:
     Py_XDECREF(module);
     return NULL;
 }
 
 
-static CYTHON_SMALL_CODE int __pyx_pymod_exec_Nodes(PyObject *__pyx_pyinit_module)
+static CYTHON_SMALL_CODE int __pyx_pymod_exec_nodes(PyObject *__pyx_pyinit_module)
 #endif
 #endif
 {
   int stringtab_initialized = 0;
   #if CYTHON_USE_MODULE_STATE
   int pystate_addmodule_run = 0;
   #endif
@@ -3916,33 +4388,33 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannyDeclarations
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   if (__pyx_m) {
     if (__pyx_m == __pyx_pyinit_module) return 0;
-    PyErr_SetString(PyExc_RuntimeError, "Module 'Nodes' has already been imported. Re-initialisation is not supported.");
+    PyErr_SetString(PyExc_RuntimeError, "Module 'nodes' has already been imported. Re-initialisation is not supported.");
     return -1;
   }
   #elif PY_MAJOR_VERSION >= 3
   if (__pyx_m) return __Pyx_NewRef(__pyx_m);
   #endif
   /*--- Module creation code ---*/
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   __pyx_m = __pyx_pyinit_module;
   Py_INCREF(__pyx_m);
   #else
   #if PY_MAJOR_VERSION < 3
-  __pyx_m = Py_InitModule4("Nodes", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
+  __pyx_m = Py_InitModule4("nodes", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
   if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
   #elif CYTHON_USE_MODULE_STATE
   __pyx_t_1 = PyModule_Create(&__pyx_moduledef); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   {
     int add_module_result = PyState_AddModule(__pyx_t_1, &__pyx_moduledef);
-    __pyx_t_1 = 0; /* transfer ownership from __pyx_t_1 to "Nodes" pseudovariable */
+    __pyx_t_1 = 0; /* transfer ownership from __pyx_t_1 to "nodes" pseudovariable */
     if (unlikely((add_module_result < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
     pystate_addmodule_run = 1;
   }
   #else
   __pyx_m = PyModule_Create(&__pyx_moduledef);
   if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
@@ -3958,15 +4430,15 @@
 if (!__Pyx_RefNanny) {
   PyErr_Clear();
   __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
   if (!__Pyx_RefNanny)
       Py_FatalError("failed to import 'refnanny' module");
 }
 #endif
-  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_Nodes(void)", 0);
+  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_nodes(void)", 0);
   if (__Pyx_check_binary_version(__PYX_LIMITED_VERSION_HEX, __Pyx_get_runtime_version(), CYTHON_COMPILING_IN_LIMITED_API) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #ifdef __Pxy_PyFrame_Initialize_Offsets
   __Pxy_PyFrame_Initialize_Offsets();
   #endif
   __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -3996,22 +4468,22 @@
   /*--- Initialize various global constants etc. ---*/
   if (__Pyx_InitConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   stringtab_initialized = 1;
   if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
   if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
-  if (__pyx_module_is_main_adaXT__decision_tree__Nodes) {
+  if (__pyx_module_is_main_adaXT__decision_tree__nodes) {
     if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   }
   #if PY_MAJOR_VERSION >= 3
   {
     PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
-    if (!PyDict_GetItemString(modules, "adaXT.decision_tree.Nodes")) {
-      if (unlikely((PyDict_SetItemString(modules, "adaXT.decision_tree.Nodes", __pyx_m) < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
+    if (!PyDict_GetItemString(modules, "adaXT.decision_tree.nodes")) {
+      if (unlikely((PyDict_SetItemString(modules, "adaXT.decision_tree.nodes", __pyx_m) < 0))) __PYX_ERR(0, 1, __pyx_L1_error)
     }
   }
   #endif
   /*--- Builtin init code ---*/
   if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   /*--- Constants init code ---*/
   if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -4024,273 +4496,324 @@
   (void)__Pyx_modinit_variable_import_code();
   (void)__Pyx_modinit_function_import_code();
   /*--- Execution code ---*/
   #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
   if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   #endif
 
-  /* "adaXT/decision_tree/Nodes.pyx":3
+  /* "adaXT/decision_tree/nodes.pyx":2
  * # cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False
- * 
  * import numpy as np             # <<<<<<<<<<<<<<
- * from typing import List
- * 
- */
-  __pyx_t_2 = __Pyx_ImportDottedModule(__pyx_n_s_numpy, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_2) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-
-  /* "adaXT/decision_tree/Nodes.pyx":4
- * 
- * import numpy as np
- * from typing import List             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_INCREF(__pyx_n_s_List);
-  __Pyx_GIVEREF(__pyx_n_s_List);
-  if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_List)) __PYX_ERR(0, 4, __pyx_L1_error);
-  __pyx_t_3 = __Pyx_Import(__pyx_n_s_typing, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_List); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_ImportDottedModule(__pyx_n_s_numpy, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_List, __pyx_t_2) < 0) __PYX_ERR(0, 4, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_2) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":7
+  /* "adaXT/decision_tree/nodes.pyx":5
  * 
  * 
  * class Node:             # <<<<<<<<<<<<<<
  *     def __init__(
  *             self,
  */
-  __pyx_t_3 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_Node, __pyx_n_s_Node, (PyObject *) NULL, __pyx_n_s_adaXT_decision_tree_Nodes, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 7, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_Node, __pyx_n_s_Node, (PyObject *) NULL, __pyx_n_s_adaXT_decision_tree_nodes, (PyObject *) NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
 
-  /* "adaXT/decision_tree/Nodes.pyx":8
+  /* "adaXT/decision_tree/nodes.pyx":6
  * 
  * class Node:
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             indices: np.ndarray,
  */
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 8, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_indices, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_depth, __pyx_n_s_int) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_impurity, __pyx_n_s_float) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_n_samples, __pyx_n_s_int) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_return, __pyx_n_s_None) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_5Nodes_4Node_1__init__, 0, __pyx_n_s_Node___init, NULL, __pyx_n_s_adaXT_decision_tree_Nodes, __pyx_d, ((PyObject *)__pyx_codeobj__4)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 8, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 6, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_indices, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_depth, __pyx_n_s_int) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_impurity, __pyx_n_s_float) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_n_samples, __pyx_n_s_int) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_return, __pyx_n_s_None) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_5nodes_4Node_1__init__, 0, __pyx_n_s_Node___init, NULL, __pyx_n_s_adaXT_decision_tree_nodes, __pyx_d, ((PyObject *)__pyx_codeobj__3)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 6, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_2);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_init, __pyx_t_4) < 0) __PYX_ERR(0, 8, __pyx_L1_error)
+  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_3);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_init, __pyx_t_4) < 0) __PYX_ERR(0, 6, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":7
+  /* "adaXT/decision_tree/nodes.pyx":5
  * 
  * 
  * class Node:             # <<<<<<<<<<<<<<
  *     def __init__(
  *             self,
  */
-  __pyx_t_4 = __Pyx_Py3ClassCreate(((PyObject*)&PyType_Type), __pyx_n_s_Node, __pyx_empty_tuple, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 7, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_Py3ClassCreate(((PyObject*)&PyType_Type), __pyx_n_s_Node, __pyx_empty_tuple, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Node, __pyx_t_4) < 0) __PYX_ERR(0, 7, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Node, __pyx_t_4) < 0) __PYX_ERR(0, 5, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":20
+  /* "adaXT/decision_tree/nodes.pyx":18
  * 
  * 
  * class DecisionNode(Node):             # <<<<<<<<<<<<<<
  *     def __init__(
  *             self,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Node); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 20, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 20, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Node); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __Pyx_GIVEREF(__pyx_t_3);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3)) __PYX_ERR(0, 20, __pyx_L1_error);
-  __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PEP560_update_bases(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 20, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 20, __pyx_L1_error)
+  __Pyx_GIVEREF(__pyx_t_2);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2)) __PYX_ERR(0, 18, __pyx_L1_error);
+  __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PEP560_update_bases(__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_3, __pyx_n_s_DecisionNode, __pyx_n_s_DecisionNode, (PyObject *) NULL, __pyx_n_s_adaXT_decision_tree_Nodes, (PyObject *) NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 20, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 18, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_5 = __Pyx_Py3MetaclassPrepare(__pyx_t_3, __pyx_t_2, __pyx_n_s_DecisionNode, __pyx_n_s_DecisionNode, (PyObject *) NULL, __pyx_n_s_adaXT_decision_tree_nodes, (PyObject *) NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  if (__pyx_t_3 != __pyx_t_4) {
-    if (unlikely((PyDict_SetItemString(__pyx_t_5, "__orig_bases__", __pyx_t_4) < 0))) __PYX_ERR(0, 20, __pyx_L1_error)
+  if (__pyx_t_2 != __pyx_t_4) {
+    if (unlikely((PyDict_SetItemString(__pyx_t_5, "__orig_bases__", __pyx_t_4) < 0))) __PYX_ERR(0, 18, __pyx_L1_error)
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 20, __pyx_L1_error)
+  __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
 
-  /* "adaXT/decision_tree/Nodes.pyx":21
+  /* "adaXT/decision_tree/nodes.pyx":19
  * 
  * class DecisionNode(Node):
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             indices: np.ndarray,
  */
-  __pyx_t_6 = __Pyx_PyDict_NewPresized(10); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 21, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyDict_NewPresized(10); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 19, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_indices, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_depth, __pyx_n_s_int) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_impurity, __pyx_n_s_float) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_n_samples, __pyx_n_s_int) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_threshold, __pyx_n_s_float) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_split_idx, __pyx_n_s_int) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_left_child, __pyx_kp_s_DecisionNode_LeafNode_None) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_right_child, __pyx_kp_s_DecisionNode_LeafNode_None) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_parent, __pyx_kp_s_DecisionNode_None) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_return, __pyx_n_s_None) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
-  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_5Nodes_12DecisionNode_1__init__, 0, __pyx_n_s_DecisionNode___init, NULL, __pyx_n_s_adaXT_decision_tree_Nodes, __pyx_d, ((PyObject *)__pyx_codeobj__6)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 21, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_indices, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_depth, __pyx_n_s_int) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_impurity, __pyx_n_s_float) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_n_samples, __pyx_n_s_int) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_threshold, __pyx_n_s_float) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_split_idx, __pyx_n_s_int) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_left_child, __pyx_kp_s_DecisionNode_LeafNode_None) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_right_child, __pyx_kp_s_DecisionNode_LeafNode_None) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_parent, __pyx_kp_s_DecisionNode_None) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_return, __pyx_n_s_None) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_5nodes_12DecisionNode_1__init__, 0, __pyx_n_s_DecisionNode___init, NULL, __pyx_n_s_adaXT_decision_tree_nodes, __pyx_d, ((PyObject *)__pyx_codeobj__5)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 19, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_INCREF(__pyx_t_7);
   PyList_Append(__pyx_t_4, __pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_7);
-  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_7, __pyx_tuple__7);
+  __Pyx_CyFunction_SetDefaultsTuple(__pyx_t_7, __pyx_tuple__6);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_7, __pyx_t_6);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_5, __pyx_n_s_init, __pyx_t_7) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_5, __pyx_n_s_init, __pyx_t_7) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":20
+  /* "adaXT/decision_tree/nodes.pyx":18
  * 
  * 
  * class DecisionNode(Node):             # <<<<<<<<<<<<<<
  *     def __init__(
  *             self,
  */
-  __pyx_t_7 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_DecisionNode, __pyx_t_3, __pyx_t_5, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 20, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_Py3ClassCreate(__pyx_t_3, __pyx_n_s_DecisionNode, __pyx_t_2, __pyx_t_5, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_4, __pyx_t_7) < 0) __PYX_ERR(0, 20, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_4, __pyx_t_7) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DecisionNode, __pyx_t_7) < 0) __PYX_ERR(0, 20, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DecisionNode, __pyx_t_7) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":41
+  /* "adaXT/decision_tree/nodes.pyx":38
  * 
  * 
  * class LeafNode(Node):             # <<<<<<<<<<<<<<
  *     def __init__(
  *             self,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Node); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 41, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_Node); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 38, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GIVEREF(__pyx_t_3);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3)) __PYX_ERR(0, 41, __pyx_L1_error);
-  __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PEP560_update_bases(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 38, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = __Pyx_CalculateMetaclass(NULL, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __Pyx_GIVEREF(__pyx_t_2);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2)) __PYX_ERR(0, 38, __pyx_L1_error);
+  __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PEP560_update_bases(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_5 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 38, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_7 = __Pyx_Py3MetaclassPrepare(__pyx_t_5, __pyx_t_3, __pyx_n_s_LeafNode, __pyx_n_s_LeafNode, (PyObject *) NULL, __pyx_n_s_adaXT_decision_tree_Nodes, (PyObject *) NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_Py3MetaclassPrepare(__pyx_t_5, __pyx_t_2, __pyx_n_s_LeafNode, __pyx_n_s_LeafNode, (PyObject *) NULL, __pyx_n_s_adaXT_decision_tree_nodes, (PyObject *) NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 38, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__pyx_t_3 != __pyx_t_2) {
-    if (unlikely((PyDict_SetItemString(__pyx_t_7, "__orig_bases__", __pyx_t_2) < 0))) __PYX_ERR(0, 41, __pyx_L1_error)
+  if (__pyx_t_2 != __pyx_t_3) {
+    if (unlikely((PyDict_SetItemString(__pyx_t_7, "__orig_bases__", __pyx_t_3) < 0))) __PYX_ERR(0, 38, __pyx_L1_error)
   }
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 41, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 38, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_3);
 
-  /* "adaXT/decision_tree/Nodes.pyx":42
+  /* "adaXT/decision_tree/nodes.pyx":39
  * 
  * class LeafNode(Node):
  *     def __init__(             # <<<<<<<<<<<<<<
  *             self,
  *             id: int,
  */
-  __pyx_t_4 = __Pyx_PyDict_NewPresized(8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 42, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyDict_NewPresized(8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 39, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_id, __pyx_n_s_int) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_indices, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_depth, __pyx_n_s_int) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_impurity, __pyx_n_s_float) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_n_samples, __pyx_n_s_int) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_value, __pyx_kp_s_List_float) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_parent, __pyx_n_s_DecisionNode) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
-  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_return, __pyx_n_s_None) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
-  __pyx_t_6 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_5Nodes_8LeafNode_1__init__, 0, __pyx_n_s_LeafNode___init, NULL, __pyx_n_s_adaXT_decision_tree_Nodes, __pyx_d, ((PyObject *)__pyx_codeobj__9)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 42, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_id, __pyx_n_s_int) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_indices, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_depth, __pyx_n_s_int) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_impurity, __pyx_n_s_float) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_n_samples, __pyx_n_s_int) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_value, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_parent, __pyx_n_s_object) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_return, __pyx_n_s_None) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_5nodes_8LeafNode_1__init__, 0, __pyx_n_s_LeafNode___init, NULL, __pyx_n_s_adaXT_decision_tree_nodes, __pyx_d, ((PyObject *)__pyx_codeobj__8)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 39, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __Pyx_INCREF(__pyx_t_6);
-  PyList_Append(__pyx_t_2, __pyx_t_6);
+  PyList_Append(__pyx_t_3, __pyx_t_6);
   __Pyx_GIVEREF(__pyx_t_6);
   __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_6, __pyx_t_4);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_init, __pyx_t_6) < 0) __PYX_ERR(0, 42, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_7, __pyx_n_s_init, __pyx_t_6) < 0) __PYX_ERR(0, 39, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":41
+  /* "adaXT/decision_tree/nodes.pyx":38
  * 
  * 
  * class LeafNode(Node):             # <<<<<<<<<<<<<<
  *     def __init__(
  *             self,
  */
-  __pyx_t_6 = __Pyx_Py3ClassCreate(__pyx_t_5, __pyx_n_s_LeafNode, __pyx_t_3, __pyx_t_7, NULL, 0, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 41, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_Py3ClassCreate(__pyx_t_5, __pyx_n_s_LeafNode, __pyx_t_2, __pyx_t_7, NULL, 0, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 38, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  if (__Pyx_CyFunction_InitClassCell(__pyx_t_2, __pyx_t_6) < 0) __PYX_ERR(0, 41, __pyx_L1_error)
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LeafNode, __pyx_t_6) < 0) __PYX_ERR(0, 41, __pyx_L1_error)
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_3, __pyx_t_6) < 0) __PYX_ERR(0, 38, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LeafNode, __pyx_t_6) < 0) __PYX_ERR(0, 38, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "adaXT/decision_tree/Nodes.pyx":1
- * # cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False             # <<<<<<<<<<<<<<
+  /* "adaXT/decision_tree/nodes.pyx":54
  * 
- * import numpy as np
+ * 
+ * class LinearRegressionLeafNode(LeafNode):             # <<<<<<<<<<<<<<
+ *     def __init__(
+ *             self,
  */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_LeafNode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 54, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 54, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_GIVEREF(__pyx_t_2);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2)) __PYX_ERR(0, 54, __pyx_L1_error);
+  __pyx_t_2 = 0;
+  __pyx_t_2 = __Pyx_PEP560_update_bases(__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 54, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_7 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 54, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_6 = __Pyx_Py3MetaclassPrepare(__pyx_t_7, __pyx_t_2, __pyx_n_s_LinearRegressionLeafNode, __pyx_n_s_LinearRegressionLeafNode, (PyObject *) NULL, __pyx_n_s_adaXT_decision_tree_nodes, (PyObject *) NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 54, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_6);
+  if (__pyx_t_2 != __pyx_t_5) {
+    if (unlikely((PyDict_SetItemString(__pyx_t_6, "__orig_bases__", __pyx_t_5) < 0))) __PYX_ERR(0, 54, __pyx_L1_error)
+  }
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __pyx_t_5 = PyList_New(0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 54, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_5);
+
+  /* "adaXT/decision_tree/nodes.pyx":55
+ * 
+ * class LinearRegressionLeafNode(LeafNode):
+ *     def __init__(             # <<<<<<<<<<<<<<
+ *             self,
+ *             id: int,
+ */
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 55, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_3) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_id, __pyx_n_s_int) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_indices, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_depth, __pyx_n_s_int) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_impurity, __pyx_n_s_float) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_n_samples, __pyx_n_s_int) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_value, __pyx_kp_s_np_ndarray) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_parent, __pyx_n_s_object) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_theta0, __pyx_n_s_float) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_theta1, __pyx_n_s_float) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_return, __pyx_n_s_None) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_5nodes_24LinearRegressionLeafNode_1__init__, 0, __pyx_n_s_LinearRegressionLeafNode___init, NULL, __pyx_n_s_adaXT_decision_tree_nodes, __pyx_d, ((PyObject *)__pyx_codeobj__10)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 55, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_INCREF(__pyx_t_4);
+  PyList_Append(__pyx_t_5, __pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_4);
+  __Pyx_CyFunction_SetAnnotationsDict(__pyx_t_4, __pyx_t_3);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (__Pyx_SetNameInClass(__pyx_t_6, __pyx_n_s_init, __pyx_t_4) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "adaXT/decision_tree/nodes.pyx":54
+ * 
+ * 
+ * class LinearRegressionLeafNode(LeafNode):             # <<<<<<<<<<<<<<
+ *     def __init__(
+ *             self,
+ */
+  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_7, __pyx_n_s_LinearRegressionLeafNode, __pyx_t_2, __pyx_t_6, NULL, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 54, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  if (__Pyx_CyFunction_InitClassCell(__pyx_t_5, __pyx_t_4) < 0) __PYX_ERR(0, 54, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_LinearRegressionLeafNode, __pyx_t_4) < 0) __PYX_ERR(0, 54, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "adaXT/decision_tree/nodes.pyx":1
+ * # cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False             # <<<<<<<<<<<<<<
+ * import numpy as np
+ * 
+ */
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /*--- Wrapped vars code ---*/
 
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
   __Pyx_XDECREF(__pyx_t_7);
   if (__pyx_m) {
     if (__pyx_d && stringtab_initialized) {
-      __Pyx_AddTraceback("init adaXT.decision_tree.Nodes", __pyx_clineno, __pyx_lineno, __pyx_filename);
+      __Pyx_AddTraceback("init adaXT.decision_tree.nodes", __pyx_clineno, __pyx_lineno, __pyx_filename);
     }
     #if !CYTHON_USE_MODULE_STATE
     Py_CLEAR(__pyx_m);
     #else
     Py_DECREF(__pyx_m);
     if (pystate_addmodule_run) {
       PyObject *tp, *value, *tb;
       PyErr_Fetch(&tp, &value, &tb);
       PyState_RemoveModule(&__pyx_moduledef);
       PyErr_Restore(tp, value, tb);
     }
     #endif
   } else if (!PyErr_Occurred()) {
-    PyErr_SetString(PyExc_ImportError, "init adaXT.decision_tree.Nodes");
+    PyErr_SetString(PyExc_ImportError, "init adaXT.decision_tree.nodes");
   }
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   #if CYTHON_PEP489_MULTI_PHASE_INIT
   return (__pyx_m != NULL) ? 0 : -1;
   #elif PY_MAJOR_VERSION >= 3
   return __pyx_m;
@@ -4936,52 +5459,82 @@
         "Argument '%.200s' has incorrect type (expected " __Pyx_FMT_TYPENAME
         ", got " __Pyx_FMT_TYPENAME ")", name, type_name, obj_type_name);
     __Pyx_DECREF_TypeName(type_name);
     __Pyx_DECREF_TypeName(obj_type_name);
     return 0;
 }
 
-/* PyObjectSetAttrStr */
-#if CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
-    PyTypeObject* tp = Py_TYPE(obj);
-    if (likely(tp->tp_setattro))
-        return tp->tp_setattro(obj, attr_name, value);
-#if PY_MAJOR_VERSION < 3
-    if (likely(tp->tp_setattr))
-        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
+/* PyDictVersioning */
+#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
+    PyObject *dict = Py_TYPE(obj)->tp_dict;
+    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
+}
+static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
+    PyObject **dictptr = NULL;
+    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
+    if (offset) {
+#if CYTHON_COMPILING_IN_CPYTHON
+        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
+#else
+        dictptr = _PyObject_GetDictPtr(obj);
 #endif
-    return PyObject_SetAttr(obj, attr_name, value);
+    }
+    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
+}
+static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
+    PyObject *dict = Py_TYPE(obj)->tp_dict;
+    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
+        return 0;
+    return obj_dict_version == __Pyx_get_object_dict_version(obj);
 }
 #endif
 
-/* PyObjectCall */
-#if CYTHON_COMPILING_IN_CPYTHON
-static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+/* GetModuleGlobalName */
+#if CYTHON_USE_DICT_VERSIONS
+static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
+#else
+static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
+#endif
+{
     PyObject *result;
-    ternaryfunc call = Py_TYPE(func)->tp_call;
-    if (unlikely(!call))
-        return PyObject_Call(func, arg, kw);
-    #if PY_MAJOR_VERSION < 3
-    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+#if !CYTHON_AVOID_BORROWED_REFS
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && PY_VERSION_HEX < 0x030d0000
+    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    } else if (unlikely(PyErr_Occurred())) {
         return NULL;
-    #else
-    if (unlikely(Py_EnterRecursiveCall(" while calling a Python object")))
+    }
+#elif CYTHON_COMPILING_IN_LIMITED_API
+    if (unlikely(!__pyx_m)) {
         return NULL;
-    #endif
-    result = (*call)(func, arg, kw);
-    Py_LeaveRecursiveCall();
-    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
-        PyErr_SetString(
-            PyExc_SystemError,
-            "NULL result without error in PyObject_Call");
     }
-    return result;
-}
+    result = PyObject_GetAttr(__pyx_m, name);
+    if (likely(result)) {
+        return result;
+    }
+#else
+    result = PyDict_GetItem(__pyx_d, name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    }
+#endif
+#else
+    result = PyObject_GetItem(__pyx_d, name);
+    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
+    if (likely(result)) {
+        return __Pyx_NewRef(result);
+    }
+    PyErr_Clear();
 #endif
+    return __Pyx_GetBuiltinName(name);
+}
 
 /* PyFunctionFastCall */
 #if CYTHON_FAST_PYCALL && !CYTHON_VECTORCALL
 static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                                PyObject *globals) {
     PyFrameObject *f;
     PyThreadState *tstate = __Pyx_PyThreadState_Current;
@@ -5098,14 +5651,39 @@
     Py_XDECREF(kwtuple);
 done:
     Py_LeaveRecursiveCall();
     return result;
 }
 #endif
 
+/* PyObjectCall */
+#if CYTHON_COMPILING_IN_CPYTHON
+static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    PyObject *result;
+    ternaryfunc call = Py_TYPE(func)->tp_call;
+    if (unlikely(!call))
+        return PyObject_Call(func, arg, kw);
+    #if PY_MAJOR_VERSION < 3
+    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
+        return NULL;
+    #else
+    if (unlikely(Py_EnterRecursiveCall(" while calling a Python object")))
+        return NULL;
+    #endif
+    result = (*call)(func, arg, kw);
+    Py_LeaveRecursiveCall();
+    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
+        PyErr_SetString(
+            PyExc_SystemError,
+            "NULL result without error in PyObject_Call");
+    }
+    return result;
+}
+#endif
+
 /* PyObjectCallMethO */
 #if CYTHON_COMPILING_IN_CPYTHON
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
     PyObject *self, *result;
     PyCFunction cfunc;
     cfunc = __Pyx_CyOrPyCFunction_GET_FUNCTION(func);
     self = __Pyx_CyOrPyCFunction_GET_SELF(func);
@@ -5201,14 +5779,28 @@
     #if PY_VERSION_HEX >= 0x03090000 && !CYTHON_COMPILING_IN_LIMITED_API
     return PyObject_VectorcallDict(func, args, (size_t)nargs, kwargs);
     #else
     return __Pyx_PyObject_FastCall_fallback(func, args, (size_t)nargs, kwargs);
     #endif
 }
 
+/* PyObjectSetAttrStr */
+#if CYTHON_USE_TYPE_SLOTS
+static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
+    PyTypeObject* tp = Py_TYPE(obj);
+    if (likely(tp->tp_setattro))
+        return tp->tp_setattro(obj, attr_name, value);
+#if PY_MAJOR_VERSION < 3
+    if (likely(tp->tp_setattr))
+        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
+#endif
+    return PyObject_SetAttr(obj, attr_name, value);
+}
+#endif
+
 /* Import */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
     PyObject *module = 0;
     PyObject *empty_dict = 0;
     PyObject *empty_list = 0;
     #if PY_MAJOR_VERSION < 3
     PyObject *py_import;
@@ -5387,57 +5979,14 @@
     } else if (PyErr_Occurred()) {
         PyErr_Clear();
     }
 #endif
     return __Pyx__ImportDottedModule(name, parts_tuple);
 }
 
-/* ImportFrom */
-static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
-    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
-    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
-        const char* module_name_str = 0;
-        PyObject* module_name = 0;
-        PyObject* module_dot = 0;
-        PyObject* full_name = 0;
-        PyErr_Clear();
-        module_name_str = PyModule_GetName(module);
-        if (unlikely(!module_name_str)) { goto modbad; }
-        module_name = PyUnicode_FromString(module_name_str);
-        if (unlikely(!module_name)) { goto modbad; }
-        module_dot = PyUnicode_Concat(module_name, __pyx_kp_u__2);
-        if (unlikely(!module_dot)) { goto modbad; }
-        full_name = PyUnicode_Concat(module_dot, name);
-        if (unlikely(!full_name)) { goto modbad; }
-        #if PY_VERSION_HEX < 0x030700A1 || (CYTHON_COMPILING_IN_PYPY && PYPY_VERSION_NUM  < 0x07030400)
-        {
-            PyObject *modules = PyImport_GetModuleDict();
-            if (unlikely(!modules))
-                goto modbad;
-            value = PyObject_GetItem(modules, full_name);
-        }
-        #else
-        value = PyImport_GetModule(full_name);
-        #endif
-      modbad:
-        Py_XDECREF(full_name);
-        Py_XDECREF(module_dot);
-        Py_XDECREF(module_name);
-    }
-    if (unlikely(!value)) {
-        PyErr_Format(PyExc_ImportError,
-        #if PY_MAJOR_VERSION < 3
-            "cannot import name %.230s", PyString_AS_STRING(name));
-        #else
-            "cannot import name %S", name);
-        #endif
-    }
-    return value;
-}
-
 /* FixUpExtensionType */
 #if CYTHON_USE_TYPE_SPECS
 static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type) {
 #if PY_VERSION_HEX > 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
     CYTHON_UNUSED_VAR(spec);
     CYTHON_UNUSED_VAR(type);
 #else
@@ -6489,15 +7038,15 @@
         break;
     case 0:
         self = ((PyCFunctionObject*)cyfunc)->m_self;
         break;
     default:
         return NULL;
     }
-    return ((_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
+    return ((__Pyx_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
 }
 static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
 {
     __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
     PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
     PyTypeObject *cls = (PyTypeObject *) __Pyx_CyFunction_GetClassObj(cyfunc);
 #if CYTHON_BACKPORT_VECTORCALL
@@ -6967,83 +7516,14 @@
     }
 #else
     (void) &__Pyx_GetBuiltinName;
 #endif
     return result;
 }
 
-/* PyDictVersioning */
-#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
-    PyObject *dict = Py_TYPE(obj)->tp_dict;
-    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
-}
-static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
-    PyObject **dictptr = NULL;
-    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
-    if (offset) {
-#if CYTHON_COMPILING_IN_CPYTHON
-        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
-#else
-        dictptr = _PyObject_GetDictPtr(obj);
-#endif
-    }
-    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
-}
-static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
-    PyObject *dict = Py_TYPE(obj)->tp_dict;
-    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
-        return 0;
-    return obj_dict_version == __Pyx_get_object_dict_version(obj);
-}
-#endif
-
-/* GetModuleGlobalName */
-#if CYTHON_USE_DICT_VERSIONS
-static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
-#else
-static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
-#endif
-{
-    PyObject *result;
-#if !CYTHON_AVOID_BORROWED_REFS
-#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && PY_VERSION_HEX < 0x030d0000
-    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    } else if (unlikely(PyErr_Occurred())) {
-        return NULL;
-    }
-#elif CYTHON_COMPILING_IN_LIMITED_API
-    if (unlikely(!__pyx_m)) {
-        return NULL;
-    }
-    result = PyObject_GetAttr(__pyx_m, name);
-    if (likely(result)) {
-        return result;
-    }
-#else
-    result = PyDict_GetItem(__pyx_d, name);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    }
-#endif
-#else
-    result = PyObject_GetItem(__pyx_d, name);
-    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
-    if (likely(result)) {
-        return __Pyx_NewRef(result);
-    }
-    PyErr_Clear();
-#endif
-    return __Pyx_GetBuiltinName(name);
-}
-
 /* PyObjectCallOneArg */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
     PyObject *args[2] = {NULL, arg};
     return __Pyx_PyObject_FastCall(func, args+1, 1 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
 }
 
 /* Py3UpdateBases */
@@ -7457,15 +7937,15 @@
 __Pyx_PyType_GetName(PyTypeObject* tp)
 {
     PyObject *name = __Pyx_PyObject_GetAttrStr((PyObject *)tp,
                                                __pyx_n_s_name);
     if (unlikely(name == NULL) || unlikely(!PyUnicode_Check(name))) {
         PyErr_Clear();
         Py_XDECREF(name);
-        name = __Pyx_NewRef(__pyx_n_s__10);
+        name = __Pyx_NewRef(__pyx_n_s__11);
     }
     return name;
 }
 #endif
 
 /* CIntToPy */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
```

### Comparing `adaXT-1.0.1/src/adaXT/decision_tree/Nodes.pyi` & `adaxt-1.1.0/src/adaXT/decision_tree/nodes.pyi`

 * *Files identical despite different names*

### Comparing `adaXT-1.0.1/src/adaXT/decision_tree/splitter.cpp` & `adaxt-1.1.0/src/adaXT/decision_tree/splitter.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,24 +1,30 @@
-/* Generated by Cython 3.0.8 */
+/* Generated by Cython 3.0.10 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
+        "define_macros": [
+            [
+                "NPY_NO_DEPRECATED_API",
+                "NPY_1_7_API_VERSION"
+            ]
+        ],
         "depends": [
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h",
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include/numpy/arrayscalars.h",
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h",
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h",
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include/numpy/ufuncobject.h"
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h",
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include/numpy/arrayscalars.h",
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h",
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h",
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include/numpy/ufuncobject.h"
         ],
         "extra_compile_args": [
             "-O3"
         ],
         "include_dirs": [
-            "/tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/core/include"
+            "/tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/core/include"
         ],
         "language": "c++",
         "name": "adaXT.decision_tree.splitter",
         "sources": [
             "src/adaXT/decision_tree/splitter.pyx"
         ]
     },
@@ -46,18 +52,18 @@
     #error Cython requires Python 2.7+ or Python 3.3+.
 #else
 #if defined(CYTHON_LIMITED_API) && CYTHON_LIMITED_API
 #define __PYX_EXTRA_ABI_MODULE_NAME "limited"
 #else
 #define __PYX_EXTRA_ABI_MODULE_NAME ""
 #endif
-#define CYTHON_ABI "3_0_8" __PYX_EXTRA_ABI_MODULE_NAME
+#define CYTHON_ABI "3_0_10" __PYX_EXTRA_ABI_MODULE_NAME
 #define __PYX_ABI_MODULE_NAME "_cython_" CYTHON_ABI
 #define __PYX_TYPE_MODULE_PREFIX __PYX_ABI_MODULE_NAME "."
-#define CYTHON_HEX_VERSION 0x030008F0
+#define CYTHON_HEX_VERSION 0x03000AF0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(_WIN32) && !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -141,14 +147,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(PYPY_VERSION)
   #define CYTHON_COMPILING_IN_PYPY 1
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #undef CYTHON_USE_TYPE_SLOTS
@@ -202,14 +210,16 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(CYTHON_LIMITED_API)
   #ifdef Py_LIMITED_API
     #undef __PYX_LIMITED_VERSION_HEX
     #define __PYX_LIMITED_VERSION_HEX Py_LIMITED_API
   #endif
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
@@ -263,60 +273,83 @@
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
+  #undef CYTHON_USE_FREELISTS
+  #define CYTHON_USE_FREELISTS 0
 #elif defined(Py_GIL_DISABLED) || defined(Py_NOGIL)
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 0
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 1
   #ifndef CYTHON_USE_TYPE_SLOTS
     #define CYTHON_USE_TYPE_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_TYPE_SPECS
+    #define CYTHON_USE_TYPE_SPECS 0
+  #endif
   #undef CYTHON_USE_PYTYPE_LOOKUP
   #define CYTHON_USE_PYTYPE_LOOKUP 0
   #ifndef CYTHON_USE_ASYNC_SLOTS
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
+  #ifndef CYTHON_USE_PYLONG_INTERNALS
+    #define CYTHON_USE_PYLONG_INTERNALS 0
+  #endif
   #undef CYTHON_USE_PYLIST_INTERNALS
   #define CYTHON_USE_PYLIST_INTERNALS 0
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
   #undef CYTHON_USE_UNICODE_WRITER
   #define CYTHON_USE_UNICODE_WRITER 0
-  #undef CYTHON_USE_PYLONG_INTERNALS
-  #define CYTHON_USE_PYLONG_INTERNALS 0
   #ifndef CYTHON_AVOID_BORROWED_REFS
     #define CYTHON_AVOID_BORROWED_REFS 0
   #endif
   #ifndef CYTHON_ASSUME_SAFE_MACROS
     #define CYTHON_ASSUME_SAFE_MACROS 1
   #endif
   #ifndef CYTHON_UNPACK_METHODS
     #define CYTHON_UNPACK_METHODS 1
   #endif
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
+  #undef CYTHON_FAST_GIL
+  #define CYTHON_FAST_GIL 0
+  #ifndef CYTHON_METH_FASTCALL
+    #define CYTHON_METH_FASTCALL 1
+  #endif
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
+  #ifndef CYTHON_PEP487_INIT_SUBCLASS
+    #define CYTHON_PEP487_INIT_SUBCLASS 1
+  #endif
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT 1
   #endif
+  #ifndef CYTHON_USE_MODULE_STATE
+    #define CYTHON_USE_MODULE_STATE 0
+  #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE 1
   #endif
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
+  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
+    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
+  #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 0
+  #endif
 #else
   #define CYTHON_COMPILING_IN_PYPY 0
   #define CYTHON_COMPILING_IN_CPYTHON 1
   #define CYTHON_COMPILING_IN_LIMITED_API 0
   #define CYTHON_COMPILING_IN_GRAAL 0
   #define CYTHON_COMPILING_IN_NOGIL 0
   #ifndef CYTHON_USE_TYPE_SLOTS
@@ -399,14 +432,17 @@
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK 1
   #endif
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
   #endif
+  #ifndef CYTHON_USE_FREELISTS
+    #define CYTHON_USE_FREELISTS 1
+  #endif
 #endif
 #if !defined(CYTHON_FAST_PYCCALL)
 #define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
 #endif
 #if !defined(CYTHON_VECTORCALL)
 #define CYTHON_VECTORCALL  (CYTHON_FAST_PYCCALL && PY_VERSION_HEX >= 0x030800B1)
 #endif
@@ -758,16 +794,21 @@
   #ifndef METH_FASTCALL
      #define METH_FASTCALL 0x80
   #endif
   typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
   typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                           Py_ssize_t nargs, PyObject *kwnames);
 #else
-  #define __Pyx_PyCFunctionFast _PyCFunctionFast
-  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #if PY_VERSION_HEX >= 0x030d00A4
+  #  define __Pyx_PyCFunctionFast PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords PyCFunctionFastWithKeywords
+  #else
+  #  define __Pyx_PyCFunctionFast _PyCFunctionFast
+  #  define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
+  #endif
 #endif
 #if CYTHON_METH_FASTCALL
   #define __Pyx_METH_FASTCALL METH_FASTCALL
   #define __Pyx_PyCFunction_FastCall __Pyx_PyCFunctionFast
   #define __Pyx_PyCFunction_FastCallWithKeywords __Pyx_PyCFunctionFastWithKeywords
 #else
   #define __Pyx_METH_FASTCALL METH_VARARGS
@@ -1111,15 +1152,15 @@
   #define __Pyx_PyList_SET_ITEM(o, i, v) PyList_SetItem(o, i, v)
   #define __Pyx_PyTuple_GET_SIZE(o) PyTuple_Size(o)
   #define __Pyx_PyList_GET_SIZE(o) PyList_Size(o)
   #define __Pyx_PySet_GET_SIZE(o) PySet_Size(o)
   #define __Pyx_PyBytes_GET_SIZE(o) PyBytes_Size(o)
   #define __Pyx_PyByteArray_GET_SIZE(o) PyByteArray_Size(o)
 #endif
-#if PY_VERSION_HEX >= 0x030d00A1
+#if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
   #define __Pyx_PyImport_AddModuleRef(name) PyImport_AddModuleRef(name)
 #else
   static CYTHON_INLINE PyObject *__Pyx_PyImport_AddModuleRef(const char *name) {
       PyObject *module = PyImport_AddModule(name);
       Py_XINCREF(module);
       return module;
   }
@@ -1198,15 +1239,15 @@
 #if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
 #define __Pyx_truncl trunc
 #else
 #define __Pyx_truncl truncl
 #endif
 
 #define __PYX_MARK_ERR_POS(f_index, lineno) \
-    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
+    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__;  (void)__pyx_clineno; }
 #define __PYX_ERR(f_index, lineno, Ln_error) \
     { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }
 
 #ifdef CYTHON_EXTERN_C
     #undef __PYX_EXTERN_C
     #define __PYX_EXTERN_C CYTHON_EXTERN_C
 #elif defined(__PYX_EXTERN_C)
@@ -1228,16 +1269,16 @@
     /* Using NumPy API declarations from "numpy/__init__.cython-30.pxd" */
     
 #include "numpy/arrayobject.h"
 #include "numpy/ndarrayobject.h"
 #include "numpy/ndarraytypes.h"
 #include "numpy/arrayscalars.h"
 #include "numpy/ufuncobject.h"
-#include "pythread.h"
 #include <stdlib.h>
+#include "pythread.h"
 #ifdef _OPENMP
 #include <omp.h>
 #endif /* _OPENMP */
 
 #if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
 #define CYTHON_WITHOUT_ASSERTIONS
 #endif
@@ -1309,32 +1350,15 @@
 #define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
 #define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
 #define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
 #define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
 #define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
 #define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
-#if CYTHON_COMPILING_IN_LIMITED_API
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const wchar_t *u)
-{
-    const wchar_t *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#else
-static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
-{
-    const Py_UNICODE *u_end = u;
-    while (*u_end++) ;
-    return (size_t)(u_end - u - 1);
-}
-#endif
 #define __Pyx_PyUnicode_FromOrdinal(o)       PyUnicode_FromOrdinal((int)o)
-#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
-#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
 #define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
 #define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
 #define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
 static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
 static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
 static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
@@ -1667,177 +1691,177 @@
   Py_ssize_t strides[8];
   Py_ssize_t suboffsets[8];
 } __Pyx_memviewslice;
 #define __Pyx_MemoryView_Len(m)  (m.shape[0])
 
 /* #### Code section: numeric_typedefs ### */
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":730
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":730
  * # in Cython to enable them only on the right systems.
  * 
  * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  */
 typedef npy_int8 __pyx_t_5numpy_int8_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":731
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":731
  * 
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t
  */
 typedef npy_int16 __pyx_t_5numpy_int16_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":732
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":732
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int64      int64_t
  * #ctypedef npy_int96      int96_t
  */
 typedef npy_int32 __pyx_t_5numpy_int32_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":733
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":733
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_int96      int96_t
  * #ctypedef npy_int128     int128_t
  */
 typedef npy_int64 __pyx_t_5numpy_int64_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":737
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":737
  * #ctypedef npy_int128     int128_t
  * 
  * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  */
 typedef npy_uint8 __pyx_t_5numpy_uint8_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":738
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":738
  * 
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t
  */
 typedef npy_uint16 __pyx_t_5numpy_uint16_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":739
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":739
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint64     uint64_t
  * #ctypedef npy_uint96     uint96_t
  */
 typedef npy_uint32 __pyx_t_5numpy_uint32_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":740
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":740
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_uint96     uint96_t
  * #ctypedef npy_uint128    uint128_t
  */
 typedef npy_uint64 __pyx_t_5numpy_uint64_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":744
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":744
  * #ctypedef npy_uint128    uint128_t
  * 
  * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_float64    float64_t
  * #ctypedef npy_float80    float80_t
  */
 typedef npy_float32 __pyx_t_5numpy_float32_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":745
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":745
  * 
  * ctypedef npy_float32    float32_t
  * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_float80    float80_t
  * #ctypedef npy_float128   float128_t
  */
 typedef npy_float64 __pyx_t_5numpy_float64_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":754
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":754
  * # The int types are mapped a bit surprising --
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   longlong_t
  * 
  */
 typedef npy_long __pyx_t_5numpy_int_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":755
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":755
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_ulong      uint_t
  */
 typedef npy_longlong __pyx_t_5numpy_longlong_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":757
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":757
  * ctypedef npy_longlong   longlong_t
  * 
  * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  */
 typedef npy_ulong __pyx_t_5numpy_uint_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":758
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":758
  * 
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_intp       intp_t
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":760
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":760
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uintp      uintp_t
  * 
  */
 typedef npy_intp __pyx_t_5numpy_intp_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":761
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":761
  * 
  * ctypedef npy_intp       intp_t
  * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_double     float_t
  */
 typedef npy_uintp __pyx_t_5numpy_uintp_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":763
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":763
  * ctypedef npy_uintp      uintp_t
  * 
  * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t
  */
 typedef npy_double __pyx_t_5numpy_float_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":764
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":764
  * 
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longdouble longdouble_t
  * 
  */
 typedef npy_double __pyx_t_5numpy_double_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":765
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":765
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cfloat      cfloat_t
  */
 typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
@@ -1872,75 +1896,78 @@
 struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria;
 struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter;
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":767
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":767
  * ctypedef npy_longdouble longdouble_t
  * 
  * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t
  */
 typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":768
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":768
  * 
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
  * ctypedef npy_clongdouble clongdouble_t
  * 
  */
 typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":769
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":769
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cdouble     complex_t
  */
 typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":771
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":771
  * ctypedef npy_clongdouble clongdouble_t
  * 
  * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  */
 typedef npy_cdouble __pyx_t_5numpy_complex_t;
-struct __pyx_ctuple_double__and_double__and_double__and_double;
-typedef struct __pyx_ctuple_double__and_double__and_double__and_double __pyx_ctuple_double__and_double__and_double__and_double;
+struct __pyx_ctuple_double__and_double;
+typedef struct __pyx_ctuple_double__and_double __pyx_ctuple_double__and_double;
 
-/* "criteria/criteria.pxd":7
- *         double[::1] sample_weight
- *     cpdef double impurity(self, int[:] indices)
- *     cdef (double, double, double, double) evaluate_split(self, int[:] indices, int split_idx, int feature)             # <<<<<<<<<<<<<<
+/* "criteria/criteria.pxd":27
+ * 
+ *     cpdef double impurity(self, int[::1] indices)
+ *     cdef (double, double) evaluate_split(self, int[::1] indices, int split_idx, int feature)             # <<<<<<<<<<<<<<
+ *     """
+ *         Function to evaluate how good a split is
  */
-struct __pyx_ctuple_double__and_double__and_double__and_double {
+struct __pyx_ctuple_double__and_double {
   double f0;
   double f1;
-  double f2;
-  double f3;
 };
 
 /* "criteria/criteria.pxd":1
  * cdef class Criteria:             # <<<<<<<<<<<<<<
  *     cdef:
  *         double[:, ::1] x
  */
 struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria {
   PyObject_HEAD
   struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *__pyx_vtab;
   __Pyx_memviewslice x;
   __Pyx_memviewslice y;
   __Pyx_memviewslice sample_weight;
+  int old_obs;
+  int old_split;
+  int old_feature;
 };
 
 
 /* "adaXT/decision_tree/splitter.pxd":5
  * cnp.import_array()
  * 
  * cdef class Splitter:             # <<<<<<<<<<<<<<
@@ -2042,30 +2069,31 @@
 /* "criteria/criteria.pxd":1
  * cdef class Criteria:             # <<<<<<<<<<<<<<
  *     cdef:
  *         double[:, ::1] x
  */
 
 struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria {
+  double (*proxy_improvement)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int);
+  double (*update_proxy)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int);
   double (*impurity)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int __pyx_skip_dispatch);
-  __pyx_ctuple_double__and_double__and_double__and_double (*evaluate_split)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int, int);
+  __pyx_ctuple_double__and_double (*evaluate_split)(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *, __Pyx_memviewslice, int, int);
 };
 static struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *__pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria;
 
 
-/* "adaXT/decision_tree/splitter.pyx":16
+/* "adaXT/decision_tree/splitter.pyx":51
  * 
  * 
  * cdef class Splitter:             # <<<<<<<<<<<<<<
- *     """
- *     Splitter class used to create splits of the data
+ *     def __init__(self, double[:, ::1] X, double[::1] Y, criteria: Criteria):
+ *         self.features = X
  */
 
 struct __pyx_vtabstruct_5adaXT_13decision_tree_8splitter_Splitter {
-  PyArrayObject *(*sort_feature)(struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter *, __Pyx_memviewslice, __Pyx_memviewslice);
   PyObject *(*get_split)(struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter *, __Pyx_memviewslice, __Pyx_memviewslice, int __pyx_skip_dispatch);
 };
 static struct __pyx_vtabstruct_5adaXT_13decision_tree_8splitter_Splitter *__pyx_vtabptr_5adaXT_13decision_tree_8splitter_Splitter;
 
 
 /* "View.MemoryView":114
  * @cython.collection_type("sequence")
@@ -2700,39 +2728,14 @@
 /* HasAttr.proto */
 #if __PYX_LIMITED_VERSION_HEX >= 0x030d00A1
 #define __Pyx_HasAttr(o, n)  PyObject_HasAttrWithError(o, n)
 #else
 static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);
 #endif
 
-/* IsLittleEndian.proto */
-static CYTHON_INLINE int __Pyx_Is_Little_Endian(void);
-
-/* BufferFormatCheck.proto */
-static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts);
-static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
-                              __Pyx_BufFmt_StackElem* stack,
-                              __Pyx_TypeInfo* type);
-
-/* BufferGetAndValidate.proto */
-#define __Pyx_GetBufferAndValidate(buf, obj, dtype, flags, nd, cast, stack)\
-    ((obj == Py_None || obj == NULL) ?\
-    (__Pyx_ZeroBuffer(buf), 0) :\
-    __Pyx__GetBufferAndValidate(buf, obj, dtype, flags, nd, cast, stack))
-static int  __Pyx__GetBufferAndValidate(Py_buffer* buf, PyObject* obj,
-    __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack);
-static void __Pyx_ZeroBuffer(Py_buffer* buf);
-static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info);
-static Py_ssize_t __Pyx_minusones[] = { -1, -1, -1, -1, -1, -1, -1, -1 };
-static Py_ssize_t __Pyx_zeros[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
-
-/* BufferFallbackError.proto */
-static void __Pyx_RaiseBufferFallbackError(void);
-
-#define __Pyx_BufPtrStrided1d(type, buf, i0, s0) (type)((char*)buf + i0 * s0)
 /* PyObject_GenericGetAttrNoDict.proto */
 #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
 #else
 #define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
 #endif
 
@@ -2781,30 +2784,30 @@
 
 /* SetupReduce.proto */
 #if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_setup_reduce(PyObject* type_obj);
 #endif
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto_3_0_8
-#define __PYX_HAVE_RT_ImportType_proto_3_0_8
+#ifndef __PYX_HAVE_RT_ImportType_proto_3_0_10
+#define __PYX_HAVE_RT_ImportType_proto_3_0_10
 #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
 #include <stdalign.h>
 #endif
 #if (defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || __cplusplus >= 201103L
-#define __PYX_GET_STRUCT_ALIGNMENT_3_0_8(s) alignof(s)
+#define __PYX_GET_STRUCT_ALIGNMENT_3_0_10(s) alignof(s)
 #else
-#define __PYX_GET_STRUCT_ALIGNMENT_3_0_8(s) sizeof(void*)
+#define __PYX_GET_STRUCT_ALIGNMENT_3_0_10(s) sizeof(void*)
 #endif
-enum __Pyx_ImportType_CheckSize_3_0_8 {
-   __Pyx_ImportType_CheckSize_Error_3_0_8 = 0,
-   __Pyx_ImportType_CheckSize_Warn_3_0_8 = 1,
-   __Pyx_ImportType_CheckSize_Ignore_3_0_8 = 2
+enum __Pyx_ImportType_CheckSize_3_0_10 {
+   __Pyx_ImportType_CheckSize_Error_3_0_10 = 0,
+   __Pyx_ImportType_CheckSize_Warn_3_0_10 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_3_0_10 = 2
 };
-static PyTypeObject *__Pyx_ImportType_3_0_8(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_8 check_size);
+static PyTypeObject *__Pyx_ImportType_3_0_10(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_10 check_size);
 #endif
 
 /* PyIntBinop.proto */
 #if !CYTHON_COMPILING_IN_PYPY
 static PyObject* __Pyx_PyInt_MultiplyCObj(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check);
 #else
 #define __Pyx_PyInt_MultiplyCObj(op1, op2, intval, inplace, zerodivision_check)\
@@ -3006,14 +3009,23 @@
 static int __pyx_memviewslice_is_contig(const __Pyx_memviewslice mvs, char order, int ndim);
 
 /* OverlappingSlices.proto */
 static int __pyx_slices_overlap(__Pyx_memviewslice *slice1,
                                 __Pyx_memviewslice *slice2,
                                 int ndim, size_t itemsize);
 
+/* IsLittleEndian.proto */
+static CYTHON_INLINE int __Pyx_Is_Little_Endian(void);
+
+/* BufferFormatCheck.proto */
+static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts);
+static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
+                              __Pyx_BufFmt_StackElem* stack,
+                              __Pyx_TypeInfo* type);
+
 /* TypeInfoCompare.proto */
 static int __pyx_typeinfo_cmp(__Pyx_TypeInfo *a, __Pyx_TypeInfo *b);
 
 /* MemviewSliceValidateAndInit.proto */
 static int __Pyx_ValidateAndInit_memviewslice(
                 int *axes_specs,
                 int c_or_f_flag,
@@ -3027,15 +3039,15 @@
 /* ObjectToMemviewSlice.proto */
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(PyObject *, int writable_flag);
 
 /* ObjectToMemviewSlice.proto */
 static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_double(PyObject *, int writable_flag);
 
 /* ObjectToMemviewSlice.proto */
-static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_int(PyObject *, int writable_flag);
+static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_int(PyObject *, int writable_flag);
 
 /* MemviewDtypeToObject.proto */
 static CYTHON_INLINE PyObject *__pyx_memview_get_double(const char *itemp);
 static CYTHON_INLINE int __pyx_memview_set_double(const char *itemp, PyObject *obj);
 
 /* MemviewDtypeToObject.proto */
 static CYTHON_INLINE PyObject *__pyx_memview_get_int(const char *itemp);
@@ -3176,23 +3188,29 @@
 
 /* CIntToPy.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);
 
+/* CIntToPy.proto */
+static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
+
+/* CopyContentsUtility.proto */
+#define __pyx_memoryview_copy_slice_dc_int_c(slice)\
+        __pyx_memoryview_copy_new_contig(&slice, "c", 1,\
+                                         sizeof(int), (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT),\
+                                         0)
+
 /* None.proto */
 #include <new>
 
 /* CIntFromPy.proto */
 static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);
 
-/* CIntToPy.proto */
-static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);
-
 /* CIntFromPy.proto */
 static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *);
 
 /* FormatTypeName.proto */
 #if CYTHON_COMPILING_IN_LIMITED_API
 typedef PyObject *__Pyx_TypeName;
 #define __Pyx_FMT_TYPENAME "%U"
@@ -3228,15 +3246,14 @@
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_7ndarray_4base_base(PyArrayObject *__pyx_v_self); /* proto*/
 static CYTHON_INLINE PyArray_Descr *__pyx_f_5numpy_7ndarray_5descr_descr(PyArrayObject *__pyx_v_self); /* proto*/
 static CYTHON_INLINE int __pyx_f_5numpy_7ndarray_4ndim_ndim(PyArrayObject *__pyx_v_self); /* proto*/
 static CYTHON_INLINE npy_intp *__pyx_f_5numpy_7ndarray_5shape_shape(PyArrayObject *__pyx_v_self); /* proto*/
 static CYTHON_INLINE npy_intp *__pyx_f_5numpy_7ndarray_7strides_strides(PyArrayObject *__pyx_v_self); /* proto*/
 static CYTHON_INLINE npy_intp __pyx_f_5numpy_7ndarray_4size_size(PyArrayObject *__pyx_v_self); /* proto*/
 static CYTHON_INLINE char *__pyx_f_5numpy_7ndarray_4data_data(PyArrayObject *__pyx_v_self); /* proto*/
-static PyArrayObject *__pyx_f_5adaXT_13decision_tree_8splitter_8Splitter_sort_feature(CYTHON_UNUSED struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, __Pyx_memviewslice __pyx_v_feature); /* proto*/
 static PyObject *__pyx_f_5adaXT_13decision_tree_8splitter_8Splitter_get_split(struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, __Pyx_memviewslice __pyx_v_feature_indices, int __pyx_skip_dispatch); /* proto*/
 
 /* Module declarations from "libc.string" */
 
 /* Module declarations from "libc.stdio" */
 
 /* Module declarations from "__builtin__" */
@@ -3252,25 +3269,30 @@
 /* Module declarations from "numpy" */
 
 /* Module declarations from "numpy" */
 static CYTHON_INLINE int __pyx_f_5numpy_import_array(void); /*proto*/
 
 /* Module declarations from "adaXT.criteria.criteria" */
 
+/* Module declarations from "libc.stdlib" */
+
 /* Module declarations from "adaXT.decision_tree.splitter" */
 static double __pyx_v_5adaXT_13decision_tree_8splitter_EPSILON;
 static double __pyx_v_5adaXT_13decision_tree_8splitter_INFINITY;
+static __Pyx_memviewslice __pyx_v_5adaXT_13decision_tree_8splitter_current_feature_values = { 0, 0, { 0 }, { 0 }, { 0 } };
 static PyObject *__pyx_collections_abc_Sequence = 0;
 static PyObject *generic = 0;
 static PyObject *strided = 0;
 static PyObject *indirect = 0;
 static PyObject *contiguous = 0;
 static PyObject *indirect_contiguous = 0;
 static int __pyx_memoryview_thread_locks_used;
 static PyThread_type_lock __pyx_memoryview_thread_locks[8];
+static int __pyx_f_5adaXT_13decision_tree_8splitter_compare(void const *, void const *); /*proto*/
+static __Pyx_memviewslice __pyx_f_5adaXT_13decision_tree_8splitter_sort_feature(__Pyx_memviewslice); /*proto*/
 static int __pyx_array_allocate_buffer(struct __pyx_array_obj *); /*proto*/
 static struct __pyx_array_obj *__pyx_array_new(PyObject *, Py_ssize_t, char *, char *, char *); /*proto*/
 static PyObject *__pyx_memoryview_new(PyObject *, int, int, __Pyx_TypeInfo *); /*proto*/
 static CYTHON_INLINE int __pyx_memoryview_check(PyObject *); /*proto*/
 static PyObject *_unellipsify(PyObject *, int); /*proto*/
 static int assert_direct_dimensions(Py_ssize_t *, int); /*proto*/
 static struct __pyx_memoryview_obj *__pyx_memview_slice(struct __pyx_memoryview_obj *, PyObject *); /*proto*/
@@ -3300,15 +3322,14 @@
 static void __pyx_memoryview_refcount_objects_in_slice(char *, Py_ssize_t *, Py_ssize_t *, int, int); /*proto*/
 static void __pyx_memoryview_slice_assign_scalar(__Pyx_memviewslice *, int, size_t, void *, int); /*proto*/
 static void __pyx_memoryview__slice_assign_scalar(char *, Py_ssize_t *, Py_ssize_t *, int, size_t, void *); /*proto*/
 static PyObject *__pyx_unpickle_Enum__set_state(struct __pyx_MemviewEnum_obj *, PyObject *); /*proto*/
 /* #### Code section: typeinfo ### */
 static __Pyx_TypeInfo __Pyx_TypeInfo_double = { "double", NULL, sizeof(double), { 0 }, 0, 'R', 0, 0 };
 static __Pyx_TypeInfo __Pyx_TypeInfo_int = { "int", NULL, sizeof(int), { 0 }, 0, __PYX_IS_UNSIGNED(int) ? 'U' : 'I', __PYX_IS_UNSIGNED(int), 0 };
-static __Pyx_TypeInfo __Pyx_TypeInfo_PY_LONG_LONG = { "long long", NULL, sizeof(PY_LONG_LONG), { 0 }, 0, __PYX_IS_UNSIGNED(PY_LONG_LONG) ? 'U' : 'I', __PYX_IS_UNSIGNED(PY_LONG_LONG), 0 };
 /* #### Code section: before_global_var ### */
 #define __Pyx_MODULE_NAME "adaXT.decision_tree.splitter"
 extern int __pyx_module_is_main_adaXT__decision_tree__splitter;
 int __pyx_module_is_main_adaXT__decision_tree__splitter = 0;
 
 /* Implementation of "adaXT.decision_tree.splitter" */
 /* #### Code section: global_var ### */
@@ -3377,15 +3398,14 @@
 static const char __pyx_k_name_2[] = "__name__";
 static const char __pyx_k_pickle[] = "pickle";
 static const char __pyx_k_reduce[] = "__reduce__";
 static const char __pyx_k_struct[] = "struct";
 static const char __pyx_k_unique[] = "unique";
 static const char __pyx_k_unpack[] = "unpack";
 static const char __pyx_k_update[] = "update";
-static const char __pyx_k_argsort[] = "argsort";
 static const char __pyx_k_asarray[] = "asarray";
 static const char __pyx_k_disable[] = "disable";
 static const char __pyx_k_fortran[] = "fortran";
 static const char __pyx_k_indices[] = "indices";
 static const char __pyx_k_memview[] = "memview";
 static const char __pyx_k_Ellipsis[] = "Ellipsis";
 static const char __pyx_k_Sequence[] = "Sequence";
@@ -3577,14 +3597,16 @@
   PyTypeObject *__pyx_ptype_5numpy_flexible;
   PyTypeObject *__pyx_ptype_5numpy_character;
   PyTypeObject *__pyx_ptype_5numpy_ufunc;
   #if CYTHON_USE_MODULE_STATE
   #endif
   PyTypeObject *__pyx_ptype_5adaXT_8criteria_8criteria_Criteria;
   #if CYTHON_USE_MODULE_STATE
+  #endif
+  #if CYTHON_USE_MODULE_STATE
   PyObject *__pyx_type_5adaXT_13decision_tree_8splitter_Splitter;
   PyObject *__pyx_type___pyx_array;
   PyObject *__pyx_type___pyx_MemviewEnum;
   PyObject *__pyx_type___pyx_memoryview;
   PyObject *__pyx_type___pyx_memoryviewslice;
   #endif
   PyTypeObject *__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter;
@@ -3635,15 +3657,14 @@
   PyObject *__pyx_n_s__3;
   PyObject *__pyx_kp_u__6;
   PyObject *__pyx_kp_u__7;
   PyObject *__pyx_n_s_abc;
   PyObject *__pyx_n_s_adaXT_decision_tree_splitter;
   PyObject *__pyx_n_s_allocate_buffer;
   PyObject *__pyx_kp_u_and;
-  PyObject *__pyx_n_s_argsort;
   PyObject *__pyx_n_s_asarray;
   PyObject *__pyx_n_s_asyncio_coroutines;
   PyObject *__pyx_n_s_base;
   PyObject *__pyx_n_s_c;
   PyObject *__pyx_n_u_c;
   PyObject *__pyx_n_s_class;
   PyObject *__pyx_n_s_class_getitem;
@@ -3652,15 +3673,15 @@
   PyObject *__pyx_kp_s_collections_abc;
   PyObject *__pyx_kp_s_contiguous_and_direct;
   PyObject *__pyx_kp_s_contiguous_and_indirect;
   PyObject *__pyx_n_s_count;
   PyObject *__pyx_n_s_criteria;
   PyObject *__pyx_n_s_dict;
   PyObject *__pyx_kp_u_disable;
-  PyObject *__pyx_n_s_double;
+  PyObject *__pyx_n_u_double;
   PyObject *__pyx_n_s_dtype_is_object;
   PyObject *__pyx_kp_u_enable;
   PyObject *__pyx_n_s_encode;
   PyObject *__pyx_n_s_enumerate;
   PyObject *__pyx_n_s_eps;
   PyObject *__pyx_n_s_error;
   PyObject *__pyx_n_s_feature_indices;
@@ -3690,16 +3711,16 @@
   PyObject *__pyx_n_s_name;
   PyObject *__pyx_n_s_name_2;
   PyObject *__pyx_n_s_ndim;
   PyObject *__pyx_n_s_new;
   PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
   PyObject *__pyx_n_s_np;
   PyObject *__pyx_n_s_numpy;
-  PyObject *__pyx_kp_s_numpy_core_multiarray_failed_to;
-  PyObject *__pyx_kp_s_numpy_core_umath_failed_to_impor;
+  PyObject *__pyx_kp_u_numpy_core_multiarray_failed_to;
+  PyObject *__pyx_kp_u_numpy_core_umath_failed_to_impor;
   PyObject *__pyx_n_s_obj;
   PyObject *__pyx_n_s_pack;
   PyObject *__pyx_n_s_pickle;
   PyObject *__pyx_n_s_pyx_PickleError;
   PyObject *__pyx_n_s_pyx_checksum;
   PyObject *__pyx_n_s_pyx_result;
   PyObject *__pyx_n_s_pyx_state;
@@ -3878,15 +3899,14 @@
   Py_CLEAR(clear_module_state->__pyx_n_s__3);
   Py_CLEAR(clear_module_state->__pyx_kp_u__6);
   Py_CLEAR(clear_module_state->__pyx_kp_u__7);
   Py_CLEAR(clear_module_state->__pyx_n_s_abc);
   Py_CLEAR(clear_module_state->__pyx_n_s_adaXT_decision_tree_splitter);
   Py_CLEAR(clear_module_state->__pyx_n_s_allocate_buffer);
   Py_CLEAR(clear_module_state->__pyx_kp_u_and);
-  Py_CLEAR(clear_module_state->__pyx_n_s_argsort);
   Py_CLEAR(clear_module_state->__pyx_n_s_asarray);
   Py_CLEAR(clear_module_state->__pyx_n_s_asyncio_coroutines);
   Py_CLEAR(clear_module_state->__pyx_n_s_base);
   Py_CLEAR(clear_module_state->__pyx_n_s_c);
   Py_CLEAR(clear_module_state->__pyx_n_u_c);
   Py_CLEAR(clear_module_state->__pyx_n_s_class);
   Py_CLEAR(clear_module_state->__pyx_n_s_class_getitem);
@@ -3895,15 +3915,15 @@
   Py_CLEAR(clear_module_state->__pyx_kp_s_collections_abc);
   Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_direct);
   Py_CLEAR(clear_module_state->__pyx_kp_s_contiguous_and_indirect);
   Py_CLEAR(clear_module_state->__pyx_n_s_count);
   Py_CLEAR(clear_module_state->__pyx_n_s_criteria);
   Py_CLEAR(clear_module_state->__pyx_n_s_dict);
   Py_CLEAR(clear_module_state->__pyx_kp_u_disable);
-  Py_CLEAR(clear_module_state->__pyx_n_s_double);
+  Py_CLEAR(clear_module_state->__pyx_n_u_double);
   Py_CLEAR(clear_module_state->__pyx_n_s_dtype_is_object);
   Py_CLEAR(clear_module_state->__pyx_kp_u_enable);
   Py_CLEAR(clear_module_state->__pyx_n_s_encode);
   Py_CLEAR(clear_module_state->__pyx_n_s_enumerate);
   Py_CLEAR(clear_module_state->__pyx_n_s_eps);
   Py_CLEAR(clear_module_state->__pyx_n_s_error);
   Py_CLEAR(clear_module_state->__pyx_n_s_feature_indices);
@@ -3933,16 +3953,16 @@
   Py_CLEAR(clear_module_state->__pyx_n_s_name);
   Py_CLEAR(clear_module_state->__pyx_n_s_name_2);
   Py_CLEAR(clear_module_state->__pyx_n_s_ndim);
   Py_CLEAR(clear_module_state->__pyx_n_s_new);
   Py_CLEAR(clear_module_state->__pyx_kp_s_no_default___reduce___due_to_non);
   Py_CLEAR(clear_module_state->__pyx_n_s_np);
   Py_CLEAR(clear_module_state->__pyx_n_s_numpy);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_numpy_core_multiarray_failed_to);
-  Py_CLEAR(clear_module_state->__pyx_kp_s_numpy_core_umath_failed_to_impor);
+  Py_CLEAR(clear_module_state->__pyx_kp_u_numpy_core_multiarray_failed_to);
+  Py_CLEAR(clear_module_state->__pyx_kp_u_numpy_core_umath_failed_to_impor);
   Py_CLEAR(clear_module_state->__pyx_n_s_obj);
   Py_CLEAR(clear_module_state->__pyx_n_s_pack);
   Py_CLEAR(clear_module_state->__pyx_n_s_pickle);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_PickleError);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_checksum);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_result);
   Py_CLEAR(clear_module_state->__pyx_n_s_pyx_state);
@@ -4099,15 +4119,14 @@
   Py_VISIT(traverse_module_state->__pyx_n_s__3);
   Py_VISIT(traverse_module_state->__pyx_kp_u__6);
   Py_VISIT(traverse_module_state->__pyx_kp_u__7);
   Py_VISIT(traverse_module_state->__pyx_n_s_abc);
   Py_VISIT(traverse_module_state->__pyx_n_s_adaXT_decision_tree_splitter);
   Py_VISIT(traverse_module_state->__pyx_n_s_allocate_buffer);
   Py_VISIT(traverse_module_state->__pyx_kp_u_and);
-  Py_VISIT(traverse_module_state->__pyx_n_s_argsort);
   Py_VISIT(traverse_module_state->__pyx_n_s_asarray);
   Py_VISIT(traverse_module_state->__pyx_n_s_asyncio_coroutines);
   Py_VISIT(traverse_module_state->__pyx_n_s_base);
   Py_VISIT(traverse_module_state->__pyx_n_s_c);
   Py_VISIT(traverse_module_state->__pyx_n_u_c);
   Py_VISIT(traverse_module_state->__pyx_n_s_class);
   Py_VISIT(traverse_module_state->__pyx_n_s_class_getitem);
@@ -4116,15 +4135,15 @@
   Py_VISIT(traverse_module_state->__pyx_kp_s_collections_abc);
   Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_direct);
   Py_VISIT(traverse_module_state->__pyx_kp_s_contiguous_and_indirect);
   Py_VISIT(traverse_module_state->__pyx_n_s_count);
   Py_VISIT(traverse_module_state->__pyx_n_s_criteria);
   Py_VISIT(traverse_module_state->__pyx_n_s_dict);
   Py_VISIT(traverse_module_state->__pyx_kp_u_disable);
-  Py_VISIT(traverse_module_state->__pyx_n_s_double);
+  Py_VISIT(traverse_module_state->__pyx_n_u_double);
   Py_VISIT(traverse_module_state->__pyx_n_s_dtype_is_object);
   Py_VISIT(traverse_module_state->__pyx_kp_u_enable);
   Py_VISIT(traverse_module_state->__pyx_n_s_encode);
   Py_VISIT(traverse_module_state->__pyx_n_s_enumerate);
   Py_VISIT(traverse_module_state->__pyx_n_s_eps);
   Py_VISIT(traverse_module_state->__pyx_n_s_error);
   Py_VISIT(traverse_module_state->__pyx_n_s_feature_indices);
@@ -4154,16 +4173,16 @@
   Py_VISIT(traverse_module_state->__pyx_n_s_name);
   Py_VISIT(traverse_module_state->__pyx_n_s_name_2);
   Py_VISIT(traverse_module_state->__pyx_n_s_ndim);
   Py_VISIT(traverse_module_state->__pyx_n_s_new);
   Py_VISIT(traverse_module_state->__pyx_kp_s_no_default___reduce___due_to_non);
   Py_VISIT(traverse_module_state->__pyx_n_s_np);
   Py_VISIT(traverse_module_state->__pyx_n_s_numpy);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_numpy_core_multiarray_failed_to);
-  Py_VISIT(traverse_module_state->__pyx_kp_s_numpy_core_umath_failed_to_impor);
+  Py_VISIT(traverse_module_state->__pyx_kp_u_numpy_core_multiarray_failed_to);
+  Py_VISIT(traverse_module_state->__pyx_kp_u_numpy_core_umath_failed_to_impor);
   Py_VISIT(traverse_module_state->__pyx_n_s_obj);
   Py_VISIT(traverse_module_state->__pyx_n_s_pack);
   Py_VISIT(traverse_module_state->__pyx_n_s_pickle);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_PickleError);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_checksum);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_result);
   Py_VISIT(traverse_module_state->__pyx_n_s_pyx_state);
@@ -4292,14 +4311,16 @@
 #define __pyx_ptype_5numpy_flexible __pyx_mstate_global->__pyx_ptype_5numpy_flexible
 #define __pyx_ptype_5numpy_character __pyx_mstate_global->__pyx_ptype_5numpy_character
 #define __pyx_ptype_5numpy_ufunc __pyx_mstate_global->__pyx_ptype_5numpy_ufunc
 #if CYTHON_USE_MODULE_STATE
 #endif
 #define __pyx_ptype_5adaXT_8criteria_8criteria_Criteria __pyx_mstate_global->__pyx_ptype_5adaXT_8criteria_8criteria_Criteria
 #if CYTHON_USE_MODULE_STATE
+#endif
+#if CYTHON_USE_MODULE_STATE
 #define __pyx_type_5adaXT_13decision_tree_8splitter_Splitter __pyx_mstate_global->__pyx_type_5adaXT_13decision_tree_8splitter_Splitter
 #define __pyx_type___pyx_array __pyx_mstate_global->__pyx_type___pyx_array
 #define __pyx_type___pyx_MemviewEnum __pyx_mstate_global->__pyx_type___pyx_MemviewEnum
 #define __pyx_type___pyx_memoryview __pyx_mstate_global->__pyx_type___pyx_memoryview
 #define __pyx_type___pyx_memoryviewslice __pyx_mstate_global->__pyx_type___pyx_memoryviewslice
 #endif
 #define __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter __pyx_mstate_global->__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter
@@ -4350,15 +4371,14 @@
 #define __pyx_n_s__3 __pyx_mstate_global->__pyx_n_s__3
 #define __pyx_kp_u__6 __pyx_mstate_global->__pyx_kp_u__6
 #define __pyx_kp_u__7 __pyx_mstate_global->__pyx_kp_u__7
 #define __pyx_n_s_abc __pyx_mstate_global->__pyx_n_s_abc
 #define __pyx_n_s_adaXT_decision_tree_splitter __pyx_mstate_global->__pyx_n_s_adaXT_decision_tree_splitter
 #define __pyx_n_s_allocate_buffer __pyx_mstate_global->__pyx_n_s_allocate_buffer
 #define __pyx_kp_u_and __pyx_mstate_global->__pyx_kp_u_and
-#define __pyx_n_s_argsort __pyx_mstate_global->__pyx_n_s_argsort
 #define __pyx_n_s_asarray __pyx_mstate_global->__pyx_n_s_asarray
 #define __pyx_n_s_asyncio_coroutines __pyx_mstate_global->__pyx_n_s_asyncio_coroutines
 #define __pyx_n_s_base __pyx_mstate_global->__pyx_n_s_base
 #define __pyx_n_s_c __pyx_mstate_global->__pyx_n_s_c
 #define __pyx_n_u_c __pyx_mstate_global->__pyx_n_u_c
 #define __pyx_n_s_class __pyx_mstate_global->__pyx_n_s_class
 #define __pyx_n_s_class_getitem __pyx_mstate_global->__pyx_n_s_class_getitem
@@ -4367,15 +4387,15 @@
 #define __pyx_kp_s_collections_abc __pyx_mstate_global->__pyx_kp_s_collections_abc
 #define __pyx_kp_s_contiguous_and_direct __pyx_mstate_global->__pyx_kp_s_contiguous_and_direct
 #define __pyx_kp_s_contiguous_and_indirect __pyx_mstate_global->__pyx_kp_s_contiguous_and_indirect
 #define __pyx_n_s_count __pyx_mstate_global->__pyx_n_s_count
 #define __pyx_n_s_criteria __pyx_mstate_global->__pyx_n_s_criteria
 #define __pyx_n_s_dict __pyx_mstate_global->__pyx_n_s_dict
 #define __pyx_kp_u_disable __pyx_mstate_global->__pyx_kp_u_disable
-#define __pyx_n_s_double __pyx_mstate_global->__pyx_n_s_double
+#define __pyx_n_u_double __pyx_mstate_global->__pyx_n_u_double
 #define __pyx_n_s_dtype_is_object __pyx_mstate_global->__pyx_n_s_dtype_is_object
 #define __pyx_kp_u_enable __pyx_mstate_global->__pyx_kp_u_enable
 #define __pyx_n_s_encode __pyx_mstate_global->__pyx_n_s_encode
 #define __pyx_n_s_enumerate __pyx_mstate_global->__pyx_n_s_enumerate
 #define __pyx_n_s_eps __pyx_mstate_global->__pyx_n_s_eps
 #define __pyx_n_s_error __pyx_mstate_global->__pyx_n_s_error
 #define __pyx_n_s_feature_indices __pyx_mstate_global->__pyx_n_s_feature_indices
@@ -4405,16 +4425,16 @@
 #define __pyx_n_s_name __pyx_mstate_global->__pyx_n_s_name
 #define __pyx_n_s_name_2 __pyx_mstate_global->__pyx_n_s_name_2
 #define __pyx_n_s_ndim __pyx_mstate_global->__pyx_n_s_ndim
 #define __pyx_n_s_new __pyx_mstate_global->__pyx_n_s_new
 #define __pyx_kp_s_no_default___reduce___due_to_non __pyx_mstate_global->__pyx_kp_s_no_default___reduce___due_to_non
 #define __pyx_n_s_np __pyx_mstate_global->__pyx_n_s_np
 #define __pyx_n_s_numpy __pyx_mstate_global->__pyx_n_s_numpy
-#define __pyx_kp_s_numpy_core_multiarray_failed_to __pyx_mstate_global->__pyx_kp_s_numpy_core_multiarray_failed_to
-#define __pyx_kp_s_numpy_core_umath_failed_to_impor __pyx_mstate_global->__pyx_kp_s_numpy_core_umath_failed_to_impor
+#define __pyx_kp_u_numpy_core_multiarray_failed_to __pyx_mstate_global->__pyx_kp_u_numpy_core_multiarray_failed_to
+#define __pyx_kp_u_numpy_core_umath_failed_to_impor __pyx_mstate_global->__pyx_kp_u_numpy_core_umath_failed_to_impor
 #define __pyx_n_s_obj __pyx_mstate_global->__pyx_n_s_obj
 #define __pyx_n_s_pack __pyx_mstate_global->__pyx_n_s_pack
 #define __pyx_n_s_pickle __pyx_mstate_global->__pyx_n_s_pickle
 #define __pyx_n_s_pyx_PickleError __pyx_mstate_global->__pyx_n_s_pyx_PickleError
 #define __pyx_n_s_pyx_checksum __pyx_mstate_global->__pyx_n_s_pyx_checksum
 #define __pyx_n_s_pyx_result __pyx_mstate_global->__pyx_n_s_pyx_result
 #define __pyx_n_s_pyx_state __pyx_mstate_global->__pyx_n_s_pyx_state
@@ -18105,261 +18125,261 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":245
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":245
  * 
  *         @property
  *         cdef inline PyObject* base(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns a borrowed reference to the object owning the data/memory.
  *             """
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_7ndarray_4base_base(PyArrayObject *__pyx_v_self) {
   PyObject *__pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":248
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":248
  *             """Returns a borrowed reference to the object owning the data/memory.
  *             """
  *             return PyArray_BASE(self)             # <<<<<<<<<<<<<<
  * 
  *         @property
  */
   __pyx_r = PyArray_BASE(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":245
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":245
  * 
  *         @property
  *         cdef inline PyObject* base(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns a borrowed reference to the object owning the data/memory.
  *             """
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":251
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":251
  * 
  *         @property
  *         cdef inline dtype descr(self):             # <<<<<<<<<<<<<<
  *             """Returns an owned reference to the dtype of the array.
  *             """
  */
 
 static CYTHON_INLINE PyArray_Descr *__pyx_f_5numpy_7ndarray_5descr_descr(PyArrayObject *__pyx_v_self) {
   PyArray_Descr *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyArray_Descr *__pyx_t_1;
   __Pyx_RefNannySetupContext("descr", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":254
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":254
  *             """Returns an owned reference to the dtype of the array.
  *             """
  *             return <dtype>PyArray_DESCR(self)             # <<<<<<<<<<<<<<
  * 
  *         @property
  */
   __Pyx_XDECREF((PyObject *)__pyx_r);
   __pyx_t_1 = PyArray_DESCR(__pyx_v_self);
   __Pyx_INCREF((PyObject *)((PyArray_Descr *)__pyx_t_1));
   __pyx_r = ((PyArray_Descr *)__pyx_t_1);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":251
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":251
  * 
  *         @property
  *         cdef inline dtype descr(self):             # <<<<<<<<<<<<<<
  *             """Returns an owned reference to the dtype of the array.
  *             """
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF((PyObject *)__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":257
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":257
  * 
  *         @property
  *         cdef inline int ndim(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns the number of dimensions in the array.
  *             """
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_7ndarray_4ndim_ndim(PyArrayObject *__pyx_v_self) {
   int __pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":260
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":260
  *             """Returns the number of dimensions in the array.
  *             """
  *             return PyArray_NDIM(self)             # <<<<<<<<<<<<<<
  * 
  *         @property
  */
   __pyx_r = PyArray_NDIM(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":257
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":257
  * 
  *         @property
  *         cdef inline int ndim(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns the number of dimensions in the array.
  *             """
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":263
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":263
  * 
  *         @property
  *         cdef inline npy_intp *shape(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns a pointer to the dimensions/shape of the array.
  *             The number of elements matches the number of dimensions of the array (ndim).
  */
 
 static CYTHON_INLINE npy_intp *__pyx_f_5numpy_7ndarray_5shape_shape(PyArrayObject *__pyx_v_self) {
   npy_intp *__pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":268
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":268
  *             Can return NULL for 0-dimensional arrays.
  *             """
  *             return PyArray_DIMS(self)             # <<<<<<<<<<<<<<
  * 
  *         @property
  */
   __pyx_r = PyArray_DIMS(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":263
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":263
  * 
  *         @property
  *         cdef inline npy_intp *shape(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns a pointer to the dimensions/shape of the array.
  *             The number of elements matches the number of dimensions of the array (ndim).
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":271
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":271
  * 
  *         @property
  *         cdef inline npy_intp *strides(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns a pointer to the strides of the array.
  *             The number of elements matches the number of dimensions of the array (ndim).
  */
 
 static CYTHON_INLINE npy_intp *__pyx_f_5numpy_7ndarray_7strides_strides(PyArrayObject *__pyx_v_self) {
   npy_intp *__pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":275
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":275
  *             The number of elements matches the number of dimensions of the array (ndim).
  *             """
  *             return PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
  * 
  *         @property
  */
   __pyx_r = PyArray_STRIDES(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":271
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":271
  * 
  *         @property
  *         cdef inline npy_intp *strides(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns a pointer to the strides of the array.
  *             The number of elements matches the number of dimensions of the array (ndim).
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":278
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":278
  * 
  *         @property
  *         cdef inline npy_intp size(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns the total size (in number of elements) of the array.
  *             """
  */
 
 static CYTHON_INLINE npy_intp __pyx_f_5numpy_7ndarray_4size_size(PyArrayObject *__pyx_v_self) {
   npy_intp __pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":281
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":281
  *             """Returns the total size (in number of elements) of the array.
  *             """
  *             return PyArray_SIZE(self)             # <<<<<<<<<<<<<<
  * 
  *         @property
  */
   __pyx_r = PyArray_SIZE(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":278
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":278
  * 
  *         @property
  *         cdef inline npy_intp size(self) nogil:             # <<<<<<<<<<<<<<
  *             """Returns the total size (in number of elements) of the array.
  *             """
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":284
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":284
  * 
  *         @property
  *         cdef inline char* data(self) nogil:             # <<<<<<<<<<<<<<
  *             """The pointer to the data buffer as a char*.
  *             This is provided for legacy reasons to avoid direct struct field access.
  */
 
 static CYTHON_INLINE char *__pyx_f_5numpy_7ndarray_4data_data(PyArrayObject *__pyx_v_self) {
   char *__pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":290
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":290
  *             of `PyArray_DATA()` instead, which returns a 'void*'.
  *             """
  *             return PyArray_BYTES(self)             # <<<<<<<<<<<<<<
  * 
  *     ctypedef unsigned char      npy_bool
  */
   __pyx_r = PyArray_BYTES(__pyx_v_self);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":284
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":284
  * 
  *         @property
  *         cdef inline char* data(self) nogil:             # <<<<<<<<<<<<<<
  *             """The pointer to the data buffer as a char*.
  *             This is provided for legacy reasons to avoid direct struct field access.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":773
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":773
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -18368,29 +18388,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":774
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":774
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 774, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":773
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":773
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -18401,15 +18421,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":776
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":776
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -18418,29 +18438,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":777
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":777
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 777, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":776
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":776
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -18451,15 +18471,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":779
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":779
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -18468,29 +18488,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":780
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":780
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 780, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":779
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":779
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -18501,15 +18521,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":782
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":782
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -18518,29 +18538,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":783
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":783
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 783, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":782
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":782
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -18551,15 +18571,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":785
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":785
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -18568,29 +18588,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":786
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":786
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 786, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":785
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":785
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -18601,217 +18621,217 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":788
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":788
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyDataType_SHAPE(PyArray_Descr *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("PyDataType_SHAPE", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":789
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":789
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   __pyx_t_1 = PyDataType_HASSUBARRAY(__pyx_v_d);
   if (__pyx_t_1) {
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":790
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":790
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape             # <<<<<<<<<<<<<<
  *     else:
  *         return ()
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject*)__pyx_v_d->subarray->shape));
     __pyx_r = ((PyObject*)__pyx_v_d->subarray->shape);
     goto __pyx_L0;
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":789
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":789
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   }
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":792
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":792
  *         return <tuple>d.subarray.shape
  *     else:
  *         return ()             # <<<<<<<<<<<<<<
  * 
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_empty_tuple);
     __pyx_r = __pyx_empty_tuple;
     goto __pyx_L0;
   }
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":788
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":788
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":968
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":968
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
 static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
   int __pyx_t_1;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":969
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":969
  * 
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!             # <<<<<<<<<<<<<<
  *     PyArray_SetBaseObject(arr, base)
  * 
  */
   Py_INCREF(__pyx_v_base);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":970
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":970
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object get_array_base(ndarray arr):
  */
   __pyx_t_1 = PyArray_SetBaseObject(__pyx_v_arr, __pyx_v_base); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(2, 970, __pyx_L1_error)
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":968
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":968
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_AddTraceback("numpy.set_array_base", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_L0:;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":972
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":972
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
   PyObject *__pyx_v_base;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("get_array_base", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":973
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":973
  * 
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)             # <<<<<<<<<<<<<<
  *     if base is NULL:
  *         return None
  */
   __pyx_v_base = PyArray_BASE(__pyx_v_arr);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":974
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":974
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   __pyx_t_1 = (__pyx_v_base == NULL);
   if (__pyx_t_1) {
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":975
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":975
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  *         return None             # <<<<<<<<<<<<<<
  *     return <object>base
  * 
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":974
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":974
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   }
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":976
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":976
  *     if base is NULL:
  *         return None
  *     return <object>base             # <<<<<<<<<<<<<<
  * 
  * # Versions of the import_* functions which are more suitable for
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_base));
   __pyx_r = ((PyObject *)__pyx_v_base);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":972
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":972
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":980
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":980
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -18827,15 +18847,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_array", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":981
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":981
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
   {
@@ -18843,68 +18863,68 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":982
+      /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":982
  * cdef inline int import_array() except -1:
  *     try:
  *         __pyx_import_array()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")
  */
       __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 982, __pyx_L3_error)
 
-      /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":981
+      /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":981
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":983
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":983
  *     try:
  *         __pyx_import_array()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 983, __pyx_L5_except_error)
       __Pyx_XGOTREF(__pyx_t_5);
       __Pyx_XGOTREF(__pyx_t_6);
       __Pyx_XGOTREF(__pyx_t_7);
 
-      /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":984
+      /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":984
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 984, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(2, 984, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":981
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":981
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     __pyx_L5_except_error:;
@@ -18912,15 +18932,15 @@
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":980
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":980
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -18935,15 +18955,15 @@
   __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":986
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":986
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -18959,15 +18979,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_umath", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":987
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":987
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -18975,68 +18995,68 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":988
+      /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":988
  * cdef inline int import_umath() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
       __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 988, __pyx_L3_error)
 
-      /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":987
+      /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":987
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":989
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":989
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 989, __pyx_L5_except_error)
       __Pyx_XGOTREF(__pyx_t_5);
       __Pyx_XGOTREF(__pyx_t_6);
       __Pyx_XGOTREF(__pyx_t_7);
 
-      /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":990
+      /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":990
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 990, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(2, 990, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":987
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":987
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __pyx_L5_except_error:;
@@ -19044,15 +19064,15 @@
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":986
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":986
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -19067,15 +19087,15 @@
   __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":992
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":992
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -19091,15 +19111,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_ufunc", 1);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":993
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":993
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -19107,68 +19127,68 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":994
+      /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":994
  * cdef inline int import_ufunc() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
       __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 994, __pyx_L3_error)
 
-      /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":993
+      /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":993
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":995
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":995
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 995, __pyx_L5_except_error)
       __Pyx_XGOTREF(__pyx_t_5);
       __Pyx_XGOTREF(__pyx_t_6);
       __Pyx_XGOTREF(__pyx_t_7);
 
-      /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":996
+      /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":996
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * 
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 996, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(2, 996, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
 
-    /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":993
+    /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":993
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __pyx_L5_except_error:;
@@ -19176,15 +19196,15 @@
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":992
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":992
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -19199,196 +19219,366 @@
   __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":999
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":999
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_timedelta64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1011
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1011
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyTimedeltaArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyTimedeltaArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":999
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":999
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1014
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1014
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_datetime64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1026
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1026
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyDatetimeArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyDatetimeArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1014
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1014
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1029
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1029
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
 static CYTHON_INLINE npy_datetime __pyx_f_5numpy_get_datetime64_value(PyObject *__pyx_v_obj) {
   npy_datetime __pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1036
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1036
  *     also needed.  That can be found using `get_datetime64_unit`.
  *     """
  *     return (<PyDatetimeScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyDatetimeScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1029
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1029
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1039
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1039
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
 static CYTHON_INLINE npy_timedelta __pyx_f_5numpy_get_timedelta64_value(PyObject *__pyx_v_obj) {
   npy_timedelta __pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1043
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1043
  *     returns the int64 value underlying scalar numpy timedelta64 object
  *     """
  *     return (<PyTimedeltaScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyTimedeltaScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1039
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1039
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1046
+/* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1046
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
 static CYTHON_INLINE NPY_DATETIMEUNIT __pyx_f_5numpy_get_datetime64_unit(PyObject *__pyx_v_obj) {
   NPY_DATETIMEUNIT __pyx_r;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1050
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1050
  *     returns the unit part of the dtype for a numpy datetime64 object.
  *     """
  *     return <NPY_DATETIMEUNIT>(<PyDatetimeScalarObject*>obj).obmeta.base             # <<<<<<<<<<<<<<
  */
   __pyx_r = ((NPY_DATETIMEUNIT)((PyDatetimeScalarObject *)__pyx_v_obj)->obmeta.base);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1046
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":1046
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/splitter.pyx":20
- *     Splitter class used to create splits of the data
+/* "adaXT/decision_tree/splitter.pyx":17
+ * cdef double[:] current_feature_values
+ * 
+ * cdef int compare(const void* a, const void* b) noexcept nogil:             # <<<<<<<<<<<<<<
+ *     cdef:
+ *         int a1 = (<int *> a)[0]
+ */
+
+static int __pyx_f_5adaXT_13decision_tree_8splitter_compare(void const *__pyx_v_a, void const *__pyx_v_b) {
+  int __pyx_v_a1;
+  int __pyx_v_b1;
+  int __pyx_r;
+  Py_ssize_t __pyx_t_1;
+  Py_ssize_t __pyx_t_2;
+  int __pyx_t_3;
+
+  /* "adaXT/decision_tree/splitter.pyx":19
+ * cdef int compare(const void* a, const void* b) noexcept nogil:
+ *     cdef:
+ *         int a1 = (<int *> a)[0]             # <<<<<<<<<<<<<<
+ *         int b1 = (<int *> b)[0]
+ * 
+ */
+  __pyx_v_a1 = (((int *)__pyx_v_a)[0]);
+
+  /* "adaXT/decision_tree/splitter.pyx":20
+ *     cdef:
+ *         int a1 = (<int *> a)[0]
+ *         int b1 = (<int *> b)[0]             # <<<<<<<<<<<<<<
+ * 
+ *     if  current_feature_values[a1] >= current_feature_values[b1]:
+ */
+  __pyx_v_b1 = (((int *)__pyx_v_b)[0]);
+
+  /* "adaXT/decision_tree/splitter.pyx":22
+ *         int b1 = (<int *> b)[0]
+ * 
+ *     if  current_feature_values[a1] >= current_feature_values[b1]:             # <<<<<<<<<<<<<<
+ *         return 1
+ *     else:
+ */
+  __pyx_t_1 = __pyx_v_a1;
+  __pyx_t_2 = __pyx_v_b1;
+  __pyx_t_3 = ((*((double *) ( /* dim=0 */ (__pyx_v_5adaXT_13decision_tree_8splitter_current_feature_values.data + __pyx_t_1 * __pyx_v_5adaXT_13decision_tree_8splitter_current_feature_values.strides[0]) ))) >= (*((double *) ( /* dim=0 */ (__pyx_v_5adaXT_13decision_tree_8splitter_current_feature_values.data + __pyx_t_2 * __pyx_v_5adaXT_13decision_tree_8splitter_current_feature_values.strides[0]) ))));
+  if (__pyx_t_3) {
+
+    /* "adaXT/decision_tree/splitter.pyx":23
+ * 
+ *     if  current_feature_values[a1] >= current_feature_values[b1]:
+ *         return 1             # <<<<<<<<<<<<<<
+ *     else:
+ *         return -1
+ */
+    __pyx_r = 1;
+    goto __pyx_L0;
+
+    /* "adaXT/decision_tree/splitter.pyx":22
+ *         int b1 = (<int *> b)[0]
+ * 
+ *     if  current_feature_values[a1] >= current_feature_values[b1]:             # <<<<<<<<<<<<<<
+ *         return 1
+ *     else:
+ */
+  }
+
+  /* "adaXT/decision_tree/splitter.pyx":25
+ *         return 1
+ *     else:
+ *         return -1             # <<<<<<<<<<<<<<
+ * 
+ * cdef int[::1] sort_feature(int[::1] indices):
+ */
+  /*else*/ {
+    __pyx_r = -1;
+    goto __pyx_L0;
+  }
+
+  /* "adaXT/decision_tree/splitter.pyx":17
+ * cdef double[:] current_feature_values
+ * 
+ * cdef int compare(const void* a, const void* b) noexcept nogil:             # <<<<<<<<<<<<<<
+ *     cdef:
+ *         int a1 = (<int *> a)[0]
+ */
+
+  /* function exit code */
+  __pyx_L0:;
+  return __pyx_r;
+}
+
+/* "adaXT/decision_tree/splitter.pyx":27
+ *         return -1
+ * 
+ * cdef int[::1] sort_feature(int[::1] indices):             # <<<<<<<<<<<<<<
+ *     """
+ *     Function to sort an array at given indices.
+ */
+
+static __Pyx_memviewslice __pyx_f_5adaXT_13decision_tree_8splitter_sort_feature(__Pyx_memviewslice __pyx_v_indices) {
+  int __pyx_v_n_obs;
+  __Pyx_memviewslice __pyx_v_ret = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_r = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_t_1 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  Py_ssize_t __pyx_t_2;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+
+  /* "adaXT/decision_tree/splitter.pyx":45
+ *     """
+ *     cdef:
+ *         int n_obs = indices.shape[0]             # <<<<<<<<<<<<<<
+ *         int[::1] ret = indices.copy()
+ *     qsort(&ret[0], n_obs, sizeof(int), compare)
+ */
+  __pyx_v_n_obs = (__pyx_v_indices.shape[0]);
+
+  /* "adaXT/decision_tree/splitter.pyx":46
+ *     cdef:
+ *         int n_obs = indices.shape[0]
+ *         int[::1] ret = indices.copy()             # <<<<<<<<<<<<<<
+ *     qsort(&ret[0], n_obs, sizeof(int), compare)
+ *     return ret
+ */
+  __pyx_t_1 = __pyx_memoryview_copy_slice_dc_int_c(__pyx_v_indices); if (unlikely(!__pyx_t_1.memview)) __PYX_ERR(0, 46, __pyx_L1_error)
+  __pyx_v_ret = __pyx_t_1;
+  __pyx_t_1.memview = NULL;
+  __pyx_t_1.data = NULL;
+
+  /* "adaXT/decision_tree/splitter.pyx":47
+ *         int n_obs = indices.shape[0]
+ *         int[::1] ret = indices.copy()
+ *     qsort(&ret[0], n_obs, sizeof(int), compare)             # <<<<<<<<<<<<<<
+ *     return ret
+ * 
+ */
+  __pyx_t_2 = 0;
+  qsort((&(*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_ret.data) + __pyx_t_2)) )))), __pyx_v_n_obs, (sizeof(int)), __pyx_f_5adaXT_13decision_tree_8splitter_compare);
+
+  /* "adaXT/decision_tree/splitter.pyx":48
+ *         int[::1] ret = indices.copy()
+ *     qsort(&ret[0], n_obs, sizeof(int), compare)
+ *     return ret             # <<<<<<<<<<<<<<
+ * 
+ * 
+ */
+  __PYX_INC_MEMVIEW(&__pyx_v_ret, 1);
+  __pyx_r = __pyx_v_ret;
+  goto __pyx_L0;
+
+  /* "adaXT/decision_tree/splitter.pyx":27
+ *         return -1
+ * 
+ * cdef int[::1] sort_feature(int[::1] indices):             # <<<<<<<<<<<<<<
  *     """
+ *     Function to sort an array at given indices.
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_1, 1);
+  __pyx_r.data = NULL;
+  __pyx_r.memview = NULL;
+  __Pyx_AddTraceback("adaXT.decision_tree.splitter.sort_feature", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  goto __pyx_L2;
+  __pyx_L0:;
+  if (unlikely(!__pyx_r.memview)) {
+    PyErr_SetString(PyExc_TypeError, "Memoryview return value is not initialized");
+  }
+  __pyx_L2:;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_ret, 1);
+  return __pyx_r;
+}
+
+/* "adaXT/decision_tree/splitter.pyx":52
+ * 
+ * cdef class Splitter:
  *     def __init__(self, double[:, ::1] X, double[::1] Y, criteria: Criteria):             # <<<<<<<<<<<<<<
- *         '''
- *         Class initializer
+ *         self.features = X
+ *         self.response = Y
  */
 
 /* Python wrapper */
 static int __pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-PyDoc_STRVAR(__pyx_doc_5adaXT_13decision_tree_8splitter_8Splitter___init__, "\n        Class initializer\n        ----------------\n        Parameters\n        ----------\n            x: memoryview of NDArray\n                The feature values of the dataset\n            y: memoryview of NDArray\n                The response values of the dataset\n            criteria: Criteria\n                The criteria class used to find the impurity of a split\n        ");
-#if CYTHON_UPDATE_DESCRIPTOR_DOC
-struct wrapperbase __pyx_wrapperbase_5adaXT_13decision_tree_8splitter_8Splitter___init__;
-#endif
 static int __pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   __Pyx_memviewslice __pyx_v_X = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_Y = { 0, 0, { 0 }, { 0 }, { 0 } };
   struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *__pyx_v_criteria = 0;
   CYTHON_UNUSED Py_ssize_t __pyx_nargs;
   CYTHON_UNUSED PyObject *const *__pyx_kwvalues;
   PyObject* values[3] = {0,0,0};
@@ -19421,55 +19611,55 @@
       kw_args = __Pyx_NumKwargs_VARARGS(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_X)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 20, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 52, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_Y)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 20, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 52, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 1); __PYX_ERR(0, 20, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 1); __PYX_ERR(0, 52, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_GetKwValue_VARARGS(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_criteria)) != 0)) {
           (void)__Pyx_Arg_NewRef_VARARGS(values[2]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 20, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 52, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 2); __PYX_ERR(0, 20, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, 2); __PYX_ERR(0, 52, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 20, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "__init__") < 0)) __PYX_ERR(0, 52, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 3)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_VARARGS(__pyx_args, 0);
       values[1] = __Pyx_Arg_VARARGS(__pyx_args, 1);
       values[2] = __Pyx_Arg_VARARGS(__pyx_args, 2);
     }
-    __pyx_v_X = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_X.memview)) __PYX_ERR(0, 20, __pyx_L3_error)
-    __pyx_v_Y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_Y.memview)) __PYX_ERR(0, 20, __pyx_L3_error)
+    __pyx_v_X = __Pyx_PyObject_to_MemoryviewSlice_d_dc_double(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_X.memview)) __PYX_ERR(0, 52, __pyx_L3_error)
+    __pyx_v_Y = __Pyx_PyObject_to_MemoryviewSlice_dc_double(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_Y.memview)) __PYX_ERR(0, 52, __pyx_L3_error)
     __pyx_v_criteria = ((struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria *)values[2]);
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 20, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 3, 3, __pyx_nargs); __PYX_ERR(0, 52, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_VARARGS(values[__pyx_temp]);
@@ -19477,15 +19667,15 @@
   }
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_X, 1);
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_Y, 1);
   __Pyx_AddTraceback("adaXT.decision_tree.splitter.Splitter.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_criteria), __pyx_ptype_5adaXT_8criteria_8criteria_Criteria, 0, "criteria", 0))) __PYX_ERR(0, 20, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_criteria), __pyx_ptype_5adaXT_8criteria_8criteria_Criteria, 0, "criteria", 0))) __PYX_ERR(0, 52, __pyx_L1_error)
   __pyx_r = __pyx_pf_5adaXT_13decision_tree_8splitter_8Splitter___init__(((struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter *)__pyx_v_self), __pyx_v_X, __pyx_v_Y, __pyx_v_criteria);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = -1;
   __pyx_L0:;
@@ -19511,71 +19701,71 @@
   int __pyx_t_5;
   Py_ssize_t __pyx_t_6;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 1);
 
-  /* "adaXT/decision_tree/splitter.pyx":33
- *                 The criteria class used to find the impurity of a split
- *         '''
+  /* "adaXT/decision_tree/splitter.pyx":53
+ * cdef class Splitter:
+ *     def __init__(self, double[:, ::1] X, double[::1] Y, criteria: Criteria):
  *         self.features = X             # <<<<<<<<<<<<<<
  *         self.response = Y
  *         self.n_features = X.shape[1]
  */
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->features, 0);
   __PYX_INC_MEMVIEW(&__pyx_v_X, 1);
   __pyx_v_self->features = __pyx_v_X;
 
-  /* "adaXT/decision_tree/splitter.pyx":34
- *         '''
+  /* "adaXT/decision_tree/splitter.pyx":54
+ *     def __init__(self, double[:, ::1] X, double[::1] Y, criteria: Criteria):
  *         self.features = X
  *         self.response = Y             # <<<<<<<<<<<<<<
  *         self.n_features = X.shape[1]
  *         self.criteria = criteria
  */
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->response, 0);
   __PYX_INC_MEMVIEW(&__pyx_v_Y, 1);
   __pyx_v_self->response = __pyx_v_Y;
 
-  /* "adaXT/decision_tree/splitter.pyx":35
+  /* "adaXT/decision_tree/splitter.pyx":55
  *         self.features = X
  *         self.response = Y
  *         self.n_features = X.shape[1]             # <<<<<<<<<<<<<<
  *         self.criteria = criteria
  *         self.n_class = len(np.unique(Y))
  */
   __pyx_v_self->n_features = (__pyx_v_X.shape[1]);
 
-  /* "adaXT/decision_tree/splitter.pyx":36
+  /* "adaXT/decision_tree/splitter.pyx":56
  *         self.response = Y
  *         self.n_features = X.shape[1]
  *         self.criteria = criteria             # <<<<<<<<<<<<<<
  *         self.n_class = len(np.unique(Y))
  * 
  */
   __Pyx_INCREF((PyObject *)__pyx_v_criteria);
   __Pyx_GIVEREF((PyObject *)__pyx_v_criteria);
   __Pyx_GOTREF((PyObject *)__pyx_v_self->criteria);
   __Pyx_DECREF((PyObject *)__pyx_v_self->criteria);
   __pyx_v_self->criteria = __pyx_v_criteria;
 
-  /* "adaXT/decision_tree/splitter.pyx":37
+  /* "adaXT/decision_tree/splitter.pyx":57
  *         self.n_features = X.shape[1]
  *         self.criteria = criteria
  *         self.n_class = len(np.unique(Y))             # <<<<<<<<<<<<<<
  * 
- *     cdef cnp.ndarray sort_feature(self, int[:] indices, double[:] feature):
+ *     cpdef get_split(self, int[::1] indices, int[::1] feature_indices):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 37, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 57, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 37, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 57, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 37, __pyx_L1_error)
+  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_Y, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 57, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   #if CYTHON_UNPACK_METHODS
   if (unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
@@ -19588,28 +19778,28 @@
   }
   #endif
   {
     PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_t_2};
     __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 37, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 57, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   }
-  __pyx_t_6 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 37, __pyx_L1_error)
+  __pyx_t_6 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 57, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_self->n_class = __pyx_t_6;
 
-  /* "adaXT/decision_tree/splitter.pyx":20
- *     Splitter class used to create splits of the data
- *     """
+  /* "adaXT/decision_tree/splitter.pyx":52
+ * 
+ * cdef class Splitter:
  *     def __init__(self, double[:, ::1] X, double[::1] Y, criteria: Criteria):             # <<<<<<<<<<<<<<
- *         '''
- *         Class initializer
+ *         self.features = X
+ *         self.response = Y
  */
 
   /* function exit code */
   __pyx_r = 0;
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
@@ -19619,369 +19809,92 @@
   __Pyx_AddTraceback("adaXT.decision_tree.splitter.Splitter.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "adaXT/decision_tree/splitter.pyx":39
- *         self.n_class = len(np.unique(Y))
- * 
- *     cdef cnp.ndarray sort_feature(self, int[:] indices, double[:] feature):             # <<<<<<<<<<<<<<
- *         """
- *         Function to sort an array at given indices.
- */
-
-static PyArrayObject *__pyx_f_5adaXT_13decision_tree_8splitter_8Splitter_sort_feature(CYTHON_UNUSED struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, __Pyx_memviewslice __pyx_v_feature) {
-  PyArrayObject *__pyx_v_feat_temp = 0;
-  PyArrayObject *__pyx_v_idx = 0;
-  PyArrayObject *__pyx_v_temp = 0;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_feat_temp;
-  __Pyx_Buffer __pyx_pybuffer_feat_temp;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_idx;
-  __Pyx_Buffer __pyx_pybuffer_idx;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_temp;
-  __Pyx_Buffer __pyx_pybuffer_temp;
-  PyArrayObject *__pyx_r = NULL;
-  __Pyx_RefNannyDeclarations
-  PyObject *__pyx_t_1 = NULL;
-  PyObject *__pyx_t_2 = NULL;
-  PyObject *__pyx_t_3 = NULL;
-  PyObject *__pyx_t_4 = NULL;
-  int __pyx_t_5;
-  PyArrayObject *__pyx_t_6 = NULL;
-  PyArrayObject *__pyx_t_7 = NULL;
-  PyArrayObject *__pyx_t_8 = NULL;
-  PyObject *__pyx_t_9 = NULL;
-  PyObject *__pyx_t_10 = NULL;
-  PyObject *__pyx_t_11 = NULL;
-  int __pyx_lineno = 0;
-  const char *__pyx_filename = NULL;
-  int __pyx_clineno = 0;
-  __Pyx_RefNannySetupContext("sort_feature", 1);
-  __pyx_pybuffer_feat_temp.pybuffer.buf = NULL;
-  __pyx_pybuffer_feat_temp.refcount = 0;
-  __pyx_pybuffernd_feat_temp.data = NULL;
-  __pyx_pybuffernd_feat_temp.rcbuffer = &__pyx_pybuffer_feat_temp;
-  __pyx_pybuffer_idx.pybuffer.buf = NULL;
-  __pyx_pybuffer_idx.refcount = 0;
-  __pyx_pybuffernd_idx.data = NULL;
-  __pyx_pybuffernd_idx.rcbuffer = &__pyx_pybuffer_idx;
-  __pyx_pybuffer_temp.pybuffer.buf = NULL;
-  __pyx_pybuffer_temp.refcount = 0;
-  __pyx_pybuffernd_temp.data = NULL;
-  __pyx_pybuffernd_temp.rcbuffer = &__pyx_pybuffer_temp;
-
-  /* "adaXT/decision_tree/splitter.pyx":58
- * 
- *         cdef:
- *             cnp.ndarray[double, ndim=1] feat_temp = np.asarray(feature)             # <<<<<<<<<<<<<<
- *             cnp.ndarray[int, ndim=1] idx = np.asarray(indices)
- *             cnp.ndarray[long long, ndim=1] temp
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 58, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_asarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 58, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __pyx_memoryview_fromslice(__pyx_v_feature, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 58, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = NULL;
-  __pyx_t_5 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_5 = 1;
-    }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_t_2};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 58, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  }
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 58, __pyx_L1_error)
-  __pyx_t_6 = ((PyArrayObject *)__pyx_t_1);
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_feat_temp.rcbuffer->pybuffer, (PyObject*)__pyx_t_6, &__Pyx_TypeInfo_double, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-      __pyx_v_feat_temp = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_feat_temp.rcbuffer->pybuffer.buf = NULL;
-      __PYX_ERR(0, 58, __pyx_L1_error)
-    } else {__pyx_pybuffernd_feat_temp.diminfo[0].strides = __pyx_pybuffernd_feat_temp.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_feat_temp.diminfo[0].shape = __pyx_pybuffernd_feat_temp.rcbuffer->pybuffer.shape[0];
-    }
-  }
-  __pyx_t_6 = 0;
-  __pyx_v_feat_temp = ((PyArrayObject *)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "adaXT/decision_tree/splitter.pyx":59
- *         cdef:
- *             cnp.ndarray[double, ndim=1] feat_temp = np.asarray(feature)
- *             cnp.ndarray[int, ndim=1] idx = np.asarray(indices)             # <<<<<<<<<<<<<<
- *             cnp.ndarray[long long, ndim=1] temp
- *         temp = np.argsort(feat_temp[idx])
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 59, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_asarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 59, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 59, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = NULL;
-  __pyx_t_5 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_2))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
-      __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_2, function);
-      __pyx_t_5 = 1;
-    }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_2, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 59, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  }
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 59, __pyx_L1_error)
-  __pyx_t_7 = ((PyArrayObject *)__pyx_t_1);
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_idx.rcbuffer->pybuffer, (PyObject*)__pyx_t_7, &__Pyx_TypeInfo_int, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-      __pyx_v_idx = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_pybuffernd_idx.rcbuffer->pybuffer.buf = NULL;
-      __PYX_ERR(0, 59, __pyx_L1_error)
-    } else {__pyx_pybuffernd_idx.diminfo[0].strides = __pyx_pybuffernd_idx.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_idx.diminfo[0].shape = __pyx_pybuffernd_idx.rcbuffer->pybuffer.shape[0];
-    }
-  }
-  __pyx_t_7 = 0;
-  __pyx_v_idx = ((PyArrayObject *)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "adaXT/decision_tree/splitter.pyx":61
- *             cnp.ndarray[int, ndim=1] idx = np.asarray(indices)
- *             cnp.ndarray[long long, ndim=1] temp
- *         temp = np.argsort(feat_temp[idx])             # <<<<<<<<<<<<<<
- *         return idx[temp]
- * 
- */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 61, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_argsort); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 61, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  __pyx_t_2 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_feat_temp), ((PyObject *)__pyx_v_idx)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 61, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = NULL;
-  __pyx_t_5 = 0;
-  #if CYTHON_UNPACK_METHODS
-  if (unlikely(PyMethod_Check(__pyx_t_3))) {
-    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
-    if (likely(__pyx_t_4)) {
-      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
-      __Pyx_INCREF(__pyx_t_4);
-      __Pyx_INCREF(function);
-      __Pyx_DECREF_SET(__pyx_t_3, function);
-      __pyx_t_5 = 1;
-    }
-  }
-  #endif
-  {
-    PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_t_2};
-    __pyx_t_1 = __Pyx_PyObject_FastCall(__pyx_t_3, __pyx_callargs+1-__pyx_t_5, 1+__pyx_t_5);
-    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 61, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  }
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 61, __pyx_L1_error)
-  __pyx_t_8 = ((PyArrayObject *)__pyx_t_1);
-  {
-    __Pyx_BufFmt_StackElem __pyx_stack[1];
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_temp.rcbuffer->pybuffer);
-    __pyx_t_5 = __Pyx_GetBufferAndValidate(&__pyx_pybuffernd_temp.rcbuffer->pybuffer, (PyObject*)__pyx_t_8, &__Pyx_TypeInfo_PY_LONG_LONG, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
-    if (unlikely(__pyx_t_5 < 0)) {
-      PyErr_Fetch(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
-      if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_temp.rcbuffer->pybuffer, (PyObject*)__pyx_v_temp, &__Pyx_TypeInfo_PY_LONG_LONG, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-        Py_XDECREF(__pyx_t_9); Py_XDECREF(__pyx_t_10); Py_XDECREF(__pyx_t_11);
-        __Pyx_RaiseBufferFallbackError();
-      } else {
-        PyErr_Restore(__pyx_t_9, __pyx_t_10, __pyx_t_11);
-      }
-      __pyx_t_9 = __pyx_t_10 = __pyx_t_11 = 0;
-    }
-    __pyx_pybuffernd_temp.diminfo[0].strides = __pyx_pybuffernd_temp.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_temp.diminfo[0].shape = __pyx_pybuffernd_temp.rcbuffer->pybuffer.shape[0];
-    if (unlikely((__pyx_t_5 < 0))) __PYX_ERR(0, 61, __pyx_L1_error)
-  }
-  __pyx_t_8 = 0;
-  __pyx_v_temp = ((PyArrayObject *)__pyx_t_1);
-  __pyx_t_1 = 0;
-
-  /* "adaXT/decision_tree/splitter.pyx":62
- *             cnp.ndarray[long long, ndim=1] temp
- *         temp = np.argsort(feat_temp[idx])
- *         return idx[temp]             # <<<<<<<<<<<<<<
- * 
- *     cpdef get_split(self, int[:] indices, int[:] feature_indices):
- */
-  __Pyx_XDECREF((PyObject *)__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetItem(((PyObject *)__pyx_v_idx), ((PyObject *)__pyx_v_temp)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 62, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))))) __PYX_ERR(0, 62, __pyx_L1_error)
-  __pyx_r = ((PyArrayObject *)__pyx_t_1);
-  __pyx_t_1 = 0;
-  goto __pyx_L0;
-
-  /* "adaXT/decision_tree/splitter.pyx":39
+/* "adaXT/decision_tree/splitter.pyx":59
  *         self.n_class = len(np.unique(Y))
  * 
- *     cdef cnp.ndarray sort_feature(self, int[:] indices, double[:] feature):             # <<<<<<<<<<<<<<
- *         """
- *         Function to sort an array at given indices.
- */
-
-  /* function exit code */
-  __pyx_L1_error:;
-  __Pyx_XDECREF(__pyx_t_1);
-  __Pyx_XDECREF(__pyx_t_2);
-  __Pyx_XDECREF(__pyx_t_3);
-  __Pyx_XDECREF(__pyx_t_4);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_feat_temp.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_idx.rcbuffer->pybuffer);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_temp.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
-  __Pyx_AddTraceback("adaXT.decision_tree.splitter.Splitter.sort_feature", __pyx_clineno, __pyx_lineno, __pyx_filename);
-  __pyx_r = 0;
-  goto __pyx_L2;
-  __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_feat_temp.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_idx.rcbuffer->pybuffer);
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_temp.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __Pyx_XDECREF((PyObject *)__pyx_v_feat_temp);
-  __Pyx_XDECREF((PyObject *)__pyx_v_idx);
-  __Pyx_XDECREF((PyObject *)__pyx_v_temp);
-  __Pyx_XGIVEREF((PyObject *)__pyx_r);
-  __Pyx_RefNannyFinishContext();
-  return __pyx_r;
-}
-
-/* "adaXT/decision_tree/splitter.pyx":64
- *         return idx[temp]
- * 
- *     cpdef get_split(self, int[:] indices, int[:] feature_indices):             # <<<<<<<<<<<<<<
- *         """
- *         Function that finds the best split of the dataset
+ *     cpdef get_split(self, int[::1] indices, int[::1] feature_indices):             # <<<<<<<<<<<<<<
+ *         global current_feature_values
+ *         self.indices = indices
  */
 
 static PyObject *__pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_3get_split(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
 static PyObject *__pyx_f_5adaXT_13decision_tree_8splitter_8Splitter_get_split(struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter *__pyx_v_self, __Pyx_memviewslice __pyx_v_indices, __Pyx_memviewslice __pyx_v_feature_indices, int __pyx_skip_dispatch) {
   int __pyx_v_N_i;
   double __pyx_v_best_threshold;
   double __pyx_v_best_score;
   int __pyx_v_best_feature;
-  __Pyx_memviewslice __pyx_v_current_feature_values = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_v_i;
   int __pyx_v_feature;
-  PyArrayObject *__pyx_v_sorted_index_list_feature = 0;
+  __Pyx_memviewslice __pyx_v_sorted_index_list_feature = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_v_best_sorted = { 0, 0, { 0 }, { 0 }, { 0 } };
   int __pyx_v_best_split_idx;
-  double __pyx_v_best_left_imp;
-  double __pyx_v_best_right_imp;
   double __pyx_v_crit;
-  PyObject *__pyx_v_features = NULL;
   PyObject *__pyx_v_split = NULL;
   PyObject *__pyx_v_best_imp = NULL;
-  double __pyx_v_left_imp;
-  double __pyx_v_right_imp;
   double __pyx_v_threshold;
-  __Pyx_LocalBuf_ND __pyx_pybuffernd_sorted_index_list_feature;
-  __Pyx_Buffer __pyx_pybuffer_sorted_index_list_feature;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   PyObject *__pyx_t_5 = NULL;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_t_7;
-  double __pyx_t_8;
-  double __pyx_t_9;
-  __Pyx_memviewslice __pyx_t_10 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_t_8 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  Py_ssize_t __pyx_t_9;
+  Py_ssize_t __pyx_t_10;
   Py_ssize_t __pyx_t_11;
   Py_ssize_t __pyx_t_12;
-  Py_ssize_t __pyx_t_13;
-  Py_ssize_t __pyx_t_14;
+  __Pyx_memviewslice __pyx_t_13 = { 0, 0, { 0 }, { 0 }, { 0 } };
+  __Pyx_memviewslice __pyx_t_14 = { 0, 0, { 0 }, { 0 }, { 0 } };
   __Pyx_memviewslice __pyx_t_15 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  PyObject *__pyx_t_16 = NULL;
-  PyObject *__pyx_t_17 = NULL;
-  PyObject *__pyx_t_18 = NULL;
-  int __pyx_t_19;
-  int __pyx_t_20;
+  int __pyx_t_16;
+  int __pyx_t_17;
+  Py_ssize_t __pyx_t_18;
+  Py_ssize_t __pyx_t_19;
+  Py_ssize_t __pyx_t_20;
   Py_ssize_t __pyx_t_21;
   Py_ssize_t __pyx_t_22;
-  Py_ssize_t __pyx_t_23;
-  int __pyx_t_24;
-  __Pyx_memviewslice __pyx_t_25 = { 0, 0, { 0 }, { 0 }, { 0 } };
-  __pyx_ctuple_double__and_double__and_double__and_double __pyx_t_26;
-  double __pyx_t_27;
-  double __pyx_t_28;
-  int __pyx_t_29;
+  int __pyx_t_23;
+  __pyx_ctuple_double__and_double __pyx_t_24;
+  double __pyx_t_25;
+  double __pyx_t_26;
+  int __pyx_t_27;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_split", 1);
-  __pyx_pybuffer_sorted_index_list_feature.pybuffer.buf = NULL;
-  __pyx_pybuffer_sorted_index_list_feature.refcount = 0;
-  __pyx_pybuffernd_sorted_index_list_feature.data = NULL;
-  __pyx_pybuffernd_sorted_index_list_feature.rcbuffer = &__pyx_pybuffer_sorted_index_list_feature;
   /* Check if called by wrapper */
   if (unlikely(__pyx_skip_dispatch)) ;
   /* Check if overridden in Python */
   else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || __Pyx_PyType_HasFeature(Py_TYPE(((PyObject *)__pyx_v_self)), (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {
     #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;
     if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {
       PY_UINT64_T __pyx_typedict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));
       #endif
-      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_get_split); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
+      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_get_split); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 59, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_1);
       if (!__Pyx_IsSameCFunction(__pyx_t_1, (void*) __pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_3get_split)) {
         __Pyx_XDECREF(__pyx_r);
-        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 64, __pyx_L1_error)
+        __pyx_t_3 = __pyx_memoryview_fromslice(__pyx_v_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 59, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_3);
-        __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_feature_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 64, __pyx_L1_error)
+        __pyx_t_4 = __pyx_memoryview_fromslice(__pyx_v_feature_indices, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 59, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_4);
         __Pyx_INCREF(__pyx_t_1);
         __pyx_t_5 = __pyx_t_1; __pyx_t_6 = NULL;
         __pyx_t_7 = 0;
         #if CYTHON_UNPACK_METHODS
         if (unlikely(PyMethod_Check(__pyx_t_5))) {
           __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
@@ -19996,15 +19909,15 @@
         #endif
         {
           PyObject *__pyx_callargs[3] = {__pyx_t_6, __pyx_t_3, __pyx_t_4};
           __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_7, 2+__pyx_t_7);
           __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-          if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 64, __pyx_L1_error)
+          if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 59, __pyx_L1_error)
           __Pyx_GOTREF(__pyx_t_2);
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
         }
         __pyx_r = __pyx_t_2;
         __pyx_t_2 = 0;
         __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
         goto __pyx_L0;
@@ -20018,558 +19931,513 @@
       #endif
       __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
       #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
     }
     #endif
   }
 
-  /* "adaXT/decision_tree/splitter.pyx":82
- *             (4) the best criteria score, and (5) the best impurity
- *         """
+  /* "adaXT/decision_tree/splitter.pyx":61
+ *     cpdef get_split(self, int[::1] indices, int[::1] feature_indices):
+ *         global current_feature_values
  *         self.indices = indices             # <<<<<<<<<<<<<<
  *         self.n_indices = indices.shape[0]
  *         cdef:
  */
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_self->indices, 0);
   __PYX_INC_MEMVIEW(&__pyx_v_indices, 1);
   __pyx_v_self->indices = __pyx_v_indices;
 
-  /* "adaXT/decision_tree/splitter.pyx":83
- *         """
+  /* "adaXT/decision_tree/splitter.pyx":62
+ *         global current_feature_values
  *         self.indices = indices
  *         self.n_indices = indices.shape[0]             # <<<<<<<<<<<<<<
  *         cdef:
  *             # number of indices to loop over. Skips last
  */
   __pyx_v_self->n_indices = (__pyx_v_indices.shape[0]);
 
-  /* "adaXT/decision_tree/splitter.pyx":86
+  /* "adaXT/decision_tree/splitter.pyx":65
  *         cdef:
  *             # number of indices to loop over. Skips last
  *             int N_i = self.n_indices - 1             # <<<<<<<<<<<<<<
  *             double best_threshold = INFINITY
  *             double best_score = INFINITY
  */
   __pyx_v_N_i = (__pyx_v_self->n_indices - 1);
 
-  /* "adaXT/decision_tree/splitter.pyx":87
+  /* "adaXT/decision_tree/splitter.pyx":66
  *             # number of indices to loop over. Skips last
  *             int N_i = self.n_indices - 1
  *             double best_threshold = INFINITY             # <<<<<<<<<<<<<<
  *             double best_score = INFINITY
  *             int best_feature = 0
  */
   __pyx_v_best_threshold = __pyx_v_5adaXT_13decision_tree_8splitter_INFINITY;
 
-  /* "adaXT/decision_tree/splitter.pyx":88
+  /* "adaXT/decision_tree/splitter.pyx":67
  *             int N_i = self.n_indices - 1
  *             double best_threshold = INFINITY
  *             double best_score = INFINITY             # <<<<<<<<<<<<<<
  *             int best_feature = 0
- *             double[:] current_feature_values
+ *             int i, feature  # variables for loop
  */
   __pyx_v_best_score = __pyx_v_5adaXT_13decision_tree_8splitter_INFINITY;
 
-  /* "adaXT/decision_tree/splitter.pyx":89
+  /* "adaXT/decision_tree/splitter.pyx":68
  *             double best_threshold = INFINITY
  *             double best_score = INFINITY
  *             int best_feature = 0             # <<<<<<<<<<<<<<
- *             double[:] current_feature_values
  *             int i, feature  # variables for loop
+ *             int[::1] sorted_index_list_feature
  */
   __pyx_v_best_feature = 0;
 
-  /* "adaXT/decision_tree/splitter.pyx":98
+  /* "adaXT/decision_tree/splitter.pyx":75
  *             double crit
  * 
- *         features = self.features.base             # <<<<<<<<<<<<<<
- *         split, best_imp = [], []
- *         best_right_imp, best_left_imp = 0.0, 0.0
- */
-  __pyx_t_1 = __pyx_memoryview_fromslice(__pyx_v_self->features, 2, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 98, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_base); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 98, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_v_features = __pyx_t_2;
-  __pyx_t_2 = 0;
-
-  /* "adaXT/decision_tree/splitter.pyx":99
- * 
- *         features = self.features.base
  *         split, best_imp = [], []             # <<<<<<<<<<<<<<
- *         best_right_imp, best_left_imp = 0.0, 0.0
  *         best_split_idx = -1
+ *         best_sorted = None
  */
-  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 99, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_v_split = ((PyObject*)__pyx_t_2);
-  __pyx_t_2 = 0;
-  __pyx_v_best_imp = ((PyObject*)__pyx_t_1);
+  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_v_split = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
+  __pyx_v_best_imp = ((PyObject*)__pyx_t_2);
+  __pyx_t_2 = 0;
 
-  /* "adaXT/decision_tree/splitter.pyx":100
- *         features = self.features.base
- *         split, best_imp = [], []
- *         best_right_imp, best_left_imp = 0.0, 0.0             # <<<<<<<<<<<<<<
- *         best_split_idx = -1
- *         best_sorted = None
- */
-  __pyx_t_8 = 0.0;
-  __pyx_t_9 = 0.0;
-  __pyx_v_best_right_imp = __pyx_t_8;
-  __pyx_v_best_left_imp = __pyx_t_9;
-
-  /* "adaXT/decision_tree/splitter.pyx":101
+  /* "adaXT/decision_tree/splitter.pyx":76
+ * 
  *         split, best_imp = [], []
- *         best_right_imp, best_left_imp = 0.0, 0.0
  *         best_split_idx = -1             # <<<<<<<<<<<<<<
  *         best_sorted = None
  *         # For all features
  */
   __pyx_v_best_split_idx = -1;
 
-  /* "adaXT/decision_tree/splitter.pyx":102
- *         best_right_imp, best_left_imp = 0.0, 0.0
+  /* "adaXT/decision_tree/splitter.pyx":77
+ *         split, best_imp = [], []
  *         best_split_idx = -1
  *         best_sorted = None             # <<<<<<<<<<<<<<
  *         # For all features
  *         for feature in feature_indices:
  */
-  __pyx_t_10 = __Pyx_PyObject_to_MemoryviewSlice_ds_int(Py_None, PyBUF_WRITABLE); if (unlikely(!__pyx_t_10.memview)) __PYX_ERR(0, 102, __pyx_L1_error)
-  __pyx_v_best_sorted = __pyx_t_10;
-  __pyx_t_10.memview = NULL;
-  __pyx_t_10.data = NULL;
+  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_dc_int(Py_None, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 77, __pyx_L1_error)
+  __pyx_v_best_sorted = __pyx_t_8;
+  __pyx_t_8.memview = NULL;
+  __pyx_t_8.data = NULL;
 
-  /* "adaXT/decision_tree/splitter.pyx":104
+  /* "adaXT/decision_tree/splitter.pyx":79
  *         best_sorted = None
  *         # For all features
  *         for feature in feature_indices:             # <<<<<<<<<<<<<<
- *             current_feature_values = features[:, feature]
- *             sorted_index_list_feature = self.sort_feature(
+ *             current_feature_values = np.asarray(self.features[:, feature])
+ *             sorted_index_list_feature = sort_feature(indices)
  */
   if (unlikely(((PyObject *) __pyx_v_feature_indices.memview) == Py_None)) {
     PyErr_SetString(PyExc_TypeError, "'NoneType' is not iterable");
-    __PYX_ERR(0, 104, __pyx_L1_error)
+    __PYX_ERR(0, 79, __pyx_L1_error)
   }
   __PYX_INC_MEMVIEW(&__pyx_v_feature_indices, 1);
-  __pyx_t_10 = __pyx_v_feature_indices;
-  __pyx_t_11 = __Pyx_MemoryView_Len(__pyx_t_10); 
-  for (__pyx_t_13 = 0; __pyx_t_13 < __pyx_t_11; __pyx_t_13++) {
-    __pyx_t_12 = __pyx_t_13;
-    __pyx_t_14 = __pyx_t_12;
-    __pyx_v_feature = (*((int *) ( /* dim=0 */ (__pyx_t_10.data + __pyx_t_14 * __pyx_t_10.strides[0]) )));
+  __pyx_t_8 = __pyx_v_feature_indices;
+  __pyx_t_9 = __Pyx_MemoryView_Len(__pyx_t_8); 
+  for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_9; __pyx_t_11++) {
+    __pyx_t_10 = __pyx_t_11;
+    __pyx_t_12 = __pyx_t_10;
+    __pyx_v_feature = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_t_8.data) + __pyx_t_12)) )));
 
-    /* "adaXT/decision_tree/splitter.pyx":105
+    /* "adaXT/decision_tree/splitter.pyx":80
  *         # For all features
  *         for feature in feature_indices:
- *             current_feature_values = features[:, feature]             # <<<<<<<<<<<<<<
- *             sorted_index_list_feature = self.sort_feature(
- *                     indices, current_feature_values
+ *             current_feature_values = np.asarray(self.features[:, feature])             # <<<<<<<<<<<<<<
+ *             sorted_index_list_feature = sort_feature(indices)
+ * 
  */
-    __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_feature); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 105, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 105, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __Pyx_INCREF(__pyx_slice__5);
-    __Pyx_GIVEREF(__pyx_slice__5);
-    if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_slice__5)) __PYX_ERR(0, 105, __pyx_L1_error);
-    __Pyx_GIVEREF(__pyx_t_1);
-    if (__Pyx_PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_1)) __PYX_ERR(0, 105, __pyx_L1_error);
-    __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_features, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 105, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 80, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_15 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_t_1, PyBUF_WRITABLE); if (unlikely(!__pyx_t_15.memview)) __PYX_ERR(0, 105, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 80, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __PYX_XCLEAR_MEMVIEW(&__pyx_v_current_feature_values, 1);
-    __pyx_v_current_feature_values = __pyx_t_15;
-    __pyx_t_15.memview = NULL;
-    __pyx_t_15.data = NULL;
+    __pyx_t_13.data = __pyx_v_self->features.data;
+    __pyx_t_13.memview = __pyx_v_self->features.memview;
+    __PYX_INC_MEMVIEW(&__pyx_t_13, 1);
+    __pyx_t_13.shape[0] = __pyx_v_self->features.shape[0];
+__pyx_t_13.strides[0] = __pyx_v_self->features.strides[0];
+    __pyx_t_13.suboffsets[0] = -1;
 
-    /* "adaXT/decision_tree/splitter.pyx":106
- *         for feature in feature_indices:
- *             current_feature_values = features[:, feature]
- *             sorted_index_list_feature = self.sort_feature(             # <<<<<<<<<<<<<<
- *                     indices, current_feature_values
- *                     )
- */
-    __pyx_t_1 = ((PyObject *)((struct __pyx_vtabstruct_5adaXT_13decision_tree_8splitter_Splitter *)__pyx_v_self->__pyx_vtab)->sort_feature(__pyx_v_self, __pyx_v_indices, __pyx_v_current_feature_values)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 106, __pyx_L1_error)
+{
+    Py_ssize_t __pyx_tmp_idx = __pyx_v_feature;
+    Py_ssize_t __pyx_tmp_stride = __pyx_v_self->features.strides[1];
+        __pyx_t_13.data += __pyx_tmp_idx * __pyx_tmp_stride;
+}
+
+__pyx_t_1 = __pyx_memoryview_fromslice(__pyx_t_13, 1, (PyObject *(*)(char *)) __pyx_memview_get_double, (int (*)(char *, PyObject *)) __pyx_memview_set_double, 0);; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 80, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    {
-      __Pyx_BufFmt_StackElem __pyx_stack[1];
-      __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_sorted_index_list_feature.rcbuffer->pybuffer);
-      __pyx_t_7 = __Pyx_GetBufferAndValidate(&__pyx_pybuffernd_sorted_index_list_feature.rcbuffer->pybuffer, (PyObject*)((PyArrayObject *)__pyx_t_1), &__Pyx_TypeInfo_int, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
-      if (unlikely(__pyx_t_7 < 0)) {
-        PyErr_Fetch(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18);
-        if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_pybuffernd_sorted_index_list_feature.rcbuffer->pybuffer, (PyObject*)__pyx_v_sorted_index_list_feature, &__Pyx_TypeInfo_int, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
-          Py_XDECREF(__pyx_t_16); Py_XDECREF(__pyx_t_17); Py_XDECREF(__pyx_t_18);
-          __Pyx_RaiseBufferFallbackError();
-        } else {
-          PyErr_Restore(__pyx_t_16, __pyx_t_17, __pyx_t_18);
-        }
-        __pyx_t_16 = __pyx_t_17 = __pyx_t_18 = 0;
+    __PYX_XCLEAR_MEMVIEW(&__pyx_t_13, 1);
+    __pyx_t_13.memview = NULL; __pyx_t_13.data = NULL;
+    __pyx_t_4 = NULL;
+    __pyx_t_7 = 0;
+    #if CYTHON_UNPACK_METHODS
+    if (unlikely(PyMethod_Check(__pyx_t_5))) {
+      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
+      if (likely(__pyx_t_4)) {
+        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
+        __Pyx_INCREF(__pyx_t_4);
+        __Pyx_INCREF(function);
+        __Pyx_DECREF_SET(__pyx_t_5, function);
+        __pyx_t_7 = 1;
       }
-      __pyx_pybuffernd_sorted_index_list_feature.diminfo[0].strides = __pyx_pybuffernd_sorted_index_list_feature.rcbuffer->pybuffer.strides[0]; __pyx_pybuffernd_sorted_index_list_feature.diminfo[0].shape = __pyx_pybuffernd_sorted_index_list_feature.rcbuffer->pybuffer.shape[0];
-      if (unlikely((__pyx_t_7 < 0))) __PYX_ERR(0, 106, __pyx_L1_error)
     }
-    __Pyx_XDECREF_SET(__pyx_v_sorted_index_list_feature, ((PyArrayObject *)__pyx_t_1));
-    __pyx_t_1 = 0;
+    #endif
+    {
+      PyObject *__pyx_callargs[2] = {__pyx_t_4, __pyx_t_1};
+      __pyx_t_2 = __Pyx_PyObject_FastCall(__pyx_t_5, __pyx_callargs+1-__pyx_t_7, 1+__pyx_t_7);
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 80, __pyx_L1_error)
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    }
+    __pyx_t_14 = __Pyx_PyObject_to_MemoryviewSlice_ds_double(__pyx_t_2, PyBUF_WRITABLE); if (unlikely(!__pyx_t_14.memview)) __PYX_ERR(0, 80, __pyx_L1_error)
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __PYX_XCLEAR_MEMVIEW(&__pyx_v_5adaXT_13decision_tree_8splitter_current_feature_values, 1);
+    __pyx_v_5adaXT_13decision_tree_8splitter_current_feature_values = __pyx_t_14;
+    __pyx_t_14.memview = NULL;
+    __pyx_t_14.data = NULL;
+
+    /* "adaXT/decision_tree/splitter.pyx":81
+ *         for feature in feature_indices:
+ *             current_feature_values = np.asarray(self.features[:, feature])
+ *             sorted_index_list_feature = sort_feature(indices)             # <<<<<<<<<<<<<<
+ * 
+ *             # Loop over sorted feature list
+ */
+    __pyx_t_15 = __pyx_f_5adaXT_13decision_tree_8splitter_sort_feature(__pyx_v_indices); if (unlikely(!__pyx_t_15.memview)) __PYX_ERR(0, 81, __pyx_L1_error)
+    __PYX_XCLEAR_MEMVIEW(&__pyx_v_sorted_index_list_feature, 1);
+    __pyx_v_sorted_index_list_feature = __pyx_t_15;
+    __pyx_t_15.memview = NULL;
+    __pyx_t_15.data = NULL;
 
-    /* "adaXT/decision_tree/splitter.pyx":111
+    /* "adaXT/decision_tree/splitter.pyx":84
  * 
  *             # Loop over sorted feature list
  *             for i in range(N_i):             # <<<<<<<<<<<<<<
  *                 # Skip one iteration of the loop if the current
  *                 # threshold value is the same as the next in the feature list
  */
     __pyx_t_7 = __pyx_v_N_i;
-    __pyx_t_19 = __pyx_t_7;
-    for (__pyx_t_20 = 0; __pyx_t_20 < __pyx_t_19; __pyx_t_20+=1) {
-      __pyx_v_i = __pyx_t_20;
+    __pyx_t_16 = __pyx_t_7;
+    for (__pyx_t_17 = 0; __pyx_t_17 < __pyx_t_16; __pyx_t_17+=1) {
+      __pyx_v_i = __pyx_t_17;
 
-      /* "adaXT/decision_tree/splitter.pyx":114
+      /* "adaXT/decision_tree/splitter.pyx":87
  *                 # Skip one iteration of the loop if the current
  *                 # threshold value is the same as the next in the feature list
- *                 if (current_feature_values[sorted_index_list_feature[i]] ==             # <<<<<<<<<<<<<<
- *                         current_feature_values[sorted_index_list_feature[i + 1]]):
+ *                 if (self.features[sorted_index_list_feature[i], feature] ==             # <<<<<<<<<<<<<<
+ *                         self.features[sorted_index_list_feature[i + 1], feature]):
  *                     continue
  */
-      __pyx_t_14 = __pyx_v_i;
-      __pyx_t_21 = (*__Pyx_BufPtrStrided1d(int *, __pyx_pybuffernd_sorted_index_list_feature.rcbuffer->pybuffer.buf, __pyx_t_14, __pyx_pybuffernd_sorted_index_list_feature.diminfo[0].strides));
+      __pyx_t_12 = __pyx_v_i;
+      __pyx_t_18 = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_sorted_index_list_feature.data) + __pyx_t_12)) )));
+      __pyx_t_19 = __pyx_v_feature;
 
-      /* "adaXT/decision_tree/splitter.pyx":115
+      /* "adaXT/decision_tree/splitter.pyx":88
  *                 # threshold value is the same as the next in the feature list
- *                 if (current_feature_values[sorted_index_list_feature[i]] ==
- *                         current_feature_values[sorted_index_list_feature[i + 1]]):             # <<<<<<<<<<<<<<
+ *                 if (self.features[sorted_index_list_feature[i], feature] ==
+ *                         self.features[sorted_index_list_feature[i + 1], feature]):             # <<<<<<<<<<<<<<
  *                     continue
  *                 # test the split
  */
-      __pyx_t_22 = (__pyx_v_i + 1);
-      __pyx_t_23 = (*__Pyx_BufPtrStrided1d(int *, __pyx_pybuffernd_sorted_index_list_feature.rcbuffer->pybuffer.buf, __pyx_t_22, __pyx_pybuffernd_sorted_index_list_feature.diminfo[0].strides));
+      __pyx_t_20 = (__pyx_v_i + 1);
+      __pyx_t_21 = (*((int *) ( /* dim=0 */ ((char *) (((int *) __pyx_v_sorted_index_list_feature.data) + __pyx_t_20)) )));
+      __pyx_t_22 = __pyx_v_feature;
 
-      /* "adaXT/decision_tree/splitter.pyx":114
+      /* "adaXT/decision_tree/splitter.pyx":87
  *                 # Skip one iteration of the loop if the current
  *                 # threshold value is the same as the next in the feature list
- *                 if (current_feature_values[sorted_index_list_feature[i]] ==             # <<<<<<<<<<<<<<
- *                         current_feature_values[sorted_index_list_feature[i + 1]]):
+ *                 if (self.features[sorted_index_list_feature[i], feature] ==             # <<<<<<<<<<<<<<
+ *                         self.features[sorted_index_list_feature[i + 1], feature]):
  *                     continue
  */
-      __pyx_t_24 = ((*((double *) ( /* dim=0 */ (__pyx_v_current_feature_values.data + __pyx_t_21 * __pyx_v_current_feature_values.strides[0]) ))) == (*((double *) ( /* dim=0 */ (__pyx_v_current_feature_values.data + __pyx_t_23 * __pyx_v_current_feature_values.strides[0]) ))));
-      if (__pyx_t_24) {
+      __pyx_t_23 = ((*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_self->features.data + __pyx_t_18 * __pyx_v_self->features.strides[0]) )) + __pyx_t_19)) ))) == (*((double *) ( /* dim=1 */ ((char *) (((double *) ( /* dim=0 */ (__pyx_v_self->features.data + __pyx_t_21 * __pyx_v_self->features.strides[0]) )) + __pyx_t_22)) ))));
+      if (__pyx_t_23) {
 
-        /* "adaXT/decision_tree/splitter.pyx":116
- *                 if (current_feature_values[sorted_index_list_feature[i]] ==
- *                         current_feature_values[sorted_index_list_feature[i + 1]]):
+        /* "adaXT/decision_tree/splitter.pyx":89
+ *                 if (self.features[sorted_index_list_feature[i], feature] ==
+ *                         self.features[sorted_index_list_feature[i + 1], feature]):
  *                     continue             # <<<<<<<<<<<<<<
  *                 # test the split
- *                 crit, left_imp, right_imp, threshold = self.criteria.evaluate_split(
+ *                 crit, threshold = self.criteria.evaluate_split(
  */
         goto __pyx_L5_continue;
 
-        /* "adaXT/decision_tree/splitter.pyx":114
+        /* "adaXT/decision_tree/splitter.pyx":87
  *                 # Skip one iteration of the loop if the current
  *                 # threshold value is the same as the next in the feature list
- *                 if (current_feature_values[sorted_index_list_feature[i]] ==             # <<<<<<<<<<<<<<
- *                         current_feature_values[sorted_index_list_feature[i + 1]]):
+ *                 if (self.features[sorted_index_list_feature[i], feature] ==             # <<<<<<<<<<<<<<
+ *                         self.features[sorted_index_list_feature[i + 1], feature]):
  *                     continue
  */
       }
 
-      /* "adaXT/decision_tree/splitter.pyx":119
- *                 # test the split
- *                 crit, left_imp, right_imp, threshold = self.criteria.evaluate_split(
- *                                                         sorted_index_list_feature, i+1,             # <<<<<<<<<<<<<<
- *                                                         feature
- *                                                         )
- */
-      __pyx_t_25 = __Pyx_PyObject_to_MemoryviewSlice_ds_int(((PyObject *)__pyx_v_sorted_index_list_feature), PyBUF_WRITABLE); if (unlikely(!__pyx_t_25.memview)) __PYX_ERR(0, 119, __pyx_L1_error)
-
-      /* "adaXT/decision_tree/splitter.pyx":118
+      /* "adaXT/decision_tree/splitter.pyx":91
  *                     continue
  *                 # test the split
- *                 crit, left_imp, right_imp, threshold = self.criteria.evaluate_split(             # <<<<<<<<<<<<<<
+ *                 crit, threshold = self.criteria.evaluate_split(             # <<<<<<<<<<<<<<
  *                                                         sorted_index_list_feature, i+1,
  *                                                         feature
  */
-      __pyx_t_26 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->criteria->__pyx_vtab)->evaluate_split(__pyx_v_self->criteria, __pyx_t_25, (__pyx_v_i + 1), __pyx_v_feature); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 118, __pyx_L1_error)
-      __PYX_XCLEAR_MEMVIEW(&__pyx_t_25, 1);
-      __pyx_t_25.memview = NULL; __pyx_t_25.data = NULL;
-      __pyx_t_9 = __pyx_t_26.f0;
-      __pyx_t_8 = __pyx_t_26.f1;
-      __pyx_t_27 = __pyx_t_26.f2;
-      __pyx_t_28 = __pyx_t_26.f3;
-      __pyx_v_crit = __pyx_t_9;
-      __pyx_v_left_imp = __pyx_t_8;
-      __pyx_v_right_imp = __pyx_t_27;
-      __pyx_v_threshold = __pyx_t_28;
+      __pyx_t_24 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->criteria->__pyx_vtab)->evaluate_split(__pyx_v_self->criteria, __pyx_v_sorted_index_list_feature, (__pyx_v_i + 1), __pyx_v_feature); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 91, __pyx_L1_error)
+      __pyx_t_25 = __pyx_t_24.f0;
+      __pyx_t_26 = __pyx_t_24.f1;
+      __pyx_v_crit = __pyx_t_25;
+      __pyx_v_threshold = __pyx_t_26;
 
-      /* "adaXT/decision_tree/splitter.pyx":122
+      /* "adaXT/decision_tree/splitter.pyx":95
  *                                                         feature
  *                                                         )
- *                 if best_score - crit > EPSILON:  # rounding error             # <<<<<<<<<<<<<<
+ *                 if best_score > crit:  # rounding error             # <<<<<<<<<<<<<<
  *                     # Save the best split
  *                     # The index is given as the index of the
  */
-      __pyx_t_24 = ((__pyx_v_best_score - __pyx_v_crit) > __pyx_v_5adaXT_13decision_tree_8splitter_EPSILON);
-      if (__pyx_t_24) {
+      __pyx_t_23 = (__pyx_v_best_score > __pyx_v_crit);
+      if (__pyx_t_23) {
 
-        /* "adaXT/decision_tree/splitter.pyx":126
+        /* "adaXT/decision_tree/splitter.pyx":99
  *                     # The index is given as the index of the
  *                     # first element of the right dataset
  *                     best_feature, best_threshold = feature, threshold             # <<<<<<<<<<<<<<
  *                     best_score = crit
- *                     best_left_imp = left_imp
+ *                     best_split_idx = i + 1
  */
-        __pyx_t_29 = __pyx_v_feature;
-        __pyx_t_28 = __pyx_v_threshold;
-        __pyx_v_best_feature = __pyx_t_29;
-        __pyx_v_best_threshold = __pyx_t_28;
+        __pyx_t_27 = __pyx_v_feature;
+        __pyx_t_26 = __pyx_v_threshold;
+        __pyx_v_best_feature = __pyx_t_27;
+        __pyx_v_best_threshold = __pyx_t_26;
 
-        /* "adaXT/decision_tree/splitter.pyx":127
+        /* "adaXT/decision_tree/splitter.pyx":100
  *                     # first element of the right dataset
  *                     best_feature, best_threshold = feature, threshold
  *                     best_score = crit             # <<<<<<<<<<<<<<
- *                     best_left_imp = left_imp
- *                     best_right_imp = right_imp
+ *                     best_split_idx = i + 1
+ *                     best_sorted = sorted_index_list_feature
  */
         __pyx_v_best_score = __pyx_v_crit;
 
-        /* "adaXT/decision_tree/splitter.pyx":128
+        /* "adaXT/decision_tree/splitter.pyx":101
  *                     best_feature, best_threshold = feature, threshold
  *                     best_score = crit
- *                     best_left_imp = left_imp             # <<<<<<<<<<<<<<
- *                     best_right_imp = right_imp
- *                     best_split_idx = i + 1
- */
-        __pyx_v_best_left_imp = __pyx_v_left_imp;
-
-        /* "adaXT/decision_tree/splitter.pyx":129
- *                     best_score = crit
- *                     best_left_imp = left_imp
- *                     best_right_imp = right_imp             # <<<<<<<<<<<<<<
- *                     best_split_idx = i + 1
- *                     best_sorted = sorted_index_list_feature
- */
-        __pyx_v_best_right_imp = __pyx_v_right_imp;
-
-        /* "adaXT/decision_tree/splitter.pyx":130
- *                     best_left_imp = left_imp
- *                     best_right_imp = right_imp
  *                     best_split_idx = i + 1             # <<<<<<<<<<<<<<
  *                     best_sorted = sorted_index_list_feature
  * 
  */
         __pyx_v_best_split_idx = (__pyx_v_i + 1);
 
-        /* "adaXT/decision_tree/splitter.pyx":131
- *                     best_right_imp = right_imp
+        /* "adaXT/decision_tree/splitter.pyx":102
+ *                     best_score = crit
  *                     best_split_idx = i + 1
  *                     best_sorted = sorted_index_list_feature             # <<<<<<<<<<<<<<
  * 
  *         # We found a best split
  */
-        __pyx_t_25 = __Pyx_PyObject_to_MemoryviewSlice_ds_int(((PyObject *)__pyx_v_sorted_index_list_feature), PyBUF_WRITABLE); if (unlikely(!__pyx_t_25.memview)) __PYX_ERR(0, 131, __pyx_L1_error)
         __PYX_XCLEAR_MEMVIEW(&__pyx_v_best_sorted, 1);
-        __pyx_v_best_sorted = __pyx_t_25;
-        __pyx_t_25.memview = NULL;
-        __pyx_t_25.data = NULL;
+        __PYX_INC_MEMVIEW(&__pyx_v_sorted_index_list_feature, 1);
+        __pyx_v_best_sorted = __pyx_v_sorted_index_list_feature;
 
-        /* "adaXT/decision_tree/splitter.pyx":122
+        /* "adaXT/decision_tree/splitter.pyx":95
  *                                                         feature
  *                                                         )
- *                 if best_score - crit > EPSILON:  # rounding error             # <<<<<<<<<<<<<<
+ *                 if best_score > crit:  # rounding error             # <<<<<<<<<<<<<<
  *                     # Save the best split
  *                     # The index is given as the index of the
  */
       }
       __pyx_L5_continue:;
     }
   }
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_10, 1);
-  __pyx_t_10.memview = NULL; __pyx_t_10.data = NULL;
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_8, 1);
+  __pyx_t_8.memview = NULL; __pyx_t_8.data = NULL;
 
-  /* "adaXT/decision_tree/splitter.pyx":134
+  /* "adaXT/decision_tree/splitter.pyx":105
  * 
  *         # We found a best split
  *         if best_sorted is not None:             # <<<<<<<<<<<<<<
  *             split = [best_sorted[0:best_split_idx], best_sorted[best_split_idx:self.n_indices]]
- *             best_imp = [best_left_imp, best_right_imp]
+ *             best_imp = [self.criteria.impurity(split[0]), self.criteria.impurity(split[1])]
  */
-  __pyx_t_24 = (((PyObject *) __pyx_v_best_sorted.memview) != Py_None);
-  if (__pyx_t_24) {
+  __pyx_t_23 = (((PyObject *) __pyx_v_best_sorted.memview) != Py_None);
+  if (__pyx_t_23) {
 
-    /* "adaXT/decision_tree/splitter.pyx":135
+    /* "adaXT/decision_tree/splitter.pyx":106
  *         # We found a best split
  *         if best_sorted is not None:
  *             split = [best_sorted[0:best_split_idx], best_sorted[best_split_idx:self.n_indices]]             # <<<<<<<<<<<<<<
- *             best_imp = [best_left_imp, best_right_imp]
- *         return split, best_threshold, best_feature, best_score, best_imp
+ *             best_imp = [self.criteria.impurity(split[0]), self.criteria.impurity(split[1])]
+ * 
  */
-    __pyx_t_10.data = __pyx_v_best_sorted.data;
-    __pyx_t_10.memview = __pyx_v_best_sorted.memview;
-    __PYX_INC_MEMVIEW(&__pyx_t_10, 1);
+    __pyx_t_8.data = __pyx_v_best_sorted.data;
+    __pyx_t_8.memview = __pyx_v_best_sorted.memview;
+    __PYX_INC_MEMVIEW(&__pyx_t_8, 1);
     __pyx_t_7 = -1;
     if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_10,
+    &__pyx_t_8,
     __pyx_v_best_sorted.shape[0], __pyx_v_best_sorted.strides[0], __pyx_v_best_sorted.suboffsets[0],
     0,
     0,
     &__pyx_t_7,
     0,
     __pyx_v_best_split_idx,
     0,
     1,
     1,
     0,
     1) < 0))
 {
-    __PYX_ERR(0, 135, __pyx_L1_error)
+    __PYX_ERR(0, 106, __pyx_L1_error)
 }
 
-__pyx_t_1 = __pyx_memoryview_fromslice(__pyx_t_10, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
-    __PYX_XCLEAR_MEMVIEW(&__pyx_t_10, 1);
-    __pyx_t_10.memview = NULL; __pyx_t_10.data = NULL;
-    __pyx_t_10.data = __pyx_v_best_sorted.data;
-    __pyx_t_10.memview = __pyx_v_best_sorted.memview;
-    __PYX_INC_MEMVIEW(&__pyx_t_10, 1);
+__pyx_t_2 = __pyx_memoryview_fromslice(__pyx_t_8, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 106, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_2);
+    __PYX_XCLEAR_MEMVIEW(&__pyx_t_8, 1);
+    __pyx_t_8.memview = NULL; __pyx_t_8.data = NULL;
+    __pyx_t_8.data = __pyx_v_best_sorted.data;
+    __pyx_t_8.memview = __pyx_v_best_sorted.memview;
+    __PYX_INC_MEMVIEW(&__pyx_t_8, 1);
     __pyx_t_7 = -1;
     if (unlikely(__pyx_memoryview_slice_memviewslice(
-    &__pyx_t_10,
+    &__pyx_t_8,
     __pyx_v_best_sorted.shape[0], __pyx_v_best_sorted.strides[0], __pyx_v_best_sorted.suboffsets[0],
     0,
     0,
     &__pyx_t_7,
     __pyx_v_best_split_idx,
     __pyx_v_self->n_indices,
     0,
     1,
     1,
     0,
     1) < 0))
 {
-    __PYX_ERR(0, 135, __pyx_L1_error)
+    __PYX_ERR(0, 106, __pyx_L1_error)
 }
 
-__pyx_t_2 = __pyx_memoryview_fromslice(__pyx_t_10, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_2);
-    __PYX_XCLEAR_MEMVIEW(&__pyx_t_10, 1);
-    __pyx_t_10.memview = NULL; __pyx_t_10.data = NULL;
-    __pyx_t_5 = PyList_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 135, __pyx_L1_error)
+__pyx_t_5 = __pyx_memoryview_fromslice(__pyx_t_8, 1, (PyObject *(*)(char *)) __pyx_memview_get_int, (int (*)(char *, PyObject *)) __pyx_memview_set_int, 0);; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 106, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __Pyx_GIVEREF(__pyx_t_1);
-    if (__Pyx_PyList_SET_ITEM(__pyx_t_5, 0, __pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error);
+    __PYX_XCLEAR_MEMVIEW(&__pyx_t_8, 1);
+    __pyx_t_8.memview = NULL; __pyx_t_8.data = NULL;
+    __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 106, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
     __Pyx_GIVEREF(__pyx_t_2);
-    if (__Pyx_PyList_SET_ITEM(__pyx_t_5, 1, __pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error);
-    __pyx_t_1 = 0;
+    if (__Pyx_PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_2)) __PYX_ERR(0, 106, __pyx_L1_error);
+    __Pyx_GIVEREF(__pyx_t_5);
+    if (__Pyx_PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_5)) __PYX_ERR(0, 106, __pyx_L1_error);
     __pyx_t_2 = 0;
-    __Pyx_DECREF_SET(__pyx_v_split, ((PyObject*)__pyx_t_5));
     __pyx_t_5 = 0;
+    __Pyx_DECREF_SET(__pyx_v_split, ((PyObject*)__pyx_t_1));
+    __pyx_t_1 = 0;
 
-    /* "adaXT/decision_tree/splitter.pyx":136
+    /* "adaXT/decision_tree/splitter.pyx":107
  *         if best_sorted is not None:
  *             split = [best_sorted[0:best_split_idx], best_sorted[best_split_idx:self.n_indices]]
- *             best_imp = [best_left_imp, best_right_imp]             # <<<<<<<<<<<<<<
+ *             best_imp = [self.criteria.impurity(split[0]), self.criteria.impurity(split[1])]             # <<<<<<<<<<<<<<
+ * 
  *         return split, best_threshold, best_feature, best_score, best_imp
  */
-    __pyx_t_5 = PyFloat_FromDouble(__pyx_v_best_left_imp); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 136, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_dc_int(PyList_GET_ITEM(__pyx_v_split, 0), PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 107, __pyx_L1_error)
+    __pyx_t_26 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->criteria->__pyx_vtab)->impurity(__pyx_v_self->criteria, __pyx_t_8, 0); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 107, __pyx_L1_error)
+    __PYX_XCLEAR_MEMVIEW(&__pyx_t_8, 1);
+    __pyx_t_8.memview = NULL; __pyx_t_8.data = NULL;
+    __pyx_t_1 = PyFloat_FromDouble(__pyx_t_26); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 107, __pyx_L1_error)
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_dc_int(PyList_GET_ITEM(__pyx_v_split, 1), PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 107, __pyx_L1_error)
+    __pyx_t_26 = ((struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria *)__pyx_v_self->criteria->__pyx_vtab)->impurity(__pyx_v_self->criteria, __pyx_t_8, 0); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 107, __pyx_L1_error)
+    __PYX_XCLEAR_MEMVIEW(&__pyx_t_8, 1);
+    __pyx_t_8.memview = NULL; __pyx_t_8.data = NULL;
+    __pyx_t_5 = PyFloat_FromDouble(__pyx_t_26); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 107, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_2 = PyFloat_FromDouble(__pyx_v_best_right_imp); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 136, __pyx_L1_error)
+    __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 107, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 136, __pyx_L1_error)
-    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_GIVEREF(__pyx_t_1);
+    if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 0, __pyx_t_1)) __PYX_ERR(0, 107, __pyx_L1_error);
     __Pyx_GIVEREF(__pyx_t_5);
-    if (__Pyx_PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_5)) __PYX_ERR(0, 136, __pyx_L1_error);
-    __Pyx_GIVEREF(__pyx_t_2);
-    if (__Pyx_PyList_SET_ITEM(__pyx_t_1, 1, __pyx_t_2)) __PYX_ERR(0, 136, __pyx_L1_error);
+    if (__Pyx_PyList_SET_ITEM(__pyx_t_2, 1, __pyx_t_5)) __PYX_ERR(0, 107, __pyx_L1_error);
+    __pyx_t_1 = 0;
     __pyx_t_5 = 0;
+    __Pyx_DECREF_SET(__pyx_v_best_imp, ((PyObject*)__pyx_t_2));
     __pyx_t_2 = 0;
-    __Pyx_DECREF_SET(__pyx_v_best_imp, ((PyObject*)__pyx_t_1));
-    __pyx_t_1 = 0;
 
-    /* "adaXT/decision_tree/splitter.pyx":134
+    /* "adaXT/decision_tree/splitter.pyx":105
  * 
  *         # We found a best split
  *         if best_sorted is not None:             # <<<<<<<<<<<<<<
  *             split = [best_sorted[0:best_split_idx], best_sorted[best_split_idx:self.n_indices]]
- *             best_imp = [best_left_imp, best_right_imp]
+ *             best_imp = [self.criteria.impurity(split[0]), self.criteria.impurity(split[1])]
  */
   }
 
-  /* "adaXT/decision_tree/splitter.pyx":137
- *             split = [best_sorted[0:best_split_idx], best_sorted[best_split_idx:self.n_indices]]
- *             best_imp = [best_left_imp, best_right_imp]
+  /* "adaXT/decision_tree/splitter.pyx":109
+ *             best_imp = [self.criteria.impurity(split[0]), self.criteria.impurity(split[1])]
+ * 
  *         return split, best_threshold, best_feature, best_score, best_imp             # <<<<<<<<<<<<<<
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_best_threshold); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_best_feature); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
+  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_best_threshold); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 109, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_5 = PyFloat_FromDouble(__pyx_v_best_score); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 137, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_best_feature); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 109, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_4 = PyTuple_New(5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 137, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_best_score); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 109, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_4 = PyTuple_New(5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 109, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_INCREF(__pyx_v_split);
   __Pyx_GIVEREF(__pyx_v_split);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_split)) __PYX_ERR(0, 137, __pyx_L1_error);
-  __Pyx_GIVEREF(__pyx_t_1);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_split)) __PYX_ERR(0, 109, __pyx_L1_error);
   __Pyx_GIVEREF(__pyx_t_2);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2)) __PYX_ERR(0, 109, __pyx_L1_error);
   __Pyx_GIVEREF(__pyx_t_5);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_t_5)) __PYX_ERR(0, 137, __pyx_L1_error);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_5)) __PYX_ERR(0, 109, __pyx_L1_error);
+  __Pyx_GIVEREF(__pyx_t_1);
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_t_1)) __PYX_ERR(0, 109, __pyx_L1_error);
   __Pyx_INCREF(__pyx_v_best_imp);
   __Pyx_GIVEREF(__pyx_v_best_imp);
-  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 4, __pyx_v_best_imp)) __PYX_ERR(0, 137, __pyx_L1_error);
-  __pyx_t_1 = 0;
+  if (__Pyx_PyTuple_SET_ITEM(__pyx_t_4, 4, __pyx_v_best_imp)) __PYX_ERR(0, 109, __pyx_L1_error);
   __pyx_t_2 = 0;
   __pyx_t_5 = 0;
+  __pyx_t_1 = 0;
   __pyx_r = __pyx_t_4;
   __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "adaXT/decision_tree/splitter.pyx":64
- *         return idx[temp]
+  /* "adaXT/decision_tree/splitter.pyx":59
+ *         self.n_class = len(np.unique(Y))
  * 
- *     cpdef get_split(self, int[:] indices, int[:] feature_indices):             # <<<<<<<<<<<<<<
- *         """
- *         Function that finds the best split of the dataset
+ *     cpdef get_split(self, int[::1] indices, int[::1] feature_indices):             # <<<<<<<<<<<<<<
+ *         global current_feature_values
+ *         self.indices = indices
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_5);
   __Pyx_XDECREF(__pyx_t_6);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_10, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_8, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_13, 1);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_t_14, 1);
   __PYX_XCLEAR_MEMVIEW(&__pyx_t_15, 1);
-  __PYX_XCLEAR_MEMVIEW(&__pyx_t_25, 1);
-  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
-    __Pyx_PyThreadState_declare
-    __Pyx_PyThreadState_assign
-    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
-    __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_sorted_index_list_feature.rcbuffer->pybuffer);
-  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
   __Pyx_AddTraceback("adaXT.decision_tree.splitter.Splitter.get_split", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = 0;
-  goto __pyx_L2;
   __pyx_L0:;
-  __Pyx_SafeReleaseBuffer(&__pyx_pybuffernd_sorted_index_list_feature.rcbuffer->pybuffer);
-  __pyx_L2:;
-  __PYX_XCLEAR_MEMVIEW(&__pyx_v_current_feature_values, 1);
-  __Pyx_XDECREF((PyObject *)__pyx_v_sorted_index_list_feature);
+  __PYX_XCLEAR_MEMVIEW(&__pyx_v_sorted_index_list_feature, 1);
   __PYX_XCLEAR_MEMVIEW(&__pyx_v_best_sorted, 1);
-  __Pyx_XDECREF(__pyx_v_features);
   __Pyx_XDECREF(__pyx_v_split);
   __Pyx_XDECREF(__pyx_v_best_imp);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
@@ -20577,16 +20445,15 @@
 static PyObject *__pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_3get_split(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ); /*proto*/
-PyDoc_STRVAR(__pyx_doc_5adaXT_13decision_tree_8splitter_8Splitter_2get_split, "\n        Function that finds the best split of the dataset\n        ----------\n\n        Parameters\n        ----------\n        indices : memoryview of NDArray\n            Indices constituting the dataset\n\n        Returns\n        -----------\n        (list, double, int, double, double)\n            Returns the best split of the dataset, with the values being:\n            (1) a list containing the left and right indices, (2) the best\n            threshold for doing the splits, (3) what feature to split on,\n            (4) the best criteria score, and (5) the best impurity\n        ");
-static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_8splitter_8Splitter_3get_split = {"get_split", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_3get_split, __Pyx_METH_FASTCALL|METH_KEYWORDS, __pyx_doc_5adaXT_13decision_tree_8splitter_8Splitter_2get_split};
+static PyMethodDef __pyx_mdef_5adaXT_13decision_tree_8splitter_8Splitter_3get_split = {"get_split", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_3get_split, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0};
 static PyObject *__pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_3get_split(PyObject *__pyx_v_self, 
 #if CYTHON_METH_FASTCALL
 PyObject *const *__pyx_args, Py_ssize_t __pyx_nargs, PyObject *__pyx_kwds
 #else
 PyObject *__pyx_args, PyObject *__pyx_kwds
 #endif
 ) {
@@ -20626,43 +20493,43 @@
       kw_args = __Pyx_NumKwargs_FASTCALL(__pyx_kwds);
       switch (__pyx_nargs) {
         case  0:
         if (likely((values[0] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[0]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 64, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 59, __pyx_L3_error)
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_GetKwValue_FASTCALL(__pyx_kwds, __pyx_kwvalues, __pyx_n_s_feature_indices)) != 0)) {
           (void)__Pyx_Arg_NewRef_FASTCALL(values[1]);
           kw_args--;
         }
-        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 64, __pyx_L3_error)
+        else if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 59, __pyx_L3_error)
         else {
-          __Pyx_RaiseArgtupleInvalid("get_split", 1, 2, 2, 1); __PYX_ERR(0, 64, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("get_split", 1, 2, 2, 1); __PYX_ERR(0, 59, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
         const Py_ssize_t kwd_pos_args = __pyx_nargs;
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "get_split") < 0)) __PYX_ERR(0, 64, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_kwvalues, __pyx_pyargnames, 0, values + 0, kwd_pos_args, "get_split") < 0)) __PYX_ERR(0, 59, __pyx_L3_error)
       }
     } else if (unlikely(__pyx_nargs != 2)) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = __Pyx_Arg_FASTCALL(__pyx_args, 0);
       values[1] = __Pyx_Arg_FASTCALL(__pyx_args, 1);
     }
-    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_ds_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(0, 64, __pyx_L3_error)
-    __pyx_v_feature_indices = __Pyx_PyObject_to_MemoryviewSlice_ds_int(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_feature_indices.memview)) __PYX_ERR(0, 64, __pyx_L3_error)
+    __pyx_v_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_int(values[0], PyBUF_WRITABLE); if (unlikely(!__pyx_v_indices.memview)) __PYX_ERR(0, 59, __pyx_L3_error)
+    __pyx_v_feature_indices = __Pyx_PyObject_to_MemoryviewSlice_dc_int(values[1], PyBUF_WRITABLE); if (unlikely(!__pyx_v_feature_indices.memview)) __PYX_ERR(0, 59, __pyx_L3_error)
   }
   goto __pyx_L6_skip;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("get_split", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 64, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("get_split", 1, 2, 2, __pyx_nargs); __PYX_ERR(0, 59, __pyx_L3_error)
   __pyx_L6_skip:;
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L3_error:;
   {
     Py_ssize_t __pyx_temp;
     for (__pyx_temp=0; __pyx_temp < (Py_ssize_t)(sizeof(values)/sizeof(values[0])); ++__pyx_temp) {
       __Pyx_Arg_XDECREF_FASTCALL(values[__pyx_temp]);
@@ -20694,15 +20561,15 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("get_split", 1);
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __pyx_f_5adaXT_13decision_tree_8splitter_8Splitter_get_split(__pyx_v_self, __pyx_v_indices, __pyx_v_feature_indices, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_5adaXT_13decision_tree_8splitter_8Splitter_get_split(__pyx_v_self, __pyx_v_indices, __pyx_v_feature_indices, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 59, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
   /* function exit code */
   __pyx_L1_error:;
@@ -21005,15 +20872,14 @@
   {"__reduce_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_5__reduce_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
   {"__setstate_cython__", (PyCFunction)(void*)(__Pyx_PyCFunction_FastCallWithKeywords)__pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_7__setstate_cython__, __Pyx_METH_FASTCALL|METH_KEYWORDS, 0},
   {0, 0, 0, 0}
 };
 #if CYTHON_USE_TYPE_SPECS
 static PyType_Slot __pyx_type_5adaXT_13decision_tree_8splitter_Splitter_slots[] = {
   {Py_tp_dealloc, (void *)__pyx_tp_dealloc_5adaXT_13decision_tree_8splitter_Splitter},
-  {Py_tp_doc, (void *)PyDoc_STR("\n    Splitter class used to create splits of the data\n    ")},
   {Py_tp_traverse, (void *)__pyx_tp_traverse_5adaXT_13decision_tree_8splitter_Splitter},
   {Py_tp_clear, (void *)__pyx_tp_clear_5adaXT_13decision_tree_8splitter_Splitter},
   {Py_tp_methods, (void *)__pyx_methods_5adaXT_13decision_tree_8splitter_Splitter},
   {Py_tp_init, (void *)__pyx_pw_5adaXT_13decision_tree_8splitter_8Splitter_1__init__},
   {Py_tp_new, (void *)__pyx_tp_new_5adaXT_13decision_tree_8splitter_Splitter},
   {0, 0},
 };
@@ -21053,15 +20919,15 @@
   0, /*tp_hash*/
   0, /*tp_call*/
   0, /*tp_str*/
   0, /*tp_getattro*/
   0, /*tp_setattro*/
   0, /*tp_as_buffer*/
   Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
-  PyDoc_STR("\n    Splitter class used to create splits of the data\n    "), /*tp_doc*/
+  0, /*tp_doc*/
   __pyx_tp_traverse_5adaXT_13decision_tree_8splitter_Splitter, /*tp_traverse*/
   __pyx_tp_clear_5adaXT_13decision_tree_8splitter_Splitter, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
   __pyx_methods_5adaXT_13decision_tree_8splitter_Splitter, /*tp_methods*/
@@ -22115,15 +21981,14 @@
     {&__pyx_n_s__3, __pyx_k__3, sizeof(__pyx_k__3), 0, 0, 1, 1},
     {&__pyx_kp_u__6, __pyx_k__6, sizeof(__pyx_k__6), 0, 1, 0, 0},
     {&__pyx_kp_u__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 1, 0, 0},
     {&__pyx_n_s_abc, __pyx_k_abc, sizeof(__pyx_k_abc), 0, 0, 1, 1},
     {&__pyx_n_s_adaXT_decision_tree_splitter, __pyx_k_adaXT_decision_tree_splitter, sizeof(__pyx_k_adaXT_decision_tree_splitter), 0, 0, 1, 1},
     {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
     {&__pyx_kp_u_and, __pyx_k_and, sizeof(__pyx_k_and), 0, 1, 0, 0},
-    {&__pyx_n_s_argsort, __pyx_k_argsort, sizeof(__pyx_k_argsort), 0, 0, 1, 1},
     {&__pyx_n_s_asarray, __pyx_k_asarray, sizeof(__pyx_k_asarray), 0, 0, 1, 1},
     {&__pyx_n_s_asyncio_coroutines, __pyx_k_asyncio_coroutines, sizeof(__pyx_k_asyncio_coroutines), 0, 0, 1, 1},
     {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
     {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
     {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
     {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
     {&__pyx_n_s_class_getitem, __pyx_k_class_getitem, sizeof(__pyx_k_class_getitem), 0, 0, 1, 1},
@@ -22132,15 +21997,15 @@
     {&__pyx_kp_s_collections_abc, __pyx_k_collections_abc, sizeof(__pyx_k_collections_abc), 0, 0, 1, 0},
     {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
     {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
     {&__pyx_n_s_count, __pyx_k_count, sizeof(__pyx_k_count), 0, 0, 1, 1},
     {&__pyx_n_s_criteria, __pyx_k_criteria, sizeof(__pyx_k_criteria), 0, 0, 1, 1},
     {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
     {&__pyx_kp_u_disable, __pyx_k_disable, sizeof(__pyx_k_disable), 0, 1, 0, 0},
-    {&__pyx_n_s_double, __pyx_k_double, sizeof(__pyx_k_double), 0, 0, 1, 1},
+    {&__pyx_n_u_double, __pyx_k_double, sizeof(__pyx_k_double), 0, 1, 0, 1},
     {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
     {&__pyx_kp_u_enable, __pyx_k_enable, sizeof(__pyx_k_enable), 0, 1, 0, 0},
     {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
     {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
     {&__pyx_n_s_eps, __pyx_k_eps, sizeof(__pyx_k_eps), 0, 0, 1, 1},
     {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
     {&__pyx_n_s_feature_indices, __pyx_k_feature_indices, sizeof(__pyx_k_feature_indices), 0, 0, 1, 1},
@@ -22170,16 +22035,16 @@
     {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
     {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
     {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
     {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
     {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
     {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
     {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
-    {&__pyx_kp_s_numpy_core_multiarray_failed_to, __pyx_k_numpy_core_multiarray_failed_to, sizeof(__pyx_k_numpy_core_multiarray_failed_to), 0, 0, 1, 0},
-    {&__pyx_kp_s_numpy_core_umath_failed_to_impor, __pyx_k_numpy_core_umath_failed_to_impor, sizeof(__pyx_k_numpy_core_umath_failed_to_impor), 0, 0, 1, 0},
+    {&__pyx_kp_u_numpy_core_multiarray_failed_to, __pyx_k_numpy_core_multiarray_failed_to, sizeof(__pyx_k_numpy_core_multiarray_failed_to), 0, 1, 0, 0},
+    {&__pyx_kp_u_numpy_core_umath_failed_to_impor, __pyx_k_numpy_core_umath_failed_to_impor, sizeof(__pyx_k_numpy_core_umath_failed_to_impor), 0, 1, 0, 0},
     {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
     {&__pyx_n_s_pack, __pyx_k_pack, sizeof(__pyx_k_pack), 0, 0, 1, 1},
     {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_PickleError, __pyx_k_pyx_PickleError, sizeof(__pyx_k_pyx_PickleError), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_checksum, __pyx_k_pyx_checksum, sizeof(__pyx_k_pyx_checksum), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_result, __pyx_k_pyx_result, sizeof(__pyx_k_pyx_result), 0, 0, 1, 1},
     {&__pyx_n_s_pyx_state, __pyx_k_pyx_state, sizeof(__pyx_k_pyx_state), 0, 0, 1, 1},
@@ -22217,15 +22082,15 @@
     {&__pyx_n_s_version_info, __pyx_k_version_info, sizeof(__pyx_k_version_info), 0, 0, 1, 1},
     {0, 0, 0, 0, 0, 0, 0}
   };
   return __Pyx_InitStrings(__pyx_string_tab);
 }
 /* #### Code section: cached_builtins ### */
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 111, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 84, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
   __pyx_builtin___import__ = __Pyx_GetBuiltinName(__pyx_n_s_import); if (!__pyx_builtin___import__) __PYX_ERR(1, 100, __pyx_L1_error)
   __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(1, 141, __pyx_L1_error)
   __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(1, 156, __pyx_L1_error)
   __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 159, __pyx_L1_error)
   __pyx_builtin_AssertionError = __Pyx_GetBuiltinName(__pyx_n_s_AssertionError); if (!__pyx_builtin_AssertionError) __PYX_ERR(1, 373, __pyx_L1_error)
   __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 408, __pyx_L1_error)
@@ -22274,33 +22139,33 @@
  *         from pickle import PickleError as __pyx_PickleError
  *         raise __pyx_PickleError, "Incompatible checksums (0x%x vs (0x82a3537, 0x6ae9995, 0xb068931) = (name))" % __pyx_checksum
  */
   __pyx_tuple__8 = PyTuple_Pack(3, __pyx_int_136983863, __pyx_int_112105877, __pyx_int_184977713); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__8);
   __Pyx_GIVEREF(__pyx_tuple__8);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":984
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":984
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
-  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(2, 984, __pyx_L1_error)
+  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(2, 984, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__9);
   __Pyx_GIVEREF(__pyx_tuple__9);
 
-  /* "../../../../../tmp/build-env-_ao0ys27/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":990
+  /* "../../../../../tmp/build-env-mh9sk5zt/lib/python3.10/site-packages/numpy/__init__.cython-30.pxd":990
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
-  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(2, 990, __pyx_L1_error)
+  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(2, 990, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__10);
   __Pyx_GIVEREF(__pyx_tuple__10);
 
   /* "View.MemoryView":100
  * cdef object __pyx_collections_abc_Sequence "__pyx_collections_abc_Sequence"
  * try:
  *     if __import__("sys").version_info >= (3, 3):             # <<<<<<<<<<<<<<
@@ -22398,35 +22263,35 @@
  */
   __pyx_tuple__20 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__20);
   __Pyx_GIVEREF(__pyx_tuple__20);
   __pyx_codeobj__21 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__20, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__21)) __PYX_ERR(1, 1, __pyx_L1_error)
 
   /* "adaXT/decision_tree/splitter.pyx":8
- * from ..criteria.criteria cimport Criteria  # Must be complete path for cimport
+ * from libc.stdlib cimport qsort
  * 
  * cdef double EPSILON = 2*np.finfo('double').eps             # <<<<<<<<<<<<<<
  * # The rounding error for a criteria function is set twice as large as in DepthTreeBuilder.
  * # This is needed due to the fact that the criteria does multiple calculations before returing the critical value,
  */
-  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_n_s_double); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 8, __pyx_L1_error)
+  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_n_u_double); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 8, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__22);
   __Pyx_GIVEREF(__pyx_tuple__22);
 
-  /* "adaXT/decision_tree/splitter.pyx":64
- *         return idx[temp]
+  /* "adaXT/decision_tree/splitter.pyx":59
+ *         self.n_class = len(np.unique(Y))
  * 
- *     cpdef get_split(self, int[:] indices, int[:] feature_indices):             # <<<<<<<<<<<<<<
- *         """
- *         Function that finds the best split of the dataset
+ *     cpdef get_split(self, int[::1] indices, int[::1] feature_indices):             # <<<<<<<<<<<<<<
+ *         global current_feature_values
+ *         self.indices = indices
  */
-  __pyx_tuple__23 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_indices, __pyx_n_s_feature_indices); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __pyx_tuple__23 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_indices, __pyx_n_s_feature_indices); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 59, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__23);
   __Pyx_GIVEREF(__pyx_tuple__23);
-  __pyx_codeobj__24 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_splitter, __pyx_n_s_get_split, 64, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__24)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __pyx_codeobj__24 = (PyObject*)__Pyx_PyCode_New(3, 0, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__23, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_adaXT_decision_tree_splitter, __pyx_n_s_get_split, 59, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__24)) __PYX_ERR(0, 59, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "self.class_labels,self.n_in_class cannot be converted to a Python object for pickling"
  * def __setstate_cython__(self, __pyx_state):
  */
   __pyx_tuple__25 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(1, 1, __pyx_L1_error)
@@ -22523,52 +22388,41 @@
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
   __pyx_vtabptr_5adaXT_13decision_tree_8splitter_Splitter = &__pyx_vtable_5adaXT_13decision_tree_8splitter_Splitter;
-  __pyx_vtable_5adaXT_13decision_tree_8splitter_Splitter.sort_feature = (PyArrayObject *(*)(struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter *, __Pyx_memviewslice, __Pyx_memviewslice))__pyx_f_5adaXT_13decision_tree_8splitter_8Splitter_sort_feature;
   __pyx_vtable_5adaXT_13decision_tree_8splitter_Splitter.get_split = (PyObject *(*)(struct __pyx_obj_5adaXT_13decision_tree_8splitter_Splitter *, __Pyx_memviewslice, __Pyx_memviewslice, int __pyx_skip_dispatch))__pyx_f_5adaXT_13decision_tree_8splitter_8Splitter_get_split;
   #if CYTHON_USE_TYPE_SPECS
-  __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_13decision_tree_8splitter_Splitter_spec, NULL); if (unlikely(!__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter)) __PYX_ERR(0, 16, __pyx_L1_error)
-  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_13decision_tree_8splitter_Splitter_spec, __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
+  __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type_5adaXT_13decision_tree_8splitter_Splitter_spec, NULL); if (unlikely(!__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter)) __PYX_ERR(0, 51, __pyx_L1_error)
+  if (__Pyx_fix_up_extension_type_from_spec(&__pyx_type_5adaXT_13decision_tree_8splitter_Splitter_spec, __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
   #else
   __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter = &__pyx_type_5adaXT_13decision_tree_8splitter_Splitter;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   #endif
   #if !CYTHON_USE_TYPE_SPECS
-  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
+  if (__Pyx_PyType_Ready(__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
   #endif
   #if PY_MAJOR_VERSION < 3
   __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter->tp_print = 0;
   #endif
   #if !CYTHON_COMPILING_IN_LIMITED_API
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter->tp_dictoffset && __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter->tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter->tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
   #endif
-  #if CYTHON_UPDATE_DESCRIPTOR_DOC
-  {
-    PyObject *wrapper = PyObject_GetAttrString((PyObject *)__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter, "__init__"); if (unlikely(!wrapper)) __PYX_ERR(0, 16, __pyx_L1_error)
-    if (__Pyx_IS_TYPE(wrapper, &PyWrapperDescr_Type)) {
-      __pyx_wrapperbase_5adaXT_13decision_tree_8splitter_8Splitter___init__ = *((PyWrapperDescrObject *)wrapper)->d_base;
-      __pyx_wrapperbase_5adaXT_13decision_tree_8splitter_8Splitter___init__.doc = __pyx_doc_5adaXT_13decision_tree_8splitter_8Splitter___init__;
-      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_5adaXT_13decision_tree_8splitter_8Splitter___init__;
-    }
-  }
-  #endif
-  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter, __pyx_vtabptr_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
+  if (__Pyx_SetVtable(__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter, __pyx_vtabptr_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
+  if (__Pyx_MergeVtables(__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
   #endif
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Splitter, (PyObject *) __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Splitter, (PyObject *) __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
-  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject *) __pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter) < 0) __PYX_ERR(0, 51, __pyx_L1_error)
   #endif
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
   #if CYTHON_USE_TYPE_SPECS
   __pyx_array_type = (PyTypeObject *) __Pyx_PyType_FromModuleAndSpec(__pyx_m, &__pyx_type___pyx_array_spec, NULL); if (unlikely(!__pyx_array_type)) __PYX_ERR(1, 114, __pyx_L1_error)
   #if !CYTHON_COMPILING_IN_LIMITED_API
   __pyx_array_type->tp_as_buffer = &__pyx_tp_as_buffer_array;
@@ -22720,45 +22574,45 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_3_0_8(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_3_0_10(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyTypeObject),
   #elif CYTHON_COMPILING_IN_LIMITED_API
-  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = PyImport_ImportModule("numpy"); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 202, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_5numpy_dtype = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyArray_Descr),__Pyx_ImportType_CheckSize_Ignore_3_0_8); if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(2, 202, __pyx_L1_error)
-  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyArrayIterObject),__Pyx_ImportType_CheckSize_Ignore_3_0_8); if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(2, 225, __pyx_L1_error)
-  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyArrayMultiIterObject),__Pyx_ImportType_CheckSize_Ignore_3_0_8); if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(2, 229, __pyx_L1_error)
-  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyArrayObject),__Pyx_ImportType_CheckSize_Ignore_3_0_8); if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(2, 238, __pyx_L1_error)
-  __pyx_ptype_5numpy_generic = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "generic", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_generic) __PYX_ERR(2, 809, __pyx_L1_error)
-  __pyx_ptype_5numpy_number = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "number", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_number) __PYX_ERR(2, 811, __pyx_L1_error)
-  __pyx_ptype_5numpy_integer = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "integer", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_integer) __PYX_ERR(2, 813, __pyx_L1_error)
-  __pyx_ptype_5numpy_signedinteger = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "signedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(2, 815, __pyx_L1_error)
-  __pyx_ptype_5numpy_unsignedinteger = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "unsignedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(2, 817, __pyx_L1_error)
-  __pyx_ptype_5numpy_inexact = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "inexact", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(2, 819, __pyx_L1_error)
-  __pyx_ptype_5numpy_floating = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "floating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_floating) __PYX_ERR(2, 821, __pyx_L1_error)
-  __pyx_ptype_5numpy_complexfloating = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "complexfloating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(2, 823, __pyx_L1_error)
-  __pyx_ptype_5numpy_flexible = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "flexible", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(2, 825, __pyx_L1_error)
-  __pyx_ptype_5numpy_character = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "character", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5numpy_character) __PYX_ERR(2, 827, __pyx_L1_error)
-  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType_3_0_8(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(PyUFuncObject),__Pyx_ImportType_CheckSize_Ignore_3_0_8); if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(2, 866, __pyx_L1_error)
+  __pyx_ptype_5numpy_dtype = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyArray_Descr),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(2, 202, __pyx_L1_error)
+  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyArrayIterObject),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(2, 225, __pyx_L1_error)
+  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyArrayMultiIterObject),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(2, 229, __pyx_L1_error)
+  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyArrayObject),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(2, 238, __pyx_L1_error)
+  __pyx_ptype_5numpy_generic = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "generic", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_generic) __PYX_ERR(2, 809, __pyx_L1_error)
+  __pyx_ptype_5numpy_number = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "number", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_number) __PYX_ERR(2, 811, __pyx_L1_error)
+  __pyx_ptype_5numpy_integer = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "integer", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_integer) __PYX_ERR(2, 813, __pyx_L1_error)
+  __pyx_ptype_5numpy_signedinteger = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "signedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(2, 815, __pyx_L1_error)
+  __pyx_ptype_5numpy_unsignedinteger = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "unsignedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(2, 817, __pyx_L1_error)
+  __pyx_ptype_5numpy_inexact = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "inexact", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(2, 819, __pyx_L1_error)
+  __pyx_ptype_5numpy_floating = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "floating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_floating) __PYX_ERR(2, 821, __pyx_L1_error)
+  __pyx_ptype_5numpy_complexfloating = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "complexfloating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(2, 823, __pyx_L1_error)
+  __pyx_ptype_5numpy_flexible = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "flexible", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(2, 825, __pyx_L1_error)
+  __pyx_ptype_5numpy_character = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "character", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyObject),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5numpy_character) __PYX_ERR(2, 827, __pyx_L1_error)
+  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType_3_0_10(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(PyUFuncObject),__Pyx_ImportType_CheckSize_Ignore_3_0_10); if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(2, 866, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = PyImport_ImportModule("adaXT.criteria.criteria"); if (unlikely(!__pyx_t_1)) __PYX_ERR(4, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_5adaXT_8criteria_8criteria_Criteria = __Pyx_ImportType_3_0_8(__pyx_t_1, "adaXT.criteria.criteria", "Criteria", sizeof(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria), __PYX_GET_STRUCT_ALIGNMENT_3_0_8(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria),__Pyx_ImportType_CheckSize_Warn_3_0_8); if (!__pyx_ptype_5adaXT_8criteria_8criteria_Criteria) __PYX_ERR(4, 1, __pyx_L1_error)
+  __pyx_ptype_5adaXT_8criteria_8criteria_Criteria = __Pyx_ImportType_3_0_10(__pyx_t_1, "adaXT.criteria.criteria", "Criteria", sizeof(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria), __PYX_GET_STRUCT_ALIGNMENT_3_0_10(struct __pyx_obj_5adaXT_8criteria_8criteria_Criteria),__Pyx_ImportType_CheckSize_Warn_3_0_10); if (!__pyx_ptype_5adaXT_8criteria_8criteria_Criteria) __PYX_ERR(4, 1, __pyx_L1_error)
   __pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria = (struct __pyx_vtabstruct_5adaXT_8criteria_8criteria_Criteria*)__Pyx_GetVtable(__pyx_ptype_5adaXT_8criteria_8criteria_Criteria); if (unlikely(!__pyx_vtabptr_5adaXT_8criteria_8criteria_Criteria)) __PYX_ERR(4, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
@@ -23576,37 +23430,36 @@
  *     cdef object __pyx_result
  */
   __pyx_t_7 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_7)) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_7) < 0) __PYX_ERR(1, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/decision_tree/splitter.pyx":3
+  /* "adaXT/decision_tree/splitter.pyx":2
  * # cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False
- * 
  * import numpy as np             # <<<<<<<<<<<<<<
  * cimport numpy as cnp
  * cnp.import_array()
  */
-  __pyx_t_7 = __Pyx_ImportDottedModule(__pyx_n_s_numpy, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_ImportDottedModule(__pyx_n_s_numpy, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_7) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_7) < 0) __PYX_ERR(0, 2, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "adaXT/decision_tree/splitter.pyx":5
+  /* "adaXT/decision_tree/splitter.pyx":4
  * import numpy as np
  * cimport numpy as cnp
  * cnp.import_array()             # <<<<<<<<<<<<<<
  * from ..criteria.criteria cimport Criteria  # Must be complete path for cimport
- * 
+ * from libc.stdlib cimport qsort
  */
-  __pyx_t_9 = __pyx_f_5numpy_import_array(); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 5, __pyx_L1_error)
+  __pyx_t_9 = __pyx_f_5numpy_import_array(); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 4, __pyx_L1_error)
 
   /* "adaXT/decision_tree/splitter.pyx":8
- * from ..criteria.criteria cimport Criteria  # Must be complete path for cimport
+ * from libc.stdlib cimport qsort
  * 
  * cdef double EPSILON = 2*np.finfo('double').eps             # <<<<<<<<<<<<<<
  * # The rounding error for a criteria function is set twice as large as in DepthTreeBuilder.
  * # This is needed due to the fact that the criteria does multiple calculations before returing the critical value,
  */
   __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 8, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
@@ -23627,35 +23480,35 @@
   __pyx_v_5adaXT_13decision_tree_8splitter_EPSILON = __pyx_t_10;
 
   /* "adaXT/decision_tree/splitter.pyx":13
  * # where the DepthTreeBuilder is just comparing the impurity (that already has gone through this check).
  * 
  * cdef double INFINITY = np.inf             # <<<<<<<<<<<<<<
  * 
- * 
+ * cdef double[:] current_feature_values
  */
   __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 13, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_inf); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 13, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_t_10 = __pyx_PyFloat_AsDouble(__pyx_t_4); if (unlikely((__pyx_t_10 == (double)-1) && PyErr_Occurred())) __PYX_ERR(0, 13, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_v_5adaXT_13decision_tree_8splitter_INFINITY = __pyx_t_10;
 
-  /* "adaXT/decision_tree/splitter.pyx":64
- *         return idx[temp]
+  /* "adaXT/decision_tree/splitter.pyx":59
+ *         self.n_class = len(np.unique(Y))
  * 
- *     cpdef get_split(self, int[:] indices, int[:] feature_indices):             # <<<<<<<<<<<<<<
- *         """
- *         Function that finds the best split of the dataset
+ *     cpdef get_split(self, int[::1] indices, int[::1] feature_indices):             # <<<<<<<<<<<<<<
+ *         global current_feature_values
+ *         self.indices = indices
  */
-  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_8splitter_8Splitter_3get_split, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Splitter_get_split, NULL, __pyx_n_s_adaXT_decision_tree_splitter, __pyx_d, ((PyObject *)__pyx_codeobj__24)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_8splitter_8Splitter_3get_split, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Splitter_get_split, NULL, __pyx_n_s_adaXT_decision_tree_splitter, __pyx_d, ((PyObject *)__pyx_codeobj__24)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 59, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter, __pyx_n_s_get_split, __pyx_t_4) < 0) __PYX_ERR(0, 64, __pyx_L1_error)
+  if (__Pyx_SetItemOnTypeDict((PyObject *)__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter, __pyx_n_s_get_split, __pyx_t_4) < 0) __PYX_ERR(0, 59, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   PyType_Modified(__pyx_ptype_5adaXT_13decision_tree_8splitter_Splitter);
 
   /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError, "self.class_labels,self.n_in_class cannot be converted to a Python object for pickling"
  * def __setstate_cython__(self, __pyx_state):
@@ -23674,16 +23527,16 @@
   __pyx_t_4 = __Pyx_CyFunction_New(&__pyx_mdef_5adaXT_13decision_tree_8splitter_8Splitter_7__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Splitter___setstate_cython, NULL, __pyx_n_s_adaXT_decision_tree_splitter, __pyx_d, ((PyObject *)__pyx_codeobj__28)); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 3, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_4) < 0) __PYX_ERR(1, 3, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
   /* "adaXT/decision_tree/splitter.pyx":1
  * # cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False             # <<<<<<<<<<<<<<
- * 
  * import numpy as np
+ * cimport numpy as cnp
  */
   __pyx_t_4 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_4) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
   /*--- Wrapped vars code ---*/
@@ -26168,590 +26021,16 @@
     } else {
         Py_DECREF(r);
         return 1;
     }
 }
 #endif
 
-/* IsLittleEndian */
-static CYTHON_INLINE int __Pyx_Is_Little_Endian(void)
-{
-  union {
-    uint32_t u32;
-    uint8_t u8[4];
-  } S;
-  S.u32 = 0x01020304;
-  return S.u8[0] == 4;
-}
-
-/* BufferFormatCheck */
-static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
-                              __Pyx_BufFmt_StackElem* stack,
-                              __Pyx_TypeInfo* type) {
-  stack[0].field = &ctx->root;
-  stack[0].parent_offset = 0;
-  ctx->root.type = type;
-  ctx->root.name = "buffer dtype";
-  ctx->root.offset = 0;
-  ctx->head = stack;
-  ctx->head->field = &ctx->root;
-  ctx->fmt_offset = 0;
-  ctx->head->parent_offset = 0;
-  ctx->new_packmode = '@';
-  ctx->enc_packmode = '@';
-  ctx->new_count = 1;
-  ctx->enc_count = 0;
-  ctx->enc_type = 0;
-  ctx->is_complex = 0;
-  ctx->is_valid_array = 0;
-  ctx->struct_alignment = 0;
-  while (type->typegroup == 'S') {
-    ++ctx->head;
-    ctx->head->field = type->fields;
-    ctx->head->parent_offset = 0;
-    type = type->fields->type;
-  }
-}
-static int __Pyx_BufFmt_ParseNumber(const char** ts) {
-    int count;
-    const char* t = *ts;
-    if (*t < '0' || *t > '9') {
-      return -1;
-    } else {
-        count = *t++ - '0';
-        while (*t >= '0' && *t <= '9') {
-            count *= 10;
-            count += *t++ - '0';
-        }
-    }
-    *ts = t;
-    return count;
-}
-static int __Pyx_BufFmt_ExpectNumber(const char **ts) {
-    int number = __Pyx_BufFmt_ParseNumber(ts);
-    if (number == -1)
-        PyErr_Format(PyExc_ValueError,\
-                     "Does not understand character buffer dtype format string ('%c')", **ts);
-    return number;
-}
-static void __Pyx_BufFmt_RaiseUnexpectedChar(char ch) {
-  PyErr_Format(PyExc_ValueError,
-               "Unexpected format string character: '%c'", ch);
-}
-static const char* __Pyx_BufFmt_DescribeTypeChar(char ch, int is_complex) {
-  switch (ch) {
-    case '?': return "'bool'";
-    case 'c': return "'char'";
-    case 'b': return "'signed char'";
-    case 'B': return "'unsigned char'";
-    case 'h': return "'short'";
-    case 'H': return "'unsigned short'";
-    case 'i': return "'int'";
-    case 'I': return "'unsigned int'";
-    case 'l': return "'long'";
-    case 'L': return "'unsigned long'";
-    case 'q': return "'long long'";
-    case 'Q': return "'unsigned long long'";
-    case 'f': return (is_complex ? "'complex float'" : "'float'");
-    case 'd': return (is_complex ? "'complex double'" : "'double'");
-    case 'g': return (is_complex ? "'complex long double'" : "'long double'");
-    case 'T': return "a struct";
-    case 'O': return "Python object";
-    case 'P': return "a pointer";
-    case 's': case 'p': return "a string";
-    case 0: return "end";
-    default: return "unparsable format string";
-  }
-}
-static size_t __Pyx_BufFmt_TypeCharToStandardSize(char ch, int is_complex) {
-  switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
-    case 'h': case 'H': return 2;
-    case 'i': case 'I': case 'l': case 'L': return 4;
-    case 'q': case 'Q': return 8;
-    case 'f': return (is_complex ? 8 : 4);
-    case 'd': return (is_complex ? 16 : 8);
-    case 'g': {
-      PyErr_SetString(PyExc_ValueError, "Python does not define a standard format string size for long double ('g')..");
-      return 0;
-    }
-    case 'O': case 'P': return sizeof(void*);
-    default:
-      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
-      return 0;
-    }
-}
-static size_t __Pyx_BufFmt_TypeCharToNativeSize(char ch, int is_complex) {
-  switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
-    case 'h': case 'H': return sizeof(short);
-    case 'i': case 'I': return sizeof(int);
-    case 'l': case 'L': return sizeof(long);
-    #ifdef HAVE_LONG_LONG
-    case 'q': case 'Q': return sizeof(PY_LONG_LONG);
-    #endif
-    case 'f': return sizeof(float) * (is_complex ? 2 : 1);
-    case 'd': return sizeof(double) * (is_complex ? 2 : 1);
-    case 'g': return sizeof(long double) * (is_complex ? 2 : 1);
-    case 'O': case 'P': return sizeof(void*);
-    default: {
-      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
-      return 0;
-    }
-  }
-}
-typedef struct { char c; short x; } __Pyx_st_short;
-typedef struct { char c; int x; } __Pyx_st_int;
-typedef struct { char c; long x; } __Pyx_st_long;
-typedef struct { char c; float x; } __Pyx_st_float;
-typedef struct { char c; double x; } __Pyx_st_double;
-typedef struct { char c; long double x; } __Pyx_st_longdouble;
-typedef struct { char c; void *x; } __Pyx_st_void_p;
-#ifdef HAVE_LONG_LONG
-typedef struct { char c; PY_LONG_LONG x; } __Pyx_st_longlong;
-#endif
-static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, int is_complex) {
-  CYTHON_UNUSED_VAR(is_complex);
-  switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
-    case 'h': case 'H': return sizeof(__Pyx_st_short) - sizeof(short);
-    case 'i': case 'I': return sizeof(__Pyx_st_int) - sizeof(int);
-    case 'l': case 'L': return sizeof(__Pyx_st_long) - sizeof(long);
-#ifdef HAVE_LONG_LONG
-    case 'q': case 'Q': return sizeof(__Pyx_st_longlong) - sizeof(PY_LONG_LONG);
-#endif
-    case 'f': return sizeof(__Pyx_st_float) - sizeof(float);
-    case 'd': return sizeof(__Pyx_st_double) - sizeof(double);
-    case 'g': return sizeof(__Pyx_st_longdouble) - sizeof(long double);
-    case 'P': case 'O': return sizeof(__Pyx_st_void_p) - sizeof(void*);
-    default:
-      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
-      return 0;
-    }
-}
-/* These are for computing the padding at the end of the struct to align
-   on the first member of the struct. This will probably the same as above,
-   but we don't have any guarantees.
- */
-typedef struct { short x; char c; } __Pyx_pad_short;
-typedef struct { int x; char c; } __Pyx_pad_int;
-typedef struct { long x; char c; } __Pyx_pad_long;
-typedef struct { float x; char c; } __Pyx_pad_float;
-typedef struct { double x; char c; } __Pyx_pad_double;
-typedef struct { long double x; char c; } __Pyx_pad_longdouble;
-typedef struct { void *x; char c; } __Pyx_pad_void_p;
-#ifdef HAVE_LONG_LONG
-typedef struct { PY_LONG_LONG x; char c; } __Pyx_pad_longlong;
-#endif
-static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, int is_complex) {
-  CYTHON_UNUSED_VAR(is_complex);
-  switch (ch) {
-    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
-    case 'h': case 'H': return sizeof(__Pyx_pad_short) - sizeof(short);
-    case 'i': case 'I': return sizeof(__Pyx_pad_int) - sizeof(int);
-    case 'l': case 'L': return sizeof(__Pyx_pad_long) - sizeof(long);
-#ifdef HAVE_LONG_LONG
-    case 'q': case 'Q': return sizeof(__Pyx_pad_longlong) - sizeof(PY_LONG_LONG);
-#endif
-    case 'f': return sizeof(__Pyx_pad_float) - sizeof(float);
-    case 'd': return sizeof(__Pyx_pad_double) - sizeof(double);
-    case 'g': return sizeof(__Pyx_pad_longdouble) - sizeof(long double);
-    case 'P': case 'O': return sizeof(__Pyx_pad_void_p) - sizeof(void*);
-    default:
-      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
-      return 0;
-    }
-}
-static char __Pyx_BufFmt_TypeCharToGroup(char ch, int is_complex) {
-  switch (ch) {
-    case 'c':
-        return 'H';
-    case 'b': case 'h': case 'i':
-    case 'l': case 'q': case 's': case 'p':
-        return 'I';
-    case '?': case 'B': case 'H': case 'I': case 'L': case 'Q':
-        return 'U';
-    case 'f': case 'd': case 'g':
-        return (is_complex ? 'C' : 'R');
-    case 'O':
-        return 'O';
-    case 'P':
-        return 'P';
-    default: {
-      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
-      return 0;
-    }
-  }
-}
-static void __Pyx_BufFmt_RaiseExpected(__Pyx_BufFmt_Context* ctx) {
-  if (ctx->head == NULL || ctx->head->field == &ctx->root) {
-    const char* expected;
-    const char* quote;
-    if (ctx->head == NULL) {
-      expected = "end";
-      quote = "";
-    } else {
-      expected = ctx->head->field->type->name;
-      quote = "'";
-    }
-    PyErr_Format(PyExc_ValueError,
-                 "Buffer dtype mismatch, expected %s%s%s but got %s",
-                 quote, expected, quote,
-                 __Pyx_BufFmt_DescribeTypeChar(ctx->enc_type, ctx->is_complex));
-  } else {
-    __Pyx_StructField* field = ctx->head->field;
-    __Pyx_StructField* parent = (ctx->head - 1)->field;
-    PyErr_Format(PyExc_ValueError,
-                 "Buffer dtype mismatch, expected '%s' but got %s in '%s.%s'",
-                 field->type->name, __Pyx_BufFmt_DescribeTypeChar(ctx->enc_type, ctx->is_complex),
-                 parent->type->name, field->name);
-  }
-}
-static int __Pyx_BufFmt_ProcessTypeChunk(__Pyx_BufFmt_Context* ctx) {
-  char group;
-  size_t size, offset, arraysize = 1;
-  if (ctx->enc_type == 0) return 0;
-  if (ctx->head->field->type->arraysize[0]) {
-    int i, ndim = 0;
-    if (ctx->enc_type == 's' || ctx->enc_type == 'p') {
-        ctx->is_valid_array = ctx->head->field->type->ndim == 1;
-        ndim = 1;
-        if (ctx->enc_count != ctx->head->field->type->arraysize[0]) {
-            PyErr_Format(PyExc_ValueError,
-                         "Expected a dimension of size %zu, got %zu",
-                         ctx->head->field->type->arraysize[0], ctx->enc_count);
-            return -1;
-        }
-    }
-    if (!ctx->is_valid_array) {
-      PyErr_Format(PyExc_ValueError, "Expected %d dimensions, got %d",
-                   ctx->head->field->type->ndim, ndim);
-      return -1;
-    }
-    for (i = 0; i < ctx->head->field->type->ndim; i++) {
-      arraysize *= ctx->head->field->type->arraysize[i];
-    }
-    ctx->is_valid_array = 0;
-    ctx->enc_count = 1;
-  }
-  group = __Pyx_BufFmt_TypeCharToGroup(ctx->enc_type, ctx->is_complex);
-  do {
-    __Pyx_StructField* field = ctx->head->field;
-    __Pyx_TypeInfo* type = field->type;
-    if (ctx->enc_packmode == '@' || ctx->enc_packmode == '^') {
-      size = __Pyx_BufFmt_TypeCharToNativeSize(ctx->enc_type, ctx->is_complex);
-    } else {
-      size = __Pyx_BufFmt_TypeCharToStandardSize(ctx->enc_type, ctx->is_complex);
-    }
-    if (ctx->enc_packmode == '@') {
-      size_t align_at = __Pyx_BufFmt_TypeCharToAlignment(ctx->enc_type, ctx->is_complex);
-      size_t align_mod_offset;
-      if (align_at == 0) return -1;
-      align_mod_offset = ctx->fmt_offset % align_at;
-      if (align_mod_offset > 0) ctx->fmt_offset += align_at - align_mod_offset;
-      if (ctx->struct_alignment == 0)
-          ctx->struct_alignment = __Pyx_BufFmt_TypeCharToPadding(ctx->enc_type,
-                                                                 ctx->is_complex);
-    }
-    if (type->size != size || type->typegroup != group) {
-      if (type->typegroup == 'C' && type->fields != NULL) {
-        size_t parent_offset = ctx->head->parent_offset + field->offset;
-        ++ctx->head;
-        ctx->head->field = type->fields;
-        ctx->head->parent_offset = parent_offset;
-        continue;
-      }
-      if ((type->typegroup == 'H' || group == 'H') && type->size == size) {
-      } else {
-          __Pyx_BufFmt_RaiseExpected(ctx);
-          return -1;
-      }
-    }
-    offset = ctx->head->parent_offset + field->offset;
-    if (ctx->fmt_offset != offset) {
-      PyErr_Format(PyExc_ValueError,
-                   "Buffer dtype mismatch; next field is at offset %" CYTHON_FORMAT_SSIZE_T "d but %" CYTHON_FORMAT_SSIZE_T "d expected",
-                   (Py_ssize_t)ctx->fmt_offset, (Py_ssize_t)offset);
-      return -1;
-    }
-    ctx->fmt_offset += size;
-    if (arraysize)
-      ctx->fmt_offset += (arraysize - 1) * size;
-    --ctx->enc_count;
-    while (1) {
-      if (field == &ctx->root) {
-        ctx->head = NULL;
-        if (ctx->enc_count != 0) {
-          __Pyx_BufFmt_RaiseExpected(ctx);
-          return -1;
-        }
-        break;
-      }
-      ctx->head->field = ++field;
-      if (field->type == NULL) {
-        --ctx->head;
-        field = ctx->head->field;
-        continue;
-      } else if (field->type->typegroup == 'S') {
-        size_t parent_offset = ctx->head->parent_offset + field->offset;
-        if (field->type->fields->type == NULL) continue;
-        field = field->type->fields;
-        ++ctx->head;
-        ctx->head->field = field;
-        ctx->head->parent_offset = parent_offset;
-        break;
-      } else {
-        break;
-      }
-    }
-  } while (ctx->enc_count);
-  ctx->enc_type = 0;
-  ctx->is_complex = 0;
-  return 0;
-}
-static int
-__pyx_buffmt_parse_array(__Pyx_BufFmt_Context* ctx, const char** tsp)
-{
-    const char *ts = *tsp;
-    int i = 0, number, ndim;
-    ++ts;
-    if (ctx->new_count != 1) {
-        PyErr_SetString(PyExc_ValueError,
-                        "Cannot handle repeated arrays in format string");
-        return -1;
-    }
-    if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return -1;
-    ndim = ctx->head->field->type->ndim;
-    while (*ts && *ts != ')') {
-        switch (*ts) {
-            case ' ': case '\f': case '\r': case '\n': case '\t': case '\v':  continue;
-            default:  break;
-        }
-        number = __Pyx_BufFmt_ExpectNumber(&ts);
-        if (number == -1) return -1;
-        if (i < ndim && (size_t) number != ctx->head->field->type->arraysize[i]) {
-            PyErr_Format(PyExc_ValueError,
-                        "Expected a dimension of size %zu, got %d",
-                        ctx->head->field->type->arraysize[i], number);
-            return -1;
-        }
-        if (*ts != ',' && *ts != ')') {
-            PyErr_Format(PyExc_ValueError,
-                                "Expected a comma in format string, got '%c'", *ts);
-            return -1;
-        }
-        if (*ts == ',') ts++;
-        i++;
-    }
-    if (i != ndim) {
-        PyErr_Format(PyExc_ValueError, "Expected %d dimension(s), got %d",
-                            ctx->head->field->type->ndim, i);
-        return -1;
-    }
-    if (!*ts) {
-        PyErr_SetString(PyExc_ValueError,
-                        "Unexpected end of format string, expected ')'");
-        return -1;
-    }
-    ctx->is_valid_array = 1;
-    ctx->new_count = 1;
-    *tsp = ++ts;
-    return 0;
-}
-static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts) {
-  int got_Z = 0;
-  while (1) {
-    switch(*ts) {
-      case 0:
-        if (ctx->enc_type != 0 && ctx->head == NULL) {
-          __Pyx_BufFmt_RaiseExpected(ctx);
-          return NULL;
-        }
-        if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-        if (ctx->head != NULL) {
-          __Pyx_BufFmt_RaiseExpected(ctx);
-          return NULL;
-        }
-        return ts;
-      case ' ':
-      case '\r':
-      case '\n':
-        ++ts;
-        break;
-      case '<':
-        if (!__Pyx_Is_Little_Endian()) {
-          PyErr_SetString(PyExc_ValueError, "Little-endian buffer not supported on big-endian compiler");
-          return NULL;
-        }
-        ctx->new_packmode = '=';
-        ++ts;
-        break;
-      case '>':
-      case '!':
-        if (__Pyx_Is_Little_Endian()) {
-          PyErr_SetString(PyExc_ValueError, "Big-endian buffer not supported on little-endian compiler");
-          return NULL;
-        }
-        ctx->new_packmode = '=';
-        ++ts;
-        break;
-      case '=':
-      case '@':
-      case '^':
-        ctx->new_packmode = *ts++;
-        break;
-      case 'T':
-        {
-          const char* ts_after_sub;
-          size_t i, struct_count = ctx->new_count;
-          size_t struct_alignment = ctx->struct_alignment;
-          ctx->new_count = 1;
-          ++ts;
-          if (*ts != '{') {
-            PyErr_SetString(PyExc_ValueError, "Buffer acquisition: Expected '{' after 'T'");
-            return NULL;
-          }
-          if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-          ctx->enc_type = 0;
-          ctx->enc_count = 0;
-          ctx->struct_alignment = 0;
-          ++ts;
-          ts_after_sub = ts;
-          for (i = 0; i != struct_count; ++i) {
-            ts_after_sub = __Pyx_BufFmt_CheckString(ctx, ts);
-            if (!ts_after_sub) return NULL;
-          }
-          ts = ts_after_sub;
-          if (struct_alignment) ctx->struct_alignment = struct_alignment;
-        }
-        break;
-      case '}':
-        {
-          size_t alignment = ctx->struct_alignment;
-          ++ts;
-          if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-          ctx->enc_type = 0;
-          if (alignment && ctx->fmt_offset % alignment) {
-            ctx->fmt_offset += alignment - (ctx->fmt_offset % alignment);
-          }
-        }
-        return ts;
-      case 'x':
-        if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-        ctx->fmt_offset += ctx->new_count;
-        ctx->new_count = 1;
-        ctx->enc_count = 0;
-        ctx->enc_type = 0;
-        ctx->enc_packmode = ctx->new_packmode;
-        ++ts;
-        break;
-      case 'Z':
-        got_Z = 1;
-        ++ts;
-        if (*ts != 'f' && *ts != 'd' && *ts != 'g') {
-          __Pyx_BufFmt_RaiseUnexpectedChar('Z');
-          return NULL;
-        }
-        CYTHON_FALLTHROUGH;
-      case '?': case 'c': case 'b': case 'B': case 'h': case 'H': case 'i': case 'I':
-      case 'l': case 'L': case 'q': case 'Q':
-      case 'f': case 'd': case 'g':
-      case 'O': case 'p':
-        if ((ctx->enc_type == *ts) && (got_Z == ctx->is_complex) &&
-            (ctx->enc_packmode == ctx->new_packmode) && (!ctx->is_valid_array)) {
-          ctx->enc_count += ctx->new_count;
-          ctx->new_count = 1;
-          got_Z = 0;
-          ++ts;
-          break;
-        }
-        CYTHON_FALLTHROUGH;
-      case 's':
-        if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
-        ctx->enc_count = ctx->new_count;
-        ctx->enc_packmode = ctx->new_packmode;
-        ctx->enc_type = *ts;
-        ctx->is_complex = got_Z;
-        ++ts;
-        ctx->new_count = 1;
-        got_Z = 0;
-        break;
-      case ':':
-        ++ts;
-        while(*ts != ':') ++ts;
-        ++ts;
-        break;
-      case '(':
-        if (__pyx_buffmt_parse_array(ctx, &ts) < 0) return NULL;
-        break;
-      default:
-        {
-          int number = __Pyx_BufFmt_ExpectNumber(&ts);
-          if (number == -1) return NULL;
-          ctx->new_count = (size_t)number;
-        }
-    }
-  }
-}
-
-/* BufferGetAndValidate */
-  static CYTHON_INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info) {
-  if (unlikely(info->buf == NULL)) return;
-  if (info->suboffsets == __Pyx_minusones) info->suboffsets = NULL;
-  __Pyx_ReleaseBuffer(info);
-}
-static void __Pyx_ZeroBuffer(Py_buffer* buf) {
-  buf->buf = NULL;
-  buf->obj = NULL;
-  buf->strides = __Pyx_zeros;
-  buf->shape = __Pyx_zeros;
-  buf->suboffsets = __Pyx_minusones;
-}
-static int __Pyx__GetBufferAndValidate(
-        Py_buffer* buf, PyObject* obj,  __Pyx_TypeInfo* dtype, int flags,
-        int nd, int cast, __Pyx_BufFmt_StackElem* stack)
-{
-  buf->buf = NULL;
-  if (unlikely(__Pyx_GetBuffer(obj, buf, flags) == -1)) {
-    __Pyx_ZeroBuffer(buf);
-    return -1;
-  }
-  if (unlikely(buf->ndim != nd)) {
-    PyErr_Format(PyExc_ValueError,
-                 "Buffer has wrong number of dimensions (expected %d, got %d)",
-                 nd, buf->ndim);
-    goto fail;
-  }
-  if (!cast) {
-    __Pyx_BufFmt_Context ctx;
-    __Pyx_BufFmt_Init(&ctx, stack, dtype);
-    if (!__Pyx_BufFmt_CheckString(&ctx, buf->format)) goto fail;
-  }
-  if (unlikely((size_t)buf->itemsize != dtype->size)) {
-    PyErr_Format(PyExc_ValueError,
-      "Item size of buffer (%" CYTHON_FORMAT_SSIZE_T "d byte%s) does not match size of '%s' (%" CYTHON_FORMAT_SSIZE_T "d byte%s)",
-      buf->itemsize, (buf->itemsize > 1) ? "s" : "",
-      dtype->name, (Py_ssize_t)dtype->size, (dtype->size > 1) ? "s" : "");
-    goto fail;
-  }
-  if (buf->suboffsets == NULL) buf->suboffsets = __Pyx_minusones;
-  return 0;
-fail:;
-  __Pyx_SafeReleaseBuffer(buf);
-  return -1;
-}
-
-/* BufferFallbackError */
-  static void __Pyx_RaiseBufferFallbackError(void) {
-  PyErr_SetString(PyExc_ValueError,
-     "Buffer acquisition failed on assignment; and then reacquiring the old buffer failed too!");
-}
-
 /* PyObject_GenericGetAttrNoDict */
-  #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
     __Pyx_TypeName type_name = __Pyx_PyType_GetName(tp);
     PyErr_Format(PyExc_AttributeError,
 #if PY_MAJOR_VERSION >= 3
                  "'" __Pyx_FMT_TYPENAME "' object has no attribute '%U'",
                  type_name, attr_name);
 #else
@@ -26785,25 +26064,25 @@
         }
     }
     return descr;
 }
 #endif
 
 /* PyObject_GenericGetAttr */
-  #if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
+#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
 static PyObject* __Pyx_PyObject_GenericGetAttr(PyObject* obj, PyObject* attr_name) {
     if (unlikely(Py_TYPE(obj)->tp_dictoffset)) {
         return PyObject_GenericGetAttr(obj, attr_name);
     }
     return __Pyx_PyObject_GenericGetAttrNoDict(obj, attr_name);
 }
 #endif
 
 /* FixUpExtensionType */
-  #if CYTHON_USE_TYPE_SPECS
+#if CYTHON_USE_TYPE_SPECS
 static int __Pyx_fix_up_extension_type_from_spec(PyType_Spec *spec, PyTypeObject *type) {
 #if PY_VERSION_HEX > 0x030900B1 || CYTHON_COMPILING_IN_LIMITED_API
     CYTHON_UNUSED_VAR(spec);
     CYTHON_UNUSED_VAR(type);
 #else
     const PyType_Slot *slot = spec->slots;
     while (slot && slot->slot && slot->slot != Py_tp_members)
@@ -26868,21 +26147,21 @@
     }
 #endif
     return 0;
 }
 #endif
 
 /* PyObjectCallNoArg */
-  static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
+static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
     PyObject *arg[2] = {NULL, NULL};
     return __Pyx_PyObject_FastCall(func, arg + 1, 0 | __Pyx_PY_VECTORCALL_ARGUMENTS_OFFSET);
 }
 
 /* PyObjectGetMethod */
-  static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
+static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
     PyObject *attr;
 #if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
     __Pyx_TypeName type_name;
     PyTypeObject *tp = Py_TYPE(obj);
     PyObject *descr;
     descrgetfunc f = NULL;
     PyObject **dictptr, *dict;
@@ -26975,15 +26254,15 @@
     }
 #endif
     *method = attr;
     return 0;
 }
 
 /* PyObjectCallMethod0 */
-  static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name) {
+static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name) {
     PyObject *method = NULL, *result = NULL;
     int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
     if (likely(is_method)) {
         result = __Pyx_PyObject_CallOneArg(method, obj);
         Py_DECREF(method);
         return result;
     }
@@ -26991,15 +26270,15 @@
     result = __Pyx_PyObject_CallNoArg(method);
     Py_DECREF(method);
 bad:
     return result;
 }
 
 /* ValidateBasesTuple */
-  #if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
+#if CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API || CYTHON_USE_TYPE_SPECS
 static int __Pyx_validate_bases_tuple(const char *type_name, Py_ssize_t dictoffset, PyObject *bases) {
     Py_ssize_t i, n;
 #if CYTHON_ASSUME_SAFE_MACROS
     n = PyTuple_GET_SIZE(bases);
 #else
     n = PyTuple_Size(bases);
     if (n < 0) return -1;
@@ -27076,15 +26355,15 @@
 #endif
     }
     return 0;
 }
 #endif
 
 /* PyType_Ready */
-  static int __Pyx_PyType_Ready(PyTypeObject *t) {
+static int __Pyx_PyType_Ready(PyTypeObject *t) {
 #if CYTHON_USE_TYPE_SPECS || !(CYTHON_COMPILING_IN_CPYTHON || CYTHON_COMPILING_IN_LIMITED_API) || defined(PYSTON_MAJOR_VERSION)
     (void)__Pyx_PyObject_CallMethod0;
 #if CYTHON_USE_TYPE_SPECS
     (void)__Pyx_validate_bases_tuple;
 #endif
     return PyType_Ready(t);
 #else
@@ -27158,15 +26437,15 @@
     }
 #endif
     return r;
 #endif
 }
 
 /* SetVTable */
-  static int __Pyx_SetVtable(PyTypeObject *type, void *vtable) {
+static int __Pyx_SetVtable(PyTypeObject *type, void *vtable) {
     PyObject *ob = PyCapsule_New(vtable, 0, 0);
     if (unlikely(!ob))
         goto bad;
 #if CYTHON_COMPILING_IN_LIMITED_API
     if (unlikely(PyObject_SetAttr((PyObject *) type, __pyx_n_s_pyx_vtable, ob) < 0))
 #else
     if (unlikely(PyDict_SetItem(type->tp_dict, __pyx_n_s_pyx_vtable, ob) < 0))
@@ -27176,15 +26455,15 @@
     return 0;
 bad:
     Py_XDECREF(ob);
     return -1;
 }
 
 /* GetVTable */
-  static void* __Pyx_GetVtable(PyTypeObject *type) {
+static void* __Pyx_GetVtable(PyTypeObject *type) {
     void* ptr;
 #if CYTHON_COMPILING_IN_LIMITED_API
     PyObject *ob = PyObject_GetAttr((PyObject *)type, __pyx_n_s_pyx_vtable);
 #else
     PyObject *ob = PyObject_GetItem(type->tp_dict, __pyx_n_s_pyx_vtable);
 #endif
     if (!ob)
@@ -27196,15 +26475,15 @@
     return ptr;
 bad:
     Py_XDECREF(ob);
     return NULL;
 }
 
 /* MergeVTables */
-  #if !CYTHON_COMPILING_IN_LIMITED_API
+#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_MergeVtables(PyTypeObject *type) {
     int i;
     void** base_vtables;
     __Pyx_TypeName tp_base_name;
     __Pyx_TypeName base_name;
     void* unknown = (void*)-1;
     PyObject* bases = type->tp_bases;
@@ -27249,15 +26528,15 @@
     __Pyx_DECREF_TypeName(base_name);
     free(base_vtables);
     return -1;
 }
 #endif
 
 /* SetupReduce */
-  #if !CYTHON_COMPILING_IN_LIMITED_API
+#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __Pyx_setup_reduce_is_named(PyObject* meth, PyObject* name) {
   int ret;
   PyObject *name_attr;
   name_attr = __Pyx_PyObject_GetAttrStrNoError(meth, __pyx_n_s_name_2);
   if (likely(name_attr)) {
       ret = PyObject_RichCompareBool(name_attr, name, Py_EQ);
   } else {
@@ -27360,18 +26639,18 @@
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 #endif
 
 /* TypeImport */
-  #ifndef __PYX_HAVE_RT_ImportType_3_0_8
-#define __PYX_HAVE_RT_ImportType_3_0_8
-static PyTypeObject *__Pyx_ImportType_3_0_8(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_8 check_size)
+#ifndef __PYX_HAVE_RT_ImportType_3_0_10
+#define __PYX_HAVE_RT_ImportType_3_0_10
+static PyTypeObject *__Pyx_ImportType_3_0_10(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_3_0_10 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
     Py_ssize_t itemsize;
 #if CYTHON_COMPILING_IN_LIMITED_API
     PyObject *py_basicsize;
@@ -27417,38 +26696,38 @@
     if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize+itemsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error_3_0_8 &&
+    if (check_size == __Pyx_ImportType_CheckSize_Error_3_0_10 &&
             ((size_t)basicsize > size || (size_t)(basicsize + itemsize) < size)) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd-%zd from PyObject",
             module_name, class_name, size, basicsize, basicsize+itemsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn_3_0_8 && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_3_0_10 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
 bad:
     Py_XDECREF(result);
     return NULL;
 }
 #endif
 
 /* PyIntBinop */
-  #if !CYTHON_COMPILING_IN_PYPY
+#if !CYTHON_COMPILING_IN_PYPY
 static PyObject* __Pyx_PyInt_MultiplyCObj(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check) {
     CYTHON_MAYBE_UNUSED_VAR(intval);
     CYTHON_MAYBE_UNUSED_VAR(inplace);
     CYTHON_UNUSED_VAR(zerodivision_check);
     #if PY_MAJOR_VERSION < 3
     if (likely(PyInt_CheckExact(op2))) {
         const long a = intval;
@@ -27587,20 +26866,20 @@
             return PyFloat_FromDouble(result);
     }
     return (inplace ? PyNumber_InPlaceMultiply : PyNumber_Multiply)(op1, op2);
 }
 #endif
 
 /* FetchSharedCythonModule */
-  static PyObject *__Pyx_FetchSharedCythonABIModule(void) {
+static PyObject *__Pyx_FetchSharedCythonABIModule(void) {
     return __Pyx_PyImport_AddModuleRef((char*) __PYX_ABI_MODULE_NAME);
 }
 
 /* FetchCommonType */
-  static int __Pyx_VerifyCachedType(PyObject *cached_type,
+static int __Pyx_VerifyCachedType(PyObject *cached_type,
                                const char *name,
                                Py_ssize_t basicsize,
                                Py_ssize_t expected_basicsize) {
     if (!PyType_Check(cached_type)) {
         PyErr_Format(PyExc_TypeError,
             "Shared Cython type %.200s is not a type object", name);
         return -1;
@@ -27693,15 +26972,15 @@
     Py_XDECREF(cached_type);
     cached_type = NULL;
     goto done;
 }
 #endif
 
 /* PyVectorcallFastCallDict */
-  #if CYTHON_METH_FASTCALL
+#if CYTHON_METH_FASTCALL
 static PyObject *__Pyx_PyVectorcall_FastCallDict_kw(PyObject *func, __pyx_vectorcallfunc vc, PyObject *const *args, size_t nargs, PyObject *kw)
 {
     PyObject *res = NULL;
     PyObject *kwnames;
     PyObject **newargs;
     PyObject **kwvalues;
     Py_ssize_t i, pos;
@@ -27749,15 +27028,15 @@
         return vc(func, args, nargs, NULL);
     }
     return __Pyx_PyVectorcall_FastCallDict_kw(func, vc, args, nargs, kw);
 }
 #endif
 
 /* CythonFunctionShared */
-  #if CYTHON_COMPILING_IN_LIMITED_API
+#if CYTHON_COMPILING_IN_LIMITED_API
 static CYTHON_INLINE int __Pyx__IsSameCyOrCFunction(PyObject *func, void *cfunc) {
     if (__Pyx_CyFunction_Check(func)) {
         return PyCFunction_GetFunction(((__pyx_CyFunctionObject*)func)->func) == (PyCFunction) cfunc;
     } else if (PyCFunction_Check(func)) {
         return PyCFunction_GetFunction(func) == (PyCFunction) cfunc;
     }
     return 0;
@@ -28572,15 +27851,15 @@
         break;
     case 0:
         self = ((PyCFunctionObject*)cyfunc)->m_self;
         break;
     default:
         return NULL;
     }
-    return ((_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
+    return ((__Pyx_PyCFunctionFastWithKeywords)(void(*)(void))def->ml_meth)(self, args, nargs, kwnames);
 }
 static PyObject * __Pyx_CyFunction_Vectorcall_FASTCALL_KEYWORDS_METHOD(PyObject *func, PyObject *const *args, size_t nargsf, PyObject *kwnames)
 {
     __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *)func;
     PyMethodDef* def = ((PyCFunctionObject*)cyfunc)->m_ml;
     PyTypeObject *cls = (PyTypeObject *) __Pyx_CyFunction_GetClassObj(cyfunc);
 #if CYTHON_BACKPORT_VECTORCALL
@@ -28751,28 +28030,28 @@
 static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
     __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
     m->func_annotations = dict;
     Py_INCREF(dict);
 }
 
 /* CythonFunction */
-  static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
+static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
     PyObject *op = __Pyx_CyFunction_Init(
         PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
         ml, flags, qualname, closure, module, globals, code
     );
     if (likely(op)) {
         PyObject_GC_Track(op);
     }
     return op;
 }
 
 /* CLineInTraceback */
-  #ifndef CYTHON_CLINE_IN_TRACEBACK
+#ifndef CYTHON_CLINE_IN_TRACEBACK
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
     PyObject *ptype, *pvalue, *ptraceback;
 #if CYTHON_COMPILING_IN_CPYTHON
     PyObject **cython_runtime_dict;
 #endif
     CYTHON_MAYBE_UNUSED_VAR(tstate);
@@ -28807,15 +28086,15 @@
     }
     __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
     return c_line;
 }
 #endif
 
 /* CodeObjectCache */
-  #if !CYTHON_COMPILING_IN_LIMITED_API
+#if !CYTHON_COMPILING_IN_LIMITED_API
 static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
     int start = 0, mid = 0, end = count - 1;
     if (end >= 0 && code_line > entries[end].code_line) {
         return count;
     }
     while (start < end) {
         mid = start + (end - start) / 2;
@@ -28889,15 +28168,15 @@
     entries[pos].code_object = code_object;
     __pyx_code_cache.count++;
     Py_INCREF(code_object);
 }
 #endif
 
 /* AddTraceback */
-  #include "compile.h"
+#include "compile.h"
 #include "frameobject.h"
 #include "traceback.h"
 #if PY_VERSION_HEX >= 0x030b00a6 && !CYTHON_COMPILING_IN_LIMITED_API
   #ifndef Py_BUILD_CORE
     #define Py_BUILD_CORE 1
   #endif
   #include "internal/pycore_frame.h"
@@ -29107,16 +28386,16 @@
     if ((0)) {}
     view->obj = NULL;
     Py_DECREF(obj);
 }
 #endif
 
 
-  /* MemviewSliceIsContig */
-  static int
+/* MemviewSliceIsContig */
+static int
 __pyx_memviewslice_is_contig(const __Pyx_memviewslice mvs, char order, int ndim)
 {
     int i, index, step, start;
     Py_ssize_t itemsize = mvs.memview->view.itemsize;
     if (order == 'F') {
         step = 1;
         start = 0;
@@ -29130,15 +28409,15 @@
             return 0;
         itemsize *= mvs.shape[index];
     }
     return 1;
 }
 
 /* OverlappingSlices */
-  static void
+static void
 __pyx_get_array_memory_extents(__Pyx_memviewslice *slice,
                                void **out_start, void **out_end,
                                int ndim, size_t itemsize)
 {
     char *start, *end;
     int i;
     start = end = slice->data;
@@ -29165,14 +28444,535 @@
 {
     void *start1, *end1, *start2, *end2;
     __pyx_get_array_memory_extents(slice1, &start1, &end1, ndim, itemsize);
     __pyx_get_array_memory_extents(slice2, &start2, &end2, ndim, itemsize);
     return (start1 < end2) && (start2 < end1);
 }
 
+/* IsLittleEndian */
+static CYTHON_INLINE int __Pyx_Is_Little_Endian(void)
+{
+  union {
+    uint32_t u32;
+    uint8_t u8[4];
+  } S;
+  S.u32 = 0x01020304;
+  return S.u8[0] == 4;
+}
+
+/* BufferFormatCheck */
+static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
+                              __Pyx_BufFmt_StackElem* stack,
+                              __Pyx_TypeInfo* type) {
+  stack[0].field = &ctx->root;
+  stack[0].parent_offset = 0;
+  ctx->root.type = type;
+  ctx->root.name = "buffer dtype";
+  ctx->root.offset = 0;
+  ctx->head = stack;
+  ctx->head->field = &ctx->root;
+  ctx->fmt_offset = 0;
+  ctx->head->parent_offset = 0;
+  ctx->new_packmode = '@';
+  ctx->enc_packmode = '@';
+  ctx->new_count = 1;
+  ctx->enc_count = 0;
+  ctx->enc_type = 0;
+  ctx->is_complex = 0;
+  ctx->is_valid_array = 0;
+  ctx->struct_alignment = 0;
+  while (type->typegroup == 'S') {
+    ++ctx->head;
+    ctx->head->field = type->fields;
+    ctx->head->parent_offset = 0;
+    type = type->fields->type;
+  }
+}
+static int __Pyx_BufFmt_ParseNumber(const char** ts) {
+    int count;
+    const char* t = *ts;
+    if (*t < '0' || *t > '9') {
+      return -1;
+    } else {
+        count = *t++ - '0';
+        while (*t >= '0' && *t <= '9') {
+            count *= 10;
+            count += *t++ - '0';
+        }
+    }
+    *ts = t;
+    return count;
+}
+static int __Pyx_BufFmt_ExpectNumber(const char **ts) {
+    int number = __Pyx_BufFmt_ParseNumber(ts);
+    if (number == -1)
+        PyErr_Format(PyExc_ValueError,\
+                     "Does not understand character buffer dtype format string ('%c')", **ts);
+    return number;
+}
+static void __Pyx_BufFmt_RaiseUnexpectedChar(char ch) {
+  PyErr_Format(PyExc_ValueError,
+               "Unexpected format string character: '%c'", ch);
+}
+static const char* __Pyx_BufFmt_DescribeTypeChar(char ch, int is_complex) {
+  switch (ch) {
+    case '?': return "'bool'";
+    case 'c': return "'char'";
+    case 'b': return "'signed char'";
+    case 'B': return "'unsigned char'";
+    case 'h': return "'short'";
+    case 'H': return "'unsigned short'";
+    case 'i': return "'int'";
+    case 'I': return "'unsigned int'";
+    case 'l': return "'long'";
+    case 'L': return "'unsigned long'";
+    case 'q': return "'long long'";
+    case 'Q': return "'unsigned long long'";
+    case 'f': return (is_complex ? "'complex float'" : "'float'");
+    case 'd': return (is_complex ? "'complex double'" : "'double'");
+    case 'g': return (is_complex ? "'complex long double'" : "'long double'");
+    case 'T': return "a struct";
+    case 'O': return "Python object";
+    case 'P': return "a pointer";
+    case 's': case 'p': return "a string";
+    case 0: return "end";
+    default: return "unparsable format string";
+  }
+}
+static size_t __Pyx_BufFmt_TypeCharToStandardSize(char ch, int is_complex) {
+  switch (ch) {
+    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case 'h': case 'H': return 2;
+    case 'i': case 'I': case 'l': case 'L': return 4;
+    case 'q': case 'Q': return 8;
+    case 'f': return (is_complex ? 8 : 4);
+    case 'd': return (is_complex ? 16 : 8);
+    case 'g': {
+      PyErr_SetString(PyExc_ValueError, "Python does not define a standard format string size for long double ('g')..");
+      return 0;
+    }
+    case 'O': case 'P': return sizeof(void*);
+    default:
+      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
+      return 0;
+    }
+}
+static size_t __Pyx_BufFmt_TypeCharToNativeSize(char ch, int is_complex) {
+  switch (ch) {
+    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case 'h': case 'H': return sizeof(short);
+    case 'i': case 'I': return sizeof(int);
+    case 'l': case 'L': return sizeof(long);
+    #ifdef HAVE_LONG_LONG
+    case 'q': case 'Q': return sizeof(PY_LONG_LONG);
+    #endif
+    case 'f': return sizeof(float) * (is_complex ? 2 : 1);
+    case 'd': return sizeof(double) * (is_complex ? 2 : 1);
+    case 'g': return sizeof(long double) * (is_complex ? 2 : 1);
+    case 'O': case 'P': return sizeof(void*);
+    default: {
+      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
+      return 0;
+    }
+  }
+}
+typedef struct { char c; short x; } __Pyx_st_short;
+typedef struct { char c; int x; } __Pyx_st_int;
+typedef struct { char c; long x; } __Pyx_st_long;
+typedef struct { char c; float x; } __Pyx_st_float;
+typedef struct { char c; double x; } __Pyx_st_double;
+typedef struct { char c; long double x; } __Pyx_st_longdouble;
+typedef struct { char c; void *x; } __Pyx_st_void_p;
+#ifdef HAVE_LONG_LONG
+typedef struct { char c; PY_LONG_LONG x; } __Pyx_st_longlong;
+#endif
+static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, int is_complex) {
+  CYTHON_UNUSED_VAR(is_complex);
+  switch (ch) {
+    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case 'h': case 'H': return sizeof(__Pyx_st_short) - sizeof(short);
+    case 'i': case 'I': return sizeof(__Pyx_st_int) - sizeof(int);
+    case 'l': case 'L': return sizeof(__Pyx_st_long) - sizeof(long);
+#ifdef HAVE_LONG_LONG
+    case 'q': case 'Q': return sizeof(__Pyx_st_longlong) - sizeof(PY_LONG_LONG);
+#endif
+    case 'f': return sizeof(__Pyx_st_float) - sizeof(float);
+    case 'd': return sizeof(__Pyx_st_double) - sizeof(double);
+    case 'g': return sizeof(__Pyx_st_longdouble) - sizeof(long double);
+    case 'P': case 'O': return sizeof(__Pyx_st_void_p) - sizeof(void*);
+    default:
+      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
+      return 0;
+    }
+}
+/* These are for computing the padding at the end of the struct to align
+   on the first member of the struct. This will probably the same as above,
+   but we don't have any guarantees.
+ */
+typedef struct { short x; char c; } __Pyx_pad_short;
+typedef struct { int x; char c; } __Pyx_pad_int;
+typedef struct { long x; char c; } __Pyx_pad_long;
+typedef struct { float x; char c; } __Pyx_pad_float;
+typedef struct { double x; char c; } __Pyx_pad_double;
+typedef struct { long double x; char c; } __Pyx_pad_longdouble;
+typedef struct { void *x; char c; } __Pyx_pad_void_p;
+#ifdef HAVE_LONG_LONG
+typedef struct { PY_LONG_LONG x; char c; } __Pyx_pad_longlong;
+#endif
+static size_t __Pyx_BufFmt_TypeCharToPadding(char ch, int is_complex) {
+  CYTHON_UNUSED_VAR(is_complex);
+  switch (ch) {
+    case '?': case 'c': case 'b': case 'B': case 's': case 'p': return 1;
+    case 'h': case 'H': return sizeof(__Pyx_pad_short) - sizeof(short);
+    case 'i': case 'I': return sizeof(__Pyx_pad_int) - sizeof(int);
+    case 'l': case 'L': return sizeof(__Pyx_pad_long) - sizeof(long);
+#ifdef HAVE_LONG_LONG
+    case 'q': case 'Q': return sizeof(__Pyx_pad_longlong) - sizeof(PY_LONG_LONG);
+#endif
+    case 'f': return sizeof(__Pyx_pad_float) - sizeof(float);
+    case 'd': return sizeof(__Pyx_pad_double) - sizeof(double);
+    case 'g': return sizeof(__Pyx_pad_longdouble) - sizeof(long double);
+    case 'P': case 'O': return sizeof(__Pyx_pad_void_p) - sizeof(void*);
+    default:
+      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
+      return 0;
+    }
+}
+static char __Pyx_BufFmt_TypeCharToGroup(char ch, int is_complex) {
+  switch (ch) {
+    case 'c':
+        return 'H';
+    case 'b': case 'h': case 'i':
+    case 'l': case 'q': case 's': case 'p':
+        return 'I';
+    case '?': case 'B': case 'H': case 'I': case 'L': case 'Q':
+        return 'U';
+    case 'f': case 'd': case 'g':
+        return (is_complex ? 'C' : 'R');
+    case 'O':
+        return 'O';
+    case 'P':
+        return 'P';
+    default: {
+      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
+      return 0;
+    }
+  }
+}
+static void __Pyx_BufFmt_RaiseExpected(__Pyx_BufFmt_Context* ctx) {
+  if (ctx->head == NULL || ctx->head->field == &ctx->root) {
+    const char* expected;
+    const char* quote;
+    if (ctx->head == NULL) {
+      expected = "end";
+      quote = "";
+    } else {
+      expected = ctx->head->field->type->name;
+      quote = "'";
+    }
+    PyErr_Format(PyExc_ValueError,
+                 "Buffer dtype mismatch, expected %s%s%s but got %s",
+                 quote, expected, quote,
+                 __Pyx_BufFmt_DescribeTypeChar(ctx->enc_type, ctx->is_complex));
+  } else {
+    __Pyx_StructField* field = ctx->head->field;
+    __Pyx_StructField* parent = (ctx->head - 1)->field;
+    PyErr_Format(PyExc_ValueError,
+                 "Buffer dtype mismatch, expected '%s' but got %s in '%s.%s'",
+                 field->type->name, __Pyx_BufFmt_DescribeTypeChar(ctx->enc_type, ctx->is_complex),
+                 parent->type->name, field->name);
+  }
+}
+static int __Pyx_BufFmt_ProcessTypeChunk(__Pyx_BufFmt_Context* ctx) {
+  char group;
+  size_t size, offset, arraysize = 1;
+  if (ctx->enc_type == 0) return 0;
+  if (ctx->head->field->type->arraysize[0]) {
+    int i, ndim = 0;
+    if (ctx->enc_type == 's' || ctx->enc_type == 'p') {
+        ctx->is_valid_array = ctx->head->field->type->ndim == 1;
+        ndim = 1;
+        if (ctx->enc_count != ctx->head->field->type->arraysize[0]) {
+            PyErr_Format(PyExc_ValueError,
+                         "Expected a dimension of size %zu, got %zu",
+                         ctx->head->field->type->arraysize[0], ctx->enc_count);
+            return -1;
+        }
+    }
+    if (!ctx->is_valid_array) {
+      PyErr_Format(PyExc_ValueError, "Expected %d dimensions, got %d",
+                   ctx->head->field->type->ndim, ndim);
+      return -1;
+    }
+    for (i = 0; i < ctx->head->field->type->ndim; i++) {
+      arraysize *= ctx->head->field->type->arraysize[i];
+    }
+    ctx->is_valid_array = 0;
+    ctx->enc_count = 1;
+  }
+  group = __Pyx_BufFmt_TypeCharToGroup(ctx->enc_type, ctx->is_complex);
+  do {
+    __Pyx_StructField* field = ctx->head->field;
+    __Pyx_TypeInfo* type = field->type;
+    if (ctx->enc_packmode == '@' || ctx->enc_packmode == '^') {
+      size = __Pyx_BufFmt_TypeCharToNativeSize(ctx->enc_type, ctx->is_complex);
+    } else {
+      size = __Pyx_BufFmt_TypeCharToStandardSize(ctx->enc_type, ctx->is_complex);
+    }
+    if (ctx->enc_packmode == '@') {
+      size_t align_at = __Pyx_BufFmt_TypeCharToAlignment(ctx->enc_type, ctx->is_complex);
+      size_t align_mod_offset;
+      if (align_at == 0) return -1;
+      align_mod_offset = ctx->fmt_offset % align_at;
+      if (align_mod_offset > 0) ctx->fmt_offset += align_at - align_mod_offset;
+      if (ctx->struct_alignment == 0)
+          ctx->struct_alignment = __Pyx_BufFmt_TypeCharToPadding(ctx->enc_type,
+                                                                 ctx->is_complex);
+    }
+    if (type->size != size || type->typegroup != group) {
+      if (type->typegroup == 'C' && type->fields != NULL) {
+        size_t parent_offset = ctx->head->parent_offset + field->offset;
+        ++ctx->head;
+        ctx->head->field = type->fields;
+        ctx->head->parent_offset = parent_offset;
+        continue;
+      }
+      if ((type->typegroup == 'H' || group == 'H') && type->size == size) {
+      } else {
+          __Pyx_BufFmt_RaiseExpected(ctx);
+          return -1;
+      }
+    }
+    offset = ctx->head->parent_offset + field->offset;
+    if (ctx->fmt_offset != offset) {
+      PyErr_Format(PyExc_ValueError,
+                   "Buffer dtype mismatch; next field is at offset %" CYTHON_FORMAT_SSIZE_T "d but %" CYTHON_FORMAT_SSIZE_T "d expected",
+                   (Py_ssize_t)ctx->fmt_offset, (Py_ssize_t)offset);
+      return -1;
+    }
+    ctx->fmt_offset += size;
+    if (arraysize)
+      ctx->fmt_offset += (arraysize - 1) * size;
+    --ctx->enc_count;
+    while (1) {
+      if (field == &ctx->root) {
+        ctx->head = NULL;
+        if (ctx->enc_count != 0) {
+          __Pyx_BufFmt_RaiseExpected(ctx);
+          return -1;
+        }
+        break;
+      }
+      ctx->head->field = ++field;
+      if (field->type == NULL) {
+        --ctx->head;
+        field = ctx->head->field;
+        continue;
+      } else if (field->type->typegroup == 'S') {
+        size_t parent_offset = ctx->head->parent_offset + field->offset;
+        if (field->type->fields->type == NULL) continue;
+        field = field->type->fields;
+        ++ctx->head;
+        ctx->head->field = field;
+        ctx->head->parent_offset = parent_offset;
+        break;
+      } else {
+        break;
+      }
+    }
+  } while (ctx->enc_count);
+  ctx->enc_type = 0;
+  ctx->is_complex = 0;
+  return 0;
+}
+static int
+__pyx_buffmt_parse_array(__Pyx_BufFmt_Context* ctx, const char** tsp)
+{
+    const char *ts = *tsp;
+    int i = 0, number, ndim;
+    ++ts;
+    if (ctx->new_count != 1) {
+        PyErr_SetString(PyExc_ValueError,
+                        "Cannot handle repeated arrays in format string");
+        return -1;
+    }
+    if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return -1;
+    ndim = ctx->head->field->type->ndim;
+    while (*ts && *ts != ')') {
+        switch (*ts) {
+            case ' ': case '\f': case '\r': case '\n': case '\t': case '\v':  continue;
+            default:  break;
+        }
+        number = __Pyx_BufFmt_ExpectNumber(&ts);
+        if (number == -1) return -1;
+        if (i < ndim && (size_t) number != ctx->head->field->type->arraysize[i]) {
+            PyErr_Format(PyExc_ValueError,
+                        "Expected a dimension of size %zu, got %d",
+                        ctx->head->field->type->arraysize[i], number);
+            return -1;
+        }
+        if (*ts != ',' && *ts != ')') {
+            PyErr_Format(PyExc_ValueError,
+                                "Expected a comma in format string, got '%c'", *ts);
+            return -1;
+        }
+        if (*ts == ',') ts++;
+        i++;
+    }
+    if (i != ndim) {
+        PyErr_Format(PyExc_ValueError, "Expected %d dimension(s), got %d",
+                            ctx->head->field->type->ndim, i);
+        return -1;
+    }
+    if (!*ts) {
+        PyErr_SetString(PyExc_ValueError,
+                        "Unexpected end of format string, expected ')'");
+        return -1;
+    }
+    ctx->is_valid_array = 1;
+    ctx->new_count = 1;
+    *tsp = ++ts;
+    return 0;
+}
+static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts) {
+  int got_Z = 0;
+  while (1) {
+    switch(*ts) {
+      case 0:
+        if (ctx->enc_type != 0 && ctx->head == NULL) {
+          __Pyx_BufFmt_RaiseExpected(ctx);
+          return NULL;
+        }
+        if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
+        if (ctx->head != NULL) {
+          __Pyx_BufFmt_RaiseExpected(ctx);
+          return NULL;
+        }
+        return ts;
+      case ' ':
+      case '\r':
+      case '\n':
+        ++ts;
+        break;
+      case '<':
+        if (!__Pyx_Is_Little_Endian()) {
+          PyErr_SetString(PyExc_ValueError, "Little-endian buffer not supported on big-endian compiler");
+          return NULL;
+        }
+        ctx->new_packmode = '=';
+        ++ts;
+        break;
+      case '>':
+      case '!':
+        if (__Pyx_Is_Little_Endian()) {
+          PyErr_SetString(PyExc_ValueError, "Big-endian buffer not supported on little-endian compiler");
+          return NULL;
+        }
+        ctx->new_packmode = '=';
+        ++ts;
+        break;
+      case '=':
+      case '@':
+      case '^':
+        ctx->new_packmode = *ts++;
+        break;
+      case 'T':
+        {
+          const char* ts_after_sub;
+          size_t i, struct_count = ctx->new_count;
+          size_t struct_alignment = ctx->struct_alignment;
+          ctx->new_count = 1;
+          ++ts;
+          if (*ts != '{') {
+            PyErr_SetString(PyExc_ValueError, "Buffer acquisition: Expected '{' after 'T'");
+            return NULL;
+          }
+          if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
+          ctx->enc_type = 0;
+          ctx->enc_count = 0;
+          ctx->struct_alignment = 0;
+          ++ts;
+          ts_after_sub = ts;
+          for (i = 0; i != struct_count; ++i) {
+            ts_after_sub = __Pyx_BufFmt_CheckString(ctx, ts);
+            if (!ts_after_sub) return NULL;
+          }
+          ts = ts_after_sub;
+          if (struct_alignment) ctx->struct_alignment = struct_alignment;
+        }
+        break;
+      case '}':
+        {
+          size_t alignment = ctx->struct_alignment;
+          ++ts;
+          if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
+          ctx->enc_type = 0;
+          if (alignment && ctx->fmt_offset % alignment) {
+            ctx->fmt_offset += alignment - (ctx->fmt_offset % alignment);
+          }
+        }
+        return ts;
+      case 'x':
+        if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
+        ctx->fmt_offset += ctx->new_count;
+        ctx->new_count = 1;
+        ctx->enc_count = 0;
+        ctx->enc_type = 0;
+        ctx->enc_packmode = ctx->new_packmode;
+        ++ts;
+        break;
+      case 'Z':
+        got_Z = 1;
+        ++ts;
+        if (*ts != 'f' && *ts != 'd' && *ts != 'g') {
+          __Pyx_BufFmt_RaiseUnexpectedChar('Z');
+          return NULL;
+        }
+        CYTHON_FALLTHROUGH;
+      case '?': case 'c': case 'b': case 'B': case 'h': case 'H': case 'i': case 'I':
+      case 'l': case 'L': case 'q': case 'Q':
+      case 'f': case 'd': case 'g':
+      case 'O': case 'p':
+        if ((ctx->enc_type == *ts) && (got_Z == ctx->is_complex) &&
+            (ctx->enc_packmode == ctx->new_packmode) && (!ctx->is_valid_array)) {
+          ctx->enc_count += ctx->new_count;
+          ctx->new_count = 1;
+          got_Z = 0;
+          ++ts;
+          break;
+        }
+        CYTHON_FALLTHROUGH;
+      case 's':
+        if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
+        ctx->enc_count = ctx->new_count;
+        ctx->enc_packmode = ctx->new_packmode;
+        ctx->enc_type = *ts;
+        ctx->is_complex = got_Z;
+        ++ts;
+        ctx->new_count = 1;
+        got_Z = 0;
+        break;
+      case ':':
+        ++ts;
+        while(*ts != ':') ++ts;
+        ++ts;
+        break;
+      case '(':
+        if (__pyx_buffmt_parse_array(ctx, &ts) < 0) return NULL;
+        break;
+      default:
+        {
+          int number = __Pyx_BufFmt_ExpectNumber(&ts);
+          if (number == -1) return NULL;
+          ctx->new_count = (size_t)number;
+        }
+    }
+  }
+}
+
 /* TypeInfoCompare */
   static int
 __pyx_typeinfo_cmp(__Pyx_TypeInfo *a, __Pyx_TypeInfo *b)
 {
     int i;
     if (!a || !b)
         return 0;
@@ -29435,25 +29235,25 @@
 __pyx_fail:
     result.memview = NULL;
     result.data = NULL;
     return result;
 }
 
 /* ObjectToMemviewSlice */
-  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_ds_int(PyObject *obj, int writable_flag) {
+  static CYTHON_INLINE __Pyx_memviewslice __Pyx_PyObject_to_MemoryviewSlice_dc_int(PyObject *obj, int writable_flag) {
     __Pyx_memviewslice result = { 0, 0, { 0 }, { 0 }, { 0 } };
     __Pyx_BufFmt_StackElem stack[1];
-    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_STRIDED) };
+    int axes_specs[] = { (__Pyx_MEMVIEW_DIRECT | __Pyx_MEMVIEW_CONTIG) };
     int retcode;
     if (obj == Py_None) {
         result.memview = (struct __pyx_memoryview_obj *) Py_None;
         return result;
     }
-    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, 0,
-                                                 PyBUF_RECORDS_RO | writable_flag, 1,
+    retcode = __Pyx_ValidateAndInit_memviewslice(axes_specs, __Pyx_IS_C_CONTIG,
+                                                 (PyBUF_C_CONTIGUOUS | PyBUF_FORMAT) | writable_flag, 1,
                                                  &__Pyx_TypeInfo_int, stack,
                                                  &result, obj);
     if (unlikely(retcode == -1))
         goto __pyx_fail;
     return result;
 __pyx_fail:
     result.memview = NULL;
@@ -30373,14 +30173,78 @@
     return (int) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to int");
     return (int) -1;
 }
 
+/* CIntToPy */
+  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wconversion"
+#endif
+    const long neg_one = (long) -1, const_zero = (long) 0;
+#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
+#pragma GCC diagnostic pop
+#endif
+    const int is_unsigned = neg_one > const_zero;
+    if (is_unsigned) {
+        if (sizeof(long) < sizeof(long)) {
+            return PyInt_FromLong((long) value);
+        } else if (sizeof(long) <= sizeof(unsigned long)) {
+            return PyLong_FromUnsignedLong((unsigned long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
+            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
+#endif
+        }
+    } else {
+        if (sizeof(long) <= sizeof(long)) {
+            return PyInt_FromLong((long) value);
+#ifdef HAVE_LONG_LONG
+        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
+            return PyLong_FromLongLong((PY_LONG_LONG) value);
+#endif
+        }
+    }
+    {
+        int one = 1; int little = (int)*(unsigned char *)&one;
+        unsigned char *bytes = (unsigned char *)&value;
+#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
+        return _PyLong_FromByteArray(bytes, sizeof(long),
+                                     little, !is_unsigned);
+#else
+        PyObject *from_bytes, *result = NULL;
+        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
+        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
+        if (!from_bytes) return NULL;
+        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(long));
+        if (!py_bytes) goto limited_bad;
+        order_str = PyUnicode_FromString(little ? "little" : "big");
+        if (!order_str) goto limited_bad;
+        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
+        if (!arg_tuple) goto limited_bad;
+        if (!is_unsigned) {
+            kwds = PyDict_New();
+            if (!kwds) goto limited_bad;
+            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
+        }
+        result = PyObject_Call(from_bytes, arg_tuple, kwds);
+        limited_bad:
+        Py_XDECREF(kwds);
+        Py_XDECREF(arg_tuple);
+        Py_XDECREF(order_str);
+        Py_XDECREF(py_bytes);
+        Py_XDECREF(from_bytes);
+        return result;
+#endif
+    }
+}
+
 /* CIntFromPy */
   static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const long neg_one = (long) -1, const_zero = (long) 0;
@@ -30646,78 +30510,14 @@
     return (long) -1;
 raise_neg_overflow:
     PyErr_SetString(PyExc_OverflowError,
         "can't convert negative value to long");
     return (long) -1;
 }
 
-/* CIntToPy */
-  static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wconversion"
-#endif
-    const long neg_one = (long) -1, const_zero = (long) 0;
-#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
-#pragma GCC diagnostic pop
-#endif
-    const int is_unsigned = neg_one > const_zero;
-    if (is_unsigned) {
-        if (sizeof(long) < sizeof(long)) {
-            return PyInt_FromLong((long) value);
-        } else if (sizeof(long) <= sizeof(unsigned long)) {
-            return PyLong_FromUnsignedLong((unsigned long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
-            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
-#endif
-        }
-    } else {
-        if (sizeof(long) <= sizeof(long)) {
-            return PyInt_FromLong((long) value);
-#ifdef HAVE_LONG_LONG
-        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
-            return PyLong_FromLongLong((PY_LONG_LONG) value);
-#endif
-        }
-    }
-    {
-        int one = 1; int little = (int)*(unsigned char *)&one;
-        unsigned char *bytes = (unsigned char *)&value;
-#if !CYTHON_COMPILING_IN_LIMITED_API && PY_VERSION_HEX < 0x030d0000
-        return _PyLong_FromByteArray(bytes, sizeof(long),
-                                     little, !is_unsigned);
-#else
-        PyObject *from_bytes, *result = NULL;
-        PyObject *py_bytes = NULL, *arg_tuple = NULL, *kwds = NULL, *order_str = NULL;
-        from_bytes = PyObject_GetAttrString((PyObject*)&PyLong_Type, "from_bytes");
-        if (!from_bytes) return NULL;
-        py_bytes = PyBytes_FromStringAndSize((char*)bytes, sizeof(long));
-        if (!py_bytes) goto limited_bad;
-        order_str = PyUnicode_FromString(little ? "little" : "big");
-        if (!order_str) goto limited_bad;
-        arg_tuple = PyTuple_Pack(2, py_bytes, order_str);
-        if (!arg_tuple) goto limited_bad;
-        if (!is_unsigned) {
-            kwds = PyDict_New();
-            if (!kwds) goto limited_bad;
-            if (PyDict_SetItemString(kwds, "signed", __Pyx_NewRef(Py_True))) goto limited_bad;
-        }
-        result = PyObject_Call(from_bytes, arg_tuple, kwds);
-        limited_bad:
-        Py_XDECREF(kwds);
-        Py_XDECREF(arg_tuple);
-        Py_XDECREF(order_str);
-        Py_XDECREF(py_bytes);
-        Py_XDECREF(from_bytes);
-        return result;
-#endif
-    }
-}
-
 /* CIntFromPy */
   static CYTHON_INLINE char __Pyx_PyInt_As_char(PyObject *x) {
 #ifdef __Pyx_HAS_GCC_DIAGNOSTIC
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wconversion"
 #endif
     const char neg_one = (char) -1, const_zero = (char) 0;
```

### Comparing `adaXT-1.0.1/src/adaXT/decision_tree/tree_utils.py` & `adaxt-1.1.0/src/adaXT/decision_tree/tree_utils.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,44 +1,46 @@
 from . import DecisionTree, LeafNode, DecisionNode
-import numpy as np
-
+import textwrap
 # Plot an entire tree
 
 
 def plot_tree(tree: DecisionTree):
     """
-    Generates the tree as a subplot of plt. To show the plot,
-    the user needs to call mathplotlib.pyplot.show().
+    Generates the tree in a subplot of plt. To show the plot,
+    the user needs to call matplotlib.pyplot.show().
 
     Parameters
     ----------
     tree : DecisionTree
         the tree to plot
 
     Returns
     -------
     matplotlib.figure.Figure
         the figure of the subplot
     matplotlib.axes.Axes
         the axes of the subplot
     """
     import matplotlib.pyplot as plt
+
     fig, ax = plt.subplots(figsize=(8, 6))
     node_positions = calculate_node_positions(tree.root, x=0, y=0)
     plot_node(ax, tree.root, node_positions)
-    ax.axis('off')
+    ax.axis("off")
     return fig, ax
 
+
 # Plot a node
 
 
 def plot_node(ax, node: LeafNode | DecisionNode, node_positions: tuple):
     """
     Helper function used to plot each node of a DecisionTree
 
+
     Parameters
     ----------
     ax : matplotlib.axes.Axes
         axes to plot on
     node : Node
         node type of a tree
     node_positions : tuple
@@ -50,42 +52,61 @@
     position = node_positions[node]
 
     # Draw the node box
     if isinstance(node, LeafNode):
         ax.text(
             position[0],
             position[1],
-            f"Impurity: {node.impurity:.3f} \n samples: {node.n_samples}\n LEAF WITH VAL: {['%.2f' % x for x in node.value]}",
-            ha='center',
-            va='center',
-            bbox=dict(
-                facecolor='white',
-                edgecolor='black'))
+            textwrap.dedent(
+                f"""\
+            Leaf Node\n\
+            Impurity: {node.impurity:.3f}\n\
+            samples: {node.n_samples}\n\
+            value: {['%.2f' % x for x in node.value]}
+            """
+            ),
+            ha="center",
+            va="center",
+            bbox=dict(facecolor="white", edgecolor="black"),
+        )
     else:
         ax.text(
             position[0],
             position[1],
-            f"Decision WITH x{node.split_idx} <= {node.threshold:.3f}\n Impurity: {node.impurity:.3f} \n samples: {node.n_samples}",
-            ha='center',
-            va='center',
-            bbox=dict(
-                facecolor='white',
-                edgecolor='black'))
+            textwrap.dedent(
+                f"""\
+                Decision Node\n\
+                x{node.split_idx} <= {node.threshold:.3f}\n\
+                Impurity: {node.impurity:.3f}\n\
+                samples: {node.n_samples}
+                """
+            ),
+            ha="center",
+            va="center",
+            bbox=dict(facecolor="white", edgecolor="black"),
+        )
 
     # Draw edges and child nodes recursively
     if isinstance(node, DecisionNode):
         if node.left_child is not None:
-            ax.plot([position[0], node_positions[node.left_child][0]], [
-                    position[1], node_positions[node.left_child][1]], color='black')
+            ax.plot(
+                [position[0], node_positions[node.left_child][0]],
+                [position[1], node_positions[node.left_child][1]],
+                color="black",
+            )
             plot_node(ax, node.left_child, node_positions)
         if node.right_child is not None:
-            ax.plot([position[0], node_positions[node.right_child][0]], [
-                    position[1], node_positions[node.right_child][1]], color='black')
+            ax.plot(
+                [position[0], node_positions[node.right_child][0]],
+                [position[1], node_positions[node.right_child][1]],
+                color="black",
+            )
             plot_node(ax, node.right_child, node_positions)
 
+
 # Calculate where to add nodes when plotting a tree
 
 
 def calculate_node_positions(
         node: LeafNode | DecisionNode,
         x: float,
         y: float):
@@ -105,14 +126,15 @@
 
     position = (x, y)
 
     node_positions = {**left_positions, **right_positions, node: position}
 
     return node_positions
 
+
 # Function to print the information of a tree
 
 
 def print_tree(tree: DecisionTree):
     queue = []
     queue.append(tree.root)
     while len(queue) > 0:
```

### Comparing `adaXT-1.0.1/tests/test_decision_tree.py` & `adaxt-1.1.0/tests/test_decision_tree.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 from adaXT.decision_tree import DecisionTree, LeafNode, DecisionNode
 from adaXT.criteria import Gini_index, Squared_error, Entropy, Linear_regression
-import numpy as np
-import scipy
 
+import numpy as np
 import scipy
 
 
 def rec_node(node: LeafNode | DecisionNode | None, depth: int) -> None:
     """
     Used to check the depth value associated with nodes
 
@@ -14,271 +13,313 @@
     ----------
     node : LeafNode | DecisionNode | None
         node to recurse on
     depth : int
         expected depth of the node
     """
     if isinstance(node, LeafNode) or isinstance(node, DecisionNode):
-        assert node.depth == depth, f'Incorrect depth, expected {depth} got {node.depth}'
+        assert (
+            node.depth == depth
+        ), f"Incorrect depth, expected {depth} got {node.depth}"
         if isinstance(node, DecisionNode):
             rec_node(node.left_child, depth + 1)
 
 
 def test_gini_single():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_cla = np.array([1, -1, 1, -1, 1, -1, 1, -1])
-
     tree = DecisionTree("Classification", criteria=Gini_index)
     tree.fit(X, Y_cla)
     root = tree.root
     exp_val = [0.25, -0.75, 0]
     spl_idx = [0, 0, 1]
     assert isinstance(root, LeafNode) or isinstance(
-        root, DecisionNode), f"root is not a node but {type(root)}"
+        root, DecisionNode
+    ), f"root is not a node but {type(root)}"
     queue = [root]
     i = 0
 
     # Loop over all the nodes
     while len(queue) > 0:
         cur_node = queue.pop()
         if isinstance(
-                cur_node,
-                DecisionNode):  # Check threshold and idx of decision node
-            assert cur_node.threshold == exp_val[
-                i], f'Expected threshold {exp_val[i]} on node={i}, got {cur_node.threshold} on split_idx {cur_node.split_idx} exp: {spl_idx[i]}'
-            assert cur_node.split_idx == spl_idx[
-                i], f'Expected split idx {spl_idx[i]} on i={i}, got {cur_node.split_idx}'
+            cur_node, DecisionNode
+        ):  # Check threshold and idx of decision node
+            assert (
+                cur_node.threshold == exp_val[i]
+            ), f"Expected threshold {exp_val[i]} on node={i}, got {cur_node.threshold} on split_idx {cur_node.split_idx} exp: {spl_idx[i]}"
+            assert (
+                cur_node.split_idx == spl_idx[i]
+            ), f"Expected split idx {spl_idx[i]} on i={i}, got {cur_node.split_idx}"
             if cur_node.left_child:
                 queue.append(cur_node.left_child)
             if cur_node.right_child:
                 queue.append(cur_node.right_child)
             i += 1
         elif isinstance(cur_node, LeafNode):  # Check that the value is of length 2
-            assert len(
-                cur_node.value) == 2, f'Expected 2 mean values, one for each class, but got: {len(cur_node.value)}'
+            assert (
+                len(cur_node.value) == 2
+            ), f"Expected 2 mean values, one for each class, but got: {len(cur_node.value)}"
 
     rec_node(root, 0)
 
 
 def test_gini_multi():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_multi = np.array([1, 2, 1, 0, 1, 0, 1, 0])
     Y_unique = len(np.unique(Y_multi))
     tree = DecisionTree("Classification", criteria=Gini_index)
     tree.fit(X, Y_multi)
     root = tree.root
     # DIFFERENT FROM SKLEARN THEIRS IS: [0.25, -0.75, -1.5], both give pure
     # leaf node
     exp_val = [0.25, -0.75, -0.75]
     # DIFFERENT FROM SKLEARN THEIRS IS: [0, 1, 1], both give pure leaf node
     spl_idx = [0, 1, 0]
     assert isinstance(root, LeafNode) or isinstance(
-        root, DecisionNode), f"root is not a node but {type(root)}"
+        root, DecisionNode
+    ), f"root is not a node but {type(root)}"
     queue = [root]
     i = 0
     while len(queue) > 0:
         cur_node = queue.pop()
         if isinstance(cur_node, DecisionNode):
-            assert cur_node.threshold == exp_val[
-                i], f'Expected threshold {exp_val[i]}, got {cur_node.threshold}'
-            assert cur_node.split_idx == spl_idx[
-                i], f'Expected split idx {spl_idx[i]}, got {cur_node.split_idx}'
+            assert (
+                cur_node.threshold == exp_val[i]
+            ), f"Expected threshold {exp_val[i]}, got {cur_node.threshold}"
+            assert (
+                cur_node.split_idx == spl_idx[i]
+            ), f"Expected split idx {spl_idx[i]}, got {cur_node.split_idx}"
             if cur_node.left_child:
                 queue.append(cur_node.left_child)
             if cur_node.right_child:
                 queue.append(cur_node.right_child)
             i += 1
         elif isinstance(cur_node, LeafNode):
-            assert len(
-                cur_node.value) == Y_unique, f'Expected {Y_unique} mean values, one for each class, but got: {len(cur_node.value)}'
+            assert (
+                len(cur_node.value) == Y_unique
+            ), f"Expected {Y_unique} mean values, one for each class, but got: {len(cur_node.value)}"
 
     rec_node(root, 0)
 
 
 def test_regression():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_reg = np.array([2.2, -0.5, 0.5, -0.5, 2, -3, 2.2, -3])
     tree = DecisionTree("Regression", criteria=Squared_error)
     tree.fit(X, Y_reg)
     root = tree.root
     exp_val2 = [0.25, -0.5, 0.5, 0.25, -0.75]
     spl_idx2 = [0, 1, 1, 1, 0]
     assert isinstance(root, LeafNode) or isinstance(
-        root, DecisionNode), f"root is not a node but {type(root)}"
+        root, DecisionNode
+    ), f"root is not a node but {type(root)}"
     queue = [root]
     i = 0
     while len(queue) > 0:
         cur_node = queue.pop()
         if isinstance(cur_node, DecisionNode):
-            assert cur_node.threshold == exp_val2[
-                i], f'Expected threshold {exp_val2[i]}, got {cur_node.threshold}'
-            assert cur_node.split_idx == spl_idx2[
-                i], f'Expected split idx {spl_idx2[i]}, got {cur_node.split_idx}'
+            assert (
+                cur_node.threshold == exp_val2[i]
+            ), f"Expected threshold {exp_val2[i]}, got {cur_node.threshold}"
+            assert (
+                cur_node.split_idx == spl_idx2[i]
+            ), f"Expected split idx {spl_idx2[i]}, got {cur_node.split_idx}"
             if cur_node.left_child:
                 queue.append(cur_node.left_child)
             if cur_node.right_child:
                 queue.append(cur_node.right_child)
             i += 1
         elif isinstance(cur_node, LeafNode):
-            assert len(
-                cur_node.value) == 1, f'Expected {1} mean values, but got: {len(cur_node.value)}'
+            assert (
+                len(cur_node.value) == 1
+            ), f"Expected {1} mean values, but got: {len(cur_node.value)}"
     rec_node(root, 0)
 
 
 def test_entropy_single():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_cla = np.array([1, -1, 1, -1, 1, -1, 1, -1])
-
     tree = DecisionTree("Classification", criteria=Entropy)
     tree.fit(X, Y_cla)
     root = tree.root
     exp_val = [0.25, -0.75, 0]
     spl_idx = [0, 0, 1]
     assert isinstance(root, LeafNode) or isinstance(
-        root, DecisionNode), f"root is not a node but {type(root)}"
+        root, DecisionNode
+    ), f"root is not a node but {type(root)}"
     queue = [root]
     i = 0
     # Loop over all the nodes
     while len(queue) > 0:
         cur_node = queue.pop()
         if isinstance(
-                cur_node,
-                DecisionNode):  # Check threshold and idx of decision node
-            assert cur_node.threshold == exp_val[
-                i], f'Expected threshold {exp_val[i]} on node={i}, got {cur_node.threshold} on split_idx {cur_node.split_idx} exp: {spl_idx[i]}'
-            assert cur_node.split_idx == spl_idx[
-                i], f'Expected split idx {spl_idx[i]} on i={i}, got {cur_node.split_idx}'
+            cur_node, DecisionNode
+        ):  # Check threshold and idx of decision node
+            assert (
+                cur_node.threshold == exp_val[i]
+            ), f"Expected threshold {exp_val[i]} on node={i}, got {cur_node.threshold} on split_idx {cur_node.split_idx} exp: {spl_idx[i]}"
+            assert (
+                cur_node.split_idx == spl_idx[i]
+            ), f"Expected split idx {spl_idx[i]} on i={i}, got {cur_node.split_idx}"
             if cur_node.left_child:
                 queue.append(cur_node.left_child)
             if cur_node.right_child:
                 queue.append(cur_node.right_child)
             i += 1
         elif isinstance(cur_node, LeafNode):  # Check that the value is of length 2
-            assert len(
-                cur_node.value) == 2, f'Expected 2 mean values, one for each class, but got: {len(cur_node.value)}'
+            assert (
+                len(cur_node.value) == 2
+            ), f"Expected 2 mean values, one for each class, but got: {len(cur_node.value)}"
 
     rec_node(root, 0)
 
 
 def test_entropy_multi():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_multi = np.array([1, 2, 1, 0, 1, 0, 1, 0])
     Y_unique = len(np.unique(Y_multi))
     tree = DecisionTree("Classification", criteria=Entropy)
     tree.fit(X, Y_multi)
     root = tree.root
     # DIFFERENT FROM SKLEARN THEIRS IS: [0.25, -0.75, -1.5], both give pure
     # leaf node
     exp_val = [0.25, -0.75, -0.75]
     # DIFFERENT FROM SKLEARN THEIRS IS: [0, 1, 1], both give pure leaf node
     spl_idx = [0, 1, 0]
     assert isinstance(root, LeafNode) or isinstance(
-        root, DecisionNode), f"root is not a node but {type(root)}"
+        root, DecisionNode
+    ), f"root is not a node but {type(root)}"
     queue = [root]
     i = 0
     while len(queue) > 0:
         cur_node = queue.pop()
         if isinstance(cur_node, DecisionNode):
-            assert cur_node.threshold == exp_val[
-                i], f'Expected threshold {exp_val[i]}, got {cur_node.threshold}'
-            assert cur_node.split_idx == spl_idx[
-                i], f'Expected split idx {spl_idx[i]}, got {cur_node.split_idx}'
+            assert (
+                cur_node.threshold == exp_val[i]
+            ), f"Expected threshold {exp_val[i]}, got {cur_node.threshold}"
+            assert (
+                cur_node.split_idx == spl_idx[i]
+            ), f"Expected split idx {spl_idx[i]}, got {cur_node.split_idx}"
             if cur_node.left_child:
                 queue.append(cur_node.left_child)
             if cur_node.right_child:
                 queue.append(cur_node.right_child)
             i += 1
         elif isinstance(cur_node, LeafNode):
-            assert len(
-                cur_node.value) == Y_unique, f'Expected {Y_unique} mean values, one for each class, but got: {len(cur_node.value)}'
+            assert (
+                len(cur_node.value) == Y_unique
+            ), f"Expected {Y_unique} mean values, one for each class, but got: {len(cur_node.value)}"
 
     rec_node(root, 0)
 
 
 def sanity_regression(n, m):
     X = np.random.uniform(0, 100, (n, m))
     Y1 = np.random.randint(0, 5, n)
     Y2 = np.random.uniform(0, 5, n)
 
-    tree1 = DecisionTree("Regression", Squared_error)
-    tree2 = DecisionTree("Regression", Squared_error)
+    tree1 = DecisionTree("Regression", criteria=Squared_error)
+    tree2 = DecisionTree("Regression", criteria=Squared_error)
     tree1.fit(X, Y1)
     tree2.fit(X, Y2)
     pred1 = tree1.predict(X)
     pred2 = tree2.predict(X)
     for i in range(n):
-        assert abs(
-            Y1[i] - pred1[i]) < 0.00001, f"Square: Expected {Y1[i]} Got {pred1[i]}"
-        assert abs(
-            Y2[i] - pred2[i]) < 0.00001, f"Square: Expected {Y2[i]} Got {pred2[i]}"
+        assert (
+            abs(Y1[i] - pred1[i]) < 0.00001
+        ), f"Square: Expected {Y1[i]} Got {pred1[i]}"
+        assert (
+            abs(Y2[i] - pred2[i]) < 0.00001
+        ), f"Square: Expected {Y2[i]} Got {pred2[i]}"
 
 
 def sanity_gini(n, m):
     X = np.random.uniform(0, 100, (n, m))
     Y = np.random.randint(0, 5, n)
 
-    tree = DecisionTree("Classification", Gini_index)
+    tree = DecisionTree("Classification", criteria=Gini_index)
     tree.fit(X, Y)
 
     pred = tree.predict(X)
     for i in range(n):
-        assert (Y[i] == pred[i]), f"Gini: Expected {Y[i]} Got {pred[i]}"
+        assert Y[i] == pred[i], f"Gini: Expected {Y[i]} Got {pred[i]}"
 
 
 def sanity_entropy(n, m):
     X = np.random.uniform(0, 100, (n, m))
     Y = np.random.randint(0, 5, n)
 
-    tree = DecisionTree("Classification", Entropy)
+    tree = DecisionTree("Classification", criteria=Entropy)
     tree.fit(X, Y)
 
     pred = tree.predict(X)
     for i in range(n):
-        assert (Y[i] == pred[i]), f"Entropy: Expected {Y[i]} Got {pred[i]}"
+        assert Y[i] == pred[i], f"Entropy: Expected {Y[i]} Got {pred[i]}"
 
 
 def sanity_linear_regression(n, m):
     X = np.random.uniform(0, 100, (n, m))
     Y = np.random.uniform(0, 10, n)
-    tree = DecisionTree("Regression", Linear_regression)
+    tree = DecisionTree("Regression", criteria=Linear_regression)
     tree.fit(X, Y)
 
     for node in tree.leaf_nodes:
         assert isinstance(node, LeafNode)
         # Linear regression fits on the X[:, 0] values,
         # so for the final node X[:, 0] should have a correlation of 1 with Y
         # in the node
@@ -293,14 +334,14 @@
     sanity_regression(n, m)
     sanity_gini(n, m)
     sanity_entropy(n, m)
     sanity_linear_regression(n, m)
 
 
 if __name__ == "__main__":
-    test_gini_single()
-    test_gini_multi()
-    test_entropy_single()
-    test_entropy_multi()
+    # test_gini_single()
+    # test_gini_multi()
+    # test_entropy_single()
+    # test_entropy_multi()
     test_regression()
     # test_sanity()
     # print("Done.")
```

### Comparing `adaXT-1.0.1/tests/test_tree_features.py` & `adaxt-1.1.0/tests/test_tree_features.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,178 +1,223 @@
 from adaXT.decision_tree import DecisionTree
 from adaXT.criteria import Gini_index, Squared_error, Entropy, Linear_regression
-from adaXT.decision_tree.Nodes import LeafNode, DecisionNode
+from adaXT.decision_tree.nodes import LeafNode, DecisionNode
+from adaXT.predict import PredictLinearRegression, PredictQuantile
+from adaXT.leaf_builder import (
+    LeafBuilderLinearRegression,
+    LeafBuilderRegression,
+)
+
 import numpy as np
 
 
+def uniform_x_y(n, m):
+    np.random.seed(2024)
+    return (
+        np.random.uniform(
+            1, 1000, (n, m)), np.random.uniform(
+            1, 1000, (n)))
+
+
 def test_predict_leaf_matrix_classification():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_cla = np.array([1, -1, 1, -1, 1, -1, 1, -1])
 
-    tree = DecisionTree("Classification", Gini_index)
+    tree = DecisionTree("Classification", criteria=Gini_index)
     tree.fit(X, Y_cla)
     res1 = tree.get_leaf_matrix()
     res2 = tree.predict_leaf_matrix(X)
     assert res1.shape == res2.shape
     row, col = res1.shape
     for i in range(row):
         for j in range(col):
             assert res1[i, j] == res2[i, j]
 
 
 def test_predict_leaf_matrix_regression():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_reg = np.array([2.2, -0.5, 0.5, -0.5, 2, -3, 2.2, -3])
-    tree = DecisionTree("Regression", Squared_error)
+    tree = DecisionTree("Regression", criteria=Squared_error)
     tree.fit(X, Y_reg)
 
     res1 = tree.get_leaf_matrix()
     res2 = tree.predict_leaf_matrix(X)
-    assert (res1.shape == res2.shape)
+    assert res1.shape == res2.shape
     row, col = res1.shape
     for i in range(row):
         for j in range(col):
             assert res1[i, j] == res2[i, j]
 
 
 def test_predict_leaf_matrix_regression_with_scaling():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_reg = np.array([2.2, -0.5, 0.5, -0.5, 2, -3, 2.2, -3])
-    tree = DecisionTree("Regression", Squared_error)
+    tree = DecisionTree("Regression", criteria=Squared_error)
     tree.fit(X, Y_reg)
 
     res1 = tree.get_leaf_matrix()
     for i in range(res1.shape[0]):
         res1[i] = res1[i] / np.sum(res1[i])
     res2 = tree.predict_leaf_matrix(X, scale=True)
-    assert (res1.shape == res2.shape)
+    assert res1.shape == res2.shape
     row, col = res1.shape
     for i in range(row):
         for j in range(col):
             assert res1[i, j] == res2[i, j]
 
 
 def test_prediction():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_cla = np.array([1, -1, 1, -1, 1, -1, 1, -1])
-    tree = DecisionTree("Classification", Gini_index)
+    tree = DecisionTree("Classification", criteria=Gini_index)
     tree.fit(X, Y_cla)
     prediction = tree.predict(X)
     for i in range(len(Y_cla)):
-        assert Y_cla[i] == prediction[
-            i], f"incorrect prediction at {i}, expected {Y_cla[i]} got {prediction[i]}"
+        assert (
+            Y_cla[i] == prediction[i]
+        ), f"incorrect prediction at {i}, expected {Y_cla[i]} got {prediction[i]}"
 
 
 def test_predict_proba_probability():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_cla = np.array([1, -1, 1, -1, 1, -1, 1, -1])
-    tree = DecisionTree("Classification", Gini_index)
+    tree = DecisionTree("Classification", criteria=Gini_index)
     tree.fit(X, Y_cla)
-    classes = tree.classes
+    classes = np.unique(Y_cla)
     prediction = tree.predict_proba(X)
     assert prediction.shape[0] == X.shape[0]
     for i in range(len(Y_cla)):
-        assert Y_cla[i] == classes[np.argmax(
-            prediction[i, :])], f"incorrect prediction at {i}, expected {Y_cla[i]} got {classes[np.argmax(prediction[i, :])]}"
+        assert (
+            Y_cla[i] == classes[np.argmax(prediction[i, :])]
+        ), f"incorrect prediction at {i}, expected {Y_cla[i]} got {classes[np.argmax(prediction[i, :])]}"
 
 
 def test_predict_proba_against_predict():
     X = np.random.uniform(0, 100, (10000, 5))
     Y = np.random.randint(0, 5, 10000)
 
-    tree = DecisionTree("Classification", Gini_index)
+    tree = DecisionTree("Classification", criteria=Gini_index)
     tree.fit(X, Y)
 
     predict = tree.predict(X)
-    classes = tree.classes
+    classes = np.unique(Y)
     predict_proba = tree.predict_proba(X)
 
     for i in range(predict.shape[0]):
-        assert predict[i] == classes[np.argmax(
-            predict_proba[i, :])], f"incorrect prediction at {i}, expected {predict[i]} got {classes[np.argmax(predict_proba[i, :])]}"
+        assert (
+            predict[i] == classes[np.argmax(predict_proba[i, :])]
+        ), f"incorrect prediction at {i}, expected {predict[i]} got {classes[np.argmax(predict_proba[i, :])]}"
 
 
 def test_NxN_matrix():
-    X = np.array([[1, -1],
-                  [-0.5, -2],
-                  [-1, -1],
-                  [-0.5, -0.5],
-                  [1, 0],
-                  [-1, 1],
-                  [1, 1],
-                  [-0.5, 2]])
+    X = np.array(
+        [
+            [1, -1],
+            [-0.5, -2],
+            [-1, -1],
+            [-0.5, -0.5],
+            [1, 0],
+            [-1, 1],
+            [1, 1],
+            [-0.5, 2],
+        ]
+    )
     Y_cla = np.array([1, -1, 1, -1, 1, -1, 1, -1])
-    tree = DecisionTree("Classification", Gini_index)
+    tree = DecisionTree("Classification", criteria=Gini_index)
     tree.fit(X, Y_cla)
     leaf_matrix = tree.get_leaf_matrix()
-    true_weight = np.array([
-        [1, 0, 0, 0, 1, 0, 1, 0],
-        [0, 1, 0, 1, 0, 0, 0, 1],
-        [0, 0, 1, 0, 0, 0, 0, 0],
-        [0, 1, 0, 1, 0, 0, 0, 1],
-        [1, 0, 0, 0, 1, 0, 1, 0],
-        [0, 0, 0, 0, 0, 1, 0, 0],
-        [1, 0, 0, 0, 1, 0, 1, 0],
-        [0, 1, 0, 1, 0, 0, 0, 1]
-    ])
+    true_weight = np.array(
+        [
+            [1, 0, 0, 0, 1, 0, 1, 0],
+            [0, 1, 0, 1, 0, 0, 0, 1],
+            [0, 0, 1, 0, 0, 0, 0, 0],
+            [0, 1, 0, 1, 0, 0, 0, 1],
+            [1, 0, 0, 0, 1, 0, 1, 0],
+            [0, 0, 0, 0, 0, 1, 0, 0],
+            [1, 0, 0, 0, 1, 0, 1, 0],
+            [0, 1, 0, 1, 0, 0, 0, 1],
+        ]
+    )
     for i in range(len(true_weight)):
         for j in range(len(true_weight[0])):
-            assert leaf_matrix[i, j] == true_weight[i,
-                                                    j], f"Failed on ({i}, {j}), should be {true_weight[i, j]} was {leaf_matrix[i, j]}"
+            assert (
+                leaf_matrix[i, j] == true_weight[i, j]
+            ), f"Failed on ({i}, {j}), should be {true_weight[i, j]} was {leaf_matrix[i, j]}"
 
 
 def test_max_depth_setting():
     np.random.seed(2023)  # Set seed such that each run is the same
     X = np.random.uniform(0, 100, (10000, 5))
     Y = np.random.randint(0, 5, 10000)
     max_depth_desired = 20
 
     tree = DecisionTree(
-        "Classification",
-        criteria=Gini_index,
-        max_depth=max_depth_desired)
+        "Classification", criteria=Gini_index, max_depth=max_depth_desired
+    )
     tree.fit(X, Y)
 
     for node in tree.leaf_nodes:
-        assert node.depth <= max_depth_desired, f"Failed as node depth was,{node.depth} but should be at the most {max_depth_desired}"
+        assert (
+            node.depth <= max_depth_desired
+        ), f"Failed as node depth was,{node.depth} but should be at the most {max_depth_desired}"
 
 
 def test_impurity_tol_setting():
     np.random.seed(2023)  # Set seed such that each run is the same
     X = np.random.uniform(0, 100, (10000, 5))
     Y = np.random.randint(0, 5, 10000)
     impurity_tol_desired = 0.75
@@ -180,31 +225,36 @@
     tree = DecisionTree(
         "Classification",
         criteria=Gini_index,
         impurity_tol=impurity_tol_desired)
     tree.fit(X, Y)
 
     for node in tree.leaf_nodes:
-        assert node.impurity <= impurity_tol_desired, f"Failed as node impurity was, {node.impurity} but should be at the most {impurity_tol_desired}"
+        assert (
+            node.impurity <= impurity_tol_desired
+        ), f"Failed as node impurity was, {node.impurity} but should be at the most {impurity_tol_desired}"
 
 
 def test_min_samples_split_setting():
     np.random.seed(2023)  # Set seed such that each run is the same
     X = np.random.uniform(0, 100, (10000, 5))
     Y = np.random.randint(0, 5, 10000)
     min_samples_split_desired = 1000
 
     tree = DecisionTree(
         "Classification",
         criteria=Gini_index,
-        min_samples_split=min_samples_split_desired)
+        min_samples_split=min_samples_split_desired,
+    )
     tree.fit(X, Y)
 
     for node in tree.leaf_nodes:
-        assert min_samples_split_desired <= node.parent.n_samples, f"Failed as node had a parent with {min_samples_split_desired}, but which should have been a lead node"
+        assert (
+            min_samples_split_desired <= node.parent.n_samples
+        ), f"Failed as node had a parent with {min_samples_split_desired}, but which should have been a leaf node"
 
 
 def test_min_samples_leaf_setting():
     np.random.seed(2023)  # Set seed such that each run is the same
     X = np.random.uniform(0, 100, (10000, 5))
     Y = np.random.randint(0, 5, 10000)
     min_samples_leaf_desired = 20
@@ -212,15 +262,17 @@
     tree = DecisionTree(
         "Classification",
         criteria=Gini_index,
         min_samples_leaf=min_samples_leaf_desired)
     tree.fit(X, Y)
 
     for node in tree.leaf_nodes:
-        assert min_samples_leaf_desired <= node.n_samples, f"Failed as node had a parent with {min_samples_leaf_desired}, but which should have been a lead node"
+        assert (
+            min_samples_leaf_desired <= node.n_samples
+        ), f"Failed as node had a parent with {min_samples_leaf_desired}, but which should have been a leaf node"
 
 
 def test_min_improvement_setting():
     np.random.seed(2023)  # Set seed such that each run is the same
     X = np.random.randint(0, 100, (10000, 5))
     Y = np.random.randint(0, 10, 10000)
     min_improvement_desired = 0.000008
@@ -228,16 +280,17 @@
     tree = DecisionTree(
         "Classification",
         criteria=Gini_index,
         min_improvement=min_improvement_desired)
     tree.fit(X, Y)
 
     for node in tree.leaf_nodes:
-        assert abs(node.parent.impurity -
-                   node.impurity) > min_improvement_desired, f"Failed as node had an impurity improvement greater than {abs(node.parent.impurity - node.impurity)}"
+        assert (
+            abs(node.parent.impurity - node.impurity) > min_improvement_desired
+        ), f"Failed as node had an impurity improvement greater than {abs(node.parent.impurity - node.impurity)}"
 
 
 def get_x_y_classification(n, m):
     np.random.seed(2024)
     X = np.random.uniform(0, 100, (n, m))
     Y = np.random.randint(0, 10, n)
     return (X, Y)
@@ -255,40 +308,45 @@
     root2 = t2.root
 
     q1, q2 = [root1], [root2]
     while len(q1) != 0:
         node1, node2 = q1.pop(), q2.pop()
 
         assert node1.depth == node2.depth
-        assert (node1.impurity ==
-                node2.impurity), f"{t1.tree_type}: {node1.impurity} != {node2.impurity}"
-        assert (node1.n_samples == node2.n_samples)
+        assert (
+            node1.impurity == node2.impurity
+        ), f"{t1.tree_type}: {node1.impurity} != {node2.impurity}"
+        assert node1.n_samples == node2.n_samples
 
         if isinstance(node1, DecisionNode):
             assert isinstance(node2, DecisionNode)
-            assert (node1.threshold ==
-                    node2.threshold), f"{t1.tree_type}: {node1.threshold} != {node2.threshold}"
-            assert (node1.depth == node2.depth)
-            assert (node1.n_samples == node2.n_samples)
-            assert (node1.split_idx == node2.split_idx)
+            assert (
+                node1.threshold == node2.threshold
+            ), f"{t1.tree_type}: {node1.threshold} != {node2.threshold}"
+            assert node1.depth == node2.depth
+            assert node1.n_samples == node2.n_samples
+            assert node1.split_idx == node2.split_idx
             if node1.left_child:
                 assert (
-                    node2.left_child is not None), "Node 1 had a left child but not Node 2"
+                    node2.left_child is not None
+                ), "Node 1 had a left child but not Node 2"
                 q1.append(node1.left_child)
                 q2.append(node2.left_child)
             if node1.right_child:
                 assert (
-                    node2.right_child is not None), "Node 1 had a right child but not Node 2"
+                    node2.right_child is not None
+                ), "Node 1 had a right child but not Node 2"
                 q1.append(node1.right_child)
                 q2.append(node2.right_child)
 
         elif isinstance(node1, LeafNode):
             isinstance(node2, LeafNode)
-            assert (
-                node1.value == node2.value), f"{t1.tree_type}: {node1.value} != {node2.value}"
+            assert np.array_equal(
+                node1.value, node2.value
+            ), f"{t1.tree_type}: {node1.value} != {node2.value}"
     assert len(
         q2) == 0, f"{t2.tree_type}: Queue 2 not empty with length {len(q2)}"
 
 
 def test_sample_indices_classification():
     N, M = 10000, 5
     X1, Y1 = get_x_y_classification(N, M)
@@ -296,24 +354,24 @@
     bloat_feature = np.linspace(0, 10, num=M)
     sample_indices = []
     for i in range(1, N * 2, 2):
         X2 = np.insert(X2, i, bloat_feature, axis=0)
         Y2 = np.insert(Y2, i, i)  # i is used as a bloat outcome value
         sample_indices.append(i - 1)
 
-    t1 = DecisionTree('Classification', criteria=Gini_index)
-    t2 = DecisionTree('Classification', criteria=Gini_index)
+    t1 = DecisionTree("Classification", criteria=Gini_index)
+    t2 = DecisionTree("Classification", criteria=Gini_index)
 
     t1.fit(X1, Y1)
     t2.fit(X2, Y2, sample_indices=sample_indices)
 
     assert_tree_equality(t1, t2)
 
-    t1 = DecisionTree('Classification', criteria=Entropy)
-    t2 = DecisionTree('Classification', criteria=Entropy)
+    t1 = DecisionTree("Classification", criteria=Entropy)
+    t2 = DecisionTree("Classification", criteria=Entropy)
 
     t1.fit(X1, Y1)
     t2.fit(X2, Y2, sample_indices=sample_indices)
 
     assert_tree_equality(t1, t2)
 
 
@@ -324,23 +382,23 @@
     bloat_feature = np.linspace(0, 10, num=M)
     sample_indices = []
     for i in range(1, N * 2, 2):
         X2 = np.insert(X2, i, bloat_feature, axis=0)
         Y2 = np.insert(Y2, i, i)  # i is used as a bloat outcome value
         sample_indices.append(i - 1)
 
-    t1 = DecisionTree('Regression', criteria=Squared_error)
-    t2 = DecisionTree('Regression', criteria=Squared_error)
+    t1 = DecisionTree("Regression", criteria=Squared_error)
+    t2 = DecisionTree("Regression", criteria=Squared_error)
 
     t1.fit(X1, Y1)
     t2.fit(X2, Y2, sample_indices=sample_indices)
     assert_tree_equality(t1, t2)
 
-    t1 = DecisionTree('Regression', criteria=Linear_regression)
-    t2 = DecisionTree('Regression', criteria=Linear_regression)
+    t1 = DecisionTree("Regression", criteria=Linear_regression)
+    t2 = DecisionTree("Regression", criteria=Linear_regression)
 
     t1.fit(X1, Y1)
     t2.fit(X2, Y2, sample_indices=sample_indices)
     assert_tree_equality(t1, t2)
 
 
 def test_sample_weight_classification():
@@ -351,24 +409,24 @@
     sample_weights = []
     for i in range(1, N * 2, 2):
         X2 = np.insert(X2, i, bloat_feature, axis=0)
         Y2 = np.insert(Y2, i, i)  # i is used as a bloat outcome value
         sample_weights.append(1)
         sample_weights.append(0)
 
-    t1 = DecisionTree('Classification', criteria=Gini_index)
-    t2 = DecisionTree('Classification', criteria=Gini_index)
+    t1 = DecisionTree("Classification", criteria=Gini_index)
+    t2 = DecisionTree("Classification", criteria=Gini_index)
 
     t1.fit(X1, Y1)
     t2.fit(X2, Y2, sample_weight=sample_weights)
 
     assert_tree_equality(t1, t2)
 
-    t1 = DecisionTree('Classification', criteria=Entropy)
-    t2 = DecisionTree('Classification', criteria=Entropy)
+    t1 = DecisionTree("Classification", criteria=Entropy)
+    t2 = DecisionTree("Classification", criteria=Entropy)
 
     t1.fit(X1, Y1)
     t2.fit(X2, Y2, sample_weight=sample_weights)
 
     assert_tree_equality(t1, t2)
 
 
@@ -380,42 +438,82 @@
     sample_weights = []
     for i in range(1, N * 2, 2):
         X2 = np.insert(X2, i, bloat_feature, axis=0)
         Y2 = np.insert(Y2, i, i)  # i is used as a bloat outcome value
         sample_weights.append(1)
         sample_weights.append(0)
 
-    t1 = DecisionTree('Regression', criteria=Squared_error)
-    t2 = DecisionTree('Regression', criteria=Squared_error)
+    t1 = DecisionTree("Regression", criteria=Squared_error)
+    t2 = DecisionTree("Regression", criteria=Squared_error)
 
     t1.fit(X1, Y1)
     t2.fit(X2, Y2, sample_weight=sample_weights)
 
     assert_tree_equality(t1, t2)
 
-    t1 = DecisionTree('Regression', criteria=Linear_regression)
-    t2 = DecisionTree('Regression', criteria=Linear_regression)
+    t1 = DecisionTree("Regression", criteria=Linear_regression)
+    t2 = DecisionTree("Regression", criteria=Linear_regression)
 
     t1.fit(X1, Y1)
     t2.fit(X2, Y2, sample_weight=sample_weights)
 
     assert_tree_equality(t1, t2)
 
 
+def test_quantile_predict():
+    X, Y = uniform_x_y(10000, 5)
+    tree = DecisionTree(
+        "Quantile",
+        criteria=Squared_error,
+        predict=PredictQuantile,
+        leaf_builder=LeafBuilderRegression,
+        max_depth=0,
+    )
+    tree.fit(X, Y)
+    pred = tree.predict(
+        X[0], quantile=0.95
+    )  # As we are never splitting, we can just check a single data point
+    np_quantile = np.quantile(Y, 0.95)
+    assert (
+        pred == np_quantile
+    ), f"Quantile predict failed with {pred} - should be {np_quantile}"
+
+
+def test_linear_predict():
+    """
+    As the Linear Regression is fitted on the index 0 of the X training data,
+    we can validate the new Prediction by first creating some "noise" data,
+    and then create some data on the same line.
+    Then with new values that should be on the same line,
+    we can make sure that the predicted Y values,
+    indeed are on the line.
+    """
+    np.random.seed(2024)
+    X = np.random.uniform(1000, 100000, (1000, 5))  # noise
+    Y = np.random.uniform(1000, 100000, (1000))
+
+    X_Y_corr = np.arange(0, 50, step=1)
+    idx = np.random.randint(0, 1000, 50)
+
+    # Replace some indices with correlated data
+    X[idx, 0] = X_Y_corr
+    Y[idx] = X_Y_corr
+
+    tree = DecisionTree(
+        "LinearRegression",
+        criteria=Linear_regression,
+        predict=PredictLinearRegression,
+        leaf_builder=LeafBuilderLinearRegression,
+    )
+    tree.fit(X, Y)
+
+    X = np.random.uniform(1, 100, (50, 5))
+    corr_data = np.arange(50, 100, step=1)
+    X[:, 0] = corr_data
+    prediction = tree.predict(X)
+    assert (
+        np.corrcoef(prediction) == 1.0
+    ), "Linear Prediction didn't predict with perfect correlation"
+
+
 if __name__ == "__main__":
-    # test_predict_leaf_matrix_classification()
-    # test_predict_leaf_matrix_regression()
-    # test_predict_leaf_matrix_regression_with_scaling()
-    # test_prediction()
-    # test_predict_proba_probability()
-    # test_predict_proba_against_predict()
-    # test_NxN_matrix()
-    # test_max_depth_setting()
-    # test_impurity_tol_setting()
-    # test_min_samples_split_setting()
-    # test_min_samples_leaf_setting()
-    # test_min_improvement_setting()
-    # test_sample_indices_classification()
-    # test_sample_indices_regression()
-    # test_sample_weight_classification()
-    test_sample_weight_regression()
     print("Done.")
```

