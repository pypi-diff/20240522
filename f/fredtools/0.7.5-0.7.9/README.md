# Comparing `tmp/fredtools-0.7.5-py3-none-any.whl.zip` & `tmp/fredtools-0.7.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,28 +1,29 @@
-Zip file size: 304187 bytes, number of entries: 26
--rw-rw-r--  2.0 unx    10019 b- defN 24-Jan-03 13:44 fredtools/__init__.py
+Zip file size: 309771 bytes, number of entries: 27
+-rw-rw-r--  2.0 unx    10479 b- defN 24-Feb-13 11:47 fredtools/__init__.py
 -rw-r--r--  2.0 unx    27295 b- defN 23-Oct-23 18:39 fredtools/ft_braggPeak.py
 -rw-r--r--  2.0 unx    19772 b- defN 23-Oct-25 17:49 fredtools/ft_displayImg.py
 -rw-r--r--  2.0 unx     8501 b- defN 23-Oct-23 18:22 fredtools/ft_dvh.py
--rw-rw-r--  2.0 unx    45903 b- defN 23-Dec-08 10:41 fredtools/ft_imgAnalyse.py
+-rw-rw-r--  2.0 unx    46620 b- defN 24-Jan-22 18:24 fredtools/ft_imgAnalyse.py
 -rw-r--r--  2.0 unx    30800 b- defN 23-Nov-10 09:09 fredtools/ft_imgGetSubimg.py
--rw-rw-r--  2.0 unx    55623 b- defN 24-Jan-05 09:50 fredtools/ft_imgManipulate.py
--rw-r--r--  2.0 unx    27765 b- defN 23-Oct-23 19:23 fredtools/ft_misc.py
--rw-r--r--  2.0 unx    33560 b- defN 23-Oct-24 07:56 fredtools/ft_simTools.py
+-rw-rw-r--  2.0 unx    60674 b- defN 24-Feb-08 10:17 fredtools/ft_imgManipulate.py
+-rw-rw-r--  2.0 unx    27880 b- defN 24-Feb-13 10:21 fredtools/ft_misc.py
+-rw-rw-r--  2.0 unx    33519 b- defN 24-Feb-13 11:39 fredtools/ft_simTools.py
 -rw-r--r--  2.0 unx     2898 b- defN 22-Nov-09 12:08 fredtools/ft_spotAnalyse.py
 -rw-r--r--  2.0 unx     6918 b- defN 22-Nov-09 12:08 fredtools/smparallel.py
 -rw-r--r--  2.0 unx       26 b- defN 22-Nov-09 12:08 fredtools/ft_gammaIndex/__init__.py
 -rw-r--r--  2.0 unx    15500 b- defN 23-Oct-23 19:00 fredtools/ft_gammaIndex/gammaIndex.py
 -rwxr--r--  2.0 unx   694568 b- defN 22-Nov-09 12:08 fredtools/ft_gammaIndex/libFredGI.so
 -rw-r--r--  2.0 unx      116 b- defN 23-Oct-25 15:11 fredtools/ft_imgIO/__init__.py
--rw-rw-r--  2.0 unx    55814 b- defN 23-Dec-18 10:30 fredtools/ft_imgIO/dicom_io.py
--rw-r--r--  2.0 unx    27534 b- defN 23-Oct-23 18:41 fredtools/ft_imgIO/dij_io.py
+-rw-rw-r--  2.0 unx    55814 b- defN 24-Feb-05 12:18 fredtools/ft_imgIO/dicom_io.py
+-rw-rw-r--  2.0 unx    28902 b- defN 24-Jan-25 09:05 fredtools/ft_imgIO/dij_io.py
 -rw-r--r--  2.0 unx     6103 b- defN 22-Nov-09 12:08 fredtools/ft_imgIO/map3d_io.py
 -rw-r--r--  2.0 unx     5950 b- defN 23-Oct-25 15:53 fredtools/ft_imgIO/mhd_io.py
--rw-rw-r--  2.0 unx     3076 b- defN 23-Dec-08 09:32 fredtools/ft_imgIO/other_io.py
--rw-r--r--  2.0 unx       40 b- defN 22-Nov-09 12:08 fredtools/ft_optimisation/__init__.py
+-rw-rw-r--  2.0 unx     3190 b- defN 24-Jan-08 13:52 fredtools/ft_imgIO/other_io.py
+-rw-rw-r--  2.0 unx       71 b- defN 24-Feb-08 12:00 fredtools/ft_optimisation/__init__.py
 -rw-rw-r--  2.0 unx    13399 b- defN 23-Mar-26 13:37 fredtools/ft_optimisation/ft_optimiseBeamPositions.py
--rw-rw-r--  2.0 unx     3755 b- defN 24-Jan-05 09:53 fredtools-0.7.5.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 24-Jan-05 09:53 fredtools-0.7.5.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 24-Jan-05 09:53 fredtools-0.7.5.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2211 b- defN 24-Jan-05 09:53 fredtools-0.7.5.dist-info/RECORD
-26 files, 1097248 bytes uncompressed, 300633 bytes compressed:  72.6%
+-rw-rw-r--  2.0 unx    16112 b- defN 24-Feb-08 11:55 fredtools/ft_optimisation/ft_preoptimizer.py
+-rw-rw-r--  2.0 unx     3755 b- defN 24-Feb-13 11:51 fredtools-0.7.9.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 24-Feb-13 11:51 fredtools-0.7.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 24-Feb-13 11:51 fredtools-0.7.9.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2313 b- defN 24-Feb-13 11:51 fredtools-0.7.9.dist-info/RECORD
+27 files, 1121277 bytes uncompressed, 306053 bytes compressed:  72.7%
```

## zipnote {}

```diff
@@ -60,20 +60,23 @@
 
 Filename: fredtools/ft_optimisation/__init__.py
 Comment: 
 
 Filename: fredtools/ft_optimisation/ft_optimiseBeamPositions.py
 Comment: 
 
-Filename: fredtools-0.7.5.dist-info/METADATA
+Filename: fredtools/ft_optimisation/ft_preoptimizer.py
 Comment: 
 
-Filename: fredtools-0.7.5.dist-info/WHEEL
+Filename: fredtools-0.7.9.dist-info/METADATA
 Comment: 
 
-Filename: fredtools-0.7.5.dist-info/top_level.txt
+Filename: fredtools-0.7.9.dist-info/WHEEL
 Comment: 
 
-Filename: fredtools-0.7.5.dist-info/RECORD
+Filename: fredtools-0.7.9.dist-info/top_level.txt
+Comment: 
+
+Filename: fredtools-0.7.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fredtools/__init__.py

```diff
@@ -3,24 +3,23 @@
 from .ft_imgGetSubimg import *
 from .ft_imgManipulate import *
 from .ft_simTools import *
 from .ft_dvh import *
 from .ft_braggPeak import *
 from .ft_spotAnalyse import *
 from .ft_displayImg import *
-from .ft_optimisation import *
 from .ft_gammaIndex import *
 from .ft_misc import *
 
 import itk
 import SimpleITK as sitk
 
 import sys
 
-version_info = [0, 7, 5]
+version_info = [0, 7, 9]
 __version__ = ".".join(map(str, version_info))
 
 
 def _checkJupyterMode():
     """Check if the FREDtools was loaded from jupyter"""
     try:
         if get_ipython().config["IPKernelApp"]:
@@ -45,188 +44,226 @@
     currentFuncName(1) get the name of the caller.
     """
     return sys._getframe(n + 1).f_code.co_name
 
 
 def _isITK2D(img, raiseError=False):
     r"""Check if input is a 2D itk.Image object and raise error if requested."""
-    import itk
-
-    instanceBool = isinstance(img, itk.Image) & (img.ndim == 2)
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is not an instance of a 2D itk image")
-    return instanceBool
+    if not _isITK(img, raiseError=raiseError):
+        return False
+    elif not img.ndim == 2:
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is not an instance of a 2D itk.Image object.")
+        return False
+    else:
+        return True
 
 
 def _isITK3D(img, raiseError=False):
     r"""Check if input is a 3D itk.Image object and raise error if requested."""
-    import itk
-
-    instanceBool = isinstance(img, itk.Image) & (img.ndim == 3)
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is not an instance of a 3D itk image")
-    return instanceBool
+    if not _isITK(img, raiseError=raiseError):
+        return False
+    elif not img.ndim == 3:
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is not an instance of a 3D itk.Image object.")
+        return False
+    else:
+        return True
 
 
 def _isITK4D(img, raiseError=False):
     r"""Check if input is a 4D itk.Image object and raise error if requested."""
-    import itk
-
-    instanceBool = isinstance(img, itk.Image) & (img.ndim == 4)
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is not an instance of a 4D itk image")
-    return instanceBool
+    if not _isITK(img, raiseError=raiseError):
+        return False
+    elif not img.ndim == 4:
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is not an instance of a 4D itk.Image object.")
+        return False
+    else:
+        return True
 
 
 def _isITK(img, raiseError=False):
     r"""Check if input is an itk.Image object and raise error if requested."""
-    import itk
+    from itk import Image as ITKImage
 
-    instanceBool = isinstance(img, itk.Image)
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is not an instance of an itk image.")
-    return instanceBool
+    if isinstance(img, ITKImage):
+        return True
+    elif raiseError:
+        raise TypeError(f"The object '{type(img)}' is not an instance of an itk.Image object.")
+    else:
+        return False
 
 
 def _isSITK2D(img, raiseError=False):
     r"""Check if input is a 2D SimpleITK.Image object and raise error if requested."""
-    import SimpleITK as sitk
-
-    instanceBool = isinstance(img, sitk.Image) & (img.GetDimension() == 2)
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is not an instance of a 2D SimpleITK image")
-    return instanceBool
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not img.GetDimension() == 2:
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is not an instance of a 2D SimpleITK.Image object.")
+        return False
+    else:
+        return True
 
 
 def _isSITK3D(img, raiseError=False):
     r"""Check if input is a 3D SimpleITK.Image object and raise error if requested."""
-    import SimpleITK as sitk
-
-    instanceBool = isinstance(img, sitk.Image) & (img.GetDimension() == 3)
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is not an instance of a 3D SimpleITK image")
-    return instanceBool
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not img.GetDimension() == 3:
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is not an instance of a 3D SimpleITK.Image object.")
+        return False
+    else:
+        return True
 
 
 def _isSITK4D(img, raiseError=False):
     r"""Check if input is a 4D SimpleITK.Image object and raise error if requested."""
-    import SimpleITK as sitk
-
-    instanceBool = isinstance(img, sitk.Image) & (img.GetDimension() == 4)
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is not an instance of a 4D SimpleITK image")
-    return instanceBool
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not img.GetDimension() == 4:
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is not an instance of a 4D SimpleITK.Image object.")
+        return False
+    else:
+        return True
 
 
 def _isSITK(img, raiseError=False):
     r"""Check if input is an SimpleITK.Image object and raise error if requested."""
-    import SimpleITK as sitk
+    from SimpleITK import Image as SITKImage
 
-    instanceBool = isinstance(img, sitk.Image)
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is not an instance of an SimpleITK image.")
-    return instanceBool
+    if isinstance(img, SITKImage):
+        return True
+    elif raiseError:
+        raise TypeError(f"The object '{type(img)}' is not an instance of an SimpleITK.Image object.")
+    else:
+        return False
 
 
 def _isSITK_volume(img, raiseError=False):
-    import fredtools as ft
-
-    ft._isSITK(img, raiseError=True)
-    instanceBool = img.GetSize().count(1) == (img.GetDimension() - 3)
-
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is an instance of SimpleITK image but does not describe a volume. Size of 'img' is {img.GetSize()}")
-    return instanceBool
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not img.GetSize().count(1) == (img.GetDimension() - 3):
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is an instance of SimpleITK.Image object but does not describe a volume. Size of 'img' is {img.GetSize()}.")
+        return False
+    else:
+        return True
 
 
 def _isSITK_timevolume(img, raiseError=False):
-    import fredtools as ft
-
-    ft._isSITK(img, raiseError=True)
-    instanceBool = img.GetSize().count(1) == (img.GetDimension() - 4)
-
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is an instance of SimpleITK image but does not describe a time volume. Size of 'img' is {img.GetSize()}")
-    return instanceBool
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not img.GetSize().count(1) == (img.GetDimension() - 4):
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is an instance of SimpleITK.Image object but does not describe a time volume. Size of 'img' is {img.GetSize()}.")
+        return False
+    else:
+        return True
 
 
 def _isSITK_slice(img, raiseError=False):
-    import fredtools as ft
-
-    ft._isSITK(img, raiseError=True)
-    instanceBool = img.GetSize().count(1) == (img.GetDimension() - 2)
-
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is an instance of SimpleITK image but does not describe a slice. Size of 'img' is {img.GetSize()}")
-    return instanceBool
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not img.GetSize().count(1) == (img.GetDimension() - 2):
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is an instance of SimpleITK.Image object but does not describe a slice. Size of 'img' is {img.GetSize()}.")
+        return False
+    else:
+        return True
 
 
 def _isSITK_profile(img, raiseError=False):
-    import fredtools as ft
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not img.GetSize().count(1) == (img.GetDimension() - 1):
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is an instance of SimpleITK.Image object but does not describe a profile. Size of 'img' is {img.GetSize()}.")
+        return False
+    else:
+        return True
 
-    ft._isSITK(img, raiseError=True)
-    instanceBool = img.GetSize().count(1) == (img.GetDimension() - 1)
 
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is an instance of SimpleITK image but does not describe a profile. Size of 'img' is {img.GetSize()}")
-    return instanceBool
+def _isSITK_point(img, raiseError=False):
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not img.GetSize().count(1) == img.GetDimension():
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is an instance of SimpleITK.Image object but does not describe a point. Size of 'img' is {img.GetSize()}.")
+        return False
+    else:
+        return True
 
 
-def _isSITK_point(img, raiseError=False):
-    import fredtools as ft
+def _isSITK_vector(img, raiseError=False):
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not "vector" in img.GetPixelIDTypeAsString():
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is an instance of SimspleITK.Image object but not a vector image.")
+        return False
+    else:
+        return True
 
-    ft._isSITK(img, raiseError=True)
-    instanceBool = img.GetSize().count(1) == (img.GetDimension())
 
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is an instance of SimspleITK image but does not describe a point. Size of 'img' is {img.GetSize()}")
-    return instanceBool
+def _isSITK_transform(img, raiseError=False):
+    from SimpleITK import Transform as SITKTransform
+
+    if isinstance(img, SITKTransform):
+        return True
+    elif raiseError:
+        raise TypeError(f"The object '{type(img)}' is not an instance of an SimpleITK.Transform object.")
+    else:
+        return False
 
 
 def _isSITK_maskBinary(img, raiseError=False):
     import fredtools as ft
-    import SimpleITK as sitk
+    from SimpleITK import sitkUInt8
 
-    ft._isSITK(img, raiseError=True)
-    stat = getStatistics(img)
-    instanceBool = (stat.GetMaximum() in [0, 1]) and (stat.GetMinimum() in [0, 1]) and (img.GetPixelID() == sitk.sitkUInt8)
+    stat = ft.getStatistics(img)
 
-    if raiseError and not instanceBool:
-        raise TypeError(
-            f"The object '{type(img)}' is an instance of SimspleITK image but does not describe a binary mask. Binary mask image must be of type '8-bit unsigned integer' and contain only voxels with values 0 or 1."
-        )
-    return instanceBool
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not ((stat.GetMaximum() in [0, 1]) and (stat.GetMinimum() in [0, 1]) and (img.GetPixelID() == sitkUInt8)):
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is an instance of SimspleITK.Image object but does not describe a binary mask. Binary mask image must be of type '8-bit unsigned integer' and contain only voxels with values 0 or 1.")
+        return False
+    else:
+        return True
 
 
 def _isSITK_maskFloating(img, raiseError=False):
     import fredtools as ft
-    import SimpleITK as sitk
+    from SimpleITK import sitkFloat32, sitkFloat64
 
-    ft._isSITK(img, raiseError=True)
-    stat = getStatistics(img)
-    instanceBool = (stat.GetMaximum() <= 1) and (stat.GetMinimum() >= 0) and ((img.GetPixelID() == sitk.sitkFloat64) or (img.GetPixelID() == sitk.sitkFloat32))
+    stat = ft.getStatistics(img)
 
-    if raiseError and not instanceBool:
-        raise TypeError(
-            f"The object '{type(img)}' is an instance of SimspleITK image but does not describe a floating mask. Floating mask image must be of type '32-bit float' or '64-bit float' and contain only voxels with values in range 0-1."
-        )
-    return instanceBool
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not ((stat.GetMaximum() <= 1) and (stat.GetMinimum() >= 0) and ((img.GetPixelID() == sitkFloat64) or (img.GetPixelID() == sitkFloat32))):
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is an instance of SimspleITK.Image object but does not describe a floating mask. Floating mask image must be of type '32-bit float' or '64-bit float' and contain only voxels with values in range 0-1.")
+        return False
+    else:
+        return True
 
 
 def _isSITK_mask(img, raiseError=False):
-    import fredtools as ft
-    import SimpleITK as sitk
-
-    ft._isSITK(img, raiseError=True)
-
-    instanceBool = _isSITK_maskBinary(img) or _isSITK_maskFloating(img)
-
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is an instance of SimspleITK image but does not describe floating nor binary mask.")
-    return instanceBool
+    if not _isSITK(img, raiseError=raiseError):
+        return False
+    elif not (_isSITK_maskBinary(img) or _isSITK_maskFloating(img)):
+        if raiseError:
+            raise TypeError(f"The object '{type(img)}' is an instance of SimspleITK.Image object but does not describe floating nor binary mask.")
+        return False
+    else:
+        return True
 
 
 def _getMaskType(img):
     import fredtools as ft
     import SimpleITK as sitk
 
     ft._isSITK(img, raiseError=True)
@@ -236,33 +273,14 @@
         return "binary"
     elif _isSITK_maskFloating(img):
         return "floating"
     else:
         return "unknown"
 
 
-def _isSITK_vector(img, raiseError=False):
-    import fredtools as ft
-
-    ft._isSITK(img, raiseError=True)
-    instanceBool = "vector" in img.GetPixelIDTypeAsString()
-
-    if raiseError and not instanceBool:
-        raise TypeError(f"The object '{type(img)}' is an instance of SimspleITK image but not vector image.")
-    return instanceBool
-
-
-def _isSITK_transform(img, raiseError=False):
-    try:
-        return "Transform" in img.GetName()
-    except:
-        if raiseError:
-            raise TypeError(f"The object '{type(img)}' is not an instance of SimspleITK transform object.")
-
-
 def _copyImgMetaData(imgSrc, imgDes):
     """Copy meta data to the image source to the image destination"""
     _isSITK(imgSrc, raiseError=True)
     _isSITK(imgDes, raiseError=True)
     for key in imgSrc.GetMetaDataKeys():
         imgDes.SetMetaData(key, imgSrc.GetMetaData(key))
     return imgDes
```

## fredtools/ft_imgAnalyse.py

```diff
@@ -312,15 +312,15 @@
     import numpy as np
     import fredtools as ft
 
     ft._isSITK(img, raiseError=True)
 
     voxelCentres = []
     for axis, axisSize in enumerate(img.GetSize()):
-        voxelIndices = np.zeros([axisSize, 3], dtype=np.int32)
+        voxelIndices = np.zeros([axisSize, img.GetDimension()], dtype=np.int32)
         voxelIndices[:, axis] = np.arange(axisSize, dtype=np.int32)
         voxelCentresAxis = np.array(ft.transformIndexToPhysicalPoint(img, voxelIndices))
         voxelCentres.append(tuple(voxelCentresAxis[:, axis]))
 
     if displayInfo:
         print(f"### {ft._currentFuncName()} ###")
         axesNames = ["x", "y", "z", "t"]
@@ -658,14 +658,45 @@
     ft._isSITK(img, raiseError=True)
 
     axesNumberNotUnity = [axis_idx for axis_idx, axis in enumerate(img.GetSize()) if axis != 1]
 
     return tuple(axesNumberNotUnity)
 
 
+def _getAxesNumberUnity(img):
+    """Get axis indexes for the axes of size equal to one.
+
+    The function calculates the indexes of the axes for which the size is equal to one.
+
+    Parameters
+    ----------
+    img : SimpleITK Image
+        An object of a SimpleITK image.
+
+    Returns
+    -------
+    tuple
+        Tuple axis indexes.
+
+    Examples
+    --------
+    Assuming that the `img` shape is [200,1,100,400] (4D image).
+
+    >>> fredtools.ft_imgAnalyse._getAxesNumberUnity(img)
+    (1)
+    """
+    import fredtools as ft
+
+    ft._isSITK(img, raiseError=True)
+
+    axesNumberUnity = [axis_idx for axis_idx, axis in enumerate(img.GetSize()) if axis == 1]
+
+    return tuple(axesNumberUnity)
+
+
 def _getDirectionArray(img):
     """Get direction in the form of a 2D array.
 
     The function converts direction from an image defined as a SimpleITK image
     object to a 2D numpy array. It reshapes img.GetDirection() results
     in a tuple to a 2D numpy array.
```

## fredtools/ft_imgManipulate.py

```diff
@@ -208,18 +208,16 @@
             if StructureContoursDirection[StructureContourIdx]:
                 arrMask[MaskDepth_idx, :, :] += StructureContoursArrays[StructureContourIdx]
             else:
                 arrMask[MaskDepth_idx, :, :] -= StructureContoursArrays[StructureContourIdx]
 
     # prepare SimpleITK mask
     imgMask = sitk.GetImageFromArray(arrMask)
-    imgMask.SetOrigin(
-        [img.GetOrigin()[0], img.GetOrigin()[1], MaskDepths.min()])
-    imgMask.SetSpacing([img.GetSpacing()[0], img.GetSpacing()[
-                       1], StructureContoursSpacing])
+    imgMask.SetOrigin([img.GetOrigin()[0], img.GetOrigin()[1], MaskDepths.min()])
+    imgMask.SetSpacing([img.GetSpacing()[0], img.GetSpacing()[1], StructureContoursSpacing])
 
     # interpolate mask to input image
     imgMask = sitk.Resample(
         imgMask, img, interpolator=ft.ft_imgGetSubimg._setSITKInterpolator(interpolation="linear"))
 
     # prepare binary mask if requested, with fraction area threshold
     if binaryMask:
@@ -663,111 +661,234 @@
         print(f"### {ft._currentFuncName()} ###")
         ft.ft_imgAnalyse._displayImageInfo(img)
         print("#" * len(f"### {ft._currentFuncName()} ###"))
 
     return img
 
 
-def createCylindricalMask(img, startPoint, endPoint, dimension, displayInfo=False):
-    """Create a cylindrical Mask in the image field of reference
+def createEllipseMask(img, point, radii, displayInfo=False):
+    """Create an Ellipse mask in the image field of reference.
 
-    The function creates a cylindrical mask with a given `dimension` and height
-    calculated from the starting and ending points of the cylinder in the frame of
-    references of an image defined as a SimpleITK image object describing a 3D image.
-    Only 3D images are supported. The routine might be helpful for instance for making
-    a geometrical acceptance correction of a chamber used for Bragg peak measurements.
-    The routine was adapted from a GitHub repository: https://github.com/heydude1337/SimplePhantomToolkit/.
+    The function creates an ellipse mask, defined with the center and radii
+    in the frame of references of an image defined as a SimpleITK image 
+    object. Any dimension, i.e. 2D-4D, of the image is supported.
+
+    Parameters
+    ----------
+    img : SimpleITK Image
+        Object of a SimpleITK image.
+    point : array_like
+        A point describing the position of the center of the ellipse. The dimension must match the image dimension.
+    radii : scalar or array_like
+        Radii of the ellipse for each dimension. It might be a scalar, then the same radii will be used in each direction.
+    displayInfo : bool, optional
+        Displays a summary of the function results. (def. False)
+
+    Returns
+    -------
+    SimpleITK Image
+        An instance of a SimpleITK image object describing a binary mask (i.e. type 'uint8' with 0/1 values).
+
+    See Also
+    --------
+        mapStructToImg : mapping a structure to an image to create a mask.
+        setValueMask : setting values of the image inside/outside a mask.
+        cropImgToMask : crop an image to mask.
+        createCylinderMask: create a cylinder mask.
+        createConeMask : create a cone mask.
+    """
+    import itk
+    import fredtools as ft
+    from collections.abc import Iterable
+    import numpy as np
+
+    ft._isSITK(img, raiseError=True)
+
+    # convert image to ITK
+    imgITK = ft.SITK2ITK(img)
+
+    # check radii and point parameters
+    if isinstance(radii, Iterable):
+        radii = list(radii)
+    if np.isscalar(radii):
+        radii = [radii]*img.GetDimension()
+    if len(radii) != img.GetDimension():
+        raise ValueError(f"The `radii` parameter must be an iterable of the same length as the image dimension. Image dimension is {img.GetDimension()} but radii {radii} was used.")
+    if len(point) != img.GetDimension():
+        raise ValueError(f"The `point` parameter must be an iterable of the same length as the image dimension. Image dimension is {img.GetDimension()} but point {point} was used.")
+
+    # create ellipse and mapping objects
+    match img.GetDimension():
+        case 2:
+            EllipseSpatialObject = itk.itkEllipseSpatialObjectPython.itkEllipseSpatialObject2_New()
+            SpatialObjectToImage = itk.itkSpatialObjectToImageFilterPython.itkSpatialObjectToImageFilterSO2IUC2_New()
+        case 3:
+            EllipseSpatialObject = itk.itkEllipseSpatialObjectPython.itkEllipseSpatialObject3_New()
+            SpatialObjectToImage = itk.itkSpatialObjectToImageFilterPython.itkSpatialObjectToImageFilterSO3IUC3_New()
+        case 2:
+            EllipseSpatialObject = itk.itkEllipseSpatialObjectPython.itkEllipseSpatialObject4_New()
+            SpatialObjectToImage = itk.itkSpatialObjectToImageFilterPython.itkSpatialObjectToImageFilterSO4IUC4_New()
+
+    EllipseSpatialObject.SetCenterInObjectSpace(point)
+    EllipseSpatialObject.SetRadiusInObjectSpace(radii)
+
+    # map spatial object to image FoR
+    SpatialObjectToImage.SetInsideValue(1)
+    SpatialObjectToImage.SetOutsideValue(0)
+    SpatialObjectToImage.SetInput(EllipseSpatialObject)
+    SpatialObjectToImage.SetSize(imgITK.GetLargestPossibleRegion().GetSize())
+    SpatialObjectToImage.SetDirection(imgITK.GetDirection())
+    SpatialObjectToImage.SetOrigin(imgITK.GetOrigin())
+    SpatialObjectToImage.SetSpacing(imgITK.GetSpacing())
+    SpatialObjectToImage.Update()
+    imgMask = SpatialObjectToImage.GetOutput()
+
+    imgMask = ft.ITK2SITK(imgMask)
+
+    if displayInfo:
+        print(f"### {ft._currentFuncName()} ###")
+        ft.ft_imgAnalyse._displayImageInfo(imgMask)
+        print("#" * len(f"### {ft._currentFuncName()} ###"))
+
+    return imgMask
+
+
+def createConeMask(img, startPoint, endPoint, startRadius, endRadius, displayInfo=False):
+    """Create a cone mask in the image field of reference.
+
+    The function creates a cone mask, defined with starting and ending points and radii 
+    in the frame of references of an image defined as a SimpleITK image object describing a 3D image.
+    Only 3D images are supported.
 
     Parameters
     ----------
     img : SimpleITK Image
         Object of a SimpleITK 3D image.
     startPoint : array_like
-        3-element point describing the position of the center of the first cylinder base.
+        3-element point describing the position of the center of the first cone base.
     endPoint : array_like
-        3-element point describing the position of the center of the second cylinder base.
-    dimension : scalar
-        Dimension of the cylinder.
+        3-element point describing the position of the center of the second cone base.
+    startRadius : scalar
+        Radious of the first cone base.
+    endRadius : scalar
+        Radious of the second cone base.
     displayInfo : bool, optional
         Displays a summary of the function results. (def. False)
 
     Returns
     -------
     SimpleITK Image
-        An instance of a SimpleITK image object describing a mask (i.e. type 'uint8' with 0/1 values).
+        An instance of a SimpleITK image object describing a binary mask (i.e. type 'uint8' with 0/1 values).
 
     See Also
     --------
         mapStructToImg : mapping a structure to an image to create a mask.
         setValueMask : setting values of the image inside/outside a mask.
         cropImgToMask : crop an image to mask.
+        createCylinderMask: create a cylinder mask.
+        createEllipseMask : create an ellipse mask.
     """
-    import SimpleITK as sitk
+    import itk
     import fredtools as ft
-    import numpy as np
-
-    def dot(v, w):
-        # Dot product
-        return sum([vi * wi for vi, wi in zip(v, w)])
-
-    def cross(u, v):
-        # Cross product
-        s1 = float(u[1]) * v[2] - float(u[2]) * v[1]
-        s2 = float(u[2]) * v[0] - float(u[0]) * v[2]
-        s3 = float(u[0]) * v[1] - float(u[1]) * v[0]
-        return (s1, s2, s3)
-
-    def grid_from_image(image):
-        # Similar to numpy.meshgrid using sitk. Grids will be in world (physical) space.
-        imsize = image.GetSize()
-        spacing = image.GetSpacing()
-        origin = image.GetOrigin()
-        direction = image.GetDirection()
-        grid = sitk.PhysicalPointSource(sitk.sitkVectorFloat64, imsize, origin, spacing, direction)
-
-        dim = image.GetDimension()
-        grid = [sitk.VectorIndexSelectionCast(grid, i) for i in range(0, dim)]
-
-        for gi in grid:
-            gi.CopyInformation(image)
-        return grid
 
     ft._isSITK3D(img, raiseError=True)
 
+    # convert image to ITK
+    imgITK = ft.SITK2ITK(img)
+
     if not isinstance(startPoint, list):
         startPoint = list(startPoint)
-
     if not isinstance(endPoint, list):
         endPoint = list(endPoint)
 
-    startPoint = np.array(startPoint, dtype="double")
-    endPoint = np.array(endPoint, dtype="double")
+    # define tube spatial object woth two points
+    TubeSpatialObject = itk.itkTubeSpatialObjectPython.itkTubeSpatialObject3_New()
 
-    heightVector = (np.array(startPoint) - np.array(endPoint)).astype("double")
-    height = np.sqrt(heightVector.dot(heightVector))
-    radius = dimension / 2
+    TubeSpatialObjectPoints = [itk.itkTubeSpatialObjectPointPython.itkTubeSpatialObjectPoint3(),
+                               itk.itkTubeSpatialObjectPointPython.itkTubeSpatialObjectPoint3()]
 
-    x, y, z = grid_from_image(img)
+    TubeSpatialObjectPoints[0].SetPositionInObjectSpace(startPoint)
+    TubeSpatialObjectPoints[0].SetRadiusInObjectSpace(startRadius)
+    TubeSpatialObjectPoints[1].SetPositionInObjectSpace(endPoint)
+    TubeSpatialObjectPoints[1].SetRadiusInObjectSpace(endRadius)
+
+    TubeSpatialObject.SetPoints(TubeSpatialObjectPoints)
+    TubeSpatialObject.SetEndRounded(False)
+    TubeSpatialObject.Update()
+
+    # map spatial object to image FoR
+    SpatialObjectToImage = itk.itkSpatialObjectToImageFilterPython.itkSpatialObjectToImageFilterSO3IUC3_New()
+
+    SpatialObjectToImage.SetInsideValue(1)
+    SpatialObjectToImage.SetOutsideValue(0)
+    SpatialObjectToImage.SetInput(TubeSpatialObject)
+    SpatialObjectToImage.SetSize(imgITK.GetLargestPossibleRegion().GetSize())
+    SpatialObjectToImage.SetDirection(imgITK.GetDirection())
+    SpatialObjectToImage.SetOrigin(imgITK.GetOrigin())
+    SpatialObjectToImage.SetSpacing(imgITK.GetSpacing())
+    SpatialObjectToImage.Update()
+    imgMask = SpatialObjectToImage.GetOutput()
 
-    u = (float(startPoint[0]) - x, float(startPoint[1]) - y, float(startPoint[2]) - z)
+    imgMask = ft.ITK2SITK(imgMask)
 
-    dxyz = cross(heightVector, u)
+    if displayInfo:
+        print(f"### {ft._currentFuncName()} ###")
+        ft.ft_imgAnalyse._displayImageInfo(imgMask)
+        print("#" * len(f"### {ft._currentFuncName()} ###"))
+
+    return imgMask
 
-    d = (sitk.Sqrt(sum([dxyzS**2 for dxyzS in dxyz])) / height) <= radius
-    side1 = dot(heightVector.tolist(), (x - float(startPoint[0]), y - float(startPoint[1]), z - float(startPoint[2]))) <= 0
-    side2 = dot(heightVector.tolist(), (x - float(endPoint[0]), y - float(endPoint[1]), z - float(endPoint[2]))) >= 0
 
-    imgMask = d * side1 * side2
+def createCylinderMask(img, startPoint, endPoint, radious, displayInfo=False):
+    """Create a cylindrical Mask in the image field of reference
+
+    The function creates a cylindrical mask with a given radious and height
+    calculated from the starting and ending points of the cylinder in the frame of
+    references of an image defined as a SimpleITK image object describing a 3D image.
+    Only 3D images are supported. For instance, the routine might help make
+    a geometrical acceptance correction of a chamber used for Bragg peak measurements.
+    The routine was adapted from a GitHub repository: https://github.com/heydude1337/SimplePhantomToolkit/.
+
+    Parameters
+    ----------
+    img : SimpleITK Image
+        Object of a SimpleITK 3D image.
+    startPoint : array_like
+        3-element point describing the position of the center of the first cylinder base.
+    endPoint : array_like
+        3-element point describing the position of the center of the second cylinder base.
+    radious : scalar
+        Radious of the cylinder.
+    displayInfo : bool, optional
+        Displays a summary of the function results. (def. False)
+
+    Returns
+    -------
+    SimpleITK Image
+        An instance of a SimpleITK image object describing a mask (i.e. type 'uint8' with 0/1 values).
+
+    See Also
+    --------
+        mapStructToImg : mapping a structure to an image to create a mask.
+        setValueMask : setting values of the image inside/outside a mask.
+        cropImgToMask : crop an image to mask.
+        createConeMask: create a cone mask.
+        createEllipseMask : create an ellipse mask.
+    """
+    import SimpleITK as sitk
+    import fredtools as ft
+    import numpy as np
+
+    imgMask = ft.createConeMask(img, startPoint, endPoint, radious, radious)
 
     if displayInfo:
         print(f"### {ft._currentFuncName()} ###")
-        print(f"# Cylinder height/dimension [mm]: {height:.2f} / {dimension:.2f}")
-        print("# Cylinder volume theoretical/real [cm3]: {:.2f} / {:.2f}".format(height * np.pi * radius**2 / 1e3, np.prod(imgMask.GetSpacing()) * sitk.GetArrayFromImage(imgMask).sum() / 1e3))
         ft.ft_imgAnalyse._displayImageInfo(imgMask)
         print("#" * len(f"### {ft._currentFuncName()} ###"))
+
     return imgMask
 
 
 def sumVectorImg(img, displayInfo=False):
     """Sum vector image.
 
     The function sums all elements of a vector in a vector image
```

## fredtools/ft_misc.py

```diff
@@ -687,28 +687,32 @@
     ----------
     pattern : string
         A string describing the regular expression. It is recommended
         the string be a row string, starting with r'...'.
     fileName : string
         Path String to ASCI file.
     kind : {'all', 'first', 'last'}, optional
-        Determine which line is to be returned: the first only, the last or all the lines. (def. 'all')
+        Determine which line is to be returned: the first only, the last, or 
+        all the lines. (def. 'all')
     startLine : int, optional
         The line number to start the search (def. 1)
     removeEoL : bool, optional
-        Determine if the end-of-line ('\n') should be removed from each returned line. (def. True)
+        Determine if the end-of-line should be removed from 
+        each returned line. (def. True)
     comment : strung, optional
         If not None or an empty string, then no lines starting with this
         string (leading white spaces are removed) will be returned. (def. '#')
 
     Returns
     -------
     line index, line string
-        If kind='all': a tuple of two tuples where the first one is the matched line numbers and the second is the line strings.
-        If kind='first' or kind='last': a tuple with the first or last matched line number and the line string.
+        If kind='all': a tuple of two tuples where the first one is the 
+        matched line numbers and the second is the line strings.
+        If kind='first' or kind='last': a tuple with the first or last 
+        reached line number and the line string.
 
     References
     ----------
     .. [1] `Regular expression operations <https://docs.python.org/3/library/re.html>`_
     """
     import re
 
@@ -729,14 +733,18 @@
         if re.findall(pattern, line):
             lineIdx.append(i)
             # remove end-of-line sign '\n' if reqiested
             if removeEoL:
                 line = line.replace("\n", "")
             lineString.append(line)
 
+    # return None if not matching was found
+    if not lineIdx:
+        return None
+
     if kind.lower() == "first":
         lineIdx = lineIdx[0]
         lineString = lineString[0]
     elif kind.lower() == "last":
         lineIdx = lineIdx[-1]
         lineString = lineString[-1]
     elif kind.lower() == "all":
```

## fredtools/ft_simTools.py

```diff
@@ -73,15 +73,15 @@
     return simFolder
 
 
 def readFREDStat(fileNameLogOut, displayInfo=False):
     """Read FRED simulation statistics information from the log file.
 
     The function reads some statistics information from a FRED run.out logfile.
-    If some information is not available, then a NaN or numpy.nan is returned.
+    If some information is unavailable, then a NaN or numpy.nan is returned.
 
     Parameters
     ----------
     fileNameLogOut : string
         A string path to FRED output logfile (usually in out/log/run.out)
     displayInfo : bool, optional
         Displays a summary of the function results. (def. False)
@@ -104,118 +104,107 @@
         if unit == "ms":
             return 1e3
         if unit == "s":
             return 1
         else:
             return nan
 
+    def matchData(lineInclude, matching, startLine=1):
+        lineFromFile = ft.getLineFromFile(lineInclude, fileNameLogOut, kind="first", startLine=startLine)
+        if not lineFromFile:
+            return "NaN"
+        value = re.findall(matching, lineFromFile[1])
+        if not value:
+            return "NaN"
+        return value[0]
+
     # check if file exists
     if not os.path.isfile(fileNameLogOut):
         raise ValueError(f"The file {fileNameLogOut} dose not exist.")
 
     simInfo = {
         "fredVersion": "NaN",
         "fredVersionDate": "NaN",
         "runConfig": "NaN",
-        "runConfigMPI": nan,
-        "runConfigTHREADS": nan,
-        "runConfigGPU": nan,
-        "runWallclockTime_s": nan,
-        "primarySimulated": nan,
-        "trackingRate_prim_s": nan,
-        "trackTimePerPrimary_us": nan,
-        "timingInitialization_s": nan,
-        "timingPBSkimming_s": nan,
-        "timingPrimaryList_s": nan,
-        "timingGeometryChecking_s": nan,
-        "timingTracking_s": nan,
-        "timingWritingOutput_s": nan,
-        "timingOther_s": nan,
+        "runWallclockTime_s": np.nan,
+        "primarySimulated": np.nan,
+        "trackingRate_prim_s": np.nan,
+        "trackTimePerPrimary_us": np.nan,
+        "timingInitialization_s": np.nan,
+        "timingPrimaryList_s": np.nan,
+        "timingDeliveryChecking_s": np.nan,
+        "timingGeometryChecking_s": np.nan,
+        "timingTracking_s": np.nan,
+        "timingWritingOutput_s": np.nan,
+        "timingOther_s": np.nan,
     }
 
-    with open(fileNameLogOut) as f:
-        for num, line in enumerate(f, 1):
-            # FRED Version and release date
-            Version_re = re.search(r"Version\W+([\S+.]+)", line)
-            VersionDate_re = re.search(r"Version.*([0-9]{4}\/[0-9]{2}\/[0-9]{2})", line)
-            if Version_re:
-                simInfo["fredVersion"] = Version_re.group(1)
-            if VersionDate_re:
-                simInfo["fredVersionDate"] = VersionDate_re.group(1)
-
-            # configuration fo the run
-            RunningConfig_re = re.search(r"Running config.*([0-9]+)\,([0-9]+)\,([0-9]+)", line)
-            if RunningConfig_re:
-                simInfo["runConfigMPI"] = int(RunningConfig_re.group(1))
-                simInfo["runConfigTHREADS"] = int(RunningConfig_re.group(2))
-                simInfo["runConfigGPU"] = int(RunningConfig_re.group(3))
-                if simInfo["runConfigGPU"] == 0:
-                    simInfo["runConfig"] = "CPUx{:d}".format(simInfo["runConfigTHREADS"])
-                else:
-                    simInfo["runConfig"] = "GPUx{:d}".format(simInfo["runConfigGPU"])
-
-            # total run time
-            RunWallclockTime_re = re.findall(r"Run wallclock time:\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)", line)
-            if RunWallclockTime_re:
-                simInfo["runWallclockTime_s"] = float(RunWallclockTime_re[0])
-
-            # total number of primaries simulated
-            PrimarySimulated_re = re.findall(r"Number of primary particles\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)", line)
-            if PrimarySimulated_re:
-                simInfo["primarySimulated"] = int(float(PrimarySimulated_re[0]))
-
-            # Average Tracking Rate (prim/s)
-            TrackingRate_re = re.findall(r"Tracking rate\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)", line)
-            if TrackingRate_re:
-                simInfo["trackingRate_prim_s"] = float(TrackingRate_re[0])
-
-            # Average Track time per prim
-            TrackTimePerPrimary_re = re.findall(r"Track time per primary\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)\W+(.+)", line)
-            if TrackTimePerPrimary_re:
-                simInfo["trackTimePerPrimary_us"] = float(TrackTimePerPrimary_re[0][0]) / scaleUnit(TrackTimePerPrimary_re[0][1]) * 1e6
-
-            # Timing: initialization
-            TimingInitialization_re = re.findall(r"\W+initialization\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)\W+([A-Za-z]+)", line)
-            if TimingInitialization_re:
-                simInfo["timingInitialization_s"] = float(TimingInitialization_re[0][0]) / scaleUnit(TimingInitialization_re[0][1])
-            # Timing: PB skimming
-            TimingPBSkimming_re = re.findall(r"\W+PB skimming\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)\W+([A-Za-z]+)", line)
-            if TimingPBSkimming_re:
-                simInfo["timingPBSkimming_s"] = float(TimingPBSkimming_re[0][0]) / scaleUnit(TimingPBSkimming_re[0][1])
-            # Timing: primary list
-            TimingPrimaryList_re = re.findall(r"\W+primary list\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)\W+([A-Za-z]+)", line)
-            if TimingPrimaryList_re:
-                simInfo["timingPrimaryList_s"] = float(TimingPrimaryList_re[0][0]) / scaleUnit(TimingPrimaryList_re[0][1])
-            # Timing: geometry checking
-            TimingGeometryChecking_re = re.findall(r"\W+geometry checking\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)\W+([A-Za-z]+)", line)
-            if TimingGeometryChecking_re:
-                simInfo["timingGeometryChecking_s"] = float(TimingGeometryChecking_re[0][0]) / scaleUnit(TimingGeometryChecking_re[0][1])
-            # Timing: tracking
-            TimingTracking_re = re.findall(r"\W+tracking\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)\W+([A-Za-z]+)", line)
-            if TimingTracking_re:
-                simInfo["timingTracking_s"] = float(TimingTracking_re[0][0]) / scaleUnit(TimingTracking_re[0][1])
-            # Timing: writing output
-            TimingWritingOutput_re = re.findall(r"\W+writing output\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)\W+([A-Za-z]+)", line)
-            if TimingWritingOutput_re:
-                simInfo["timingWritingOutput_s"] = float(TimingWritingOutput_re[0][0]) / scaleUnit(TimingWritingOutput_re[0][1])
-            # Timing: other
-            TimingOther_re = re.findall(r"\W+other\W+([-+]?[.]?[\d]+(?:,\d\d\d)*[\.]?\d*(?:[eE][-+]?\d+)?)\W+([A-Za-z]+)", line)
-            if TimingOther_re:
-                simInfo["timingOther_s"] = float(TimingOther_re[0][0]) / scaleUnit(TimingOther_re[0][1])
+    simInfo["fredVersion"] = matchData(r"Version", r"Version\W+([\S+.]+)")
+    simInfo["fredVersionDate"] = matchData(r"Version", r"Version.*([0-9]{4}\/[0-9]{2}\/[0-9]{2})")
+
+    # check run config
+    runningConfigLine = ft.getLineFromFile(r"Running config", fileNameLogOut, kind="first")
+    if runningConfigLine:
+        runningConfigTypes = re.findall(r"\w+", re.findall(r"Running config.*\((.*)\)", runningConfigLine[1])[0])
+        runningConfigValues = re.findall(r"\d+", re.findall(r"Running config.*:(.*)", runningConfigLine[1])[0])
+        for runningConfigType, runningConfigValue in zip(runningConfigTypes, runningConfigValues):
+            simInfo["runConfig"+runningConfigType] = int(runningConfigValue)
+        if "runConfigGPU" in simInfo.keys() and simInfo["runConfigGPU"] > 0:
+            simInfo["runConfig"] = "GPUx{:d}".format(simInfo["runConfigGPU"])
+        elif "runConfigPTHREADS" in simInfo.keys():
+            simInfo["runConfig"] = "CPUx{:d}".format(simInfo["runConfigPTHREADS"])
+        else:
+            simInfo["runConfig"] = "NaN"
+
+    simInfo["runWallclockTime_s"] = float(matchData(r"Run wallclock time", rf"Run wallclock time:\W+({ft.re_number})"))
+    simInfo["primarySimulated"] = int(float(matchData(r"Number of primary particles", rf"Number of primary particles:\W+({ft.re_number})")))
+
+    simInfo["trackingRate_prim_s"] = int(float(matchData(r"Tracking rate", rf"Tracking rate:\W+({ft.re_number})")))
+    simInfo["trackTimePerPrimary_us"] = float(matchData(r"Track time per primary", rf"Track time per primary:\W+({ft.re_number})"))
+    simInfo["trackTimePerPrimary_us"] /= scaleUnit(matchData(r"Track time per primary", rf"Track time per primary\W+{ft.re_number}\W*(\w+)"))
+    simInfo["trackTimePerPrimary_us"] *= 1E6
+
+    timingSummaryStartLine = ft.getLineFromFile(r"^Timing summary", fileNameLogOut, kind="first")
+    if timingSummaryStartLine:
+        simInfo["timingInitialization_s"] = float(matchData(r"initialization", rf"initialization\W+({ft.re_number})", startLine=timingSummaryStartLine[0]))
+        simInfo["timingInitialization_s"] /= scaleUnit(matchData(r"initialization", rf"initialization\W+{ft.re_number}\W*(\w+)", startLine=timingSummaryStartLine[0]))
+
+        simInfo["timingPrimaryList_s"] = float(matchData(r"primary list", rf"primary list\W+({ft.re_number})", startLine=timingSummaryStartLine[0]))
+        simInfo["timingPrimaryList_s"] /= scaleUnit(matchData(r"primary list", rf"primary list\W+{ft.re_number}\W*(\w+)", startLine=timingSummaryStartLine[0]))
+
+        simInfo["timingDeliveryChecking_s"] = float(matchData(r"delivery checking", rf"delivery checking\W+({ft.re_number})", startLine=timingSummaryStartLine[0]))
+        simInfo["timingDeliveryChecking_s"] /= scaleUnit(matchData(r"delivery checking", rf"delivery checking\W+{ft.re_number}\W*(\w+)", startLine=timingSummaryStartLine[0]))
+
+        simInfo["timingGeometryChecking_s"] = float(matchData(r"geometry checking", rf"geometry checking\W+({ft.re_number})", startLine=timingSummaryStartLine[0]))
+        simInfo["timingGeometryChecking_s"] /= scaleUnit(matchData(r"geometry checking", rf"geometry checking\W+{ft.re_number}\W*(\w+)", startLine=timingSummaryStartLine[0]))
+
+        simInfo["timingTracking_s"] = float(matchData(r"tracking", rf"tracking\W+({ft.re_number})", startLine=timingSummaryStartLine[0]))
+        simInfo["timingTracking_s"] /= scaleUnit(matchData(r"tracking", rf"tracking\W+{ft.re_number}\W*(\w+)", startLine=timingSummaryStartLine[0]))
+
+        simInfo["timingWritingOutput_s"] = float(matchData(r"writing output", rf"writing output\W+({ft.re_number})", startLine=timingSummaryStartLine[0]))
+        simInfo["timingWritingOutput_s"] /= scaleUnit(matchData(r"writing output", rf"writing output\W+{ft.re_number}\W*(\w+)", startLine=timingSummaryStartLine[0]))
+
+        simInfo["timingOther_s"] = float(matchData(r"other", rf"other\W+({ft.re_number})", startLine=timingSummaryStartLine[0]))
+        simInfo["timingOther_s"] /= scaleUnit(matchData(r"other", rf"other\W+{ft.re_number}\W*(\w+)", startLine=timingSummaryStartLine[0]))
 
     if displayInfo:
         print(f"### {ft._currentFuncName()} ###")
         print("# FRED Version: {:s}".format(simInfo["fredVersion"]))
         print("# FRED Version Date: {:s}".format(simInfo["fredVersionDate"]))
-        print("# Run Config (MPI,THREADS,GPU): {:d},{:d},{:d}".format(simInfo["runConfigMPI"], simInfo["runConfigTHREADS"], simInfo["runConfigGPU"]))
+        runConfigKeys = [key for key in simInfo.keys() if re.search("runConfig.+", key)]
+        if runConfigKeys:
+            runConfigValues = [simInfo[runConfigKey] for runConfigKey in runConfigKeys]
+            runConfigKeys = [runConfigKey.replace("runConfig", "") for runConfigKey in runConfigKeys]
+            print(f"# Run Config ({','.join(runConfigKeys)}): {str(runConfigValues).replace('[','').replace(']','')}")
         print("# Run Config: {:s}".format(simInfo["runConfig"]))
         print("# Run Wall clock Time: {:.2f} s".format(simInfo["runWallclockTime_s"]))
         print("# Average Track Time Per Primary: {:5f} us".format(simInfo["trackTimePerPrimary_us"]))
         print("# Average Tracking Rate: {:.3E} prim/s".format(simInfo["trackingRate_prim_s"]))
         print("#" * len(f"### {ft._currentFuncName()} ###"))
+
     return simInfo
 
 
 def readBeamModel(fileName):
     """Read beam model from a YAML file.
 
     The function reads the beam model parameters from a YAML beam model file.
@@ -263,15 +252,15 @@
             f"Missing sections in the beam model loaded from {fileName}\nThe beam model must include at least 'BM Description', 'BM Energy', 'BM RangeShifters' and 'BM Materials' sections."
         )
 
     # convert all dataFrame-like lists of strings to dataFrame
     for key in beamModel.keys():
         if isinstance(beamModel[key], list):
             if ("row" in beamModel[key][-1]) and ("column" in beamModel[key][-1]):  # the key is a pandas DataFrame
-                beamModel[key] = pd.read_csv(StringIO("\n".join(beamModel[key][:-1])), delim_whitespace=True)
+                beamModel[key] = pd.read_csv(StringIO("\n".join(beamModel[key][:-1])), sep='\s+')
                 if "nomEnergy" in beamModel[key].columns:
                     beamModel[key].set_index("nomEnergy", inplace=True)
 
     # validate if required columns exist in BM Energy
     if not {"Energy", "dEnergy", "scalingFactor", "alphaX", "betaX", "epsilonX", "alphaY", "betaY", "epsilonY"}.issubset(beamModel["BM Energy"].columns):
         raise ValueError(f"Missing columns or wrong column names of 'BM Energy' when loading beam model from {fileName}.")
     # validate if there are any missing (None, NaN) values in BM Energy
```

## fredtools/ft_imgIO/dicom_io.py

```diff
@@ -525,15 +525,15 @@
             sliceInfo["PBSnoutPos"] = [IonControlPointDataset.SnoutPosition.real] * spotsNo if "SnoutPosition" in IonControlPointDataset else np.nan
             sliceInfo["PBnomEnergy"] = [IonControlPointDataset.NominalBeamEnergy.real] * spotsNo if "NominalBeamEnergy" in IonControlPointDataset else np.nan
             sliceInfo["PBMsW"] = IonControlPointDataset.ScanSpotMetersetWeights
             sliceInfo["PBMU"] = np.array(IonControlPointDataset.ScanSpotMetersetWeights) / fieldCumMsW * fieldDose
             sliceInfo["PBPosX"] = IonControlPointDataset.ScanSpotPositionMap[0::2]
             sliceInfo["PBPosY"] = IonControlPointDataset.ScanSpotPositionMap[1::2]
             sliceInfo["PBTuneID"] = [IonControlPointDataset.ScanSpotTuneID] * spotsNo
-            sliceInfo["PNPainting"] = [IonControlPointDataset.NumberOfPaintings] * spotsNo
+            sliceInfo["PBPainting"] = [IonControlPointDataset.NumberOfPaintings] * spotsNo
             sliceInfo = pd.DataFrame(sliceInfo)
             slicesInfo.append(sliceInfo)
         slicesInfo = pd.concat(slicesInfo)
         slicesInfo["FSpotNo"] = range(1, slicesInfo.shape[0] + 1)
         spotsInfo.append(slicesInfo)
     spotsInfo = pd.concat(spotsInfo)
```

## fredtools/ft_imgIO/dij_io.py

```diff
@@ -46,14 +46,18 @@
     -----
     It is possible to request various combinations of pencil beams and fields. For instance:
 
         - FNo=None, PBNo=2: will get just the pencil beam no 2 and the field ID will be calculated automatically,
         - FNo=None, PBNo=[20,30,40]: will get just the pencil beams no 20, 30 and 40 and the field ID will be calculated automatically,
         - FNo=1, PBNo=None: will get all the pencil beams from field 1,
         - FNo=[3,1], PBNo=None: will get all the pencil beams from fields 1 and 3.
+
+    The binary influence matrix file format had changed from FRED 3.69.3 version. The function has been aligned to this format 
+    but will not work for the previous format. Use FREDtools v. 0.7.6 to read the old binary influence matrix file format or 
+    contact the FREDtools developers.
     """
     import struct
     import SimpleITK as sitk
     import numpy as np
     import fredtools as ft
     import psutil
     import pandas as pd
@@ -125,15 +129,17 @@
     with open(dijFileName, "rb") as dijFile_h:
         [sizeX, sizeY, sizeZ, spacingX, spacingY, spacingZ, offsetX, offsetY, offsetZ, pencilBeamNo] = struct.unpack("<3i6f1i", dijFile_h.read(40))
 
         arr = []
         FIDs = []
         PBIDs = []
         for pencilBeam_idx in range(pencilBeamNo):
-            [PBID, FID, voxelsNo] = struct.unpack("3i", dijFile_h.read(12))
+            [PBTag, voxelsNo] = struct.unpack("2i", dijFile_h.read(8))
+            PBID = PBTag % 1000000
+            FID = int(PBTag / 1000000)
             if len(PBInfo.loc[(PBInfo.FID == FID) & (PBInfo.PBID == PBID)]) == 1:
                 FIDs.append(FID)
                 PBIDs.append(PBID)
 
                 voxelIndices = np.frombuffer(dijFile_h.read(voxelsNo * 4), dtype="uint32", count=voxelsNo)
                 voxelValues = np.frombuffer(dijFile_h.read(voxelsNo * 4), dtype="float32", count=voxelsNo)
 
@@ -214,14 +220,18 @@
         - FNo=[3,1], PBNo=None, weight=[1E9, 1E5]: will get all the pencil beams from fields 1 and 3 and the pencil beams will be weighted by 1E9 and 1E5 for the respective fields,
         - FNo=None, PBNo=None, weight=[1E9, 2E9, ..., 3E9]: will get all the pencil beams saved in the Dij influence matrix and each pencil beam will be weighted by a separate number (the length of `weight` must be the same as the number of the pencil beams in the Dij influence matrix).
 
     The last example is the most common. The Dij influence matrix is usually calculated for a single primary for each pencil beam.
     In such a case, the weights represent the number of particles to be delivered, calculated from a treatment plan. It has been tested that
     the 3D dose distribution is consistent concerning the field-of-reference and values with the dose distribution calculated directly
     by FRED Monte Carlo.
+
+    The binary influence matrix file format had changed from FRED 3.69.3 version. The function has been aligned to this format 
+    but will not work for the previous format. Use FREDtools v. 0.7.6 to read the old binary influence matrix file format or 
+    contact the FREDtools developers.
     """
     import struct
     import SimpleITK as sitk
     import numpy as np
     import fredtools as ft
     from collections.abc import Iterable
     import pandas as pd
@@ -319,15 +329,17 @@
     # create empty vector
     arrVec = np.zeros(size, dtype="float64")
 
     with open(dijFileName, "rb") as dijFile_h:
         [sizeX, sizeY, sizeZ, spacingX, spacingY, spacingZ, offsetX, offsetY, offsetZ, pencilBeamNo] = struct.unpack("<3i6f1i", dijFile_h.read(40))
 
         for pencilBeam_idx in range(pencilBeamNo):
-            [PBID, FID, voxelsNo] = struct.unpack("3i", dijFile_h.read(12))
+            [PBTag, voxelsNo] = struct.unpack("2i", dijFile_h.read(8))
+            PBID = PBTag % 1000000
+            FID = int(PBTag / 1000000)
             if len(PBInfo.loc[(PBInfo.FID == FID) & (PBInfo.PBID == PBID)]) == 1:
                 voxelIndices = np.frombuffer(dijFile_h.read(voxelsNo * 4), dtype="uint32", count=voxelsNo)
                 voxelValues = np.frombuffer(dijFile_h.read(voxelsNo * 4), dtype="float32", count=voxelsNo)
 
                 weight = PBInfo.loc[(PBInfo.FID == FID) & (PBInfo.PBID == PBID)].weight.values[0]
                 arrVec[voxelIndices] += voxelValues * weight  # add values to array
 
@@ -397,14 +409,20 @@
     3. It is often that some of the vectors (when calculating for multiple points) are all filled with zero.
     It means that no pencil beam, saved in the Dij influence matrix delivered the dose to that voxels. It is
     recommended filtering the output of the function for such cases and recording the zero-signal voxels.
 
     References
     ----------
     .. [1] https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.RegularGridInterpolator.html
+
+    Notes
+    -----
+    The binary influence matrix file format had changed from FRED 3.69.3 version. The function has been aligned to this format 
+    but will not work for the previous format. Use FREDtools v. 0.7.6 to read the old binary influence matrix file format or 
+    contact the FREDtools developers.
     """
     import struct
     import fredtools as ft
     import numpy as np
     import psutil
     import SimpleITK as sitk
     from scipy.interpolate import RegularGridInterpolator
@@ -448,15 +466,15 @@
         voxelCentres = ft.getVoxelCentres(imgBase)
         arrVec = np.zeros(size, dtype="float32")
         rgi = RegularGridInterpolator(voxelCentres, np.reshape(arrVec, shape, order="F"), method=interpolation, bounds_error=False, fill_value=None)
 
         # interpolate point value for BP
         pointValues = []
         for pencilBeam_idx in range(pencilBeamNo):
-            [PBID, FID, voxelsNo] = struct.unpack("3i", dijFile_h.read(12))
+            [PBTag, voxelsNo] = struct.unpack("2i", dijFile_h.read(8))
             voxelIndices = np.frombuffer(dijFile_h.read(voxelsNo * 4), dtype="uint32", count=voxelsNo)
             voxelValues = np.frombuffer(dijFile_h.read(voxelsNo * 4), dtype="float32", count=voxelsNo)
 
             arrVec = np.zeros(size, dtype="float32")
             arrVec[voxelIndices] = voxelValues  # replace values in array
             rgi.values = np.reshape(arrVec, shape, order="F")
             pointValues.append(rgi(points).astype("float32"))
@@ -493,14 +511,20 @@
         Pandas DataFrame with pencil beams and field numbers.
 
     See Also
     --------
         getDijFREDPoint : get a vector of interpolated values in a point from a Dij influence matrix produced by FRED Monte Carlo.
         getDijFREDVectorImage : get a vector image from a Dij influence matrix produced by FRED Monte Carlo.
         getDijFREDSumImage : get FRED Dij image to a sum SimpleITK image object.
+
+    Notes
+    -----
+    The binary influence matrix file format had changed from FRED 3.69.3 version. The function has been aligned to this format 
+    but will not work for the previous format. Use FREDtools v. 0.7.6 to read the old binary influence matrix file format or 
+    contact the FREDtools developers.
     """
     import fredtools as ft
     import numpy as np
     import SimpleITK as sitk
     import pandas as pd
     import struct
 
@@ -518,17 +542,17 @@
         imgBase.SetOrigin(origin)
         imgBase.SetSpacing(spacing)
 
         PBIDs = []
         FIDs = []
         voxelsNos = []
         for pencilBeam_idx in range(pencilBeamNo):
-            [PBID, FID, voxelsNo] = struct.unpack("3i", dijFile_h.read(12))
-            PBIDs.append(PBID)
-            FIDs.append(FID)
+            [PBTag, voxelsNo] = struct.unpack("2i", dijFile_h.read(8))
+            PBIDs.append(PBTag % 1000000)
+            FIDs.append(int(PBTag / 1000000))
             voxelsNos.append(voxelsNo)
 
             dijFile_h.seek(voxelsNo * 8, 1)
 
     DijInfo = pd.DataFrame({"PBID": PBIDs, "FID": FIDs, "voxelsNo": voxelsNos})
 
     if displayInfo:
```

## fredtools/ft_imgIO/other_io.py

```diff
@@ -30,15 +30,15 @@
     asciibodyStart = ft.getLineFromFile(r"^<asciibody>", fileName, kind="first")[0]
     asciibodyEnd = ft.getLineFromFile(r"^</asciibody>", fileName, kind="first")[0]
     Xcoor = ft.getLineFromFile(rf"X\[{LengthUnit}\]", fileName, kind="first", startLine=asciibodyStart)[1].replace(f"X[{LengthUnit}]", "").replace("\t", "")
     Xcoor = np.fromstring(Xcoor, sep=" ")
 
     with open(fileName, "r") as file:
         data = file.readlines()
-    data = data[ft.getLineFromFile(rf"Y\[{LengthUnit}\]", fileName, kind="first", startLine=asciibodyStart)[0] : asciibodyEnd - 1]
+    data = data[ft.getLineFromFile(rf"Y\[{LengthUnit}\]", fileName, kind="first", startLine=asciibodyStart)[0]: asciibodyEnd - 1]
     arr = []
     for dataLine in data:
         arr.append(np.fromstring(dataLine.replace("\t", ""), sep=" "))
     arr = np.stack(arr)
     Ycoor = arr[:, 0]
     arr = arr[:, 1:]
     arr = arr * DataFactor  # rescale data
@@ -66,15 +66,16 @@
             Ycoor *= 10
         case _:
             raise AttributeError(f"Could not recognise length unit '{LengthUnit}'.")
 
     arr = np.expand_dims(arr, 0)
 
     img = sitk.GetImageFromArray(arr)
-    img.SetSpacing([np.unique(np.diff(Xcoor).round(2))[0], np.unique(np.diff(Ycoor).round(2))[0], 0.1])
+    # img.SetSpacing([np.unique(np.diff(Xcoor).round(2))[0], np.unique(np.diff(Ycoor).round(2))[0], 0.1])
+    img.SetSpacing([7.619354838709677, 7.619354838709677, 0.1])  # values set to constant distance of MatriXX PT
     img.SetOrigin([Xcoor[0], Ycoor[0], depth])
 
     if displayInfo:
         print(f"### {ft._currentFuncName()} ###")
         print(f"# Original Data Unit:   {DataUnit}")
         print(f"# Original Data Factor: {DataFactor}")
         print(f"# Original Length Unit: {LengthUnit}")
```

## fredtools/ft_optimisation/__init__.py

```diff
@@ -1 +1,2 @@
 from .ft_optimiseBeamPositions import *
+from .ft_preoptimizer import *
```

## Comparing `fredtools-0.7.5.dist-info/METADATA` & `fredtools-0.7.9.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 Metadata-Version: 2.1
 Name: fredtools
-Version: 0.7.5
+Version: 0.7.9
 Summary: FRED tools is a collection of python functions for image manipulation and analysis. See more on https://github.com/jasqs/FREDtools.
 Home-page: https://www.fredtools.ifj.edu.pl/
 Author: FRED Collaboration
 Author-email: jan.gajewski@ifj.edu.pl
 Project-URL: Repository, https://github.com/jasqs/FREDtools
 Project-URL: FRED MC, http://www.fred-mc.org/
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.10,<4.0
 Description-Content-Type: text/markdown
 Requires-Dist: dicompyler-core (>=0.5.6)
 Requires-Dist: fitz (>=0.0.1.dev2)
-Requires-Dist: fredtools (>=0.7.4)
-Requires-Dist: ipython (>=8.19.0)
-Requires-Dist: ipywidgets (>=8.1.1)
+Requires-Dist: fredtools (>=0.7.5)
+Requires-Dist: ipython (>=8.21.0)
+Requires-Dist: ipywidgets (>=8.1.2)
 Requires-Dist: itk (>=5.3.0)
 Requires-Dist: itk-core (>=5.3.0)
 Requires-Dist: itk-filtering (>=5.3.0)
 Requires-Dist: itk-io (>=5.3.0)
 Requires-Dist: itk-numerics (>=5.3.0)
 Requires-Dist: itk-registration (>=5.3.0)
 Requires-Dist: itk-segmentation (>=5.3.0)
 Requires-Dist: landaupy (>=0.1)
 Requires-Dist: lmfit (>=1.2.2)
 Requires-Dist: matplotlib (>=3.8.2)
 Requires-Dist: numpy (>=1.24.2)
-Requires-Dist: pandas (>=2.1.4)
+Requires-Dist: pandas (>=2.2.0)
 Requires-Dist: psutil (>=5.9.4)
 Requires-Dist: pyamtrack (>=0.14.0)
 Requires-Dist: pydicom (>=2.4.4)
 Requires-Dist: PyYAML (>=6.0.1)
 Requires-Dist: PyYAML (>=5.4.1)
-Requires-Dist: scipy (>=1.11.4)
+Requires-Dist: scipy (>=1.12.0)
 Requires-Dist: Shapely (>=2.0.2)
 Requires-Dist: SimpleITK (>=2.3.1)
-Requires-Dist: uproot (>=5.2.1)
+Requires-Dist: uproot (>=5.2.2)
 
 FRED tools repository
 ================================
 
 FRED tools is a collection of python functions for image manipulation and analysis. The basic methods have been developed for analysis of the images produced by the Monte Carlo FRED (www.fred-mc.org) in MetaImage format (*.mha, *.mhd), but they can be applied for images in other formats, e.g. dicom.
 
 Basic Concept
```

## Comparing `fredtools-0.7.5.dist-info/RECORD` & `fredtools-0.7.9.dist-info/RECORD`

 * *Files 17% similar despite different names*

```diff
@@ -1,26 +1,27 @@
-fredtools/__init__.py,sha256=SjORQv5nNuhc7CTs9RDVuBwH6UpjUT6iYU-qE3cTz4g,10019
+fredtools/__init__.py,sha256=N2bTL9XEywp6LcJEFOjtfmXhrA9Erx3-x_Omw5G7F9g,10479
 fredtools/ft_braggPeak.py,sha256=KQNuu5OEmEZ7aR1vtKGxFn0jNrk_S5Oeli93Gb6cNtk,27295
 fredtools/ft_displayImg.py,sha256=53JAxWu_Trr8KSWkKBy3Iqz40qlRgk8Mudw98pQEr1s,19772
 fredtools/ft_dvh.py,sha256=aarbrSKWUUkBHepp2SFTpwTWKWe08hQO0pwx128qAQE,8501
-fredtools/ft_imgAnalyse.py,sha256=6xKtzBbqu6ziUrXSE4bhoM10mPINVwdqqBqNgZGgb1M,45903
+fredtools/ft_imgAnalyse.py,sha256=dLoVy085swjgajyZUcm-S5-0sv26nC5xb_iiy6fzxKE,46620
 fredtools/ft_imgGetSubimg.py,sha256=uSS9V4YL7ppn2EGnwWWkJzZoRorzQmlvlUe5Wpd_vmg,30800
-fredtools/ft_imgManipulate.py,sha256=yI7412_MOU4s-mgEch1XLba9D_24tQTD06GCEmRES5U,55623
-fredtools/ft_misc.py,sha256=FUKZXY1AVdljAMQ1TYAR8m89QL7Py3gfIqMu-gr4q7U,27765
-fredtools/ft_simTools.py,sha256=SSdH3QhdyxTlgPva30mL2Ew1KanJp70eEQsDqa0SXe4,33560
+fredtools/ft_imgManipulate.py,sha256=K-n6UYnpBFr33iu4xS98XNMx3UNJEX-SF0gLB8vVSkw,60674
+fredtools/ft_misc.py,sha256=p5DJ8-a0zTBtQLObzLOpwFI3LOgDjjN-cv45BNr5Q6U,27880
+fredtools/ft_simTools.py,sha256=HCZ6wsEN_1KQMeYDSJIxEEp79HRDgvZMJsXbFh_RTUs,33519
 fredtools/ft_spotAnalyse.py,sha256=EDwsN4D3HkLXuc4L00ldJGn0d44dcT2msYxtKLCP1b8,2898
 fredtools/smparallel.py,sha256=dR_SNGVRPG5SQWIUHhPgqPTt1ygoNR4x_ezieEAhkqg,6918
 fredtools/ft_gammaIndex/__init__.py,sha256=cnTFMo24C65Ihz3gjkovuGFziwWNBDaFGOxL7y9WdmY,26
 fredtools/ft_gammaIndex/gammaIndex.py,sha256=YW5zpshpI6cwmsha381hxGC-WWgegiY5rkPRcZvbRdE,15500
 fredtools/ft_gammaIndex/libFredGI.so,sha256=QVmR55MaOWlyfZ53r0ydNvcP30iP618qi0sI5asB4yc,694568
 fredtools/ft_imgIO/__init__.py,sha256=kB5FcYapqb7vNWuTNjZQu1s9WPR2t2octpITFYxp9fk,116
-fredtools/ft_imgIO/dicom_io.py,sha256=IJhKq41jf4q8CGvvItMi-TrQMVctnTduq4wcpTG4YMs,55814
-fredtools/ft_imgIO/dij_io.py,sha256=DC1Qas7dd7snpvbiDp5ZzfAXCEBdCO8dMeUmQN607O8,27534
+fredtools/ft_imgIO/dicom_io.py,sha256=-Wq5CPw8RPNZft5hwB1rXQjAftVK5sXf3DfkUt3y9DE,55814
+fredtools/ft_imgIO/dij_io.py,sha256=21EyLCzHL_IjFuPKQJ_jIywuLfDxeFH_qb0xGy-_9zQ,28902
 fredtools/ft_imgIO/map3d_io.py,sha256=vXaFC0aW92_zzxsduZFpNGjU_GDNWfBKBUfkf6lGCjQ,6103
 fredtools/ft_imgIO/mhd_io.py,sha256=ZPy_z68JxdIDaTxUfAbtTirsi4VQaKFqNDa1qFA6nGc,5950
-fredtools/ft_imgIO/other_io.py,sha256=BKIgdEOCK9GItbqAxxVDGh5DJ3k76_nxBMzibFuLJ3g,3076
-fredtools/ft_optimisation/__init__.py,sha256=aFNTuTd4zEARYG24qVESFAHrCHthVZe7ZJeZ35Lgj3k,40
+fredtools/ft_imgIO/other_io.py,sha256=UK86DFIbGQ-TANyw9T_2LNiX6AgHt1rJT38Xk0QI_Fg,3190
+fredtools/ft_optimisation/__init__.py,sha256=mDG7GZL6qxlIdM718Up7QPFdUSqpPBhB_MH7lbvEtyU,71
 fredtools/ft_optimisation/ft_optimiseBeamPositions.py,sha256=hV0WasWZS2hFoVpvJcabKjePd0pd-Uon9WDvtFIQLZw,13399
-fredtools-0.7.5.dist-info/METADATA,sha256=NCPS_sDPOssJ1uSRuSO4lyObedfkyGOAuQBaoxcmTmM,3755
-fredtools-0.7.5.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-fredtools-0.7.5.dist-info/top_level.txt,sha256=E6A6ysomqbiGakufEZjE4VH4UU1W_mGffZ0qc3OobgM,10
-fredtools-0.7.5.dist-info/RECORD,,
+fredtools/ft_optimisation/ft_preoptimizer.py,sha256=ThJj_V-bGQ3koSTMiiyytbL8fyq-vrbGei0kT6N5TKI,16112
+fredtools-0.7.9.dist-info/METADATA,sha256=XndS4JOCmmL-v1Z7XXA_rHKcowy5EoxAyMCRxETevdI,3755
+fredtools-0.7.9.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+fredtools-0.7.9.dist-info/top_level.txt,sha256=E6A6ysomqbiGakufEZjE4VH4UU1W_mGffZ0qc3OobgM,10
+fredtools-0.7.9.dist-info/RECORD,,
```

