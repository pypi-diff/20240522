# Comparing `tmp/vios-2.4.2-py3-none-any.whl.zip` & `tmp/vios-2.4.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 52321 bytes, number of entries: 24
--rw-rw-rw-  2.0 fat    18473 b- defN 24-May-14 04:37 quark/proxy.py
--rw-rw-rw-  2.0 fat    16568 b- defN 24-May-20 13:52 quark/app/__init__.py
--rw-rw-rw-  2.0 fat     3556 b- defN 24-May-20 13:52 quark/app/_data.py
--rw-rw-rw-  2.0 fat    11325 b- defN 24-May-09 13:38 quark/app/_demo.py
--rw-rw-rw-  2.0 fat     9888 b- defN 24-May-09 13:38 quark/app/_task.py
--rw-rw-rw-  2.0 fat     6622 b- defN 24-May-10 11:53 quark/app/uapi.py
--rw-rw-rw-  2.0 fat     7528 b- defN 24-May-10 11:53 quark/driver/VirtualDevice.py
--rw-rw-rw-  2.0 fat     1325 b- defN 24-May-10 11:53 quark/driver/__init__.py
--rw-rw-rw-  2.0 fat     1386 b- defN 24-May-09 13:38 quark/driver/common/__init__.py
--rw-rw-rw-  2.0 fat     5384 b- defN 24-May-10 11:53 quark/driver/common/basedriver.py
--rw-rw-rw-  2.0 fat     5856 b- defN 24-May-09 13:38 quark/driver/common/quantity.py
--rw-rw-rw-  2.0 fat     6473 b- defN 24-May-10 11:53 quark/driver/common/visadriver.py
--rw-rw-rw-  2.0 fat     2194 b- defN 24-May-14 04:37 quark/envelope/__init__.py
--rw-rw-rw-  2.0 fat    15109 b- defN 24-May-10 11:53 quark/envelope/assembler.py
--rw-rw-rw-  2.0 fat     5245 b- defN 24-May-14 04:37 quark/envelope/calculator.py
--rw-rw-rw-  2.0 fat     1984 b- defN 24-May-09 13:38 quark/envelope/device.py
--rw-rw-rw-  2.0 fat     4689 b- defN 24-May-09 13:38 quark/envelope/processor.py
--rw-rw-rw-  2.0 fat     5216 b- defN 24-May-14 04:37 quark/envelope/router.py
--rw-rw-rw-  2.0 fat     3812 b- defN 24-May-09 13:38 quark/envelope/systemq.py
--rw-rw-rw-  2.0 fat     1064 b- defN 24-May-20 14:11 vios-2.4.2.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     2432 b- defN 24-May-20 14:11 vios-2.4.2.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-May-20 14:11 vios-2.4.2.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        6 b- defN 24-May-20 14:11 vios-2.4.2.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1925 b- defN 24-May-20 14:11 vios-2.4.2.dist-info/RECORD
-24 files, 138152 bytes uncompressed, 49251 bytes compressed:  64.4%
+Zip file size: 52488 bytes, number of entries: 24
+-rw-rw-rw-  2.0 fat    19026 b- defN 24-May-13 00:57 quark/proxy.py
+-rw-rw-rw-  2.0 fat    16489 b- defN 24-May-22 02:11 quark/app/__init__.py
+-rw-rw-rw-  2.0 fat     3652 b- defN 24-May-22 02:11 quark/app/_data.py
+-rw-rw-rw-  2.0 fat    11325 b- defN 24-May-13 00:57 quark/app/_demo.py
+-rw-rw-rw-  2.0 fat    10163 b- defN 24-May-13 00:57 quark/app/_task.py
+-rw-rw-rw-  2.0 fat     6622 b- defN 24-May-13 00:57 quark/app/uapi.py
+-rw-rw-rw-  2.0 fat     7738 b- defN 24-May-13 00:57 quark/driver/VirtualDevice.py
+-rw-rw-rw-  2.0 fat     1325 b- defN 24-May-13 00:57 quark/driver/__init__.py
+-rw-rw-rw-  2.0 fat     1418 b- defN 24-May-13 00:57 quark/driver/common/__init__.py
+-rw-rw-rw-  2.0 fat     5384 b- defN 24-May-13 00:57 quark/driver/common/basedriver.py
+-rw-rw-rw-  2.0 fat     5856 b- defN 24-May-13 00:57 quark/driver/common/quantity.py
+-rw-rw-rw-  2.0 fat     6473 b- defN 24-May-13 00:57 quark/driver/common/visadriver.py
+-rw-rw-rw-  2.0 fat     2194 b- defN 24-May-13 00:57 quark/envelope/__init__.py
+-rw-rw-rw-  2.0 fat    15508 b- defN 24-May-13 00:57 quark/envelope/assembler.py
+-rw-rw-rw-  2.0 fat     5402 b- defN 24-May-13 00:57 quark/envelope/calculator.py
+-rw-rw-rw-  2.0 fat     2035 b- defN 24-May-13 00:57 quark/envelope/device.py
+-rw-rw-rw-  2.0 fat     4799 b- defN 24-May-20 05:48 quark/envelope/processor.py
+-rw-rw-rw-  2.0 fat     5216 b- defN 24-May-13 00:57 quark/envelope/router.py
+-rw-rw-rw-  2.0 fat     3812 b- defN 24-May-13 00:57 quark/envelope/systemq.py
+-rw-rw-rw-  2.0 fat     1084 b- defN 24-May-22 02:13 vios-2.4.3.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     2436 b- defN 24-May-22 02:13 vios-2.4.3.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-May-22 02:13 vios-2.4.3.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        6 b- defN 24-May-22 02:13 vios-2.4.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1926 b- defN 24-May-22 02:13 vios-2.4.3.dist-info/RECORD
+24 files, 139981 bytes uncompressed, 49418 bytes compressed:  64.7%
```

## zipnote {}

```diff
@@ -51,23 +51,23 @@
 
 Filename: quark/envelope/router.py
 Comment: 
 
 Filename: quark/envelope/systemq.py
 Comment: 
 
-Filename: vios-2.4.2.dist-info/LICENSE
+Filename: vios-2.4.3.dist-info/LICENSE
 Comment: 
 
-Filename: vios-2.4.2.dist-info/METADATA
+Filename: vios-2.4.3.dist-info/METADATA
 Comment: 
 
-Filename: vios-2.4.2.dist-info/WHEEL
+Filename: vios-2.4.3.dist-info/WHEEL
 Comment: 
 
-Filename: vios-2.4.2.dist-info/top_level.txt
+Filename: vios-2.4.3.dist-info/top_level.txt
 Comment: 
 
-Filename: vios-2.4.2.dist-info/RECORD
+Filename: vios-2.4.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## quark/proxy.py

 * *Ordering differences only*

```diff
@@ -1,553 +1,553 @@
-# MIT License
-
-# Copyright (c) 2021 YL Feng
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
-"""
-Abstract: **about proxy**
-    - `Task`: interact with the `QuarkServer` from the view of a task
-"""
-
-
-import asyncio
-import inspect
-import json
-import string
-import sys
-import time
-from collections import defaultdict
-from functools import cached_property
-from multiprocessing.shared_memory import SharedMemory
-from pathlib import Path
-from threading import current_thread
-
-import numpy as np
-from loguru import logger
-
-QUARK = Path.home()/'quark'
-
-try:
-    with open(QUARK/'startup.json', 'r') as f:
-        startup = json.loads(f.read())
-        SYSTEMQ = str(Path(startup['site']).resolve())
-        if SYSTEMQ.lower() not in sys.path:
-            sys.path.append(SYSTEMQ)
-except Exception as e:
-    logger.error(str(e))
-    startup = {}
-
-
-def setlog(prefix: str = ''):
-    logger.remove()
-    root = Path.home()/f"Desktop/home/log/proxy/{prefix}"
-    path = root/"{time:%Y-%m-%d}.log"
-    level = "INFO"
-    config = {'handlers': [{'sink': sys.stdout,
-                            'level': level},
-                           {'sink': path,
-                            'rotation': '00:00',
-                            'retention': '10 days',
-                            'encoding': 'utf-8',
-                            'level': level,
-                            'backtrace': False, }]}
-    # logger.add(path, rotation="20 MB")
-    logger.configure(**config)
-
-
-def debug(circuit: list = [(('Measure', 0), 'Q1001')], tid: int = 0):
-    from .app import get_config_by_tid
-    from .envelope import ccompile, initialize
-    initialize(get_config_by_tid(tid))
-    return ccompile(0, {}, circuit, signal='iq')
-
-
-TABLE = string.digits+string.ascii_uppercase
-
-
-def basen(number: int, base: int, table: str = TABLE):
-    mods = []
-    while True:
-        div, mod = divmod(number, base)
-        mods.append(mod)
-        if div == 0:
-            mods.reverse()
-            return ''.join([table[i] for i in mods])
-        number = div
-
-
-def baser(number: str, base: int, table: str = TABLE):
-    return sum([table.index(c)*base**i for i, c in enumerate(reversed(number))])
-
-
-def dumpv(value):
-    # print('ccccccccccccccccccccccc', value)
-    # if type(value).__name__ in ['Waveform', 'WaveVStack']:
-    #     sl = ShareableList([dump(value)])
-    #     result = ('ShareableList', sl.shm.name)
-    if isinstance(value, np.ndarray):
-        sm = SharedMemory(create=True, size=value.nbytes)
-        buf = np.ndarray(value.shape, dtype=value.dtype, buffer=sm.buf)
-        buf[:] = value[:]
-        result = sm, ('SharedMemory', sm.name, buf.shape, buf.dtype.str)
-        # sm.close()
-    else:
-        result = '', value
-    return result
-
-
-def loadv(value):
-    if isinstance(value, tuple) and value[0] == 'SharedMemory':
-        name, shape, dtype = value[1:]
-        shm = SharedMemory(name=name)
-        buf = np.ndarray(shape=shape, dtype=dtype, buffer=shm.buf)
-        return shm, buf
-    else:
-        return '', value
-
-
-try:
-    from IPython import get_ipython
-
-    shell = get_ipython().__class__.__name__
-    if shell == 'ZMQInteractiveShell':
-        from tqdm.notebook import tqdm  # jupyter notebook or qtconsole
-    else:
-        # ipython in terminal(TerminalInteractiveShell)
-        # None(Win)
-        # Nonetype(Mac)
-        from tqdm import tqdm
-except Exception as e:
-    # not installed or Probably IDLE
-    from tqdm import tqdm
-
-
-class Progress(tqdm):
-    bar_format = '{desc} {percentage:3.0f}%|{bar}|{n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}{postfix}]'
-
-    def __init__(self, desc='test', total=100, postfix='running', disable: bool = False):
-        super().__init__([], desc, total, ncols=None, colour='blue',
-                         bar_format=self.bar_format, position=0, postfix=postfix, disable=disable)
-
-    @property
-    def max(self):
-        return self.total
-
-    @max.setter
-    def max(self, value: int):
-        self.reset(value)
-
-    def goto(self, index: int):
-        self.n = index
-        self.refresh()
-
-    def finish(self, success: bool = True):
-        self.colour = 'green' if success else 'red'
-        # self.set_description_str(str(success))
-
-
-class Task(object):
-    """tracking progress, get result and debug
-    """
-
-    handles = {}
-    counter = defaultdict(lambda: 0)
-    server = None
-
-    def __init__(self, task: dict, timeout: float | None = None, plot: bool = False) -> None:
-        """instantiate a task
-
-        Args:
-            task (dict): see **quark.app.submit**
-            timeout (float | None, optional): timeout for the task. Defaults to None.
-            plot (bool, optional): plot result in `quark studio` if True. Defaults to False.
-        """
-        self.task = task
-        self.timeout = timeout
-        self.plot = plot
-
-        self.data: dict[str, np.ndarray] = {}  # retrieve data from server
-        self.meta = {}  # metainfo like axis
-        self.index = 0  # index of data already retrieved
-        self.last = 0  # last index of retrieved data
-
-        self.thread = current_thread().name
-
-    @cached_property
-    def name(self):
-        return self.task['metainfo'].get('name', 'Unknown')
-
-    @cached_property
-    def ctx(self):
-        return self.step(-9, 'ctx')
-
-    def run(self):
-        """submit the task to the `QuarkServer`
-        """
-        self.stime = time.time()  # start time
-        try:
-            circuit = self.task['taskinfo']['CIRQ']
-            if isinstance(circuit, list) and callable(circuit[0]):
-                circuit[0] = inspect.getsource(circuit[0])
-        except Exception as e:
-            logger.error(f'Failed to get circuit: {e}')
-        self.tid = self.server.submit(self.task)
-
-    def cancel(self):
-        """cancel the task
-        """
-        self.server.cancel(self.tid)
-        # self.clear()
-
-    def result(self):
-        """result of the task
-        """
-        meta = True if not self.meta else False
-        res = self.server.fetch(self.tid, start=self.index, meta=meta)
-
-        if isinstance(res, str):
-            return self.data
-        elif isinstance(res, tuple):
-            if isinstance(res[0], str):
-                return self.data
-            data, self.meta = res
-        else:
-            data = res
-        self.last = self.index
-        self.index += len(data)
-        # data.clear()
-        self.process(data)
-
-        if callable(self.plot):
-            self.plot(self, not meta)
-            # self.plot(not meta)
-
-        return self.data
-
-    def status(self, key: str = 'runtime'):
-        if key == 'runtime':
-            return self.server.track(self.tid)
-        elif key == 'compile':
-            return self.server.apply('status', user='task')
-        else:
-            return 'supported arguments are: {rumtime, compile}'
-
-    def report(self):
-        return self.server.report(self.tid)
-
-    def step(self, index: int, stage: str = 'raw'):
-        """step details
-
-        Args:
-            index (int): step index
-            stage (str, optional): stage name. Defaults to 'raw'.
-
-        Examples: stage values
-            - ini: original instruction
-            - raw: preprocessed instruction
-            - ctx: compiler context
-            - debug: raw data returned from devices
-            - trace: time consumption for each channel
-
-        Returns:
-            _type_: _description_
-        """
-        if stage in ['ini', 'raw', 'ctx', 'byp']:
-            return self.server.review(self.tid, index)[stage]
-        elif stage in ['debug', 'trace']:
-            return self.server.track(self.tid, index)[stage]
-
-    def process(self, data: list[dict]):
-        for dat in data:
-            for k, v in dat.items():
-                if k in self.data:
-                    self.data[k].append(v)
-                else:
-                    self.data[k] = [v]
-
-    def update(self):
-        try:
-            self.result()
-        except Exception as e:
-            logger.error(f'Failed to fetch result: {e}')
-
-        status = self.status()['status']
-
-        if status in ['Failed', 'Canceled']:
-            self.stop(self.tid, False)
-            return True
-        elif status in ['Running']:
-            self.progress.goto(self.index)
-            return False
-        elif status in ['Finished', 'Archived']:
-            self.progress.goto(self.progress.max)
-            if hasattr(self, 'app'):
-                self.app.save()
-            self.stop(self.tid)
-            self.result()
-            return True
-
-    def clear(self):
-        self.counter.clear()
-        for tid, handle in self.handles.items():
-            self.stop(tid)
-
-    def stop(self, tid: int, success: bool = True):
-        try:
-            self.progress.finish(success)
-            self.handles[tid].cancel()
-        except Exception as e:
-            pass
-
-    def bar(self, interval: float = 2.0, disable: bool = False):
-        """task progress. 
-
-        Tip: tips
-            - Reduce the interval if result is empty.
-            - If timeout is not None or not 0, task will be blocked, otherwise, the task will be executed asynchronously.
-
-        Args:
-            interval (float, optional): time period to retrieve data from `QuarkServer`. Defaults to 2.0.
-
-        Raises:
-            TimeoutError: if TimeoutError is raised, the task progress bar will be stopped.
-        """
-        while True:
-            try:
-                status = self.status()['status']
-                if status in ['Pending']:
-                    time.sleep(interval)
-                    continue
-                elif status == 'Canceled':
-                    return 'Task canceled!'
-                else:
-                    self.progress = Progress(desc=self.name,
-                                             total=self.report()['size'],
-                                             postfix=self.thread, disable=disable)
-                    break
-            except Exception as e:
-                logger.error(
-                    f'Failed to get status: {e},{self.report()}')
-
-        if isinstance(self.timeout, float):
-            while True:
-                if self.timeout > 0 and (time.time() - self.stime > self.timeout):
-                    msg = f'Timeout: {self.timeout}'
-                    logger.warning(msg)
-                    raise TimeoutError(msg)
-                time.sleep(interval)
-                if self.update():
-                    break
-        else:
-            self.progress.clear()
-            self.refresh(interval)
-        self.progress.close()
-
-    def refresh(self, interval: float = 2.0):
-        self.progress.display()
-        if self.update():
-            self.progress.display()
-            return
-        self.handles[self.tid] = asyncio.get_running_loop(
-        ).call_later(interval, self.refresh, *(interval,))
-
-
-def transpile(task: dict):
-    quafuos = str(Path.home()/'Desktop/qusteed/0.1.6')
-    if quafuos not in sys.path:
-        print('adding quafuos', quafuos)
-        sys.path.append(quafuos)
-
-    circuit = task.get('circuit', '')
-    qasm = ''
-    if not isinstance(circuit, list):
-        from ._cloud import openqasm_to_qlisp
-        # if task.get('compile', True):
-        from qusteedAPIs import call_transpiler_api
-        qasm, final_qubit2cbit, compiled_circuit_information = call_transpiler_api(
-            input_circuit=circuit,
-            compile=task.get('compile', True),
-            backend=task.get('chip', ''))
-        # import compiler
-        # transpile
-        # else:
-        #     print('nononononoonoo compile')
-        #     qasm = circuit
-        mapping = {}
-        try:
-            with open(Path.home()/'Desktop/home/mapping.json', 'r') as f:
-                mapping = json.loads(f.read())
-        except Exception as e:
-            if task['chip'] == 'Haituo':
-                mapping[task['chip']] = {
-                    str(i): f'Q{i+39}' for i in range(156)}
-            else:
-                mapping[task['chip']] = {str(i): f'Q{i+0}' for i in range(156)}
-        QMAP = mapping[task['chip']]
-
-        circuit, qubits = openqasm_to_qlisp(qasm, QMAP=QMAP)
-
-    qlisp = ',\n'.join([str(op) for op in circuit])
-    logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
-
-    measure = []
-    for ops in circuit:
-        if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
-            measure.append((ops[0][1], ops[1]))
-    return qasm, [circuit], measure
-
-
-def update(backend: str, info: dict, token: str = ''):
-
-    quafuos = str(Path.home()/'Desktop/qusteed/0.1.6')
-    if quafuos not in sys.path:
-        print('adding quafuos', quafuos)
-        sys.path.append(quafuos)
-    with open(f'{backend}.json', 'w') as f:
-        f.write(json.dumps(info, indent=4))
-    from qusteedAPIs import call_local_backend_api
-    call_local_backend_api(backend=backend, chip_info_dict=info)
-    logger.warning(f'database of {backend} updated!')
-
-    try:
-        from ._cloud import update_chip_info_of_quafu
-        msg = update_chip_info_of_quafu(backend.lower(), info, token)
-        logger.warning(f'chip info of quafu[{backend.lower()}] updated!')
-    except Exception as e:
-        msg = f'Failed to update chip info of quafu, {e}'
-        logger.critical(msg)
-
-    return f'compiler database of {backend} updated!\r\n{msg}'
-
-
-class QuarkProxy(object):
-
-    def __init__(self) -> None:
-        from .app import login
-
-        self.server = login()
-        setlog()
-
-    def submit(self, task: dict, block: bool = False):
-        from .app import submit
-
-        # by server
-        # logger.info(f'task will be executed on local machine: {chip}!')
-        logger.warning(f'\n\n\n{"#"*80} task start to run ...\n')
-
-        try:
-            from home.ylfeng.cloud import get_bias_of_coupler
-            bias = get_bias_of_coupler()
-        except Exception as e:
-            bias = []
-            logger.error(f'Failed to get bias of coupler, {e}!')
-        circuit = [bias+c for c in task['taskinfo']['CIRQ']]
-        task['taskinfo']['CIRQ'] = circuit
-
-        qlisp = ',\n'.join([str(op) for op in circuit[0]])
-        qasm = task['metainfo']['coqis']['qasm']
-        logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
-
-        t: Task = submit(task, block=block)  # local machine
-        if block:
-            t.bar(0.2, disable=False)  # if block is True
-        eid = task['metainfo']['coqis']['eid']
-        logger.warning(f'task {t.tid}[{eid}] will be executed!')
-
-        return t.tid
-
-    def cancel(self, tid: int):
-        return self.server.cancel(tid)
-
-    def status(self, tid: int = 0):
-        pass
-
-    def result(self, tid: int, raw: bool = False):
-        from .app import get_data_by_tid
-        try:
-            result = get_data_by_tid(tid, 'count')
-            return result if raw else self.process(result)
-        except Exception as e:
-            return f'No data found for {tid}!'
-
-    @classmethod
-    def process(cls, result: dict, dropout: bool = False):
-        def _delete_dict(ret: dict, num: int = 0):
-            while num > 0:
-                tmp = np.cumsum(list(ret.values()))
-                ran_num = np.random.randint(tmp[-1]+1)
-                ran_pos = np.searchsorted(tmp, ran_num)
-                ret[list(ret.keys())[ran_pos]] -= 1
-                if ret[list(ret.keys())[ran_pos]] == 0:
-                    ret.pop(list(ret.keys())[ran_pos], 0)
-                num -= 1
-
-        meta = result['meta']
-        coqis = meta.get('coqis', {})
-        status = 'Failed'
-        if meta['status'] in ['Finished', 'Archived']:
-            try:
-                # data: list[dict] = result['data']['count']
-                data: list[np.ndarray] = result['data']['count']
-                status = 'Finished'
-            except Exception as e:
-                logger.error(f'Failed to postprocess result: {e}')
-
-        dres, cdres = {}, {}
-        if status == 'Finished':
-            for dat in data:
-                # for k, v in dat.items():  # dat[()][0]
-                #     dres[k] = dres.get(k, 0)+v
-                for kv in dat:
-                    if kv[-1] < 0:
-                        continue
-                    base = tuple(kv[:-1]-1)  # from 1&2 to 0&1
-                    dres[base] = dres.get(base, 0)+int(kv[-1])
-
-            try:
-                if dropout:
-                    shots = meta['other']['shots'] * \
-                        len(meta['axis']['repeat']['repeat'])
-                    _delete_dict(dres, shots - (shots//1000)*1000)
-            except Exception as e:
-                logger.error(f'Failed to dropout: {e}')
-
-            try:
-                if meta['coqis']['correct']:
-                    from home.ylfeng.cloud import correct_readout
-                    cdres = correct_readout(dres, meta['other']['measure'])
-                else:
-                    cdres = {}
-            except Exception as e:
-                cdres = dres
-                logger.error(f'Failed to correct readout, {e}!')
-
-        ret = {'count': {''.join((str(i) for i in k)): v for k, v in dres.items()},
-               'corrected': {''.join((str(i) for i in k)): v for k, v in cdres.items()},
-               'transpiled': coqis.get('qasm', ''),
-               'qlisp': coqis.get('qlisp', ''),
-               'tid': meta['tid'],
-               'error': meta.get('error', ''),
-               'status': status,
-               'finished': meta['finished'],
-               }
-        return ret
-
-    def snr(self, data):
-        return data
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+"""
+Abstract: **about proxy**
+    - `Task`: interact with the `QuarkServer` from the view of a task
+"""
+
+
+import asyncio
+import inspect
+import json
+import string
+import sys
+import time
+from collections import defaultdict
+from functools import cached_property
+from multiprocessing.shared_memory import SharedMemory
+from pathlib import Path
+from threading import current_thread
+
+import numpy as np
+from loguru import logger
+
+QUARK = Path.home()/'quark'
+
+try:
+    with open(QUARK/'startup.json', 'r') as f:
+        startup = json.loads(f.read())
+        SYSTEMQ = str(Path(startup['site']).resolve())
+        if SYSTEMQ.lower() not in sys.path:
+            sys.path.append(SYSTEMQ)
+except Exception as e:
+    logger.error(str(e))
+    startup = {}
+
+
+def setlog(prefix: str = ''):
+    logger.remove()
+    root = Path.home()/f"Desktop/home/log/proxy/{prefix}"
+    path = root/"{time:%Y-%m-%d}.log"
+    level = "INFO"
+    config = {'handlers': [{'sink': sys.stdout,
+                            'level': level},
+                           {'sink': path,
+                            'rotation': '00:00',
+                            'retention': '10 days',
+                            'encoding': 'utf-8',
+                            'level': level,
+                            'backtrace': False, }]}
+    # logger.add(path, rotation="20 MB")
+    logger.configure(**config)
+
+
+def debug(circuit: list = [(('Measure', 0), 'Q1001')], tid: int = 0):
+    from .app import get_config_by_tid
+    from .envelope import ccompile, initialize
+    initialize(get_config_by_tid(tid))
+    return ccompile(0, {}, circuit, signal='iq')
+
+
+TABLE = string.digits+string.ascii_uppercase
+
+
+def basen(number: int, base: int, table: str = TABLE):
+    mods = []
+    while True:
+        div, mod = divmod(number, base)
+        mods.append(mod)
+        if div == 0:
+            mods.reverse()
+            return ''.join([table[i] for i in mods])
+        number = div
+
+
+def baser(number: str, base: int, table: str = TABLE):
+    return sum([table.index(c)*base**i for i, c in enumerate(reversed(number))])
+
+
+def dumpv(value):
+    # print('ccccccccccccccccccccccc', value)
+    # if type(value).__name__ in ['Waveform', 'WaveVStack']:
+    #     sl = ShareableList([dump(value)])
+    #     result = ('ShareableList', sl.shm.name)
+    if isinstance(value, np.ndarray):
+        sm = SharedMemory(create=True, size=value.nbytes)
+        buf = np.ndarray(value.shape, dtype=value.dtype, buffer=sm.buf)
+        buf[:] = value[:]
+        result = sm, ('SharedMemory', sm.name, buf.shape, buf.dtype.str)
+        # sm.close()
+    else:
+        result = '', value
+    return result
+
+
+def loadv(value):
+    if isinstance(value, tuple) and value[0] == 'SharedMemory':
+        name, shape, dtype = value[1:]
+        shm = SharedMemory(name=name)
+        buf = np.ndarray(shape=shape, dtype=dtype, buffer=shm.buf)
+        return shm, buf
+    else:
+        return '', value
+
+
+try:
+    from IPython import get_ipython
+
+    shell = get_ipython().__class__.__name__
+    if shell == 'ZMQInteractiveShell':
+        from tqdm.notebook import tqdm  # jupyter notebook or qtconsole
+    else:
+        # ipython in terminal(TerminalInteractiveShell)
+        # None(Win)
+        # Nonetype(Mac)
+        from tqdm import tqdm
+except Exception as e:
+    # not installed or Probably IDLE
+    from tqdm import tqdm
+
+
+class Progress(tqdm):
+    bar_format = '{desc} {percentage:3.0f}%|{bar}|{n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate_fmt}{postfix}]'
+
+    def __init__(self, desc='test', total=100, postfix='running', disable: bool = False):
+        super().__init__([], desc, total, ncols=None, colour='blue',
+                         bar_format=self.bar_format, position=0, postfix=postfix, disable=disable)
+
+    @property
+    def max(self):
+        return self.total
+
+    @max.setter
+    def max(self, value: int):
+        self.reset(value)
+
+    def goto(self, index: int):
+        self.n = index
+        self.refresh()
+
+    def finish(self, success: bool = True):
+        self.colour = 'green' if success else 'red'
+        # self.set_description_str(str(success))
+
+
+class Task(object):
+    """tracking progress, get result and debug
+    """
+
+    handles = {}
+    counter = defaultdict(lambda: 0)
+    server = None
+
+    def __init__(self, task: dict, timeout: float | None = None, plot: bool = False) -> None:
+        """instantiate a task
+
+        Args:
+            task (dict): see **quark.app.submit**
+            timeout (float | None, optional): timeout for the task. Defaults to None.
+            plot (bool, optional): plot result in `quark studio` if True. Defaults to False.
+        """
+        self.task = task
+        self.timeout = timeout
+        self.plot = plot
+
+        self.data: dict[str, np.ndarray] = {}  # retrieve data from server
+        self.meta = {}  # metainfo like axis
+        self.index = 0  # index of data already retrieved
+        self.last = 0  # last index of retrieved data
+
+        self.thread = current_thread().name
+
+    @cached_property
+    def name(self):
+        return self.task['metainfo'].get('name', 'Unknown')
+
+    @cached_property
+    def ctx(self):
+        return self.step(-9, 'ctx')
+
+    def run(self):
+        """submit the task to the `QuarkServer`
+        """
+        self.stime = time.time()  # start time
+        try:
+            circuit = self.task['taskinfo']['CIRQ']
+            if isinstance(circuit, list) and callable(circuit[0]):
+                circuit[0] = inspect.getsource(circuit[0])
+        except Exception as e:
+            logger.error(f'Failed to get circuit: {e}')
+        self.tid = self.server.submit(self.task)
+
+    def cancel(self):
+        """cancel the task
+        """
+        self.server.cancel(self.tid)
+        # self.clear()
+
+    def result(self):
+        """result of the task
+        """
+        meta = True if not self.meta else False
+        res = self.server.fetch(self.tid, start=self.index, meta=meta)
+
+        if isinstance(res, str):
+            return self.data
+        elif isinstance(res, tuple):
+            if isinstance(res[0], str):
+                return self.data
+            data, self.meta = res
+        else:
+            data = res
+        self.last = self.index
+        self.index += len(data)
+        # data.clear()
+        self.process(data)
+
+        if callable(self.plot):
+            self.plot(self, not meta)
+            # self.plot(not meta)
+
+        return self.data
+
+    def status(self, key: str = 'runtime'):
+        if key == 'runtime':
+            return self.server.track(self.tid)
+        elif key == 'compile':
+            return self.server.apply('status', user='task')
+        else:
+            return 'supported arguments are: {rumtime, compile}'
+
+    def report(self):
+        return self.server.report(self.tid)
+
+    def step(self, index: int, stage: str = 'raw'):
+        """step details
+
+        Args:
+            index (int): step index
+            stage (str, optional): stage name. Defaults to 'raw'.
+
+        Examples: stage values
+            - ini: original instruction
+            - raw: preprocessed instruction
+            - ctx: compiler context
+            - debug: raw data returned from devices
+            - trace: time consumption for each channel
+
+        Returns:
+            _type_: _description_
+        """
+        if stage in ['ini', 'raw', 'ctx', 'byp']:
+            return self.server.review(self.tid, index)[stage]
+        elif stage in ['debug', 'trace']:
+            return self.server.track(self.tid, index)[stage]
+
+    def process(self, data: list[dict]):
+        for dat in data:
+            for k, v in dat.items():
+                if k in self.data:
+                    self.data[k].append(v)
+                else:
+                    self.data[k] = [v]
+
+    def update(self):
+        try:
+            self.result()
+        except Exception as e:
+            logger.error(f'Failed to fetch result: {e}')
+
+        status = self.status()['status']
+
+        if status in ['Failed', 'Canceled']:
+            self.stop(self.tid, False)
+            return True
+        elif status in ['Running']:
+            self.progress.goto(self.index)
+            return False
+        elif status in ['Finished', 'Archived']:
+            self.progress.goto(self.progress.max)
+            if hasattr(self, 'app'):
+                self.app.save()
+            self.stop(self.tid)
+            self.result()
+            return True
+
+    def clear(self):
+        self.counter.clear()
+        for tid, handle in self.handles.items():
+            self.stop(tid)
+
+    def stop(self, tid: int, success: bool = True):
+        try:
+            self.progress.finish(success)
+            self.handles[tid].cancel()
+        except Exception as e:
+            pass
+
+    def bar(self, interval: float = 2.0, disable: bool = False):
+        """task progress. 
+
+        Tip: tips
+            - Reduce the interval if result is empty.
+            - If timeout is not None or not 0, task will be blocked, otherwise, the task will be executed asynchronously.
+
+        Args:
+            interval (float, optional): time period to retrieve data from `QuarkServer`. Defaults to 2.0.
+
+        Raises:
+            TimeoutError: if TimeoutError is raised, the task progress bar will be stopped.
+        """
+        while True:
+            try:
+                status = self.status()['status']
+                if status in ['Pending']:
+                    time.sleep(interval)
+                    continue
+                elif status == 'Canceled':
+                    return 'Task canceled!'
+                else:
+                    self.progress = Progress(desc=self.name,
+                                             total=self.report()['size'],
+                                             postfix=self.thread, disable=disable)
+                    break
+            except Exception as e:
+                logger.error(
+                    f'Failed to get status: {e},{self.report()}')
+
+        if isinstance(self.timeout, float):
+            while True:
+                if self.timeout > 0 and (time.time() - self.stime > self.timeout):
+                    msg = f'Timeout: {self.timeout}'
+                    logger.warning(msg)
+                    raise TimeoutError(msg)
+                time.sleep(interval)
+                if self.update():
+                    break
+        else:
+            self.progress.clear()
+            self.refresh(interval)
+        self.progress.close()
+
+    def refresh(self, interval: float = 2.0):
+        self.progress.display()
+        if self.update():
+            self.progress.display()
+            return
+        self.handles[self.tid] = asyncio.get_running_loop(
+        ).call_later(interval, self.refresh, *(interval,))
+
+
+def transpile(task: dict):
+    quafuos = str(Path.home()/'Desktop/qusteed/0.1.6')
+    if quafuos not in sys.path:
+        print('adding quafuos', quafuos)
+        sys.path.append(quafuos)
+
+    circuit = task.get('circuit', '')
+    qasm = ''
+    if not isinstance(circuit, list):
+        from ._cloud import openqasm_to_qlisp
+        # if task.get('compile', True):
+        from qusteedAPIs import call_transpiler_api
+        qasm, final_qubit2cbit, compiled_circuit_information = call_transpiler_api(
+            input_circuit=circuit,
+            compile=task.get('compile', True),
+            backend=task.get('chip', ''))
+        # import compiler
+        # transpile
+        # else:
+        #     print('nononononoonoo compile')
+        #     qasm = circuit
+        mapping = {}
+        try:
+            with open(Path.home()/'Desktop/home/mapping.json', 'r') as f:
+                mapping = json.loads(f.read())
+        except Exception as e:
+            if task['chip'] == 'Haituo':
+                mapping[task['chip']] = {
+                    str(i): f'Q{i+39}' for i in range(156)}
+            else:
+                mapping[task['chip']] = {str(i): f'Q{i+0}' for i in range(156)}
+        QMAP = mapping[task['chip']]
+
+        circuit, qubits = openqasm_to_qlisp(qasm, QMAP=QMAP)
+
+    qlisp = ',\n'.join([str(op) for op in circuit])
+    logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
+
+    measure = []
+    for ops in circuit:
+        if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
+            measure.append((ops[0][1], ops[1]))
+    return qasm, [circuit], measure
+
+
+def update(backend: str, info: dict, token: str = ''):
+
+    quafuos = str(Path.home()/'Desktop/qusteed/0.1.6')
+    if quafuos not in sys.path:
+        print('adding quafuos', quafuos)
+        sys.path.append(quafuos)
+    with open(f'{backend}.json', 'w') as f:
+        f.write(json.dumps(info, indent=4))
+    from qusteedAPIs import call_local_backend_api
+    call_local_backend_api(backend=backend, chip_info_dict=info)
+    logger.warning(f'database of {backend} updated!')
+
+    try:
+        from ._cloud import update_chip_info_of_quafu
+        msg = update_chip_info_of_quafu(backend.lower(), info, token)
+        logger.warning(f'chip info of quafu[{backend.lower()}] updated!')
+    except Exception as e:
+        msg = f'Failed to update chip info of quafu, {e}'
+        logger.critical(msg)
+
+    return f'compiler database of {backend} updated!\r\n{msg}'
+
+
+class QuarkProxy(object):
+
+    def __init__(self) -> None:
+        from .app import login
+
+        self.server = login()
+        setlog()
+
+    def submit(self, task: dict, block: bool = False):
+        from .app import submit
+
+        # by server
+        # logger.info(f'task will be executed on local machine: {chip}!')
+        logger.warning(f'\n\n\n{"#"*80} task start to run ...\n')
+
+        try:
+            from home.ylfeng.cloud import get_bias_of_coupler
+            bias = get_bias_of_coupler()
+        except Exception as e:
+            bias = []
+            logger.error(f'Failed to get bias of coupler, {e}!')
+        circuit = [bias+c for c in task['taskinfo']['CIRQ']]
+        task['taskinfo']['CIRQ'] = circuit
+
+        qlisp = ',\n'.join([str(op) for op in circuit[0]])
+        qasm = task['metainfo']['coqis']['qasm']
+        logger.info(f"\n{'>'*36}qasm:\n{qasm}\n{'>'*36}qlisp:\n[{qlisp}]")
+
+        t: Task = submit(task, block=block)  # local machine
+        if block:
+            t.bar(0.2, disable=False)  # if block is True
+        eid = task['metainfo']['coqis']['eid']
+        logger.warning(f'task {t.tid}[{eid}] will be executed!')
+
+        return t.tid
+
+    def cancel(self, tid: int):
+        return self.server.cancel(tid)
+
+    def status(self, tid: int = 0):
+        pass
+
+    def result(self, tid: int, raw: bool = False):
+        from .app import get_data_by_tid
+        try:
+            result = get_data_by_tid(tid, 'count')
+            return result if raw else self.process(result)
+        except Exception as e:
+            return f'No data found for {tid}!'
+
+    @classmethod
+    def process(cls, result: dict, dropout: bool = False):
+        def _delete_dict(ret: dict, num: int = 0):
+            while num > 0:
+                tmp = np.cumsum(list(ret.values()))
+                ran_num = np.random.randint(tmp[-1]+1)
+                ran_pos = np.searchsorted(tmp, ran_num)
+                ret[list(ret.keys())[ran_pos]] -= 1
+                if ret[list(ret.keys())[ran_pos]] == 0:
+                    ret.pop(list(ret.keys())[ran_pos], 0)
+                num -= 1
+
+        meta = result['meta']
+        coqis = meta.get('coqis', {})
+        status = 'Failed'
+        if meta['status'] in ['Finished', 'Archived']:
+            try:
+                # data: list[dict] = result['data']['count']
+                data: list[np.ndarray] = result['data']['count']
+                status = 'Finished'
+            except Exception as e:
+                logger.error(f'Failed to postprocess result: {e}')
+
+        dres, cdres = {}, {}
+        if status == 'Finished':
+            for dat in data:
+                # for k, v in dat.items():  # dat[()][0]
+                #     dres[k] = dres.get(k, 0)+v
+                for kv in dat:
+                    if kv[-1] < 0:
+                        continue
+                    base = tuple(kv[:-1]-1)  # from 1&2 to 0&1
+                    dres[base] = dres.get(base, 0)+int(kv[-1])
+
+            try:
+                if dropout:
+                    shots = meta['other']['shots'] * \
+                        len(meta['axis']['repeat']['repeat'])
+                    _delete_dict(dres, shots - (shots//1000)*1000)
+            except Exception as e:
+                logger.error(f'Failed to dropout: {e}')
+
+            try:
+                if meta['coqis']['correct']:
+                    from home.ylfeng.cloud import correct_readout
+                    cdres = correct_readout(dres, meta['other']['measure'])
+                else:
+                    cdres = {}
+            except Exception as e:
+                cdres = dres
+                logger.error(f'Failed to correct readout, {e}!')
+
+        ret = {'count': {''.join((str(i) for i in k)): v for k, v in dres.items()},
+               'corrected': {''.join((str(i) for i in k)): v for k, v in cdres.items()},
+               'transpiled': coqis.get('qasm', ''),
+               'qlisp': coqis.get('qlisp', ''),
+               'tid': meta['tid'],
+               'error': meta.get('error', ''),
+               'status': status,
+               'finished': meta['finished'],
+               }
+        return ret
+
+    def snr(self, data):
+        return data
```

## quark/app/__init__.py

```diff
@@ -139,25 +139,24 @@
     t.server = ss
     t.plot = plot if kwds.get('plot', False) else False
     t.timeout = 1e9 if block else None
     t.run()
     return t
 
 
-def rollback(tid: int, checkpoint: str):
+def rollback(tid: int):
     """rollback the parameters with given task id and checkpoint name
 
     Args:
         tid (int): task id
-        checkpoint (str): filename of checkpoint
     """
     _s = login(verbose=False)
 
     try:
-        config = get_config_by_tid(tid, checkpoint)
+        config = get_config_by_tid(tid)
         _s.clear()
         for k, v in config.items():
             _s.create(k, v)
     except Exception as e:
         logger.error(f'Failed to rollback: {e}')
```

## quark/app/_data.py

```diff
@@ -1,101 +1,101 @@
-# MIT License
-
-# Copyright (c) 2021 YL Feng
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
-import sqlite3
-from pathlib import Path
-
-import h5py
-import numpy as np
-from loguru import logger
-from quark import loads
-
-from quark.proxy import QUARK
-
-sql = sqlite3.connect(QUARK/'checkpoint.db', check_same_thread=False)
-
-
-def get_dataset_by_tid(tid: int, signal: str, shape: tuple | list = []):
-    filename, dataset = get_record_by_tid(tid)[7:9]
-
-    info, data = {}, {}
-    with h5py.File(filename) as f:
-        group = f[dataset]
-        info = loads(dict(group.attrs).get('snapshot', '{}'))
-        if not shape:
-            if not info:
-                shape = -1
-                info['meta'] = {}
-            else:
-                shape = []
-                for k, v in info['meta']['axis'].items():
-                    shape.extend(tuple(v.values())[0].shape)
-
-        for k in group.keys():
-            if k != signal or not signal:
-                continue
-            ds = group[f'{k}']
-            if shape == -1:
-                data[k] = ds[:]
-                continue
-            data[k] = np.full((*shape, *ds.shape[1:]), 0, ds.dtype)
-            data[k][np.unravel_index(np.arange(ds.shape[0]), shape)] = ds[:]
-    return info, data
-
-
-def get_config_by_tid(tid: int = 0, checkpoint: str = ''):
-    try:
-        import git
-
-        cfgp = Path.home()/f'Desktop/home/cfg/{checkpoint}'
-        file = cfgp.with_suffix('.json')
-
-        repo = git.Repo(file.resolve().parent)
-        if not tid:
-            tree = repo.head.commit.tree
-        else:
-            tree = repo.commit(get_record_by_tid(tid)[-1]).tree
-        config: dict = loads(tree[file.name].data_stream.read().decode())
-        return config
-    except Exception as e:
-        logger.error(f'Failed to get config: {e}')
-        return {}
-
-
-def get_record_by_tid(tid: int, table: str = 'task'):
-    try:
-        return sql.execute(f'select * from {table} where tid="{tid}"').fetchall()[0]
-    except Exception as e:
-        logger.error(f'Record not found: {e}!')
-
-
-def get_record_list_by_name(task: str, start: str, stop: str, table: str = 'task'):
-    try:
-        return sql.execute(f'select * from {table} where name like "%{task}%" and created between "{start}" and "{stop}" limit 100').fetchall()
-    except Exception as e:
-        logger.error(f'Records not found: {e}!')
-
-
-def get_record_set_by_name():
-    try:
-        return sql.execute('select distinct task.name from task').fetchall()
-    except Exception as e:
-        logger.error(f'Records not found: {e}!')
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+import sqlite3
+from pathlib import Path
+
+import h5py
+import numpy as np
+from loguru import logger
+from quark import loads
+
+from quark.proxy import QUARK
+
+sql = sqlite3.connect(QUARK/'checkpoint.db', check_same_thread=False)
+
+
+def get_dataset_by_tid(tid: int, signal: str, shape: tuple | list = []):
+    filename, dataset = get_record_by_tid(tid)[7:9]
+
+    info, data = {}, {}
+    with h5py.File(filename) as f:
+        group = f[dataset]
+        info = loads(dict(group.attrs).get('snapshot', '{}'))
+        if not shape:
+            if not info:
+                shape = -1
+                info['meta'] = {}
+            else:
+                shape = []
+                for k, v in info['meta']['axis'].items():
+                    shape.extend(tuple(v.values())[0].shape)
+
+        for k in group.keys():
+            if k != signal or not signal:
+                continue
+            ds = group[f'{k}']
+            if shape == -1:
+                data[k] = ds[:]
+                continue
+            data[k] = np.full((*shape, *ds.shape[1:]), 0, ds.dtype)
+            data[k][np.unravel_index(np.arange(ds.shape[0]), shape)] = ds[:]
+    return info, data
+
+
+def get_config_by_tid(tid: int = 0):
+    try:
+        import git
+
+        ckpt = get_record_by_tid(tid)[5]
+        file = (Path.home()/f'Desktop/home/cfg/{ckpt}').with_suffix('.json')
+
+        repo = git.Repo(file.resolve().parent)
+        if not tid:
+            tree = repo.head.commit.tree
+        else:
+            tree = repo.commit(get_record_by_tid(tid)[-1]).tree
+        config: dict = loads(tree[file.name].data_stream.read().decode())
+        return config
+    except Exception as e:
+        logger.error(f'Failed to get config: {e}')
+        return {}
+
+
+def get_record_by_tid(tid: int, table: str = 'task'):
+    try:
+        return sql.execute(f'select * from {table} where tid="{tid}"').fetchall()[0]
+    except Exception as e:
+        logger.error(f'Record not found: {e}!')
+
+
+def get_record_list_by_name(task: str, start: str, stop: str, table: str = 'task'):
+    try:
+        return sql.execute(f'select * from {table} where name like "%{task}%" and created between "{start}" and "{stop}" limit 100').fetchall()
+    except Exception as e:
+        logger.error(f'Records not found: {e}!')
+
+
+def get_record_set_by_name():
+    try:
+        return sql.execute('select distinct task.name from task').fetchall()
+    except Exception as e:
+        logger.error(f'Records not found: {e}!')
```

## quark/app/_task.py

 * *Ordering differences only*

```diff
@@ -1,275 +1,275 @@
-# MIT License
-
-# Copyright (c) 2021 YL Feng
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
-"""扩展各Scanner以用于submit
-"""
-
-from abc import ABC, abstractmethod
-from pathlib import Path
-
-import dill
-import numpy as np
-from kernel.terminal.scan import App
-from kernel.terminal.scan import Scan as _Scan
-from loguru import logger
-from qos_tools.experiment.scanner2 import Scanner as _Scanner
-from tqdm import tqdm
-from waveforms.dicttree import flattenDictIter
-from waveforms.scan_iter import StepStatus
-
-
-class TaskMixin(ABC):
-    """扩展兼容App
-    """
-
-    def __new__(cls, *args, **kwds):
-        for base in cls.__mro__:
-            if base.__name__ == 'TaskMixin':
-                for k in dir(base):
-                    if not k.startswith('__') and k not in base.__abstractmethods__:
-                        setattr(cls, k, getattr(base, k))
-        return super().__new__(cls)
-
-    @abstractmethod
-    def variables(self) -> dict[str, list[tuple]]:
-        """生成变量
-
-        Examples: 形如
-            >>> {'x':[('x1', [1,2,3], 'au'), ('x2', [1,2,3], 'au')],
-                'y':[('y1', [1,2,3], 'au'), ('y2', [1,2,3], 'au')],
-                'z':[('z1', [1,2,3], 'au'), ('z2', [1,2,3], 'au')]
-                }
-        """
-        return {}
-
-    @abstractmethod
-    def dependencies(self) -> list[str]:
-        """生成参数依赖
-
-        Examples: 形如
-            >>> [f'<gate.rfUnitary.{q}.params.frequency>=12345' for q in qubits]
-        """
-        return []
-
-    @abstractmethod
-    def circuits(self):
-        """生成线路描述
-
-        Examples: 形如
-            >>> [c1, c2, c3, ...]
-        """
-        yield
-
-    def run(self, dry_run=False, quiet=False):
-        try:
-            self.toserver.run()
-        except:
-            import kernel
-            from kernel.sched.sched import generate_task_id, get_system_info
-            self.runtime.prog.task_arguments = (), {}
-            self.runtime.prog.meta_info['arguments'] = {}
-            self.runtime.id = generate_task_id()
-            self.runtime.user = None
-            self.runtime.system_info = {}  # get_system_info()
-            kernel.submit(self, dry_run=dry_run)
-            if not dry_run and not quiet:
-                self.bar()
-
-    def result(self, reshape=True):
-        d = super(App, self).result(reshape)
-        try:
-            if self.toserver:
-                for k, v in self.toserver.result().items():
-                    try:
-                        dk = np.asarray(v)
-                        d[k] = dk.reshape([*self.shape, *dk[0].shape])
-                    except Exception as e:
-                        logger.error(f'Failed to fill result: {e}')
-                        d[k] = v
-                d['mqubits'] = self.toserver.title
-        except Exception as e:
-            logger.error(f'Failed to get result: {e}')
-        return d
-
-    def cancel(self):
-        try:
-            self.toserver.cancel()
-        except:
-            super(App, self).cancel()
-
-    def bar(self, interval: float = 2.0):
-        try:
-            self.toserver.bar(interval)
-        except:
-            super(App, self).bar()
-
-    def save(self):
-        from kernel.sched.sched import session
-        from storage.models import Record
-        with session() as db:
-            record = db.get(Record, self.record_id)
-            record.data = self.result(self.reshape_record)
-
-    def dumps(self, filepath: Path, localhost: bool = True):
-        """将线路写入文件
-
-        Args:
-            filepath (Path): 线路待写入的文件路径
-
-        Raises:
-            TypeError: 线路由StepStatus得到
-
-        Returns:
-            list: 线路中的比特列表
-        """
-        qubits = []
-        circuits = []
-        with open(filepath, 'w', encoding='utf-8') as f:
-            for step in tqdm(self.circuits(), desc='CircuitExpansion'):
-                if isinstance(step, StepStatus):
-                    cc = step.kwds['circuit']
-                    if localhost:
-                        f.writelines(str(dill.dumps(cc))+'\n')
-                    else:
-                        circuits.append(cc)
-
-                    if step.iteration == 0:
-                        # 获取线路中读取比特列表
-                        for ops in cc:
-                            if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
-                                qubits.append((ops[0][1], ops[1]))
-                else:
-                    raise TypeError('Wrong type of step!')
-            self.shape = [i+1 for i in step.index]
-        return qubits, circuits
-
-
-class Scan(_Scan, TaskMixin):
-    """扩展Scanner3, 可直接替换原Scanner3
-    """
-    def __init__(self, name, *args, mixin=None, **kwds):
-        super().__init__(name, *args, mixin=mixin, **kwds)
-        self.patches = {}
-
-    def variables(self) -> dict[str, list[tuple]]:
-        loops = {}
-        for k, v in self.loops.items():
-            loops[k] = [(k, v, 'au')]
-        return loops
-
-    def circuits(self):
-        from waveforms.scan.base import _try_to_call as try_to_call
-
-        self.assemble()
-        for step in self.scan():
-            for k, v in self.mapping.items():
-                self.set(k, step.kwds[v])
-                if not isinstance(step.kwds[v], dict):
-                    self.patches.setdefault((k, v), []).append(step.kwds[v])
-            circ = try_to_call(self.circuit, (), step.kwds)
-            step.kwds['circuit'] = circ
-            yield step
-        # self.assemble()
-        # for step in self.scan():
-        #     for k, v in self.mapping.items():
-        #         self.set(k, step.kwds[v])
-        #     yield step
-
-    def resolve(self):
-        """
-        Examples: 解析获取变量定义
-            >>> loops
-            ({'x': [('x',  array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
-                    ('__tmp_0__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
-                    ('__tmp_1__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), au'),
-                    ('__tmp_2__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
-                    ('__tmp_3__',  array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au')],
-            'frequency': [('frequency', array([-2000000.,  2000000.]), 'au')]},
-            >>> deps
-            ['<Q7.bias>=<x.__tmp_0__',
-            '<Q25.bias>=<x.__tmp_1__',
-            '<Q37.bias>=<x.__tmp_2__',
-            '<Q17.bias>=<x.__tmp_3__'])
-        """
-        loops = self.variables()
-        deps = []
-        for axis, value in loops.items():
-            _val = []
-            for k, v in self.patches.items():
-                self.patches[k] = np.unique(v)
-                target, tmpvar = k
-                if len(self.patches[k]) == len(value[0][1]):
-                    _val.append((tmpvar, self.patches[k], 'au'))
-                    deps.append(f'<{target}>=<{axis}.{tmpvar}>')
-                elif len(self.patches[k]) == 1:
-                    dep = f'<{target}>={self.patches[k][0]}'
-                    if dep not in deps:
-                        deps.append(dep)
-            value.extend(_val)
-        return loops, deps
-
-    def dependencies(self) -> list[str]:
-        deps = []
-        for k, v in self.mapping.items():
-            if isinstance(self[v], str):
-                deps.append(f'<{k}>="{self[v]}"')
-            elif isinstance(self[v], dict):
-                for _k, _v in flattenDictIter(self[v]):
-                    if isinstance(_v, str):
-                        deps.append(f'<{k}.{_k}>="{_v}"')
-                    else:
-                        deps.append(f'<{k}.{_k}>={_v}')
-            else:
-                deps.append(f'<{k}>={self[v]}')
-        return deps
-
-
-class Scanner(_Scanner, TaskMixin):
-    """扩展Scanner2, 可直接替换原Scanner2
-    """
-    def __init__(self, name: str, qubits: list[int], scanner_name: str = '', **kw):
-        super().__init__(name, qubits, scanner_name, **kw)
-
-    def variables(self) -> dict[str, list[tuple]]:
-        loops = {}
-        for k, v in self.sweep_setting.items():
-            if isinstance(k, tuple):
-                loops['temp'] = list(zip(k, v, ['au']*len(k)))
-            else:
-                if 'rb' in self.name.lower() and k == 'gate':
-                    continue
-                loops[k] = [(k, v, 'au')]
-        return loops
-
-    def circuits(self):
-        for step in self.scan():
-            # self.update({v_dict['addr']: step.kwds[k]
-            #              for k, v_dict in self.sweep_config.items()})
-            yield step
-
-    def resolve(self):
-        loops = self.variables()
-        deps = []
-        return loops, deps
-
-    def dependencies(self) -> list[str]:
-        return super().dependencies()
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+"""扩展各Scanner以用于submit
+"""
+
+from abc import ABC, abstractmethod
+from pathlib import Path
+
+import dill
+import numpy as np
+from kernel.terminal.scan import App
+from kernel.terminal.scan import Scan as _Scan
+from loguru import logger
+from qos_tools.experiment.scanner2 import Scanner as _Scanner
+from tqdm import tqdm
+from waveforms.dicttree import flattenDictIter
+from waveforms.scan_iter import StepStatus
+
+
+class TaskMixin(ABC):
+    """扩展兼容App
+    """
+
+    def __new__(cls, *args, **kwds):
+        for base in cls.__mro__:
+            if base.__name__ == 'TaskMixin':
+                for k in dir(base):
+                    if not k.startswith('__') and k not in base.__abstractmethods__:
+                        setattr(cls, k, getattr(base, k))
+        return super().__new__(cls)
+
+    @abstractmethod
+    def variables(self) -> dict[str, list[tuple]]:
+        """生成变量
+
+        Examples: 形如
+            >>> {'x':[('x1', [1,2,3], 'au'), ('x2', [1,2,3], 'au')],
+                'y':[('y1', [1,2,3], 'au'), ('y2', [1,2,3], 'au')],
+                'z':[('z1', [1,2,3], 'au'), ('z2', [1,2,3], 'au')]
+                }
+        """
+        return {}
+
+    @abstractmethod
+    def dependencies(self) -> list[str]:
+        """生成参数依赖
+
+        Examples: 形如
+            >>> [f'<gate.rfUnitary.{q}.params.frequency>=12345' for q in qubits]
+        """
+        return []
+
+    @abstractmethod
+    def circuits(self):
+        """生成线路描述
+
+        Examples: 形如
+            >>> [c1, c2, c3, ...]
+        """
+        yield
+
+    def run(self, dry_run=False, quiet=False):
+        try:
+            self.toserver.run()
+        except:
+            import kernel
+            from kernel.sched.sched import generate_task_id, get_system_info
+            self.runtime.prog.task_arguments = (), {}
+            self.runtime.prog.meta_info['arguments'] = {}
+            self.runtime.id = generate_task_id()
+            self.runtime.user = None
+            self.runtime.system_info = {}  # get_system_info()
+            kernel.submit(self, dry_run=dry_run)
+            if not dry_run and not quiet:
+                self.bar()
+
+    def result(self, reshape=True):
+        d = super(App, self).result(reshape)
+        try:
+            if self.toserver:
+                for k, v in self.toserver.result().items():
+                    try:
+                        dk = np.asarray(v)
+                        d[k] = dk.reshape([*self.shape, *dk[0].shape])
+                    except Exception as e:
+                        logger.error(f'Failed to fill result: {e}')
+                        d[k] = v
+                d['mqubits'] = self.toserver.title
+        except Exception as e:
+            logger.error(f'Failed to get result: {e}')
+        return d
+
+    def cancel(self):
+        try:
+            self.toserver.cancel()
+        except:
+            super(App, self).cancel()
+
+    def bar(self, interval: float = 2.0):
+        try:
+            self.toserver.bar(interval)
+        except:
+            super(App, self).bar()
+
+    def save(self):
+        from kernel.sched.sched import session
+        from storage.models import Record
+        with session() as db:
+            record = db.get(Record, self.record_id)
+            record.data = self.result(self.reshape_record)
+
+    def dumps(self, filepath: Path, localhost: bool = True):
+        """将线路写入文件
+
+        Args:
+            filepath (Path): 线路待写入的文件路径
+
+        Raises:
+            TypeError: 线路由StepStatus得到
+
+        Returns:
+            list: 线路中的比特列表
+        """
+        qubits = []
+        circuits = []
+        with open(filepath, 'w', encoding='utf-8') as f:
+            for step in tqdm(self.circuits(), desc='CircuitExpansion'):
+                if isinstance(step, StepStatus):
+                    cc = step.kwds['circuit']
+                    if localhost:
+                        f.writelines(str(dill.dumps(cc))+'\n')
+                    else:
+                        circuits.append(cc)
+
+                    if step.iteration == 0:
+                        # 获取线路中读取比特列表
+                        for ops in cc:
+                            if isinstance(ops[0], tuple) and ops[0][0] == 'Measure':
+                                qubits.append((ops[0][1], ops[1]))
+                else:
+                    raise TypeError('Wrong type of step!')
+            self.shape = [i+1 for i in step.index]
+        return qubits, circuits
+
+
+class Scan(_Scan, TaskMixin):
+    """扩展Scanner3, 可直接替换原Scanner3
+    """
+    def __init__(self, name, *args, mixin=None, **kwds):
+        super().__init__(name, *args, mixin=mixin, **kwds)
+        self.patches = {}
+
+    def variables(self) -> dict[str, list[tuple]]:
+        loops = {}
+        for k, v in self.loops.items():
+            loops[k] = [(k, v, 'au')]
+        return loops
+
+    def circuits(self):
+        from waveforms.scan.base import _try_to_call as try_to_call
+
+        self.assemble()
+        for step in self.scan():
+            for k, v in self.mapping.items():
+                self.set(k, step.kwds[v])
+                if not isinstance(step.kwds[v], dict):
+                    self.patches.setdefault((k, v), []).append(step.kwds[v])
+            circ = try_to_call(self.circuit, (), step.kwds)
+            step.kwds['circuit'] = circ
+            yield step
+        # self.assemble()
+        # for step in self.scan():
+        #     for k, v in self.mapping.items():
+        #         self.set(k, step.kwds[v])
+        #     yield step
+
+    def resolve(self):
+        """
+        Examples: 解析获取变量定义
+            >>> loops
+            ({'x': [('x',  array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
+                    ('__tmp_0__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
+                    ('__tmp_1__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), au'),
+                    ('__tmp_2__', array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au'),
+                    ('__tmp_3__',  array([-0.5, -0.4, -0.3, -0.2, -0.1,  0. ,  0.1,  0.2,  0.3,  0.4,  0.5]), 'au')],
+            'frequency': [('frequency', array([-2000000.,  2000000.]), 'au')]},
+            >>> deps
+            ['<Q7.bias>=<x.__tmp_0__',
+            '<Q25.bias>=<x.__tmp_1__',
+            '<Q37.bias>=<x.__tmp_2__',
+            '<Q17.bias>=<x.__tmp_3__'])
+        """
+        loops = self.variables()
+        deps = []
+        for axis, value in loops.items():
+            _val = []
+            for k, v in self.patches.items():
+                self.patches[k] = np.unique(v)
+                target, tmpvar = k
+                if len(self.patches[k]) == len(value[0][1]):
+                    _val.append((tmpvar, self.patches[k], 'au'))
+                    deps.append(f'<{target}>=<{axis}.{tmpvar}>')
+                elif len(self.patches[k]) == 1:
+                    dep = f'<{target}>={self.patches[k][0]}'
+                    if dep not in deps:
+                        deps.append(dep)
+            value.extend(_val)
+        return loops, deps
+
+    def dependencies(self) -> list[str]:
+        deps = []
+        for k, v in self.mapping.items():
+            if isinstance(self[v], str):
+                deps.append(f'<{k}>="{self[v]}"')
+            elif isinstance(self[v], dict):
+                for _k, _v in flattenDictIter(self[v]):
+                    if isinstance(_v, str):
+                        deps.append(f'<{k}.{_k}>="{_v}"')
+                    else:
+                        deps.append(f'<{k}.{_k}>={_v}')
+            else:
+                deps.append(f'<{k}>={self[v]}')
+        return deps
+
+
+class Scanner(_Scanner, TaskMixin):
+    """扩展Scanner2, 可直接替换原Scanner2
+    """
+    def __init__(self, name: str, qubits: list[int], scanner_name: str = '', **kw):
+        super().__init__(name, qubits, scanner_name, **kw)
+
+    def variables(self) -> dict[str, list[tuple]]:
+        loops = {}
+        for k, v in self.sweep_setting.items():
+            if isinstance(k, tuple):
+                loops['temp'] = list(zip(k, v, ['au']*len(k)))
+            else:
+                if 'rb' in self.name.lower() and k == 'gate':
+                    continue
+                loops[k] = [(k, v, 'au')]
+        return loops
+
+    def circuits(self):
+        for step in self.scan():
+            # self.update({v_dict['addr']: step.kwds[k]
+            #              for k, v_dict in self.sweep_config.items()})
+            yield step
+
+    def resolve(self):
+        loops = self.variables()
+        deps = []
+        return loops, deps
+
+    def dependencies(self) -> list[str]:
+        return super().dependencies()
```

## quark/driver/VirtualDevice.py

 * *Ordering differences only*

```diff
@@ -1,210 +1,210 @@
-# MIT License
-
-# Copyright (c) 2021 YL Feng
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
-
-import time
-
-import numpy as np
-
-from waveforms import Waveform, WaveVStack, wave_eval
-from waveforms.math.signal import getFTMatrix, shift
-
-from .common import BaseDriver, Quantity
-
-
-def get_coef(coef_info, sampleRate):
-    start, stop = coef_info['start'], coef_info['stop']
-    numberOfPoints = int(
-        (stop - start) * sampleRate)
-    if numberOfPoints % 1024 != 0:
-        numberOfPoints = numberOfPoints + 1024 - numberOfPoints % 1024
-    t = np.arange(numberOfPoints) / sampleRate + start
-
-    fList = []
-    wList = []
-    phases = []
-
-    for kw in coef_info['wList']:
-        Delta, t0, weight, w, phase = kw['Delta'], kw['t0'], kw['weight'], kw['w'], kw['phase']
-        fList.append(Delta)
-
-        if w is not None:
-            w = np.zeros(numberOfPoints, dtype=complex)
-            w[:len(w)] = w
-            w = shift(w, t0 - start)
-            phases.append(np.mod(phase + 2 * np.pi * Delta * start, 2*np.pi))
-        else:
-            weight = weight
-            if isinstance(weight, np.ndarray):
-                pass
-            else:
-                if isinstance(weight, str):
-                    fun = wave_eval(weight) >> t0
-                elif isinstance(weight, Waveform):
-                    fun = weight >> t0
-                else:
-                    raise TypeError(f'Unsupported type {weight}')
-                weight = fun(t)
-            phase += 2 * np.pi * Delta * start
-            w = getFTMatrix([Delta],
-                            numberOfPoints,
-                            phaseList=[phase],
-                            weight=weight,
-                            sampleRate=sampleRate)[:, 0]
-            phases.append(np.mod(phase, 2*np.pi))
-        wList.append(w)
-    return np.asarray(wList), fList, numberOfPoints, phases
-
-
-# class Quantity(object):
-#     def __init__(self, name: str, value=None, ch: int = None, unit: str = ''):
-#         self.name = name
-#         self.default = dict(value=value, ch=ch, unit=unit)
-
-
-def tolist(wv: WaveVStack) -> list:
-    ret = [wv.start, wv.stop, wv.sample_rate, len(wv.wlist)]
-    for w in wv.wlist:
-        ret.extend(w.tolist())
-    return ret
-
-
-def fromlist(wl: list) -> WaveVStack:
-    wv, wpos = WaveVStack([]), 4
-    wv.start, wv.stop, wv.sample_rate, n = wl[:wpos]
-    for _ in range(n):
-        wav, pos = Waveform.fromlist(wl[wpos:], True)
-        wv.wlist.append(wav)
-        wpos += pos
-    return wv
-
-
-class Driver(BaseDriver):
-    """driver template
-
-    Warning:
-        All drivers must inherit from the base class(with fixed class name ***Driver***) and methods open/close/read/write must be implemented!
-    """
-    segment = ('na', '101|102|103')
-    # number of available channels
-    CHs = list(range(36))
-
-    quants = [
-        # Microwave source(MW)
-        Quantity('Frequency', value=0, ch=1, unit='Hz'),  # float
-        Quantity('Power', value=0, ch=1, unit='dBm'),  # loat
-        Quantity('Output', value='OFF', ch=1),  # str
-
-        # 任意波形发生器(AWG)
-        Quantity('Amplitude', value=0, ch=1, unit='Vpp'),  # float
-        Quantity('Offset', value=0, ch=1, unit='V'),  # float
-        Quantity('Waveform', value=np.array([]), ch=1),  # np.array or Waveform
-        Quantity('Marker1', value=[], ch=1),  # Marker1，np.array
-        Quantity('Marker2', value=[], ch=1),  # Marker2，np.array
-
-        # Data Acquisition(ADC)
-        Quantity('PointNumber', value=1024, ch=1, unit='point'),  # int
-        Quantity('TriggerDelay', value=0, ch=1, unit='s'),  # float
-        Quantity('Shot', value=512, ch=1),  # int
-        Quantity('TraceIQ', value=np.array([]), ch=1),  # np.array
-        Quantity('Trace', value=np.array([]), ch=1),  # np.array
-        Quantity('IQ', value=np.array([]), ch=1),  # np.array
-        Quantity('Coefficient', value=np.array([]), ch=1),  # np.array
-        Quantity('StartCapture', value=1, ch=1,),  # int
-        
-        Quantity('CaptureMode', value='raw', ch=1), # raw->TraceIQ, alg-> IQ
-
-        # test
-        Quantity('Classify', value=0, ch=1),
-        Quantity('Counts', value=[], ch=1),
-
-        # Trigger(TRIG)
-        Quantity('TRIG'),
-        Quantity('TriggerMode'),  # burst or continuous
-        Quantity('Wait', value=0, ch=1),  # wait
-    ]
-
-    def __init__(self, addr: str = '', timeout: float = 3.0, **kw):
-        super().__init__(addr=addr, timeout=timeout, **kw)
-        self.model = 'VirtualDevice'  # device model
-        self.timeout = 1.0
-        self.srate = 1e9  # sampling rate
-
-    def open(self, **kw):
-        """open device
-        """
-        self.handle = 'DeviceHandler'
-        # test = 1/0
-
-    def close(self, **kw):
-        """close device
-        """
-        self.handle.close()
-
-    def write(self, name: str, value, **kw):
-        """write to device
-        """
-        if name == 'Wait':
-            time.sleep(value)
-        elif name == 'Waveform':
-            if isinstance(value, list):
-                t0 = time.time()
-                wf = fromlist(value)
-                t1 = time.time()
-                wf.sample()
-            if isinstance(value, Waveform):
-                t0 = time.time()
-                value.sample()
-            # 如，self.set_offset(value, ch=1)
-        elif name == 'Shot':
-            pass
-        elif name == 'Coefficient':
-            data, f_list, numberOfPoints, phase = get_coef(value, self.srate)
-            # coef_data = np.moveaxis([data.real,data.imag],0,-2)
-            self.setValue('PointNumber', numberOfPoints, **kw)
-            # self.update('Coefficient', data, channel=ch)
-            return data
-            # 如，self.set_shot(value, ch=2)
-        return value
-
-    def read(self, name: str, **kw):
-        """read from device
-        """
-        if name == 'TraceIQ':
-            shot = self.getValue('Shot', **kw)
-            point = self.getValue('PointNumber', **kw)
-            # test = 1/0
-            return np.ones((shot, point)), np.ones((shot, point))
-        elif name == 'IQ':
-            shot = self.getValue('Shot', **kw)
-            fnum = self.getValue('Coefficient', **kw).shape[0]
-            # time.sleep(0.1)
-            si = np.random.randint(20)+np.random.randn(shot, fnum)
-            sq = np.random.randint(20)+np.random.randn(shot, fnum)
-            return si, sq
-
-    # *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*# user defined #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
-    def get_iq(self):
-        pass
-
-    def get_trace(self):
-        pass
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+
+import time
+
+import numpy as np
+
+from waveforms import Waveform, WaveVStack, wave_eval
+from waveforms.math.signal import getFTMatrix, shift
+
+from .common import BaseDriver, Quantity
+
+
+def get_coef(coef_info, sampleRate):
+    start, stop = coef_info['start'], coef_info['stop']
+    numberOfPoints = int(
+        (stop - start) * sampleRate)
+    if numberOfPoints % 1024 != 0:
+        numberOfPoints = numberOfPoints + 1024 - numberOfPoints % 1024
+    t = np.arange(numberOfPoints) / sampleRate + start
+
+    fList = []
+    wList = []
+    phases = []
+
+    for kw in coef_info['wList']:
+        Delta, t0, weight, w, phase = kw['Delta'], kw['t0'], kw['weight'], kw['w'], kw['phase']
+        fList.append(Delta)
+
+        if w is not None:
+            w = np.zeros(numberOfPoints, dtype=complex)
+            w[:len(w)] = w
+            w = shift(w, t0 - start)
+            phases.append(np.mod(phase + 2 * np.pi * Delta * start, 2*np.pi))
+        else:
+            weight = weight
+            if isinstance(weight, np.ndarray):
+                pass
+            else:
+                if isinstance(weight, str):
+                    fun = wave_eval(weight) >> t0
+                elif isinstance(weight, Waveform):
+                    fun = weight >> t0
+                else:
+                    raise TypeError(f'Unsupported type {weight}')
+                weight = fun(t)
+            phase += 2 * np.pi * Delta * start
+            w = getFTMatrix([Delta],
+                            numberOfPoints,
+                            phaseList=[phase],
+                            weight=weight,
+                            sampleRate=sampleRate)[:, 0]
+            phases.append(np.mod(phase, 2*np.pi))
+        wList.append(w)
+    return np.asarray(wList), fList, numberOfPoints, phases
+
+
+# class Quantity(object):
+#     def __init__(self, name: str, value=None, ch: int = None, unit: str = ''):
+#         self.name = name
+#         self.default = dict(value=value, ch=ch, unit=unit)
+
+
+def tolist(wv: WaveVStack) -> list:
+    ret = [wv.start, wv.stop, wv.sample_rate, len(wv.wlist)]
+    for w in wv.wlist:
+        ret.extend(w.tolist())
+    return ret
+
+
+def fromlist(wl: list) -> WaveVStack:
+    wv, wpos = WaveVStack([]), 4
+    wv.start, wv.stop, wv.sample_rate, n = wl[:wpos]
+    for _ in range(n):
+        wav, pos = Waveform.fromlist(wl[wpos:], True)
+        wv.wlist.append(wav)
+        wpos += pos
+    return wv
+
+
+class Driver(BaseDriver):
+    """driver template
+
+    Warning:
+        All drivers must inherit from the base class(with fixed class name ***Driver***) and methods open/close/read/write must be implemented!
+    """
+    segment = ('na', '101|102|103')
+    # number of available channels
+    CHs = list(range(36))
+
+    quants = [
+        # Microwave source(MW)
+        Quantity('Frequency', value=0, ch=1, unit='Hz'),  # float
+        Quantity('Power', value=0, ch=1, unit='dBm'),  # loat
+        Quantity('Output', value='OFF', ch=1),  # str
+
+        # 任意波形发生器(AWG)
+        Quantity('Amplitude', value=0, ch=1, unit='Vpp'),  # float
+        Quantity('Offset', value=0, ch=1, unit='V'),  # float
+        Quantity('Waveform', value=np.array([]), ch=1),  # np.array or Waveform
+        Quantity('Marker1', value=[], ch=1),  # Marker1，np.array
+        Quantity('Marker2', value=[], ch=1),  # Marker2，np.array
+
+        # Data Acquisition(ADC)
+        Quantity('PointNumber', value=1024, ch=1, unit='point'),  # int
+        Quantity('TriggerDelay', value=0, ch=1, unit='s'),  # float
+        Quantity('Shot', value=512, ch=1),  # int
+        Quantity('TraceIQ', value=np.array([]), ch=1),  # np.array
+        Quantity('Trace', value=np.array([]), ch=1),  # np.array
+        Quantity('IQ', value=np.array([]), ch=1),  # np.array
+        Quantity('Coefficient', value=np.array([]), ch=1),  # np.array
+        Quantity('StartCapture', value=1, ch=1,),  # int
+        
+        Quantity('CaptureMode', value='raw', ch=1), # raw->TraceIQ, alg-> IQ
+
+        # test
+        Quantity('Classify', value=0, ch=1),
+        Quantity('Counts', value=[], ch=1),
+
+        # Trigger(TRIG)
+        Quantity('TRIG'),
+        Quantity('TriggerMode'),  # burst or continuous
+        Quantity('Wait', value=0, ch=1),  # wait
+    ]
+
+    def __init__(self, addr: str = '', timeout: float = 3.0, **kw):
+        super().__init__(addr=addr, timeout=timeout, **kw)
+        self.model = 'VirtualDevice'  # device model
+        self.timeout = 1.0
+        self.srate = 1e9  # sampling rate
+
+    def open(self, **kw):
+        """open device
+        """
+        self.handle = 'DeviceHandler'
+        # test = 1/0
+
+    def close(self, **kw):
+        """close device
+        """
+        self.handle.close()
+
+    def write(self, name: str, value, **kw):
+        """write to device
+        """
+        if name == 'Wait':
+            time.sleep(value)
+        elif name == 'Waveform':
+            if isinstance(value, list):
+                t0 = time.time()
+                wf = fromlist(value)
+                t1 = time.time()
+                wf.sample()
+            if isinstance(value, Waveform):
+                t0 = time.time()
+                value.sample()
+            # 如，self.set_offset(value, ch=1)
+        elif name == 'Shot':
+            pass
+        elif name == 'Coefficient':
+            data, f_list, numberOfPoints, phase = get_coef(value, self.srate)
+            # coef_data = np.moveaxis([data.real,data.imag],0,-2)
+            self.setValue('PointNumber', numberOfPoints, **kw)
+            # self.update('Coefficient', data, channel=ch)
+            return data
+            # 如，self.set_shot(value, ch=2)
+        return value
+
+    def read(self, name: str, **kw):
+        """read from device
+        """
+        if name == 'TraceIQ':
+            shot = self.getValue('Shot', **kw)
+            point = self.getValue('PointNumber', **kw)
+            # test = 1/0
+            return np.ones((shot, point)), np.ones((shot, point))
+        elif name == 'IQ':
+            shot = self.getValue('Shot', **kw)
+            fnum = self.getValue('Coefficient', **kw).shape[0]
+            # time.sleep(0.1)
+            si = np.random.randint(20)+np.random.randn(shot, fnum)
+            sq = np.random.randint(20)+np.random.randn(shot, fnum)
+            return si, sq
+
+    # *#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*# user defined #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
+    def get_iq(self):
+        pass
+
+    def get_trace(self):
+        pass
```

## quark/driver/common/__init__.py

 * *Ordering differences only*

```diff
@@ -1,32 +1,32 @@
-# MIT License
-
-# Copyright (c) 2021 YL Feng
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
-"""
-Abstract: about common
-    - define the base driver and quantity
-"""
-
-
-from .basedriver import BaseDriver
-from .quantity import (QBool, QInteger, QList, QOption, QReal, QString,
-                       Quantity, QVector, newcfg)
-from .visadriver import IEEE_488_2_BinBlock, VisaDriver
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+"""
+Abstract: about common
+    - define the base driver and quantity
+"""
+
+
+from .basedriver import BaseDriver
+from .quantity import (QBool, QInteger, QList, QOption, QReal, QString,
+                       Quantity, QVector, newcfg)
+from .visadriver import IEEE_488_2_BinBlock, VisaDriver
```

## quark/envelope/assembler.py

 * *Ordering differences only*

```diff
@@ -1,399 +1,399 @@
-# MIT License
-
-# Copyright (c) 2021 YL Feng
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
-import os
-import time
-from typing import Any
-
-import numpy as np
-from loguru import logger
-
-from quark.proxy import dumpv
-
-from .systemq import (CompilerContext, Waveform, WaveVStack, _form_signal,
-                      get_all_channels, qcompile, square, stdlib, wave_eval)
-
-cfg = CompilerContext({})  # cfg (CompilerContext): 线路编绎所需配置
-
-
-def initialize(snapshot, **kwds):
-    """compiler context for current task
-
-    Note:
-        every task has its own context
-
-    Args:
-        snapshot (_type_): frozen snapshot for current task
-
-    Returns:
-        cfg (CompilerContext): CompilerContext to be used in compilation
-
-    """
-    if isinstance(snapshot, int):
-        return os.getpid()
-    cfg.reset(snapshot)
-    cfg.initial = kwds.get('initial', {'restore': []})
-    cfg.bypass = kwds.get('bypass', {})
-    cfg._keys = kwds.get('keys', [])
-    return cfg
-
-
-def ccompile(sid: int, instruction: dict, circuit: list, **kwds):
-    """compile circuits to commands(saved in **instruction**)
-
-    Args:
-        sid (int): step index(starts from 0)
-        instruction (dict): where commands are saved
-        circuit (list): qlisp circuit(@HK)
-
-    Returns:
-        tuple: instruction, extra arguments
-
-    Example: compile a circuit to instruction
-        ``` {.py3 linenums="1"}
-        from quark import connect
-        s = connect('QuarkServer')
-        cfg = initialize(s.snapshot())
-        circuit = [(('Measure',0),'Q0503')]
-        instruction, datamap =ccompile(0,circuit,signal='iq')
-
-        print(instruction) # before assemble
-        {'main': [('WRITE', 'Q0503.waveform.DDS', <waveforms.waveform.Waveform at 0x291381b6c80>, ''),
-                ('WRITE', 'M5.waveform.DDS', <waveforms.waveform.Waveform at 0x291381b7f40>, ''),
-                ('WRITE', 'ADx86_159.CH5.Shot', 1024, ''),
-                ('WRITE', 'ADx86_159.CH5.Coefficient', {'start': 2.4000000000000003e-08,
-                                                        'stop': 4.0299999999999995e-06,
-                                                        'wList': [{'Delta': 6932860000.0,
-                                                                    'phase': 0,
-                                                                    'weight': 'const(1)',
-                                                                    'window': (0, 1024),
-                                                                    'w': None,
-                                                                    't0': 3e-08,
-                                                                    'phi': -0.7873217091999384,
-                                                                    'threshold': 2334194991.172387}]}, ''),
-                ('WRITE', 'ADx86_159.CH5.TriggerDelay', 7e-07, ''),
-                ('WRITE', 'ADx86_159.CH5.CaptureMode', 'alg', ''),
-                ('WRITE', 'ADx86_159.CH5.StartCapture', 54328, '')],
-        'READ': [('READ', 'ADx86_159.CH5.IQ', 'READ', '')]
-        }
-
-        print(datamap)
-        {'dataMap': {'cbits': {0: ('READ.ADx86_159.CH5', 
-                                    0, 
-                                    6932860000.0, 
-                                    {'duration': 4e-06,
-                                     'amp': 0.083,
-                                     'frequency': 6932860000.0,
-                                     'phase': [[-1, 1], [-1, 1]],
-                                     'weight': 'const(1)',
-                                     'phi': -0.7873217091999384,
-                                     'threshold': 2334194991.172387,
-                                     'ring_up_amp': 0.083,
-                                     'ring_up_waist': 0.083,
-                                     'ring_up_time': 5e-07,
-                                     'w': None},
-                                    3e-08,
-                                    2.4000000000000003e-08,
-                                    4.0299999999999995e-06)
-                                },
-                    'signal': 2,
-                    'arch': 'baqis'
-                    }
-        }
-        ```
-
-    """
-    # kwds['signal'] = _form_signal(kwds.get('signal'))
-    # kwds['lib'] = kwds.get('lib', stdlib)
-
-    ctx = kwds.pop('ctx', cfg)
-    ctx.snapshot().cache = kwds.pop('cache', {})
-
-    # align_right = kwds.pop('align_right', True)
-    # waveform_length = kwds.pop('waveform_length', 98e-6)
-    if kwds.get('fillzero', False):  # whether to initialize all channels to zero()
-        compiled = {'main': [('WRITE', target, 'zero()', '')
-                             for target in get_all_channels(ctx)]}
-    else:
-        compiled = {}
-
-    # code = _compile(circuit, cfg=ctx, **kwds)
-
-    # if align_right:
-    #     delay = waveform_length - code.end
-
-    #     code.waveforms = {k: v >> delay for k, v in code.waveforms.items()}
-    #     code.measures = {
-    #         k:
-    #         Capture(v.qubit, v.cbit, v.time + delay, v.signal,
-    #                 v.params, v.hardware, v.shift + delay)
-    #         for k, v in code.measures.items()
-    #     }
-
-    # cmds, datamap = assembly_code(code)
-    code, (cmds, datamap) = qcompile(circuit,
-                                     lib=kwds.get('lib', stdlib),
-                                     cfg=kwds.get('cfg', ctx),
-                                     signal=_form_signal(kwds.get('signal')),
-                                     shots=kwds.get('shots', 1024),
-                                     context=kwds.get('context', {}),
-                                     arch=kwds.get('arch', 'baqis'),
-                                     align_right=kwds.get('align_right', True),
-                                     waveform_length=kwds.get('waveform_length', 98e-6))
-
-    for cmd in cmds:
-        ctype = type(cmd).__name__  # WRITE,TRIG,READ
-        if ctype == 'WRITE':
-            step = 'main'
-        else:
-            step = ctype
-        op = (ctype, cmd.address, cmd.value, 'au')
-        if step in compiled:
-            compiled[step].append(op)
-        else:
-            compiled[step] = [op]
-
-    # merge loop body with compiled result
-    for step, _cmds in compiled.items():
-        if step in instruction:
-            instruction[step].extend(_cmds)
-        else:
-            instruction[step] = _cmds
-    assemble(sid, instruction, prep=False, hold=kwds.get('hold', False))
-    if sid == 0:
-        kwds['restore'] = cfg.initial
-        kwds['clear'] = True
-    logger.info(f'Step {sid} compiled >>>>>>>>>>>>>')
-    return instruction, {'dataMap': datamap} | kwds
-
-
-def assemble(sid: int, instruction: dict[str, list[str, str, Any, str]], **kw):
-    """assemble compiled instruction(see cccompile) to corresponding devices
-
-    Args:
-        sid (int): step index
-        instruction (dict[str, list[str, str, Any, str]]): see cccompile
-
-    Raises:
-        TypeError: srate should be float, defaults to -1.0
-    """
-
-    try:
-        query = kw.get('ctx', cfg).query
-    except AttributeError as e:
-        query = cfg.query
-
-    for step, operations in instruction.items():
-        if not isinstance(operations, list):
-            break
-        scmd = {}
-        for ctype, target, value, unit in operations:
-            kwds = {'sid': sid, 'target': target,
-                    'track': query('etc.track'),
-                    'shared': query('etc.shared'),
-                    'filter': query('etc.filter')}
-            if 'CH' in target or ctype == 'WAIT':
-                _target = target
-            else:
-                try:
-                    # logical channel to hardware channel
-                    context = query(target.split('.', 1)[0])
-                    mapping = query('etc.mapping')
-                    _target = decode(target, context, mapping)
-                    kwds.update({"context": context})
-                except (ValueError, KeyError) as e:
-                    continue
-
-                # save initial value to restore
-                if sid == 0 and not kw.get('hold', False):
-                    init = query(target.removesuffix(
-                        '.I').removesuffix('.Q'))
-                    cfg.initial['restore'].append((ctype, target, init, unit))
-
-            # get sample rate from device
-            if ctype != 'WAIT':
-                dev = _target.split('.', 1)[0]
-                kwds['srate'] = query(f'dev.{dev}.srate')
-                if not kwds['srate']:
-                    logger.critical(f'Failed to get srate for {dev}!')
-            cmd = [ctype, value, unit, kwds]
-
-            # shared channels
-            try:
-                if _target in scmd and 'waveform' in target.lower():
-                    if isinstance(scmd[_target][1], str):
-                        scmd[_target][1] = wave_eval(scmd[_target][1])
-                    if isinstance(cmd[1], str):
-                        cmd[1] = wave_eval(cmd[1])
-                    scmd[_target][1] += cmd[1]
-                else:
-                    scmd[_target] = cmd
-            except Exception as e:
-                logger.warning(f'Channel[{_target}] mutiplexing error: {e}')
-                scmd[_target] = cmd
-        instruction[step] = scmd
-
-    # preprocess if True
-    if kw.get('prep', True):
-        return preprocess(sid, instruction)
-
-
-# mapping logical attribute to hardware attribute
-MAPPING = {
-    "setting_LO": "LO.Frequency",
-    "setting_POW": "LO.Power",
-    "setting_OFFSET": "ZBIAS.Offset",
-    "waveform_RF_I": "I.Waveform",
-    "waveform_RF_Q": "Q.Waveform",
-    "waveform_TRIG": "TRIG.Marker1",
-    "waveform_DDS": "DDS.Waveform",
-    "waveform_SW": "SW.Marker1",
-    "waveform_Z": "Z.Waveform",
-    "setting_PNT": "ADC.PointNumber",
-    "setting_SHOT": "ADC.Shot",
-    "setting_TRIGD": "ADC.TriggerDelay"
-}
-
-
-# commands filters
-SUFFIX = ('Waveform', 'Shot', 'Coefficient', 'TriggerDelay')
-
-
-def decode(target: str, context: dict, mapping: dict = MAPPING):
-    """decode target to hardware channel
-
-    Args:
-        target (str): target to be decoded like **Q0.setting.LO**
-        context (dict): target location like **Q0**
-        mapping (dict, optional): mapping relations. Defaults to MAPPING.
-
-    Raises:
-        KeyError: mapping not found
-        ValueError: channel not found
-
-    Returns:
-        str: hardware channel like **AD.CH1.TraceIQ**
-    """
-    try:
-        mkey = target.split('.', 1)[-1].replace('.', '_')
-        chkey, quantity = mapping[mkey].split('.', 1)
-    except KeyError as e:
-        raise KeyError(f'{e} not found in mapping!')
-
-    try:
-        channel = context.get('channel', {})[chkey]
-    except KeyError as e:
-        raise KeyError(f'{chkey} not found!')
-
-    if channel is None:
-        raise ValueError('ChannelNotFound')
-    elif not isinstance(channel, str):
-        raise TypeError(
-            f'Wrong type of channel of {target}, string needed got {channel}')
-    elif 'Marker' not in channel:
-        channel = '.'.join((channel, quantity))
-
-    return channel
-
-
-WINDOW = square(500e-3) >> 150e-3
-
-
-def equal(a, b):
-    if isinstance(a, WaveVStack) or isinstance(b, WaveVStack):
-        return False
-    if isinstance(a, Waveform) and isinstance(b, Waveform):
-        return (a*WINDOW) == (b*WINDOW)
-    try:
-        return a == b
-    except Exception as e:
-        # logger.warning(f'Failed to compare {e}')
-        return False
-
-
-def preprocess(sid: int, instruction: dict[str, dict[str, list[str, Any, str, dict]]]):
-    """filters and paramters 
-
-    Args:
-        sid (int): step index
-        instruction (dict):instruction set like **{step: {target: [ctype, value, unit, kwds]}}**
-
-    Example: instruction structure
-        - step (str): step name, e.g., main/step1/step2
-        - target (list): hardware channel, e.g., AWG.CH1.Waveform、AD.CH2.TraceIQ
-            - ctype (str): command type, must be one of READ/WRITE/WAIT
-            - value (Any): command value, None for READ, seconds for WAIT, arbitary for WRITE, see corresponding driver
-            - unit (str): command unit, useless for now
-            - kwds (dict):
-                - sid (int): step index
-                - track (list): list of sid to be tracked
-                - target (str): original target like Q0101.waveform.Z
-                - filter (list): sample waveform in the filter list to show in `QuarkCanvas`
-                - srate (float): sampling rate
-                - context (dict): target location like Q0101
-    """
-    if sid == 0:
-        cfg.bypass.clear()
-    bypass = cfg.bypass
-
-    shared = []
-    for step, operations in instruction.items():
-        if not isinstance(operations, dict):
-            break
-        scmd = {}
-        for target, cmd in operations.items():
-            try:
-                kwds = cmd[-1]
-                # 重复指令缓存比较, 如果与上一步相同, 则跳过执行
-                if target in bypass and target.endswith(SUFFIX) and equal(bypass[target][0], cmd[1]):
-                    continue
-                bypass[target] = (cmd[1], kwds['target'])
-
-                # context设置, 用于calculator.calculate
-                context = kwds.pop('context', {})  # 即cfg表中的Qubit、Coupler等
-                if context:
-                    kwds['LEN'] = context['waveform']['LEN']
-                    kwds['calibration'] = context['calibration']
-
-                # if isinstance(cmd[1], Waveform):
-                #     cmd[1].sample_rate = kwds['srate']
-                #     cmd[1].start = 0
-                #     cmd[1].stop = 1e-3  # kwds['LEN']
-                #     cmd[1] = cmd[1].sample()
-
-                if kwds['shared']:
-                    sm, value = dumpv(cmd[1])
-                    if sm:
-                        shared.append(sm)
-                        cmd[1] = value
-            except Exception as e:
-                logger.error(f'Failed to preprocess {target}, {e}!')
-            scmd[target] = cmd
-        instruction[step] = scmd
-
-    return shared
-
-
-# %%
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+import os
+import time
+from typing import Any
+
+import numpy as np
+from loguru import logger
+
+from quark.proxy import dumpv
+
+from .systemq import (CompilerContext, Waveform, WaveVStack, _form_signal,
+                      get_all_channels, qcompile, square, stdlib, wave_eval)
+
+cfg = CompilerContext({})  # cfg (CompilerContext): 线路编绎所需配置
+
+
+def initialize(snapshot, **kwds):
+    """compiler context for current task
+
+    Note:
+        every task has its own context
+
+    Args:
+        snapshot (_type_): frozen snapshot for current task
+
+    Returns:
+        cfg (CompilerContext): CompilerContext to be used in compilation
+
+    """
+    if isinstance(snapshot, int):
+        return os.getpid()
+    cfg.reset(snapshot)
+    cfg.initial = kwds.get('initial', {'restore': []})
+    cfg.bypass = kwds.get('bypass', {})
+    cfg._keys = kwds.get('keys', [])
+    return cfg
+
+
+def ccompile(sid: int, instruction: dict, circuit: list, **kwds):
+    """compile circuits to commands(saved in **instruction**)
+
+    Args:
+        sid (int): step index(starts from 0)
+        instruction (dict): where commands are saved
+        circuit (list): qlisp circuit(@HK)
+
+    Returns:
+        tuple: instruction, extra arguments
+
+    Example: compile a circuit to instruction
+        ``` {.py3 linenums="1"}
+        from quark import connect
+        s = connect('QuarkServer')
+        cfg = initialize(s.snapshot())
+        circuit = [(('Measure',0),'Q0503')]
+        instruction, datamap =ccompile(0,circuit,signal='iq')
+
+        print(instruction) # before assemble
+        {'main': [('WRITE', 'Q0503.waveform.DDS', <waveforms.waveform.Waveform at 0x291381b6c80>, ''),
+                ('WRITE', 'M5.waveform.DDS', <waveforms.waveform.Waveform at 0x291381b7f40>, ''),
+                ('WRITE', 'ADx86_159.CH5.Shot', 1024, ''),
+                ('WRITE', 'ADx86_159.CH5.Coefficient', {'start': 2.4000000000000003e-08,
+                                                        'stop': 4.0299999999999995e-06,
+                                                        'wList': [{'Delta': 6932860000.0,
+                                                                    'phase': 0,
+                                                                    'weight': 'const(1)',
+                                                                    'window': (0, 1024),
+                                                                    'w': None,
+                                                                    't0': 3e-08,
+                                                                    'phi': -0.7873217091999384,
+                                                                    'threshold': 2334194991.172387}]}, ''),
+                ('WRITE', 'ADx86_159.CH5.TriggerDelay', 7e-07, ''),
+                ('WRITE', 'ADx86_159.CH5.CaptureMode', 'alg', ''),
+                ('WRITE', 'ADx86_159.CH5.StartCapture', 54328, '')],
+        'READ': [('READ', 'ADx86_159.CH5.IQ', 'READ', '')]
+        }
+
+        print(datamap)
+        {'dataMap': {'cbits': {0: ('READ.ADx86_159.CH5', 
+                                    0, 
+                                    6932860000.0, 
+                                    {'duration': 4e-06,
+                                     'amp': 0.083,
+                                     'frequency': 6932860000.0,
+                                     'phase': [[-1, 1], [-1, 1]],
+                                     'weight': 'const(1)',
+                                     'phi': -0.7873217091999384,
+                                     'threshold': 2334194991.172387,
+                                     'ring_up_amp': 0.083,
+                                     'ring_up_waist': 0.083,
+                                     'ring_up_time': 5e-07,
+                                     'w': None},
+                                    3e-08,
+                                    2.4000000000000003e-08,
+                                    4.0299999999999995e-06)
+                                },
+                    'signal': 2,
+                    'arch': 'baqis'
+                    }
+        }
+        ```
+
+    """
+    # kwds['signal'] = _form_signal(kwds.get('signal'))
+    # kwds['lib'] = kwds.get('lib', stdlib)
+
+    ctx = kwds.pop('ctx', cfg)
+    ctx.snapshot().cache = kwds.pop('cache', {})
+
+    # align_right = kwds.pop('align_right', True)
+    # waveform_length = kwds.pop('waveform_length', 98e-6)
+    if kwds.get('fillzero', False):  # whether to initialize all channels to zero()
+        compiled = {'main': [('WRITE', target, 'zero()', '')
+                             for target in get_all_channels(ctx)]}
+    else:
+        compiled = {}
+
+    # code = _compile(circuit, cfg=ctx, **kwds)
+
+    # if align_right:
+    #     delay = waveform_length - code.end
+
+    #     code.waveforms = {k: v >> delay for k, v in code.waveforms.items()}
+    #     code.measures = {
+    #         k:
+    #         Capture(v.qubit, v.cbit, v.time + delay, v.signal,
+    #                 v.params, v.hardware, v.shift + delay)
+    #         for k, v in code.measures.items()
+    #     }
+
+    # cmds, datamap = assembly_code(code)
+    code, (cmds, datamap) = qcompile(circuit,
+                                     lib=kwds.get('lib', stdlib),
+                                     cfg=kwds.get('cfg', ctx),
+                                     signal=_form_signal(kwds.get('signal')),
+                                     shots=kwds.get('shots', 1024),
+                                     context=kwds.get('context', {}),
+                                     arch=kwds.get('arch', 'baqis'),
+                                     align_right=kwds.get('align_right', True),
+                                     waveform_length=kwds.get('waveform_length', 98e-6))
+
+    for cmd in cmds:
+        ctype = type(cmd).__name__  # WRITE,TRIG,READ
+        if ctype == 'WRITE':
+            step = 'main'
+        else:
+            step = ctype
+        op = (ctype, cmd.address, cmd.value, 'au')
+        if step in compiled:
+            compiled[step].append(op)
+        else:
+            compiled[step] = [op]
+
+    # merge loop body with compiled result
+    for step, _cmds in compiled.items():
+        if step in instruction:
+            instruction[step].extend(_cmds)
+        else:
+            instruction[step] = _cmds
+    assemble(sid, instruction, prep=False, hold=kwds.get('hold', False))
+    if sid == 0:
+        kwds['restore'] = cfg.initial
+        kwds['clear'] = True
+    logger.info(f'Step {sid} compiled >>>>>>>>>>>>>')
+    return instruction, {'dataMap': datamap} | kwds
+
+
+def assemble(sid: int, instruction: dict[str, list[str, str, Any, str]], **kw):
+    """assemble compiled instruction(see cccompile) to corresponding devices
+
+    Args:
+        sid (int): step index
+        instruction (dict[str, list[str, str, Any, str]]): see cccompile
+
+    Raises:
+        TypeError: srate should be float, defaults to -1.0
+    """
+
+    try:
+        query = kw.get('ctx', cfg).query
+    except AttributeError as e:
+        query = cfg.query
+
+    for step, operations in instruction.items():
+        if not isinstance(operations, list):
+            break
+        scmd = {}
+        for ctype, target, value, unit in operations:
+            kwds = {'sid': sid, 'target': target,
+                    'track': query('etc.track'),
+                    'shared': query('etc.shared'),
+                    'filter': query('etc.filter')}
+            if 'CH' in target or ctype == 'WAIT':
+                _target = target
+            else:
+                try:
+                    # logical channel to hardware channel
+                    context = query(target.split('.', 1)[0])
+                    mapping = query('etc.mapping')
+                    _target = decode(target, context, mapping)
+                    kwds.update({"context": context})
+                except (ValueError, KeyError) as e:
+                    continue
+
+                # save initial value to restore
+                if sid == 0 and not kw.get('hold', False):
+                    init = query(target.removesuffix(
+                        '.I').removesuffix('.Q'))
+                    cfg.initial['restore'].append((ctype, target, init, unit))
+
+            # get sample rate from device
+            if ctype != 'WAIT':
+                dev = _target.split('.', 1)[0]
+                kwds['srate'] = query(f'dev.{dev}.srate')
+                if not kwds['srate']:
+                    logger.critical(f'Failed to get srate for {dev}!')
+            cmd = [ctype, value, unit, kwds]
+
+            # shared channels
+            try:
+                if _target in scmd and 'waveform' in target.lower():
+                    if isinstance(scmd[_target][1], str):
+                        scmd[_target][1] = wave_eval(scmd[_target][1])
+                    if isinstance(cmd[1], str):
+                        cmd[1] = wave_eval(cmd[1])
+                    scmd[_target][1] += cmd[1]
+                else:
+                    scmd[_target] = cmd
+            except Exception as e:
+                logger.warning(f'Channel[{_target}] mutiplexing error: {e}')
+                scmd[_target] = cmd
+        instruction[step] = scmd
+
+    # preprocess if True
+    if kw.get('prep', True):
+        return preprocess(sid, instruction)
+
+
+# mapping logical attribute to hardware attribute
+MAPPING = {
+    "setting_LO": "LO.Frequency",
+    "setting_POW": "LO.Power",
+    "setting_OFFSET": "ZBIAS.Offset",
+    "waveform_RF_I": "I.Waveform",
+    "waveform_RF_Q": "Q.Waveform",
+    "waveform_TRIG": "TRIG.Marker1",
+    "waveform_DDS": "DDS.Waveform",
+    "waveform_SW": "SW.Marker1",
+    "waveform_Z": "Z.Waveform",
+    "setting_PNT": "ADC.PointNumber",
+    "setting_SHOT": "ADC.Shot",
+    "setting_TRIGD": "ADC.TriggerDelay"
+}
+
+
+# commands filters
+SUFFIX = ('Waveform', 'Shot', 'Coefficient', 'TriggerDelay')
+
+
+def decode(target: str, context: dict, mapping: dict = MAPPING):
+    """decode target to hardware channel
+
+    Args:
+        target (str): target to be decoded like **Q0.setting.LO**
+        context (dict): target location like **Q0**
+        mapping (dict, optional): mapping relations. Defaults to MAPPING.
+
+    Raises:
+        KeyError: mapping not found
+        ValueError: channel not found
+
+    Returns:
+        str: hardware channel like **AD.CH1.TraceIQ**
+    """
+    try:
+        mkey = target.split('.', 1)[-1].replace('.', '_')
+        chkey, quantity = mapping[mkey].split('.', 1)
+    except KeyError as e:
+        raise KeyError(f'{e} not found in mapping!')
+
+    try:
+        channel = context.get('channel', {})[chkey]
+    except KeyError as e:
+        raise KeyError(f'{chkey} not found!')
+
+    if channel is None:
+        raise ValueError('ChannelNotFound')
+    elif not isinstance(channel, str):
+        raise TypeError(
+            f'Wrong type of channel of {target}, string needed got {channel}')
+    elif 'Marker' not in channel:
+        channel = '.'.join((channel, quantity))
+
+    return channel
+
+
+WINDOW = square(500e-3) >> 150e-3
+
+
+def equal(a, b):
+    if isinstance(a, WaveVStack) or isinstance(b, WaveVStack):
+        return False
+    if isinstance(a, Waveform) and isinstance(b, Waveform):
+        return (a*WINDOW) == (b*WINDOW)
+    try:
+        return a == b
+    except Exception as e:
+        # logger.warning(f'Failed to compare {e}')
+        return False
+
+
+def preprocess(sid: int, instruction: dict[str, dict[str, list[str, Any, str, dict]]]):
+    """filters and paramters 
+
+    Args:
+        sid (int): step index
+        instruction (dict):instruction set like **{step: {target: [ctype, value, unit, kwds]}}**
+
+    Example: instruction structure
+        - step (str): step name, e.g., main/step1/step2
+        - target (list): hardware channel, e.g., AWG.CH1.Waveform、AD.CH2.TraceIQ
+            - ctype (str): command type, must be one of READ/WRITE/WAIT
+            - value (Any): command value, None for READ, seconds for WAIT, arbitary for WRITE, see corresponding driver
+            - unit (str): command unit, useless for now
+            - kwds (dict):
+                - sid (int): step index
+                - track (list): list of sid to be tracked
+                - target (str): original target like Q0101.waveform.Z
+                - filter (list): sample waveform in the filter list to show in `QuarkCanvas`
+                - srate (float): sampling rate
+                - context (dict): target location like Q0101
+    """
+    if sid == 0:
+        cfg.bypass.clear()
+    bypass = cfg.bypass
+
+    shared = []
+    for step, operations in instruction.items():
+        if not isinstance(operations, dict):
+            break
+        scmd = {}
+        for target, cmd in operations.items():
+            try:
+                kwds = cmd[-1]
+                # 重复指令缓存比较, 如果与上一步相同, 则跳过执行
+                if target in bypass and target.endswith(SUFFIX) and equal(bypass[target][0], cmd[1]):
+                    continue
+                bypass[target] = (cmd[1], kwds['target'])
+
+                # context设置, 用于calculator.calculate
+                context = kwds.pop('context', {})  # 即cfg表中的Qubit、Coupler等
+                if context:
+                    kwds['LEN'] = context['waveform']['LEN']
+                    kwds['calibration'] = context['calibration']
+
+                # if isinstance(cmd[1], Waveform):
+                #     cmd[1].sample_rate = kwds['srate']
+                #     cmd[1].start = 0
+                #     cmd[1].stop = 1e-3  # kwds['LEN']
+                #     cmd[1] = cmd[1].sample()
+
+                if kwds['shared']:
+                    sm, value = dumpv(cmd[1])
+                    if sm:
+                        shared.append(sm)
+                        cmd[1] = value
+            except Exception as e:
+                logger.error(f'Failed to preprocess {target}, {e}!')
+            scmd[target] = cmd
+        instruction[step] = scmd
+
+    return shared
+
+
+# %%
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## quark/envelope/calculator.py

 * *Ordering differences only*

```diff
@@ -1,157 +1,157 @@
-# MIT License
-
-# Copyright (c) 2021 YL Feng
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
-import numpy as np
-from loguru import logger
-
-from quark.proxy import loadv
-
-from .systemq import Waveform, sample_waveform, wave_eval
-
-
-def calculate(step: str, target: str, cmd: list, preview: dict = {}):
-    """preprocess each command such as predistortion and sampling
-
-    Args:
-        step (str): step name, e.g., main/step1/...
-        target (str): hardware channel like **AWG.CH1.Offset**
-        cmd (list): command, in the type of tuple **(ctype, value, unit, kwds)**, where ctype
-            must be one of **WRITE/READ/WAIT**, see `assembler.preprocess` for more details. 
-
-    Returns:
-        tuple: (preprocessed result, sampled waveform to be shown in the `QuarkCanvas`)
-
-    Example:
-        ``` {.py3 linenums="1"}
-        calculate('main', 'AWG.CH1.Waveform',('WRITE',square(100e-6),'au',{'calibration':{}}))
-        ```
-    """
-    ctype, value, unit, kwds = cmd
-
-    line = {}
-
-    if ctype != 'WRITE':
-        return (step, target, cmd), line
-
-    if isinstance(value, str):
-        try:
-            func = wave_eval(value)
-        except SyntaxError as e:
-            func = value
-    else:
-        func = value
-
-    delay = 0
-
-    # sm, _value = loadv(func) # _value[:] = _value*10
-
-    if isinstance(func, Waveform):
-        if target.startswith(tuple(kwds.get('filter', ['zzzzz']))):
-            support_waveform_object = True
-        else:
-            support_waveform_object = False
-
-        try:
-            ch = kwds['target'].split('.')[-1]
-            delay = kwds['calibration'][ch].get('delay', 0)
-            cmd[1] = sample_waveform(func, kwds['calibration'][ch],
-                                     sample_rate=kwds['srate'],
-                                     start=0, stop=kwds['LEN'],
-                                     support_waveform_object=support_waveform_object)
-        except Exception as e:
-            # KeyError: 'calibration'
-            logger.error(f'Failed to sample waveform: {e}')
-            func.start = 0
-            func.stop = 100e-6
-            func.sample_rate = kwds['srate']
-
-            if support_waveform_object:
-                cmd[1] = func
-            else:
-                cmd[1] = func.sample()
-    else:
-        cmd[1] = func
-
-    cmd[-1] = {'sid': kwds['sid'], 'target': kwds['target'], 'srate': kwds['srate'],
-               'track': kwds['track'], 'shared': kwds['shared']}
-
-    try:
-        line = plot(target, cmd, preview, delay)
-    except Exception as e:
-        logger.error(
-            f"{'>'*30}'  failed to calculate waveform', {e}, {type(e).__name__}")
-
-    return (step, target, cmd), line
-
-
-def plot(target: str, cmd: dict, preview: dict = {}, delay: float = 0.0):
-    """sample waveforms needed to be shown in the `QuarkCanvas`
-
-    Args:
-        target (str): hardware channel
-        cmd (dict): see calculator
-        preview (dict, optional): from **etc.preview**. Defaults to {}.
-        delay (float, optional): time delay for the channel. Defaults to 0.0.
-
-    Returns:
-        _type_: _description_
-    """
-    if not preview.get('filter', []):
-        return {}
-
-    if cmd[-1]['target'].split('.')[0] not in preview['filter'] or cmd[-1]['sid'] < 0:
-        return {}
-
-    if target.endswith('Waveform'):
-
-        srate = cmd[-1]['srate']
-        t1, t2 = preview['range']
-        xr = slice(int(t1*srate), int(t2*srate))
-
-        val = cmd[1]
-        if isinstance(val, Waveform):
-            val = val.sample()
-
-        xt = (np.arange(len(val))/srate)[xr] - delay
-        yt = val[xr]
-
-        try:
-            nz = np.argwhere(np.abs(np.diff(yt)) > 1e-6).squeeze()
-            nz = np.hstack((0, nz-1, nz, nz+1, len(yt)-1))
-            # nz.sort(kind='mergesort')
-            nz = np.unique(nz[nz >= 0])
-            xx, yy = xt[nz], yt[nz]
-        except Exception as e:
-            xx, yy = xt, yt
-
-        line = {'xdata': xx, 'ydata': yy, 'suptitle': cmd[-1]["sid"]}
-        color = preview.get('color', None)
-        if color and isinstance(color, (list, tuple)):
-            line['color'] = tuple(color)
-
-        return {cmd[-1]['target']: line}
-    return {}
-
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+import numpy as np
+from loguru import logger
+
+from quark.proxy import loadv
+
+from .systemq import Waveform, sample_waveform, wave_eval
+
+
+def calculate(step: str, target: str, cmd: list, preview: dict = {}):
+    """preprocess each command such as predistortion and sampling
+
+    Args:
+        step (str): step name, e.g., main/step1/...
+        target (str): hardware channel like **AWG.CH1.Offset**
+        cmd (list): command, in the type of tuple **(ctype, value, unit, kwds)**, where ctype
+            must be one of **WRITE/READ/WAIT**, see `assembler.preprocess` for more details. 
+
+    Returns:
+        tuple: (preprocessed result, sampled waveform to be shown in the `QuarkCanvas`)
+
+    Example:
+        ``` {.py3 linenums="1"}
+        calculate('main', 'AWG.CH1.Waveform',('WRITE',square(100e-6),'au',{'calibration':{}}))
+        ```
+    """
+    ctype, value, unit, kwds = cmd
+
+    line = {}
+
+    if ctype != 'WRITE':
+        return (step, target, cmd), line
+
+    if isinstance(value, str):
+        try:
+            func = wave_eval(value)
+        except SyntaxError as e:
+            func = value
+    else:
+        func = value
+
+    delay = 0
+
+    # sm, _value = loadv(func) # _value[:] = _value*10
+
+    if isinstance(func, Waveform):
+        if target.startswith(tuple(kwds.get('filter', ['zzzzz']))):
+            support_waveform_object = True
+        else:
+            support_waveform_object = False
+
+        try:
+            ch = kwds['target'].split('.')[-1]
+            delay = kwds['calibration'][ch].get('delay', 0)
+            cmd[1] = sample_waveform(func, kwds['calibration'][ch],
+                                     sample_rate=kwds['srate'],
+                                     start=0, stop=kwds['LEN'],
+                                     support_waveform_object=support_waveform_object)
+        except Exception as e:
+            # KeyError: 'calibration'
+            logger.error(f'Failed to sample waveform: {e}')
+            func.start = 0
+            func.stop = 100e-6
+            func.sample_rate = kwds['srate']
+
+            if support_waveform_object:
+                cmd[1] = func
+            else:
+                cmd[1] = func.sample()
+    else:
+        cmd[1] = func
+
+    cmd[-1] = {'sid': kwds['sid'], 'target': kwds['target'], 'srate': kwds['srate'],
+               'track': kwds['track'], 'shared': kwds['shared']}
+
+    try:
+        line = plot(target, cmd, preview, delay)
+    except Exception as e:
+        logger.error(
+            f"{'>'*30}'  failed to calculate waveform', {e}, {type(e).__name__}")
+
+    return (step, target, cmd), line
+
+
+def plot(target: str, cmd: dict, preview: dict = {}, delay: float = 0.0):
+    """sample waveforms needed to be shown in the `QuarkCanvas`
+
+    Args:
+        target (str): hardware channel
+        cmd (dict): see calculator
+        preview (dict, optional): from **etc.preview**. Defaults to {}.
+        delay (float, optional): time delay for the channel. Defaults to 0.0.
+
+    Returns:
+        _type_: _description_
+    """
+    if not preview.get('filter', []):
+        return {}
+
+    if cmd[-1]['target'].split('.')[0] not in preview['filter'] or cmd[-1]['sid'] < 0:
+        return {}
+
+    if target.endswith('Waveform'):
+
+        srate = cmd[-1]['srate']
+        t1, t2 = preview['range']
+        xr = slice(int(t1*srate), int(t2*srate))
+
+        val = cmd[1]
+        if isinstance(val, Waveform):
+            val = val.sample()
+
+        xt = (np.arange(len(val))/srate)[xr] - delay
+        yt = val[xr]
+
+        try:
+            nz = np.argwhere(np.abs(np.diff(yt)) > 1e-6).squeeze()
+            nz = np.hstack((0, nz-1, nz, nz+1, len(yt)-1))
+            # nz.sort(kind='mergesort')
+            nz = np.unique(nz[nz >= 0])
+            xx, yy = xt[nz], yt[nz]
+        except Exception as e:
+            xx, yy = xt, yt
+
+        line = {'xdata': xx, 'ydata': yy, 'suptitle': cmd[-1]["sid"]}
+        color = preview.get('color', None)
+        if color and isinstance(color, (list, tuple)):
+            line['color'] = tuple(color)
+
+        return {cmd[-1]['target']: line}
+    return {}
+
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## quark/envelope/device.py

 * *Ordering differences only*

```diff
@@ -1,51 +1,51 @@
-# MIT License
-
-# Copyright (c) 2021 YL Feng
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
-from typing import Any
-
-from quark.driver.common import BaseDriver
-
-
-def read(device: BaseDriver, quantity: str, channel: int = 1, **kwds):
-    """read from the device
-
-    Args:
-        device (_type_): device handler
-        quantity (str): hardware attribute, e.g., Waveform/Power/Offset
-        channel (int, optional): channel number. Defaults to 1.
-
-    Returns:
-        _type_: result from the device
-    """
-    return device.getValue(quantity, ch=channel, **kwds)
-
-
-def write(device: BaseDriver, quantity: str, value: Any, channel: int = 1, **kwds):
-    """write to the device
-
-    Args:
-        device (_type_): device handler
-        quantity (str): hardware attribute, e.g., Waveform/Power/Offset
-        value (Any): value to be written
-        channel (int, optional): channel number. Defaults to 1.
-    """
-    return device.setValue(quantity, value, ch=channel, **kwds)
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+from typing import Any
+
+from quark.driver.common import BaseDriver
+
+
+def read(device: BaseDriver, quantity: str, channel: int = 1, **kwds):
+    """read from the device
+
+    Args:
+        device (_type_): device handler
+        quantity (str): hardware attribute, e.g., Waveform/Power/Offset
+        channel (int, optional): channel number. Defaults to 1.
+
+    Returns:
+        _type_: result from the device
+    """
+    return device.getValue(quantity, ch=channel, **kwds)
+
+
+def write(device: BaseDriver, quantity: str, value: Any, channel: int = 1, **kwds):
+    """write to the device
+
+    Args:
+        device (_type_): device handler
+        quantity (str): hardware attribute, e.g., Waveform/Power/Offset
+        value (Any): value to be written
+        channel (int, optional): channel number. Defaults to 1.
+    """
+    return device.setValue(quantity, value, ch=channel, **kwds)
```

## quark/envelope/processor.py

 * *Ordering differences only*

```diff
@@ -1,110 +1,110 @@
-# MIT License
-
-# Copyright (c) 2021 YL Feng
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-
-import numpy as np
-from loguru import logger
-
-from .systemq import baqisArchitecture, get_arch, register_arch
-
-register_arch(baqisArchitecture)
-
-
-def demodulate(raw_data, **kwds):
-    pass
-
-
-def process(raw_data, **kwds):
-    """processing data
-
-    Args:
-        raw_data (dict): result from devices
-
-    Returns:
-        result (dict): processed data in the form of {'key1':np.array,'key2':np.array, ...}
-
-    Example: raw_data
-        ``` {.py3 linenums="1"}
-        {'main': {'DAx86_153': {'CH1.Waveform': None}, 
-                                'DAx86_50': {'CH1.Waveform': None}, 
-                                'ADx86_159': {'CH10.CaptureMode': None,
-                                              'CH11.CaptureMode': None, 
-                                              'CH10.StartCapture': None, 
-                                              'CH11.StartCapture': None}}, 
-         'tigger': {'Trigger': {'CH1.TRIG': None}}, 
-         'READ': {'ADx86_159': {'CH10.IQ': (array([[16.62256833],
-                                                   ...,
-                                                   [14.58617952]]), 
-                                            array([[4.0120324 ],
-                                                   ...,
-                                                   [4.97671573]])), 
-                                'CH11.IQ': (array([[14.6038444],
-                                                   ...,
-                                                   [15.33774413]]),
-                                            array([[10.76387584],
-                                                   ...,
-                                                   [11.23863306]]))}}
-        }
-        ```
-    """
-    # print('ddddddddddoooooooooooooooooooooo', kwds)
-    # print("=============================================", raw_data)
-
-    dataMap = kwds.get('dataMap', {'arch': 'baqis'})
-    result = {}
-
-    try:
-
-        if 'arch' in dataMap and dataMap['arch'] == 'general':
-            return raw_data['READ']['AD']
-        elif list(dataMap.keys()) == ['arch']:  # for NA
-            if 'READ' in raw_data:
-                print(raw_data)
-                nadata = result['data'] = raw_data['READ']['NA']
-                if 'CH1.Trace' in nadata:
-                    result['data'] = raw_data['READ']['NA'].pop('CH1.Trace')
-                elif 'CH1.S' in nadata:
-                    result['data'] = raw_data['READ']['NA'].pop('CH1.S')
-            result['extra'] = raw_data
-        else:
-            result = get_arch(dataMap['arch']).assembly_data(raw_data, dataMap)
-
-            for k, v in result.items():
-                if isinstance(v, dict):  # k: count or remote_count
-                    # v: {(0, 0): 100, (0, 1): 1, (1, 0): 2, (1, 1): 100}
-                    base = np.array(tuple(v))
-                    count = np.array(tuple(v.values()))
-                    # result[k] = np.hstack((base, count[:, None]))
-                    nb, nq, shots = *base.shape, kwds.get('shots', 1024)
-                    # _k = k.removeprefix('remote_')
-                    result[k] = np.zeros((min(2**nq, shots), nq+1), int) - 1
-                    result[k][:nb] = np.hstack((base, count[:, None]))
-                else:
-                    result[k] = np.asarray(v)
-    except Exception as e:
-        logger.error(f"{'>'*10} 'Failed to process the result', {e}, {'<'*10}")
-        result['error'] = [
-            f'Failed to process the result, raise Exception: {e.__class__.__name__}("{str(e)}")',
-            raw_data,
-            dataMap
-        ]
-
-    return result
+# MIT License
+
+# Copyright (c) 2021 YL Feng
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+import numpy as np
+from loguru import logger
+
+from .systemq import baqisArchitecture, get_arch, register_arch
+
+register_arch(baqisArchitecture)
+
+
+def demodulate(raw_data, **kwds):
+    pass
+
+
+def process(raw_data, **kwds):
+    """processing data
+
+    Args:
+        raw_data (dict): result from devices
+
+    Returns:
+        result (dict): processed data in the form of {'key1':np.array,'key2':np.array, ...}
+
+    Example: raw_data
+        ``` {.py3 linenums="1"}
+        {'main': {'DAx86_153': {'CH1.Waveform': None}, 
+                                'DAx86_50': {'CH1.Waveform': None}, 
+                                'ADx86_159': {'CH10.CaptureMode': None,
+                                              'CH11.CaptureMode': None, 
+                                              'CH10.StartCapture': None, 
+                                              'CH11.StartCapture': None}}, 
+         'tigger': {'Trigger': {'CH1.TRIG': None}}, 
+         'READ': {'ADx86_159': {'CH10.IQ': (array([[16.62256833],
+                                                   ...,
+                                                   [14.58617952]]), 
+                                            array([[4.0120324 ],
+                                                   ...,
+                                                   [4.97671573]])), 
+                                'CH11.IQ': (array([[14.6038444],
+                                                   ...,
+                                                   [15.33774413]]),
+                                            array([[10.76387584],
+                                                   ...,
+                                                   [11.23863306]]))}}
+        }
+        ```
+    """
+    # print('ddddddddddoooooooooooooooooooooo', kwds)
+    # print("=============================================", raw_data)
+
+    dataMap = kwds.get('dataMap', {'arch': 'baqis'})
+    result = {}
+
+    try:
+
+        if 'arch' in dataMap and dataMap['arch'] == 'general':
+            return raw_data['READ']['AD']
+        elif list(dataMap.keys()) == ['arch']:  # for NA
+            if 'READ' in raw_data:
+                print(raw_data)
+                nadata = result['data'] = raw_data['READ']['NA']
+                if 'CH1.Trace' in nadata:
+                    result['data'] = raw_data['READ']['NA'].pop('CH1.Trace')
+                elif 'CH1.S' in nadata:
+                    result['data'] = raw_data['READ']['NA'].pop('CH1.S')
+            result['extra'] = raw_data
+        else:
+            result = get_arch(dataMap['arch']).assembly_data(raw_data, dataMap)
+
+            for k, v in result.items():
+                if isinstance(v, dict):  # k: count or remote_count
+                    # v: {(0, 0): 100, (0, 1): 1, (1, 0): 2, (1, 1): 100}
+                    base = np.array(tuple(v))
+                    count = np.array(tuple(v.values()))
+                    # result[k] = np.hstack((base, count[:, None]))
+                    nb, nq, shots = *base.shape, kwds.get('shots', 1024)
+                    # _k = k.removeprefix('remote_')
+                    result[k] = np.zeros((min(2**nq, shots), nq+1), int) - 1
+                    result[k][:nb] = np.hstack((base, count[:, None]))
+                else:
+                    result[k] = np.asarray(v)
+    except Exception as e:
+        logger.error(f"{'>'*10} 'Failed to process the result', {e}, {'<'*10}")
+        result['error'] = [
+            f'Failed to process the result, raise Exception: {e.__class__.__name__}("{str(e)}")',
+            raw_data,
+            dataMap
+        ]
+
+    return result
```

## Comparing `vios-2.4.2.dist-info/LICENSE` & `vios-2.4.3.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-MIT License
-
-Copyright (c) 2021 YL Feng
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+MIT License
+
+Copyright (c) 2021 YL Feng
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

## Comparing `vios-2.4.2.dist-info/METADATA` & `vios-2.4.3.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: vios
-Version: 2.4.2
+Version: 2.4.3
 Summary: runtime requirements for systemq
 Author-email: YL Feng <fengyl@baqis.ac.cn>
 License: MIT License
         
         Copyright (c) 2021 YL Feng
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -43,16 +43,16 @@
 Requires-Dist: tqdm
 Requires-Dist: loguru
 Requires-Dist: gitpython
 Requires-Dist: waveforms
 Requires-Dist: pyvisa
 Requires-Dist: pyserial
 Provides-Extra: full
-Requires-Dist: quarkstudio[full] >=6.5.0 ; extra == 'full'
-Requires-Dist: waveforms-math >=1.0.0 ; extra == 'full'
+Requires-Dist: quarkstudio[full] (>=6.5.0) ; extra == 'full'
+Requires-Dist: waveforms-math (>=1.0.0) ; extra == 'full'
 
 ...
```

## Comparing `vios-2.4.2.dist-info/RECORD` & `vios-2.4.3.dist-info/RECORD`

 * *Files 22% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-quark/proxy.py,sha256=9VAPdztBILqUoczm7umDI6VpPt0tc129tCtWfE_jgTc,18473
-quark/app/__init__.py,sha256=EPjmMvf_BImJvvZ1VWRs5SIuj4Gx1LLKAIM4yFchGks,16568
-quark/app/_data.py,sha256=QL5pmn4UO_oRERK3LVbbiKNnYMaGHzBjab3UMwhigS4,3556
+quark/proxy.py,sha256=4cN8CIN47Nz4u1WybUXuVI6SoT4fKu5wqp7SAG31aRQ,19026
+quark/app/__init__.py,sha256=BzCpTM61YjD_U0Xx83QwVHLQ1lv85GfYByborzj-7r4,16489
+quark/app/_data.py,sha256=BuxCtfK9OKqr6UyzdlDA0unDeMfZ_ywrNhX04MWzzWY,3652
 quark/app/_demo.py,sha256=9v09F2-2sU5ppIlgJUF1YNlUZzExd7l5436tFb5Mpsc,11325
-quark/app/_task.py,sha256=c0o-kmk0hIBEza8NmDME6copp_NAM6HGEAKb1wY_Kx0,9888
+quark/app/_task.py,sha256=EPBh42l94iOLjkLibvqe1_Sa9GPWaPlZ0NM0YTKpH9A,10163
 quark/app/uapi.py,sha256=KM0KemYqd5E3xkHlgbtqSgoPkO5uFR_oxKxR8WW55p0,6622
-quark/driver/VirtualDevice.py,sha256=ePBTcZKlJpKC4Ojh1QdOfmSJ1G0HgpvpVU-jTV7IY-Y,7528
+quark/driver/VirtualDevice.py,sha256=_1BeaHSuxaF-GmOSxD2NSfKMQPqZ5kOYpPXx7YXf7ds,7738
 quark/driver/__init__.py,sha256=GK94J6OicjDBhCWIMvQCZ7s9wpRg6Fh0gt2titR63AU,1325
-quark/driver/common/__init__.py,sha256=Z_DQzH9A4XxzFPt049Ly6Pz371zkT9NDuXXw2XD67WE,1386
+quark/driver/common/__init__.py,sha256=-d_VlquEGycYbTdVOBd5kfdltFUPjFT6qJ_apRueaRA,1418
 quark/driver/common/basedriver.py,sha256=Y3n62UxRu4Tsy07sEyK2bdvr9YUNi5WKsrIonjL02c0,5384
 quark/driver/common/quantity.py,sha256=_SaUpPKrIdkzr0yBntWG8Kwk3v6w0pwy7YcPIfCIgtA,5856
 quark/driver/common/visadriver.py,sha256=HTQLbgGpx8iJCu2tZS_GLFWSbCYoGzzGgdy0MTcT7ds,6473
 quark/envelope/__init__.py,sha256=CcQ78Uz8lpCIUsJgJIfMT983js_D9l-_kVYsuQG3B1s,2194
-quark/envelope/assembler.py,sha256=xI8hN1Vol_YVzYN3wPde6avbFLz20WNIm9KrdQnm0Qk,15109
-quark/envelope/calculator.py,sha256=btrTYQLGwSXrSIjc_EU6TAKdac17M8ztjl7wcGFzjQA,5245
-quark/envelope/device.py,sha256=caTghDhh-doUrKMUplW4bTO8OK6M-scvZJo8MD-S5iY,1984
-quark/envelope/processor.py,sha256=xb2qBF9ZY12y-CeUgFFLrMSpuerwJYsKC619YLu3-0s,4689
+quark/envelope/assembler.py,sha256=CoIN7ActxlLCx7PkOAzmTaOo64LMuqfZBbcmLm1fPAU,15508
+quark/envelope/calculator.py,sha256=-e51BWg3R3BserYS3cv5192HaIKJigvNDzb_4YgIq7A,5402
+quark/envelope/device.py,sha256=hW9vNW9qFdfVMS3OSQ-NhCitgqK9GueB3kxRL4YRUKY,2035
+quark/envelope/processor.py,sha256=g6Q8fVoMyB8S65ubiMUJ_sX3wv6J8XYgeNtfqrF1eKA,4799
 quark/envelope/router.py,sha256=PaH8POWgRfCUUqRTiGEb0lsn5ntp1TnF30oljkWA1ys,5216
 quark/envelope/systemq.py,sha256=M15zb_gXG_fZR3c-ZiUTPMwParVJQg5gbOyJx3lfbv4,3812
-vios-2.4.2.dist-info/LICENSE,sha256=_lj6hFgaA-HA_kybcTr1ahdMp9VPeqEIJnOT8RbwOTg,1064
-vios-2.4.2.dist-info/METADATA,sha256=JZ8QAtusLZbO6wlTbDdhhL936fYrho2AwWiqZ_EMfzA,2432
-vios-2.4.2.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-vios-2.4.2.dist-info/top_level.txt,sha256=7SspgYXMW_50_NVkPj0EbFg4jFlGVsaIDfpqNsA1IMY,6
-vios-2.4.2.dist-info/RECORD,,
+vios-2.4.3.dist-info/LICENSE,sha256=kYK8AINBBnuUY-tXKz9wHOoNoLzg9ZmAAYbM82WJykE,1084
+vios-2.4.3.dist-info/METADATA,sha256=ITwBySmQ26EkFxoisXcetpmQehlkQhuaxjuYBOndMuo,2436
+vios-2.4.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+vios-2.4.3.dist-info/top_level.txt,sha256=7SspgYXMW_50_NVkPj0EbFg4jFlGVsaIDfpqNsA1IMY,6
+vios-2.4.3.dist-info/RECORD,,
```

