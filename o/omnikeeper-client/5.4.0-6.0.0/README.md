# Comparing `tmp/omnikeeper_client-5.4.0-py3-none-any.whl.zip` & `tmp/omnikeeper_client-6.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 22626 bytes, number of entries: 17
--rw-r--r--  2.0 unx     1344 b- defN 24-May-21 09:11 omnikeeper_client/__init__.py
--rw-r--r--  2.0 unx     1984 b- defN 24-Mar-14 11:13 omnikeeper_client/apiclient.py
--rw-r--r--  2.0 unx     5040 b- defN 24-Feb-06 12:05 omnikeeper_client/ci.py
--rw-r--r--  2.0 unx     3796 b- defN 24-Apr-04 07:13 omnikeeper_client/dataframes.py
--rw-r--r--  2.0 unx     1080 b- defN 24-May-21 09:14 omnikeeper_client/issues.py
--rw-r--r--  2.0 unx     3232 b- defN 24-Feb-06 12:05 omnikeeper_client/layer.py
--rw-r--r--  2.0 unx     2765 b- defN 24-Apr-05 10:02 omnikeeper_client/pyd.py
--rw-r--r--  2.0 unx    10639 b- defN 24-Apr-04 07:14 omnikeeper_client/simple_traits.py
--rw-r--r--  2.0 unx     4574 b- defN 24-Apr-04 07:13 omnikeeper_client/trait.py
--rw-r--r--  2.0 unx    24876 b- defN 24-May-21 09:14 omnikeeper_client/traitentities.py
--rw-r--r--  2.0 unx     5262 b- defN 24-Feb-06 12:05 omnikeeper_client/typing.py
--rw-r--r--  2.0 unx      917 b- defN 24-Feb-06 12:05 omnikeeper_client/util.py
--rw-r--r--  2.0 unx    11357 b- defN 24-May-21 09:15 omnikeeper_client-5.4.0.dist-info/LICENSE
--rw-r--r--  2.0 unx      572 b- defN 24-May-21 09:15 omnikeeper_client-5.4.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-May-21 09:15 omnikeeper_client-5.4.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       18 b- defN 24-May-21 09:15 omnikeeper_client-5.4.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1457 b- defN 24-May-21 09:15 omnikeeper_client-5.4.0.dist-info/RECORD
-17 files, 79005 bytes uncompressed, 20222 bytes compressed:  74.4%
+Zip file size: 23085 bytes, number of entries: 17
+-rw-rw-rw-  2.0 fat     1415 b- defN 24-May-21 12:56 omnikeeper_client/__init__.py
+-rw-rw-rw-  2.0 fat     2045 b- defN 24-May-21 12:56 omnikeeper_client/apiclient.py
+-rw-rw-rw-  2.0 fat     5211 b- defN 24-May-21 12:56 omnikeeper_client/ci.py
+-rw-rw-rw-  2.0 fat     3907 b- defN 24-May-21 12:56 omnikeeper_client/dataframes.py
+-rw-rw-rw-  2.0 fat     1206 b- defN 24-May-22 07:59 omnikeeper_client/issues.py
+-rw-rw-rw-  2.0 fat     3354 b- defN 24-May-21 12:56 omnikeeper_client/layer.py
+-rw-rw-rw-  2.0 fat     2854 b- defN 24-May-21 12:56 omnikeeper_client/pyd.py
+-rw-rw-rw-  2.0 fat    10855 b- defN 24-May-21 12:56 omnikeeper_client/simple_traits.py
+-rw-rw-rw-  2.0 fat     4717 b- defN 24-May-21 12:56 omnikeeper_client/trait.py
+-rw-rw-rw-  2.0 fat    26923 b- defN 24-May-22 08:02 omnikeeper_client/traitentities.py
+-rw-rw-rw-  2.0 fat     5439 b- defN 24-May-21 12:56 omnikeeper_client/typing.py
+-rw-rw-rw-  2.0 fat      950 b- defN 24-May-21 12:56 omnikeeper_client/util.py
+-rw-rw-rw-  2.0 fat    11558 b- defN 24-May-22 08:07 omnikeeper_client-6.0.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat      543 b- defN 24-May-22 08:07 omnikeeper_client-6.0.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-May-22 08:07 omnikeeper_client-6.0.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       18 b- defN 24-May-22 08:07 omnikeeper_client-6.0.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1457 b- defN 24-May-22 08:07 omnikeeper_client-6.0.0.dist-info/RECORD
+17 files, 82544 bytes uncompressed, 20681 bytes compressed:  74.9%
```

## zipnote {}

```diff
@@ -30,23 +30,23 @@
 
 Filename: omnikeeper_client/typing.py
 Comment: 
 
 Filename: omnikeeper_client/util.py
 Comment: 
 
-Filename: omnikeeper_client-5.4.0.dist-info/LICENSE
+Filename: omnikeeper_client-6.0.0.dist-info/LICENSE
 Comment: 
 
-Filename: omnikeeper_client-5.4.0.dist-info/METADATA
+Filename: omnikeeper_client-6.0.0.dist-info/METADATA
 Comment: 
 
-Filename: omnikeeper_client-5.4.0.dist-info/WHEEL
+Filename: omnikeeper_client-6.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: omnikeeper_client-5.4.0.dist-info/top_level.txt
+Filename: omnikeeper_client-6.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: omnikeeper_client-5.4.0.dist-info/RECORD
+Filename: omnikeeper_client-6.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## omnikeeper_client/__init__.py

 * *Ordering differences only*

```diff
@@ -1,72 +1,72 @@
-from .apiclient import (
-    OkApiClient
-)
-
-from .layer import (
-    create_layer,
-    update_layerdata,
-    truncate_layer,
-)
-
-from .ci import (
-    create_ci,
-    get_attributes_of_cis,
-    get_attributes_of_ci,
-    mutate_ci,
-    mutate_cis,
-)
-
-from .trait import (
-    upsert_trait,
-    delete_trait,
-    check_trait,
-
-    TraitDefinition,
-    TraitAttributeDefinition,
-    TraitRelationDefinition
-)
-
-# import util
-from .util import (
-    hex_string_to_rgb_color,
-)
-
-from .typing import (
-    ATTRIBUTETYPE_TEXT,
-    ATTRIBUTETYPE_MULTILINE_TEXT,
-    ATTRIBUTETYPE_INTEGER,
-    ATTRIBUTETYPE_DOUBLE,
-    ATTRIBUTETYPE_BOOLEAN,
-    ATTRIBUTETYPE_JSON,
-)
-
-from .traitentities import (
-    get_latest_trait_change,
-    get_all_traitentities,
-    get_all_traitentity_relations,
-    set_traitentity_relations,
-    bulk_replace_trait_entities,
-    bulk_replace_trait_entities_by_filter,
-    bulk_replace_traitentity_relations,
-    OKEntityList,
-    OKRelationList
-)
-
-from .dataframes import (
-    get_all_traitentities_dataframe,
-    bulk_replace_trait_entities_dataframe,
-    bulk_replace_trait_entities_by_filter_dataframe,
-)
-
-from .pyd import (
-    SerializableUUID,
-    AttributeName,
-    AttributeOptional,
-    TypeHint,
-    get_all_traitentities_pydantic,
-    bulk_replace_trait_entities_pydantic
-)
-
-from .issues import (
-    OKIssueList,
+from .apiclient import (
+    OkApiClient
+)
+
+from .layer import (
+    create_layer,
+    update_layerdata,
+    truncate_layer,
+)
+
+from .ci import (
+    create_ci,
+    get_attributes_of_cis,
+    get_attributes_of_ci,
+    mutate_ci,
+    mutate_cis,
+)
+
+from .trait import (
+    upsert_trait,
+    delete_trait,
+    check_trait,
+
+    TraitDefinition,
+    TraitAttributeDefinition,
+    TraitRelationDefinition
+)
+
+# import util
+from .util import (
+    hex_string_to_rgb_color,
+)
+
+from .typing import (
+    ATTRIBUTETYPE_TEXT,
+    ATTRIBUTETYPE_MULTILINE_TEXT,
+    ATTRIBUTETYPE_INTEGER,
+    ATTRIBUTETYPE_DOUBLE,
+    ATTRIBUTETYPE_BOOLEAN,
+    ATTRIBUTETYPE_JSON,
+)
+
+from .traitentities import (
+    get_latest_trait_change,
+    get_all_traitentities,
+    get_all_traitentity_relations,
+    set_traitentity_relations,
+    bulk_replace_trait_entities,
+    bulk_replace_trait_entities_by_filter,
+    bulk_replace_traitentity_relations,
+    OKEntityList,
+    OKRelationList
+)
+
+from .dataframes import (
+    get_all_traitentities_dataframe,
+    bulk_replace_trait_entities_dataframe,
+    bulk_replace_trait_entities_by_filter_dataframe,
+)
+
+from .pyd import (
+    SerializableUUID,
+    AttributeName,
+    AttributeOptional,
+    TypeHint,
+    get_all_traitentities_pydantic,
+    bulk_replace_trait_entities_pydantic
+)
+
+from .issues import (
+    OKIssueList,
 )
```

## omnikeeper_client/apiclient.py

 * *Ordering differences only*

```diff
@@ -1,62 +1,62 @@
-
-from gql import gql, Client as GqlClient
-from graphql import DocumentNode
-from gql.transport.requests import RequestsHTTPTransport
-
-import oauthlib_sessionhandler
-
-from typing import (
-    Any,
-    Dict,
-    Optional, Union
-)
-
-class OkApiClient():
-    # TODO doc class
-
-    def __init__(self,
-                 backend_url : str,
-
-                 client_id : str = None,
-                 client_secret : str = None,
-                 username : str = None,
-                 password : str = None,
-
-                ) -> None:
-        
-        self._backend_url = backend_url
-        self._client_id = client_id
-        self._client_secret = client_secret
-        self._username = username
-        self._password = password
-
-        self._use_auth = False
-        self._oash = None
-        if self._client_id is not None:
-            self._use_auth = True
-            self._oash = oauthlib_sessionhandler.OAuthLibSessionHandler(
-                wellknown_url=f"{self._backend_url}/.well-known/openid-configuration",
-                client_id=self._client_id,
-                client_secret=self._client_secret,
-                username=self._username,
-                password=self._password,
-            )
-
-        self.graphql_url = f"{self._backend_url}/graphql"
-
-    def _get_graphql_client(self) -> GqlClient:
-        headers={}
-        if self._use_auth:
-            headers['Authorization'] = f"Bearer {self._oash.get_accesstoken()}"
-
-        transport = RequestsHTTPTransport(url=self.graphql_url, headers=headers, verify=True)
-        return GqlClient(transport=transport, fetch_schema_from_transport=True)
-    
-    # TODO doc at least public functions
-    def execute_graphql(self, query: Union[str, DocumentNode], variables: Optional[Dict[str, Any]] = None):
-        client = self._get_graphql_client()
-        
-        prepared_query = gql(query) if query is str else query
-        data = client.execute(prepared_query, variable_values=variables)
-        
+
+from gql import gql, Client as GqlClient
+from graphql import DocumentNode
+from gql.transport.requests import RequestsHTTPTransport
+
+import oauthlib_sessionhandler
+
+from typing import (
+    Any,
+    Dict,
+    Optional, Union
+)
+
+class OkApiClient():
+    # TODO doc class
+
+    def __init__(self,
+                 backend_url : str,
+
+                 client_id : str = None,
+                 client_secret : str = None,
+                 username : str = None,
+                 password : str = None,
+
+                ) -> None:
+        
+        self._backend_url = backend_url
+        self._client_id = client_id
+        self._client_secret = client_secret
+        self._username = username
+        self._password = password
+
+        self._use_auth = False
+        self._oash = None
+        if self._client_id is not None:
+            self._use_auth = True
+            self._oash = oauthlib_sessionhandler.OAuthLibSessionHandler(
+                wellknown_url=f"{self._backend_url}/.well-known/openid-configuration",
+                client_id=self._client_id,
+                client_secret=self._client_secret,
+                username=self._username,
+                password=self._password,
+            )
+
+        self.graphql_url = f"{self._backend_url}/graphql"
+
+    def _get_graphql_client(self) -> GqlClient:
+        headers={}
+        if self._use_auth:
+            headers['Authorization'] = f"Bearer {self._oash.get_accesstoken()}"
+
+        transport = RequestsHTTPTransport(url=self.graphql_url, headers=headers, verify=True)
+        return GqlClient(transport=transport, fetch_schema_from_transport=True)
+    
+    # TODO doc at least public functions
+    def execute_graphql(self, query: Union[str, DocumentNode], variables: Optional[Dict[str, Any]] = None):
+        client = self._get_graphql_client()
+        
+        prepared_query = gql(query) if query is str else query
+        data = client.execute(prepared_query, variable_values=variables)
+        
         return data
```

## omnikeeper_client/ci.py

 * *Ordering differences only*

```diff
@@ -1,172 +1,172 @@
-import omnikeeper_client as okc
-import omnikeeper_client.typing as okc_typing
-import omnikeeper_client.util as okc_util
-
-from gql import gql
-from gql.transport.exceptions import (
-    TransportQueryError,
-)
-
-import uuid
-
-from typing import (
-    Dict,
-    List,
-    Any,
-    Optional,
-)
-
-
-def create_ci(ok_api_client: okc.OkApiClient, ci_name: Optional[str] = None, layer_id_for_ci_name: Optional[str] = None, ciid: Optional[uuid.UUID] = None) -> uuid.UUID:
-    """creates a ci with _name attribute in specifed layer. 
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    ci_name : Optional[str]
-        name of the ci, means _name attribute
-
-    layer_id_for_ci_name : Optional[str]
-        id of layer to store _name attribute
-
-    ciid: Optional[uuid.UUID]
-        optional client-provided ciid 
-
-    Returns
-    -------
-    uuid.UUID
-        uuid of inserted CI or None if something fails
-    """
-
-    query = gql("""
-    mutation($name: String, $layerIDForName: String, $ciid: Guid) {
-        createCIs(cis: [{name: $name, layerIDForName: $layerIDForName, ciid: $ciid}]) {
-            ciids
-        }
-    }""")
-    
-    result = ok_api_client.execute_graphql(query, variables=dict(
-            name=ci_name, layerIDForName=layer_id_for_ci_name, ciid=ciid
-    ))
-    return uuid.UUID(result["createCIs"]['ciids'][0])
-
-def mutate_ci(ok_api_client: okc.OkApiClient, write_layer_id: str, ciid : uuid.UUID, attribute_upserts: Dict[str, Any]) -> bool:
-    return mutate_cis(ok_api_client, write_layer_id, {ciid: attribute_upserts})
-
-def mutate_cis(ok_api_client: okc.OkApiClient, write_layer_id: str, attribute_upserts: Dict[str, Dict[str, Any]]) -> bool:
-    # TODO doc
-
-    insertAttributes = []
-    for ciid, attributes in attribute_upserts.items():
-        # TODO add hinting
-        insertAttributes += okc_typing.dict_to_attributes(ciid, attributes)
-
-    # print(okc_util.json_pretty(insertAttributes))
-
-    query = gql("""
-    mutation ($writeLayer: String!, $readLayers: [String]!, $insertAttributes: [InsertCIAttributeInputType], $removeAttributes: [RemoveCIAttributeInputType], $insertRelations: [InsertRelationInputType], $removeRelations: [RemoveRelationInputType]) {
-        mutateCIs(
-            writeLayer: $writeLayer
-            readLayers: $readLayers
-            insertAttributes: $insertAttributes
-            removeAttributes: $removeAttributes
-            insertRelations: $insertRelations
-            removeRelations: $removeRelations
-        ) {
-            affectedCIs {
-                id
-            }
-        }
-    }""")
-    
-    try:
-        
-        result = ok_api_client.execute_graphql(query, variables=dict(
-            writeLayer=write_layer_id, readLayers=[write_layer_id], insertAttributes=insertAttributes
-        ))
-
-        return result
-    
-    except TransportQueryError as e:
-        print(e)
-        return False  
-
-def get_attributes_of_ci(ok_api_client: okc.OkApiClient, layer_ids: List[str], ciid: uuid.UUID) -> Dict:
-    """fetches all attributes of a single ci
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    layer_ids : List[str]
-        ids of layers to include in attributes from
-
-    ciid : uuid.UUID
-        ciid to fetch
-
-    Returns
-    -------
-    Dict
-        dict of attributes, empty dict if ci contains no attributes
-    """
-        
-    return get_attributes_of_cis(ok_api_client, layer_ids, ciids=[ciid]).get(str(ciid), {})
-
-def get_attributes_of_cis(ok_api_client: okc.OkApiClient, layer_ids: List[str], ciids: Optional[List[uuid.UUID]] = None) -> Dict[uuid.UUID, Dict]:
-    """fetches all attributes of cis
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    layer_ids : List[str]
-        ids of layers to include in attributes from
-
-    ciids : Optional[List[uuid.UUID]]
-        ciids to fetch, if omitted return all CIs
-
-    Returns
-    -------
-    Dict[uuid.UUID, Dict]
-        dictionary of CIs with dict of attributes
-    """
-
-
-
-    query = gql("""
-    query ($layers: [String]!, $ciids: [Guid]) {
-        cis(layers: $layers, ciids: $ciids) {
-            id
-            mergedAttributes {
-                attribute {
-                    name
-                    value {
-                        type
-                        isArray
-                        values
-                    }
-                }
-            }
-        }
-    }""")
-   
-    try:
-        ciids_query = None
-        if ciids is not None:
-            ciids_query = list(map(lambda ciid: str(ciid), ciids))
-        
-        result = ok_api_client.execute_graphql(query, variables=dict(layers=layer_ids, ciids=ciids_query))
-
-        cis = {ci['id']: 
-               okc_typing.attributes_to_dict(ci['mergedAttributes']) 
-
-               for ci in result['cis']}
-
-        return cis
-    
-    except TransportQueryError as e:
+import omnikeeper_client as okc
+import omnikeeper_client.typing as okc_typing
+import omnikeeper_client.util as okc_util
+
+from gql import gql
+from gql.transport.exceptions import (
+    TransportQueryError,
+)
+
+import uuid
+
+from typing import (
+    Dict,
+    List,
+    Any,
+    Optional,
+)
+
+
+def create_ci(ok_api_client: okc.OkApiClient, ci_name: Optional[str] = None, layer_id_for_ci_name: Optional[str] = None, ciid: Optional[uuid.UUID] = None) -> uuid.UUID:
+    """creates a ci with _name attribute in specifed layer. 
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    ci_name : Optional[str]
+        name of the ci, means _name attribute
+
+    layer_id_for_ci_name : Optional[str]
+        id of layer to store _name attribute
+
+    ciid: Optional[uuid.UUID]
+        optional client-provided ciid 
+
+    Returns
+    -------
+    uuid.UUID
+        uuid of inserted CI or None if something fails
+    """
+
+    query = gql("""
+    mutation($name: String, $layerIDForName: String, $ciid: Guid) {
+        createCIs(cis: [{name: $name, layerIDForName: $layerIDForName, ciid: $ciid}]) {
+            ciids
+        }
+    }""")
+    
+    result = ok_api_client.execute_graphql(query, variables=dict(
+            name=ci_name, layerIDForName=layer_id_for_ci_name, ciid=ciid
+    ))
+    return uuid.UUID(result["createCIs"]['ciids'][0])
+
+def mutate_ci(ok_api_client: okc.OkApiClient, write_layer_id: str, ciid : uuid.UUID, attribute_upserts: Dict[str, Any]) -> bool:
+    return mutate_cis(ok_api_client, write_layer_id, {ciid: attribute_upserts})
+
+def mutate_cis(ok_api_client: okc.OkApiClient, write_layer_id: str, attribute_upserts: Dict[str, Dict[str, Any]]) -> bool:
+    # TODO doc
+
+    insertAttributes = []
+    for ciid, attributes in attribute_upserts.items():
+        # TODO add hinting
+        insertAttributes += okc_typing.dict_to_attributes(ciid, attributes)
+
+    # print(okc_util.json_pretty(insertAttributes))
+
+    query = gql("""
+    mutation ($writeLayer: String!, $readLayers: [String]!, $insertAttributes: [InsertCIAttributeInputType], $removeAttributes: [RemoveCIAttributeInputType], $insertRelations: [InsertRelationInputType], $removeRelations: [RemoveRelationInputType]) {
+        mutateCIs(
+            writeLayer: $writeLayer
+            readLayers: $readLayers
+            insertAttributes: $insertAttributes
+            removeAttributes: $removeAttributes
+            insertRelations: $insertRelations
+            removeRelations: $removeRelations
+        ) {
+            affectedCIs {
+                id
+            }
+        }
+    }""")
+    
+    try:
+        
+        result = ok_api_client.execute_graphql(query, variables=dict(
+            writeLayer=write_layer_id, readLayers=[write_layer_id], insertAttributes=insertAttributes
+        ))
+
+        return result
+    
+    except TransportQueryError as e:
+        print(e)
+        return False  
+
+def get_attributes_of_ci(ok_api_client: okc.OkApiClient, layer_ids: List[str], ciid: uuid.UUID) -> Dict:
+    """fetches all attributes of a single ci
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    layer_ids : List[str]
+        ids of layers to include in attributes from
+
+    ciid : uuid.UUID
+        ciid to fetch
+
+    Returns
+    -------
+    Dict
+        dict of attributes, empty dict if ci contains no attributes
+    """
+        
+    return get_attributes_of_cis(ok_api_client, layer_ids, ciids=[ciid]).get(str(ciid), {})
+
+def get_attributes_of_cis(ok_api_client: okc.OkApiClient, layer_ids: List[str], ciids: Optional[List[uuid.UUID]] = None) -> Dict[uuid.UUID, Dict]:
+    """fetches all attributes of cis
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    layer_ids : List[str]
+        ids of layers to include in attributes from
+
+    ciids : Optional[List[uuid.UUID]]
+        ciids to fetch, if omitted return all CIs
+
+    Returns
+    -------
+    Dict[uuid.UUID, Dict]
+        dictionary of CIs with dict of attributes
+    """
+
+
+
+    query = gql("""
+    query ($layers: [String]!, $ciids: [Guid]) {
+        cis(layers: $layers, ciids: $ciids) {
+            id
+            mergedAttributes {
+                attribute {
+                    name
+                    value {
+                        type
+                        isArray
+                        values
+                    }
+                }
+            }
+        }
+    }""")
+   
+    try:
+        ciids_query = None
+        if ciids is not None:
+            ciids_query = list(map(lambda ciid: str(ciid), ciids))
+        
+        result = ok_api_client.execute_graphql(query, variables=dict(layers=layer_ids, ciids=ciids_query))
+
+        cis = {ci['id']: 
+               okc_typing.attributes_to_dict(ci['mergedAttributes']) 
+
+               for ci in result['cis']}
+
+        return cis
+    
+    except TransportQueryError as e:
         return False
```

## omnikeeper_client/dataframes.py

 * *Ordering differences only*

```diff
@@ -1,112 +1,112 @@
-import omnikeeper_client as okc
-import pandas as pd
-from .traitentities import (
-    _get_all_traitentities,
-    _bulk_replace_trait_entities_by_filter,
-    _bulk_replace_trait_entities,
-)
-from typing import (
-    List,
-)
-
-def get_all_traitentities_dataframe(ok_api_client: okc.OkApiClient, trait_name: str, layers: List[str], keep_ciid_as_column: bool = False) -> pd.DataFrame:
-    """
-    Returns all traitentites as pandas dataframe 
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_name : str
-        the name of the trait to query the data
-
-    layers : [str]
-        list containing layer_ids to search
-
-    Returns
-    -------
-    pd.DataFrame
-        result containing all traitentites in pandas dataframe format
-    """
-
-    data_list = _get_all_traitentities(ok_api_client, trait_id=trait_name, layers=layers)
-    data_df = pd.DataFrame(data_list)
-    data_df.set_index('ciid', inplace=True, drop=not keep_ciid_as_column)
-
-    return data_df
-
-def bulk_replace_trait_entities_by_filter_dataframe(ok_api_client: okc.OkApiClient, trait_name: str, input: pd.DataFrame, id_attributes: List[str], id_relations: List[str], write_layer: str, read_layers: List[str] = None, filter: object = {}) -> bool:
-    """
-    Replaces all traitentites in a layer input data is a dataframe, it can use a filter when updating the traitentities,
-    this will also delete all old trait entities, if there are any
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_name : str
-        the name of the trait to query the data
-
-    input : pd.DataFrame
-        Trait entities in dataframe format
-
-    id_attributes : [str]
-        attributes to be considered as trait IDs
-    
-    id_relations : [str]
-        ids to be considered as trait relations IDs
-
-    write_layer : str
-        the id of the layer in which the data should be added
-
-    read_layers : [str]
-        A list with ids of the layers in which the omnikeeper will look if the cis already exists
-
-    filter : object
-        a filter object can be used, default {}, example for filter object: {type: {exact: "Validator"}, context: {exact: "test"}, group: {exact: "test"} }
-
-    Returns
-    -------
-    bool 
-        True if the update is successful, False otherwise
-    """
-
-    input_as_dict = input.to_dict('records')
-    result = _bulk_replace_trait_entities_by_filter(ok_api_client, trait_name, input_as_dict, id_attributes, id_relations, write_layer, read_layers, filter)
-    return result
-
-def bulk_replace_trait_entities_dataframe(ok_api_client: okc.OkApiClient, trait_name: str, input: pd.DataFrame, write_layer: str, read_layers: List[str] = None) -> bool:
-    """
-    Sets all traitentities, the input is a pd.DataFrame, this will also delete all old trait entities, if there are any
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_name : str
-        the name of the trait to query the data
-
-    input : pd.DataFrame
-        traitentities in dataframe format
-
-    write_layer : str
-        the id of the layer in which the data should be added
-
-    read_layers : [str]
-        A list with ids of the layers in which the omnikeeper will look if the cis already exists
-
-    Returns
-    -------
-    bool 
-        True if the update is successful, False otherwise
-    """
-
-    if 'ciid' not in input.columns:
-        input = input.reset_index(drop=False).rename(columns={'index': 'ciid'})
-    input_as_dict = input.to_dict('records')
-
-    result = _bulk_replace_trait_entities(ok_api_client, trait_name, input_as_dict, write_layer, read_layers)
+import omnikeeper_client as okc
+import pandas as pd
+from .traitentities import (
+    _get_all_traitentities,
+    _bulk_replace_trait_entities_by_filter,
+    _bulk_replace_trait_entities,
+)
+from typing import (
+    List,
+)
+
+def get_all_traitentities_dataframe(ok_api_client: okc.OkApiClient, trait_name: str, layers: List[str], keep_ciid_as_column: bool = False) -> pd.DataFrame:
+    """
+    Returns all traitentites as pandas dataframe 
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_name : str
+        the name of the trait to query the data
+
+    layers : [str]
+        list containing layer_ids to search
+
+    Returns
+    -------
+    pd.DataFrame
+        result containing all traitentites in pandas dataframe format
+    """
+
+    data_list = _get_all_traitentities(ok_api_client, trait_id=trait_name, layers=layers)
+    data_df = pd.DataFrame(data_list)
+    data_df.set_index('ciid', inplace=True, drop=not keep_ciid_as_column)
+
+    return data_df
+
+def bulk_replace_trait_entities_by_filter_dataframe(ok_api_client: okc.OkApiClient, trait_name: str, input: pd.DataFrame, id_attributes: List[str], id_relations: List[str], write_layer: str, read_layers: List[str] = None, filter: object = {}) -> bool:
+    """
+    Replaces all traitentites in a layer input data is a dataframe, it can use a filter when updating the traitentities,
+    this will also delete all old trait entities, if there are any
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_name : str
+        the name of the trait to query the data
+
+    input : pd.DataFrame
+        Trait entities in dataframe format
+
+    id_attributes : [str]
+        attributes to be considered as trait IDs
+    
+    id_relations : [str]
+        ids to be considered as trait relations IDs
+
+    write_layer : str
+        the id of the layer in which the data should be added
+
+    read_layers : [str]
+        A list with ids of the layers in which the omnikeeper will look if the cis already exists
+
+    filter : object
+        a filter object can be used, default {}, example for filter object: {type: {exact: "Validator"}, context: {exact: "test"}, group: {exact: "test"} }
+
+    Returns
+    -------
+    bool 
+        True if the update is successful, False otherwise
+    """
+
+    input_as_dict = input.to_dict('records')
+    result = _bulk_replace_trait_entities_by_filter(ok_api_client, trait_name, input_as_dict, id_attributes, id_relations, write_layer, read_layers, filter)
+    return result
+
+def bulk_replace_trait_entities_dataframe(ok_api_client: okc.OkApiClient, trait_name: str, input: pd.DataFrame, write_layer: str, read_layers: List[str] = None) -> bool:
+    """
+    Sets all traitentities, the input is a pd.DataFrame, this will also delete all old trait entities, if there are any
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_name : str
+        the name of the trait to query the data
+
+    input : pd.DataFrame
+        traitentities in dataframe format
+
+    write_layer : str
+        the id of the layer in which the data should be added
+
+    read_layers : [str]
+        A list with ids of the layers in which the omnikeeper will look if the cis already exists
+
+    Returns
+    -------
+    bool 
+        True if the update is successful, False otherwise
+    """
+
+    if 'ciid' not in input.columns:
+        input = input.reset_index(drop=False).rename(columns={'index': 'ciid'})
+    input_as_dict = input.to_dict('records')
+
+    result = _bulk_replace_trait_entities(ok_api_client, trait_name, input_as_dict, write_layer, read_layers)
     return result
```

## omnikeeper_client/issues.py

```diff
@@ -1,24 +1,26 @@
-from typing import List
-import omnikeeper_client as okc
-
-class OKIssueList:
-    def __init__(self, context: str):
-        self.context = context
-        self.issues = []
-
-    def add(self, group: str, id: str, message: str, affected_cis: List[str] = [], type: str = 'ComputeLayerBrain'):
-        self.issues.append({
-            'type': type,
-            'context': self.context,
-            'group': group,
-            'id': id,
-            'message': message,
-            'affectedCIs': affected_cis,
-            'name': f"OK-Issue - {type}_{self.context}_{group}_{id}", # TODO: ensure its the same as C# internal variant
-        })
-
-    def write(self, okapiclient: okc.OkApiClient) -> bool:
-        return okc.bulk_replace_trait_entities_by_filter(okapiclient, '__meta.issue.issue', self.issues, 
-                                                  id_attributes=['type', 'group', 'id'], id_relations=[],
-                                                  write_layer="__okissues", 
-                                                  filter={'context': {'exact': self.context} })
+from typing import List
+import omnikeeper_client as okc
+
+class OKIssueList:
+    def __init__(self, context: str):
+        self.context = context
+        self.issues = {} # NOTE: using dict ensures we have no duplicates
+
+    def add(self, group: str, id: str, message: str, affected_cis: List[str] = [], type: str = 'ComputeLayerBrain'):
+        key = (type, group, id)
+        self.issues[key] = {
+            'type': type,
+            'context': self.context,
+            'group': group,
+            'id': id,
+            'message': message,
+            'affectedCIs': affected_cis,
+            'name': f"OK-Issue - {type}_{self.context}_{group}_{id}", # TODO: ensure its the same as C# internal variant
+        }
+
+    def write(self, okapiclient: okc.OkApiClient) -> bool:
+        return okc.bulk_replace_trait_entities_by_filter(okapiclient, '__meta.issue.issue', list(self.issues.values()), 
+                                                  id_attributes=['type', 'group', 'id'], id_relations=[],
+                                                  write_layer="__okissues", 
+                                                  filter={'context': {'exact': self.context} })
+
```

## omnikeeper_client/layer.py

 * *Ordering differences only*

```diff
@@ -1,123 +1,123 @@
-import omnikeeper_client as okc
-
-from gql import gql
-from gql.transport.exceptions import (
-    TransportQueryError,
-)
-
-def create_layer(ok_api_client: okc.OkApiClient, layer_id: str, description: str = None, argbColor: int = None) -> bool:
-    """creates a layer by specifying layer_id. 
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    layer_id : str
-        id of layer to create, must only contain charaters [A-Za-z_]
-
-    description : str
-        description to set for this layer
-
-    argbColor : int
-        color of layer, see omnikeeperclient.hexString2RGBColor() for more details
-
-    Returns
-    -------
-    bool
-        True, if layer was created or was already present. False, if something fails
-    """
-
-    query = gql("""
-    mutation ($id: String!) {
-        manage_createLayer(id: $id) {
-            id
-        }
-    }""")
-    
-    try:
-        ok_api_client.execute_graphql(query, variables=dict(id=layer_id))
-
-        if description is not None or argbColor is not None:
-            description = description or ""
-            argbColor = argbColor or -1
-            update_layerdata(ok_api_client, layer_id, description, argbColor)
-
-        return True
-    except TransportQueryError as e:
-        return False
-
-def update_layerdata(ok_api_client: okc.OkApiClient, layer_id: str, description: str, argbColor: int) -> bool:
-    """updates attributes of a layer
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    layer_id : str
-        id of layer to mutate, must only contain charaters [A-Za-z_]
-
-    description : str
-        description to set for this layer
-
-    argbColor : int
-        color of layer, see omnikeeperclient.hexString2RGBColor() for more details
-
-
-    Returns
-    -------
-    bool
-        True, if layer was updated. False, if something fails
-    """
-
-
-    query = gql("""
-    mutation ($id: String!, $description: String!, $color: Int!) {
-        manage_upsertLayerData(
-            layer: {id: $id, description: $description, state: ACTIVE, color: $color, generators: []}
-        ) {
-            id
-        }
-    }""")
-
-    try:
-        ok_api_client.execute_graphql(query, variables=dict(
-            id=layer_id,
-            description=description,
-            color=argbColor)
-        )
-        return True
-    except TransportQueryError as e:
-        return False
-    
-def truncate_layer(ok_api_client: okc.OkApiClient, layer_id: str) -> bool:
-    """truncate a layer, removing all attributes and relations on all CIs on that layer
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    layer_id : str
-        id of layer to truncate
-
-    Returns
-    -------
-    bool
-        True, if layer was truncated. False, if something fails
-    """
-
-    query = gql("""
-    mutation ($id: String!) {
-        manage_truncateLayer(id: $id)
-    }
-    """)
-
-    try:
-        ok_api_client.execute_graphql(query, variables=dict(
-            id=layer_id,
-        ))
-        return True
-    except TransportQueryError as e:
+import omnikeeper_client as okc
+
+from gql import gql
+from gql.transport.exceptions import (
+    TransportQueryError,
+)
+
+def create_layer(ok_api_client: okc.OkApiClient, layer_id: str, description: str = None, argbColor: int = None) -> bool:
+    """creates a layer by specifying layer_id. 
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    layer_id : str
+        id of layer to create, must only contain charaters [A-Za-z_]
+
+    description : str
+        description to set for this layer
+
+    argbColor : int
+        color of layer, see omnikeeperclient.hexString2RGBColor() for more details
+
+    Returns
+    -------
+    bool
+        True, if layer was created or was already present. False, if something fails
+    """
+
+    query = gql("""
+    mutation ($id: String!) {
+        manage_createLayer(id: $id) {
+            id
+        }
+    }""")
+    
+    try:
+        ok_api_client.execute_graphql(query, variables=dict(id=layer_id))
+
+        if description is not None or argbColor is not None:
+            description = description or ""
+            argbColor = argbColor or -1
+            update_layerdata(ok_api_client, layer_id, description, argbColor)
+
+        return True
+    except TransportQueryError as e:
+        return False
+
+def update_layerdata(ok_api_client: okc.OkApiClient, layer_id: str, description: str, argbColor: int) -> bool:
+    """updates attributes of a layer
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    layer_id : str
+        id of layer to mutate, must only contain charaters [A-Za-z_]
+
+    description : str
+        description to set for this layer
+
+    argbColor : int
+        color of layer, see omnikeeperclient.hexString2RGBColor() for more details
+
+
+    Returns
+    -------
+    bool
+        True, if layer was updated. False, if something fails
+    """
+
+
+    query = gql("""
+    mutation ($id: String!, $description: String!, $color: Int!) {
+        manage_upsertLayerData(
+            layer: {id: $id, description: $description, state: ACTIVE, color: $color, generators: []}
+        ) {
+            id
+        }
+    }""")
+
+    try:
+        ok_api_client.execute_graphql(query, variables=dict(
+            id=layer_id,
+            description=description,
+            color=argbColor)
+        )
+        return True
+    except TransportQueryError as e:
+        return False
+    
+def truncate_layer(ok_api_client: okc.OkApiClient, layer_id: str) -> bool:
+    """truncate a layer, removing all attributes and relations on all CIs on that layer
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    layer_id : str
+        id of layer to truncate
+
+    Returns
+    -------
+    bool
+        True, if layer was truncated. False, if something fails
+    """
+
+    query = gql("""
+    mutation ($id: String!) {
+        manage_truncateLayer(id: $id)
+    }
+    """)
+
+    try:
+        ok_api_client.execute_graphql(query, variables=dict(
+            id=layer_id,
+        ))
+        return True
+    except TransportQueryError as e:
         return False
```

## omnikeeper_client/pyd.py

 * *Ordering differences only*

```diff
@@ -1,89 +1,89 @@
-import omnikeeper_client as okc
-from .traitentities import (
-    _get_all_traitentities,
-    _bulk_replace_trait_entities
-)
-from pydantic import BaseModel, TypeAdapter, PlainSerializer
-from typing_extensions import Annotated
-import uuid
-from typing import (
-    List,
-    TypeVar
-)
-
-SerializableUUID = Annotated[uuid.UUID, PlainSerializer(lambda x: str(x), return_type=str)]
-
-# experimental ok trait hints
-class AttributeName:
-    def __init__(self, name: str):
-        self.name = name
-class AttributeOptional:
-    def __init__(self, optional: bool = True):
-        self.optional = optional
-class TypeHint:
-    def __init__(self, type: str, is_array: bool = False):
-        self.type = type
-        self.is_array = is_array
-
-
-T = TypeVar("T", bound=BaseModel)
-
-def get_all_traitentities_pydantic(ok_api_client: okc.OkApiClient, trait_name: str, ta: TypeAdapter, layers: List[str]) -> List[T]:
-    """
-    Returns all traitentites as pydantic objects 
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_name : str
-        the name of the trait to query the data
-
-    ta : TypeAdapter
-        a pydantic Type Adapter for the type List[T] where T is the model's type
-
-    layers : List[str]
-        list containing layer_ids to search
-
-    Returns
-    -------
-    List[T]
-        list of pydantic model objects
-    """
-
-    data = _get_all_traitentities(ok_api_client, trait_id=trait_name, layers=layers)
-    m = ta.validate_python(data, strict=False) # NOTE: consider using strict mode! But UUID matching requires non-strict without further changes
-    return m
-
-
-def bulk_replace_trait_entities_pydantic(ok_api_client: okc.OkApiClient, trait_name: str, input: List[T], write_layer: str, read_layers: List[str] = None) -> bool:
-    """
-    Sets all traitentities, the input is a list of pydantic model objects, this will also delete all old trait entities, if there are any
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_name : str
-        the name of the trait to query the data
-
-    input : List[T]
-        traitentities as a list of pydantic model objects, must contain ciid field
-
-    write_layer : str
-        the id of the layer in which the data should be added
-
-    read_layers : [str]
-        A list with ids of the layers in which the omnikeeper will look if the cis already exists
-
-    Returns
-    -------
-    bool 
-        True if the update is successful, False otherwise
-    """
-
-    input_as_dict = (item.model_dump() for item in input)
-    result = _bulk_replace_trait_entities(ok_api_client, trait_name, input_as_dict, write_layer, read_layers)
-    return result
+import omnikeeper_client as okc
+from .traitentities import (
+    _get_all_traitentities,
+    _bulk_replace_trait_entities
+)
+from pydantic import BaseModel, TypeAdapter, PlainSerializer
+from typing_extensions import Annotated
+import uuid
+from typing import (
+    List,
+    TypeVar
+)
+
+SerializableUUID = Annotated[uuid.UUID, PlainSerializer(lambda x: str(x), return_type=str)]
+
+# experimental ok trait hints
+class AttributeName:
+    def __init__(self, name: str):
+        self.name = name
+class AttributeOptional:
+    def __init__(self, optional: bool = True):
+        self.optional = optional
+class TypeHint:
+    def __init__(self, type: str, is_array: bool = False):
+        self.type = type
+        self.is_array = is_array
+
+
+T = TypeVar("T", bound=BaseModel)
+
+def get_all_traitentities_pydantic(ok_api_client: okc.OkApiClient, trait_name: str, ta: TypeAdapter, layers: List[str]) -> List[T]:
+    """
+    Returns all traitentites as pydantic objects 
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_name : str
+        the name of the trait to query the data
+
+    ta : TypeAdapter
+        a pydantic Type Adapter for the type List[T] where T is the model's type
+
+    layers : List[str]
+        list containing layer_ids to search
+
+    Returns
+    -------
+    List[T]
+        list of pydantic model objects
+    """
+
+    data = _get_all_traitentities(ok_api_client, trait_id=trait_name, layers=layers)
+    m = ta.validate_python(data, strict=False) # NOTE: consider using strict mode! But UUID matching requires non-strict without further changes
+    return m
+
+
+def bulk_replace_trait_entities_pydantic(ok_api_client: okc.OkApiClient, trait_name: str, input: List[T], write_layer: str, read_layers: List[str] = None) -> bool:
+    """
+    Sets all traitentities, the input is a list of pydantic model objects, this will also delete all old trait entities, if there are any
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_name : str
+        the name of the trait to query the data
+
+    input : List[T]
+        traitentities as a list of pydantic model objects, must contain ciid field
+
+    write_layer : str
+        the id of the layer in which the data should be added
+
+    read_layers : [str]
+        A list with ids of the layers in which the omnikeeper will look if the cis already exists
+
+    Returns
+    -------
+    bool 
+        True if the update is successful, False otherwise
+    """
+
+    input_as_dict = (item.model_dump() for item in input)
+    result = _bulk_replace_trait_entities(ok_api_client, trait_name, input_as_dict, write_layer, read_layers)
+    return result
```

## omnikeeper_client/simple_traits.py

 * *Ordering differences only*

```diff
@@ -1,216 +1,216 @@
-from gql import Client, gql
-import pandas as pd
-import graphql
-from graphql import GraphQLType
-from gql.dsl import DSLQuery, DSLVariableDefinitions, DSLSchema, dsl_gql
-from dateutil import parser
-import datetime
-from deprecated import deprecated
-from typing import (
-    List,
-)
-
-@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, if really needed, use  OkApiClient()._is_relation_field()")
-def is_relation_field(type: GraphQLType) -> bool:
-    # a typical relation field looks like this:
-    # GraphQLList <GraphQLObjectType 'TEWrapper_tsa_cmdb__interface'>>
-    # or
-    # GraphQLList <GraphQLObjectType 'RelatedCIType'>
-    if not graphql.type.is_list_type(type):
-        return False
-    list_type = graphql.type.assert_list_type(type)
-    if not graphql.type.is_object_type(list_type.of_type): # TODO: is this enough?
-        return False
-    return True
-
-@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, if really needed, use  OkApiClient()._is_non_trait_hinted_relation_field()")
-def is_non_trait_hinted_relation_field(type: GraphQLType) -> bool:
-    if not graphql.type.is_list_type(type):
-        return False
-    list_type = graphql.type.assert_list_type(type)
-    if not graphql.type.is_object_type(list_type.of_type):
-        return False
-    if list_type.of_type.name != 'RelatedCIType':
-        return False
-    return True
-
-@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, if really needed, use  OkApiClient()._get_escaped_trait_name()")
-def get_escaped_trait_name(name: str) -> str:
-    return str.replace(name, '.', '__')
-
-@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, if really needed, use  OkApiClient()._get_prefixed_trait_name()")
-def get_prefixed_trait_name(name: str) -> str:
-    if name.startswith("_"):
-        return f"m{name}"
-    return name
-
-@deprecated(category=FutureWarning, reason="please use omnikeeper_client public function get_latest_trait_change() instead")
-def get_latest_change_for_all(client: Client, trait_name: str, layers: List[str]) -> datetime.datetime:
-    with client as session:
-        ds = DSLSchema(client.schema)
-
-        escaped_trait_name = get_escaped_trait_name(trait_name)
-        prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
-
-        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_name)
-        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_name}")
-        var = DSLVariableDefinitions()
-        raw_query = DSLQuery(
-                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
-                        tetType.select(
-                            dsl_root_type.latestChangeAll.select(
-                                ds.ChangesetType.timestamp
-                            )
-                        )
-                    )
-                )
-        raw_query.variable_definitions = var
-        query = dsl_gql(raw_query)
-
-        result = session.execute(query, variable_values={"layers": layers})
-
-        timestamp_str = result['traitEntities'][prefixed_escaped_trait_name]['latestChangeAll']['timestamp']
-        timestamp = parser.parse(timestamp_str)
-        return timestamp
-
-@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, use get_all_traitentities_list() if you want to work with list, use get_all_traitentities_dataframe() if you want to work with dataframes")
-def get_all(client: Client, trait_name: str, layers: List[str], keep_ciid_as_column: bool = False) -> pd.DataFrame:
-    with client as session:
-        ds = DSLSchema(client.schema)
-
-        escaped_trait_name = get_escaped_trait_name(trait_name)
-        prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
-
-        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_name)
-        dsl_type = getattr(ds, f"TE_{escaped_trait_name}")
-        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_name}")
-        dsl_wrapper_type = getattr(ds, f"TEWrapper_{escaped_trait_name}")
-        entity_fields = list(map(lambda t: getattr(dsl_type, t[0]), filter(lambda t: not is_relation_field(t[1].type), dsl_type._type.fields.items())))
-
-        var = DSLVariableDefinitions()
-        raw_query = DSLQuery(
-                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
-                        tetType.select(
-                            dsl_root_type.all.select(
-                                dsl_wrapper_type.ciid,
-                                dsl_wrapper_type.entity.select(*entity_fields)
-                            )
-                        )
-                    )
-                )
-        raw_query.variable_definitions = var
-        query = dsl_gql(raw_query)
-
-        result = session.execute(query, variable_values={"layers": layers})
-
-        data_frame = (
-            pd.json_normalize(result['traitEntities'][prefixed_escaped_trait_name]['all'])
-                .set_index('ciid', drop=not keep_ciid_as_column)
-        )
-        data_frame.columns = data_frame.columns.str.removeprefix('entity.')
-
-        return data_frame
-
-@deprecated(category=FutureWarning, reason="please use omnikeeper_client public function get_trait_relation() instead")
-def get_relation(client: Client, trait_name: str, relation_name: str, layers: List[str], keep_ciid_as_column: bool = False) -> pd.DataFrame:
-    with client as session:
-        ds = DSLSchema(client.schema)
-
-        escaped_trait_name = get_escaped_trait_name(trait_name)
-        prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
-
-        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_name)
-        dsl_type = getattr(ds, f"TE_{escaped_trait_name}")
-        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_name}")
-        dsl_wrapper_type = getattr(ds, f"TEWrapper_{escaped_trait_name}")
-        entity_fields = list(map(lambda t: getattr(dsl_type, t[0]).select(ds.RelatedCIType.relatedCIID), filter(lambda t: t[0] == relation_name and is_non_trait_hinted_relation_field(t[1].type), dsl_type._type.fields.items())))
-
-        var = DSLVariableDefinitions()
-        raw_query = DSLQuery(
-                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
-                        tetType.select(
-                            dsl_root_type.all.select(
-                                dsl_wrapper_type.ciid,
-                                dsl_wrapper_type.entity.select(*entity_fields)
-                            )
-                        )
-                    )
-                )
-        raw_query.variable_definitions = var
-        query = dsl_gql(raw_query)
-
-        result = session.execute(query, variable_values={"layers": layers})
-
-        data_frame = (
-            pd.json_normalize(result['traitEntities'][prefixed_escaped_trait_name]['all'])
-                .rename(columns={"ciid": "base_ciid", f'entity.{relation_name}': "related_ciids"})
-                .set_index('base_ciid', drop=not keep_ciid_as_column)
-        )
-        data_frame['related_ciids'] = data_frame['related_ciids'].apply(lambda x: list(map(lambda i: i['relatedCIID'], x)))
-
-        return data_frame
-    
-@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, use bulk_replace_trait_entities_list() if you want to work with list, use bulk_replace_trait_entities_dataframe() if you want to work with dataframes")
-def set_all(client: Client, trait_name: str, input: pd.DataFrame, write_layer: str, read_layers: List[str] = None) -> bool:
-    escaped_trait_name = get_escaped_trait_name(trait_name)
-    prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
-
-    with client as session:
-        query = gql(f"""
-            mutation($readLayers: [String]!, $writeLayer: String!, $input: [TE_CIID_And_Upsert_Attributes_Only_Input_{escaped_trait_name}]!) {{
-            bulkReplace_{prefixed_escaped_trait_name}(
-                layers: $readLayers
-                writeLayer: $writeLayer
-                input: $input
-            ) {{
-                success
-            }}
-            }}
-            """)
-        
-        final_input = list(map(lambda kv: {"ciid": kv[0], "attributes": kv[1]}, input.to_dict('index').items()))
-        
-        if read_layers is None:
-            read_layers = [write_layer]
-        result = session.execute(query, variable_values=dict(
-            writeLayer=write_layer, 
-            readLayers=read_layers, 
-            input=final_input
-            ))
-        return result[f"bulkReplace_{prefixed_escaped_trait_name}"]["success"]
-
-@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, use bulk_replace_trait_entities_by_filter_list() if you want to work with list, use bulk_replace_trait_entities_by_filter_dataframe() if you want to work with dataframes")
-def bulk_replace(client: Client, trait_name: str, input: pd.DataFrame, id_attributes: List[str], id_relations: List[str], write_layer: str, read_layers: List[str] = None, filter: object = {}) -> bool:
-    escaped_trait_name = get_escaped_trait_name(trait_name)
-    prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
-
-    with client as session:
-        # example for filter object: {type: {exact: "Validator"}, context: {exact: "test"}, group: {exact: "test"} }
-        query = gql(f"""
-            mutation($readLayers: [String]!, $writeLayer: String!, $idAttributes: [String!]!, $idRelations: [String!]!, $filter: TE_filter_Input_{escaped_trait_name}!, $input: [TE_Upsert_Input_{escaped_trait_name}]!) {{
-            bulkReplaceByFilter_{prefixed_escaped_trait_name}(
-                layers: $readLayers
-                writeLayer: $writeLayer
-                filter: $filter
-                input: $input
-                idAttributes: $idAttributes
-                idRelations: $idRelations
-            ) {{
-                success
-            }}
-            }}
-            """)
-        
-        final_input = input.to_dict('records')
-        
-        if read_layers is None:
-            read_layers = [write_layer]
-        result = session.execute(query, variable_values=dict(
-            writeLayer=write_layer, 
-            readLayers=read_layers, 
-            idAttributes=id_attributes,
-            idRelations=id_relations,
-            filter=filter,
-            input=final_input
-            ))
-        return result[f"bulkReplaceByFilter_{prefixed_escaped_trait_name}"]["success"]
+from gql import Client, gql
+import pandas as pd
+import graphql
+from graphql import GraphQLType
+from gql.dsl import DSLQuery, DSLVariableDefinitions, DSLSchema, dsl_gql
+from dateutil import parser
+import datetime
+from deprecated import deprecated
+from typing import (
+    List,
+)
+
+@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, if really needed, use  OkApiClient()._is_relation_field()")
+def is_relation_field(type: GraphQLType) -> bool:
+    # a typical relation field looks like this:
+    # GraphQLList <GraphQLObjectType 'TEWrapper_tsa_cmdb__interface'>>
+    # or
+    # GraphQLList <GraphQLObjectType 'RelatedCIType'>
+    if not graphql.type.is_list_type(type):
+        return False
+    list_type = graphql.type.assert_list_type(type)
+    if not graphql.type.is_object_type(list_type.of_type): # TODO: is this enough?
+        return False
+    return True
+
+@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, if really needed, use  OkApiClient()._is_non_trait_hinted_relation_field()")
+def is_non_trait_hinted_relation_field(type: GraphQLType) -> bool:
+    if not graphql.type.is_list_type(type):
+        return False
+    list_type = graphql.type.assert_list_type(type)
+    if not graphql.type.is_object_type(list_type.of_type):
+        return False
+    if list_type.of_type.name != 'RelatedCIType':
+        return False
+    return True
+
+@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, if really needed, use  OkApiClient()._get_escaped_trait_name()")
+def get_escaped_trait_name(name: str) -> str:
+    return str.replace(name, '.', '__')
+
+@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, if really needed, use  OkApiClient()._get_prefixed_trait_name()")
+def get_prefixed_trait_name(name: str) -> str:
+    if name.startswith("_"):
+        return f"m{name}"
+    return name
+
+@deprecated(category=FutureWarning, reason="please use omnikeeper_client public function get_latest_trait_change() instead")
+def get_latest_change_for_all(client: Client, trait_name: str, layers: List[str]) -> datetime.datetime:
+    with client as session:
+        ds = DSLSchema(client.schema)
+
+        escaped_trait_name = get_escaped_trait_name(trait_name)
+        prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
+
+        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_name)
+        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_name}")
+        var = DSLVariableDefinitions()
+        raw_query = DSLQuery(
+                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
+                        tetType.select(
+                            dsl_root_type.latestChangeAll.select(
+                                ds.ChangesetType.timestamp
+                            )
+                        )
+                    )
+                )
+        raw_query.variable_definitions = var
+        query = dsl_gql(raw_query)
+
+        result = session.execute(query, variable_values={"layers": layers})
+
+        timestamp_str = result['traitEntities'][prefixed_escaped_trait_name]['latestChangeAll']['timestamp']
+        timestamp = parser.parse(timestamp_str)
+        return timestamp
+
+@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, use get_all_traitentities_list() if you want to work with list, use get_all_traitentities_dataframe() if you want to work with dataframes")
+def get_all(client: Client, trait_name: str, layers: List[str], keep_ciid_as_column: bool = False) -> pd.DataFrame:
+    with client as session:
+        ds = DSLSchema(client.schema)
+
+        escaped_trait_name = get_escaped_trait_name(trait_name)
+        prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
+
+        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_name)
+        dsl_type = getattr(ds, f"TE_{escaped_trait_name}")
+        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_name}")
+        dsl_wrapper_type = getattr(ds, f"TEWrapper_{escaped_trait_name}")
+        entity_fields = list(map(lambda t: getattr(dsl_type, t[0]), filter(lambda t: not is_relation_field(t[1].type), dsl_type._type.fields.items())))
+
+        var = DSLVariableDefinitions()
+        raw_query = DSLQuery(
+                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
+                        tetType.select(
+                            dsl_root_type.all.select(
+                                dsl_wrapper_type.ciid,
+                                dsl_wrapper_type.entity.select(*entity_fields)
+                            )
+                        )
+                    )
+                )
+        raw_query.variable_definitions = var
+        query = dsl_gql(raw_query)
+
+        result = session.execute(query, variable_values={"layers": layers})
+
+        data_frame = (
+            pd.json_normalize(result['traitEntities'][prefixed_escaped_trait_name]['all'])
+                .set_index('ciid', drop=not keep_ciid_as_column)
+        )
+        data_frame.columns = data_frame.columns.str.removeprefix('entity.')
+
+        return data_frame
+
+@deprecated(category=FutureWarning, reason="please use omnikeeper_client public function get_trait_relation() instead")
+def get_relation(client: Client, trait_name: str, relation_name: str, layers: List[str], keep_ciid_as_column: bool = False) -> pd.DataFrame:
+    with client as session:
+        ds = DSLSchema(client.schema)
+
+        escaped_trait_name = get_escaped_trait_name(trait_name)
+        prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
+
+        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_name)
+        dsl_type = getattr(ds, f"TE_{escaped_trait_name}")
+        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_name}")
+        dsl_wrapper_type = getattr(ds, f"TEWrapper_{escaped_trait_name}")
+        entity_fields = list(map(lambda t: getattr(dsl_type, t[0]).select(ds.RelatedCIType.relatedCIID), filter(lambda t: t[0] == relation_name and is_non_trait_hinted_relation_field(t[1].type), dsl_type._type.fields.items())))
+
+        var = DSLVariableDefinitions()
+        raw_query = DSLQuery(
+                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
+                        tetType.select(
+                            dsl_root_type.all.select(
+                                dsl_wrapper_type.ciid,
+                                dsl_wrapper_type.entity.select(*entity_fields)
+                            )
+                        )
+                    )
+                )
+        raw_query.variable_definitions = var
+        query = dsl_gql(raw_query)
+
+        result = session.execute(query, variable_values={"layers": layers})
+
+        data_frame = (
+            pd.json_normalize(result['traitEntities'][prefixed_escaped_trait_name]['all'])
+                .rename(columns={"ciid": "base_ciid", f'entity.{relation_name}': "related_ciids"})
+                .set_index('base_ciid', drop=not keep_ciid_as_column)
+        )
+        data_frame['related_ciids'] = data_frame['related_ciids'].apply(lambda x: list(map(lambda i: i['relatedCIID'], x)))
+
+        return data_frame
+    
+@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, use bulk_replace_trait_entities_list() if you want to work with list, use bulk_replace_trait_entities_dataframe() if you want to work with dataframes")
+def set_all(client: Client, trait_name: str, input: pd.DataFrame, write_layer: str, read_layers: List[str] = None) -> bool:
+    escaped_trait_name = get_escaped_trait_name(trait_name)
+    prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
+
+    with client as session:
+        query = gql(f"""
+            mutation($readLayers: [String]!, $writeLayer: String!, $input: [TE_CIID_And_Upsert_Attributes_Only_Input_{escaped_trait_name}]!) {{
+            bulkReplace_{prefixed_escaped_trait_name}(
+                layers: $readLayers
+                writeLayer: $writeLayer
+                input: $input
+            ) {{
+                success
+            }}
+            }}
+            """)
+        
+        final_input = list(map(lambda kv: {"ciid": kv[0], "attributes": kv[1]}, input.to_dict('index').items()))
+        
+        if read_layers is None:
+            read_layers = [write_layer]
+        result = session.execute(query, variable_values=dict(
+            writeLayer=write_layer, 
+            readLayers=read_layers, 
+            input=final_input
+            ))
+        return result[f"bulkReplace_{prefixed_escaped_trait_name}"]["success"]
+
+@deprecated(category=FutureWarning, reason="please use omnikeeper_client.* public functions instead, use bulk_replace_trait_entities_by_filter_list() if you want to work with list, use bulk_replace_trait_entities_by_filter_dataframe() if you want to work with dataframes")
+def bulk_replace(client: Client, trait_name: str, input: pd.DataFrame, id_attributes: List[str], id_relations: List[str], write_layer: str, read_layers: List[str] = None, filter: object = {}) -> bool:
+    escaped_trait_name = get_escaped_trait_name(trait_name)
+    prefixed_escaped_trait_name = get_prefixed_trait_name(escaped_trait_name)
+
+    with client as session:
+        # example for filter object: {type: {exact: "Validator"}, context: {exact: "test"}, group: {exact: "test"} }
+        query = gql(f"""
+            mutation($readLayers: [String]!, $writeLayer: String!, $idAttributes: [String!]!, $idRelations: [String!]!, $filter: TE_filter_Input_{escaped_trait_name}!, $input: [TE_Upsert_Input_{escaped_trait_name}]!) {{
+            bulkReplaceByFilter_{prefixed_escaped_trait_name}(
+                layers: $readLayers
+                writeLayer: $writeLayer
+                filter: $filter
+                input: $input
+                idAttributes: $idAttributes
+                idRelations: $idRelations
+            ) {{
+                success
+            }}
+            }}
+            """)
+        
+        final_input = input.to_dict('records')
+        
+        if read_layers is None:
+            read_layers = [write_layer]
+        result = session.execute(query, variable_values=dict(
+            writeLayer=write_layer, 
+            readLayers=read_layers, 
+            idAttributes=id_attributes,
+            idRelations=id_relations,
+            filter=filter,
+            input=final_input
+            ))
+        return result[f"bulkReplaceByFilter_{prefixed_escaped_trait_name}"]["success"]
```

## omnikeeper_client/trait.py

 * *Ordering differences only*

```diff
@@ -1,144 +1,144 @@
-import omnikeeper_client as okc
-import omnikeeper_client.typing as okc_typing
-import omnikeeper_client.util as okc_util
-from gql import gql
-from gql.transport.exceptions import (
-    TransportQueryError,
-)
-from typing import (
-    List,
-)
-
-# NOTE: these classes use camelCase members, so they can be easily encoded for GraphQL using okc_util.to_dict()
-class TraitAttributeDefinition:
-    def __init__(self, identifier: str, name: str, attribute_type: str = okc_typing.ATTRIBUTETYPE_TEXT, is_array: bool = False):
-        self.identifier = identifier
-        self.template = dict(
-            name = name,
-            type = attribute_type,
-            isArray = is_array,
-            isID = False, # NOTE: isID is deprecated anyway, so we don't support this
-            valueConstraints = [] # TODO: support value constraints properly
-        )
-
-class TraitRelationDefinition:
-    def __init__(self, identifier: str, predicate_id: str, direction_forward: bool, trait_hints: List[str] = []):
-        self.identifier = identifier
-        self.template = dict(
-            predicateID = predicate_id,
-            directionForward = direction_forward,
-            traitHints = trait_hints
-        )
-
-class TraitDefinition:
-    def __init__(self, trait_id: str, required_attributes: List[TraitAttributeDefinition], optional_attributes: List[TraitAttributeDefinition] = [], optional_relations: List[TraitRelationDefinition] = [], required_traits: List[str] = []):
-        self.id = trait_id
-        self.requiredAttributes = required_attributes
-        self.optionalAttributes = optional_attributes
-        self.optionalRelations = optional_relations
-        self.requiredTraits = required_traits
-
-def upsert_trait(ok_api_client: okc.OkApiClient, trait_definition: TraitDefinition):
-    """upsert a trait; create the trait if it does not exist, update it if it does
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_definition : TraitDefinition
-        the trait's definition
-
-    Returns
-    -------
-    bool
-        True, if trait was upserted and is ready to use. False, if something fails
-    """
-        
-    query = gql("""
-    mutation ($trait_definition: UpsertRecursiveTraitInputType!) {
-        manage_upsertRecursiveTrait(
-            trait: $trait_definition
-        ) {
-            id
-        }
-    }""")
-    
-    marshalled_trait = okc_util.to_dict(trait_definition)
-    try:
-        ok_api_client.execute_graphql(query, variables=dict(
-            trait_definition=marshalled_trait
-        ))
-    except TransportQueryError as e:
-        return False
-
-    return True
-
-
-
-# TODO: should we change the return to a tri-state? deleted, not deleted, error?
-def delete_trait(ok_api_client: okc.OkApiClient, trait_id: str):
-    """deletes a trait
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the trait's ID
-
-    Returns
-    -------
-    bool
-        True, if trait was successfully deleted. False, if it did not exist in the first place, or if something failed
-    """
-        
-    query = gql("""
-    mutation ($trait_id: String!) {
-        manage_removeRecursiveTrait(
-            id: $trait_id
-        )
-    }""")
-    
-    try:
-        ret = ok_api_client.execute_graphql(query, variables=dict(
-            trait_id=trait_id
-        ))
-        return ret['manage_removeRecursiveTrait']
-    except TransportQueryError as e:
-        return False
-
-# TODO: should we change the return to a tri-state? deleted, not deleted, error?
-def check_trait(ok_api_client: okc.OkApiClient, trait_definition: TraitDefinition):
-    """checks if a trait already exists with this exact definition
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_definition : TraitDefinition
-        the trait's definition
-
-    Returns
-    -------
-    bool
-        True, if trait exists exactly as defined; False if not, or in case of an error
-    """
-        
-    query = gql("""
-    query ($trait_definition: UpsertRecursiveTraitInputType!) {
-        checkTrait(
-            trait: $trait_definition
-        )
-    }""")
-    
-    marshalled_trait = okc_util.to_dict(trait_definition)
-    try:
-        ret = ok_api_client.execute_graphql(query, variables=dict(
-            trait_definition=marshalled_trait
-        ))
-        return ret['checkTrait']
-    except TransportQueryError as e:
+import omnikeeper_client as okc
+import omnikeeper_client.typing as okc_typing
+import omnikeeper_client.util as okc_util
+from gql import gql
+from gql.transport.exceptions import (
+    TransportQueryError,
+)
+from typing import (
+    List,
+)
+
+# NOTE: these classes use camelCase members, so they can be easily encoded for GraphQL using okc_util.to_dict()
+class TraitAttributeDefinition:
+    def __init__(self, identifier: str, name: str, attribute_type: str = okc_typing.ATTRIBUTETYPE_TEXT, is_array: bool = False):
+        self.identifier = identifier
+        self.template = dict(
+            name = name,
+            type = attribute_type,
+            isArray = is_array,
+            isID = False, # NOTE: isID is deprecated anyway, so we don't support this
+            valueConstraints = [] # TODO: support value constraints properly
+        )
+
+class TraitRelationDefinition:
+    def __init__(self, identifier: str, predicate_id: str, direction_forward: bool, trait_hints: List[str] = []):
+        self.identifier = identifier
+        self.template = dict(
+            predicateID = predicate_id,
+            directionForward = direction_forward,
+            traitHints = trait_hints
+        )
+
+class TraitDefinition:
+    def __init__(self, trait_id: str, required_attributes: List[TraitAttributeDefinition], optional_attributes: List[TraitAttributeDefinition] = [], optional_relations: List[TraitRelationDefinition] = [], required_traits: List[str] = []):
+        self.id = trait_id
+        self.requiredAttributes = required_attributes
+        self.optionalAttributes = optional_attributes
+        self.optionalRelations = optional_relations
+        self.requiredTraits = required_traits
+
+def upsert_trait(ok_api_client: okc.OkApiClient, trait_definition: TraitDefinition):
+    """upsert a trait; create the trait if it does not exist, update it if it does
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_definition : TraitDefinition
+        the trait's definition
+
+    Returns
+    -------
+    bool
+        True, if trait was upserted and is ready to use. False, if something fails
+    """
+        
+    query = gql("""
+    mutation ($trait_definition: UpsertRecursiveTraitInputType!) {
+        manage_upsertRecursiveTrait(
+            trait: $trait_definition
+        ) {
+            id
+        }
+    }""")
+    
+    marshalled_trait = okc_util.to_dict(trait_definition)
+    try:
+        ok_api_client.execute_graphql(query, variables=dict(
+            trait_definition=marshalled_trait
+        ))
+    except TransportQueryError as e:
+        return False
+
+    return True
+
+
+
+# TODO: should we change the return to a tri-state? deleted, not deleted, error?
+def delete_trait(ok_api_client: okc.OkApiClient, trait_id: str):
+    """deletes a trait
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the trait's ID
+
+    Returns
+    -------
+    bool
+        True, if trait was successfully deleted. False, if it did not exist in the first place, or if something failed
+    """
+        
+    query = gql("""
+    mutation ($trait_id: String!) {
+        manage_removeRecursiveTrait(
+            id: $trait_id
+        )
+    }""")
+    
+    try:
+        ret = ok_api_client.execute_graphql(query, variables=dict(
+            trait_id=trait_id
+        ))
+        return ret['manage_removeRecursiveTrait']
+    except TransportQueryError as e:
+        return False
+
+# TODO: should we change the return to a tri-state? deleted, not deleted, error?
+def check_trait(ok_api_client: okc.OkApiClient, trait_definition: TraitDefinition):
+    """checks if a trait already exists with this exact definition
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_definition : TraitDefinition
+        the trait's definition
+
+    Returns
+    -------
+    bool
+        True, if trait exists exactly as defined; False if not, or in case of an error
+    """
+        
+    query = gql("""
+    query ($trait_definition: UpsertRecursiveTraitInputType!) {
+        checkTrait(
+            trait: $trait_definition
+        )
+    }""")
+    
+    marshalled_trait = okc_util.to_dict(trait_definition)
+    try:
+        ret = ok_api_client.execute_graphql(query, variables=dict(
+            trait_definition=marshalled_trait
+        ))
+        return ret['checkTrait']
+    except TransportQueryError as e:
         return False
```

## omnikeeper_client/traitentities.py

```diff
@@ -1,680 +1,702 @@
-from gql import gql
-import graphql
-from graphql import GraphQLType
-from gql.dsl import DSLQuery, DSLVariableDefinitions, DSLSchema, dsl_gql
-from dateutil import parser
-import datetime
-import omnikeeper_client as okc
-from typing import List, Dict, Any, Self
-import uuid
-from typing import (
-    List,
-)
-
-
-def _is_relation_field(type: GraphQLType) -> bool:
-    """
-    Checks if field is a relation. A typical relation field looks like this:
-    GraphQLList <GraphQLObjectType 'TEWrapper_tsa_cmdb__interface'>> or
-    GraphQLList <GraphQLObjectType 'RelatedCIType'>
-    Parameters
-    ----------
-    type : GraphQLType
-        The type of the field
-    Returns
-    -------
-    bool
-        True if field is a relation, False otherwise
-    """
-    if not graphql.type.is_list_type(type):
-        return False
-    list_type = graphql.type.assert_list_type(type)
-    if not graphql.type.is_object_type(list_type.of_type): # TODO: is this enough?
-        return False
-    return True
-
-def _is_non_trait_hinted_relation_field(type: GraphQLType) -> bool:
-    """
-    Checks if field of a non-trait hinted is a realtion
-    Parameters
-    ----------
-    type : GraphQLType
-        The GraphQLType to check
-    Returns
-    -------
-    bool
-        True if the type is a non-trait hinted relation field, False otherwise
-    """
-    if not graphql.type.is_list_type(type):
-        return False
-    list_type = graphql.type.assert_list_type(type)
-    if not graphql.type.is_object_type(list_type.of_type):
-        return False
-    if list_type.of_type.name != 'RelatedCIType':
-        return False
-    return True
-
-def _get_escaped_trait_id(name: str) -> str:
-    """
-    Creates the escaped trait name
-    Parameters
-    ----------
-    name : str
-        the trait name
-    Returns
-    -------
-    str
-        the escaped trait name
-    """
-    return str.replace(name, '.', '__')
-
-def _get_prefixed_trait_id(name: str) -> str:
-    """
-    Creates the prefixed trait name with m prefix
-    Parameters
-    ----------
-    name : str
-        the trait name
-    Returns
-    -------
-    str
-        the prefixed trait name with m prefix
-    """
-    if name.startswith("_"):
-        return f"m{name}"
-    return name
-
-def get_latest_trait_change(ok_api_client: okc.OkApiClient, trait_id: str, layers: List[str]) -> datetime.datetime:
-    """
-    Returns the timestamp of the latest change for the provided trait
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait to query the data
-
-    layers : [str]
-        list containing layer_ids to search
-
-    Returns
-    -------
-    timestamp : datetime
-        timestamp of the latest trait data change
-    """
-
-    client = ok_api_client._get_graphql_client()
-    with client as session:
-        ds = DSLSchema(client.schema)
-
-        escaped_trait_id = _get_escaped_trait_id(trait_id)
-        prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
-        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_id)
-        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_id}")
-        var = DSLVariableDefinitions()
-        raw_query = DSLQuery(
-                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
-                        tetType.select(
-                            dsl_root_type.latestChangeAll.select(
-                                ds.ChangesetType.timestamp
-                            )
-                        )
-                    )
-                )
-        raw_query.variable_definitions = var
-        query = dsl_gql(raw_query)
-
-        result = session.execute(query, variable_values={"layers": layers})
-
-        timestamp_str = result['traitEntities'][prefixed_escaped_trait_id]['latestChangeAll']['timestamp']
-        timestamp = parser.parse(timestamp_str)
-        return timestamp
- 
-def _get_all_traitentities(ok_api_client: okc.OkApiClient, trait_id: str, layers: List[str]) -> List[Dict[str,Any]]:
-    """
-    Internal method used to fetch all traitentites
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait to query the data
-
-    layers : [str]
-        list containing layer_ids to search
-
-    Returns
-    -------
-    List[Dict[str,Any]]
-        result containing all traitentites
-    """
-    
-    client = ok_api_client._get_graphql_client()
-    with client as session:
-        ds = DSLSchema(client.schema)
-
-        escaped_trait_id = _get_escaped_trait_id(trait_id)
-        prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
-
-        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_id)
-        dsl_type = getattr(ds, f"TE_{escaped_trait_id}")
-        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_id}")
-        dsl_wrapper_type = getattr(ds, f"TEWrapper_{escaped_trait_id}")
-        entity_fields = list(map(lambda t: getattr(dsl_type, t[0]), filter(lambda t: not _is_relation_field(t[1].type), dsl_type._type.fields.items())))
-
-        var = DSLVariableDefinitions()
-        raw_query = DSLQuery(
-                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
-                        tetType.select(
-                            dsl_root_type.all.select(
-                                dsl_wrapper_type.ciid,
-                                dsl_wrapper_type.entity.select(*entity_fields)
-                            )
-                        )
-                    )
-                )
-        raw_query.variable_definitions = var
-        query = dsl_gql(raw_query)
-
-        result = session.execute(query, variable_values={"layers": layers})
-
-        data_list = result['traitEntities'][prefixed_escaped_trait_id]['all']
-        for data in data_list:
-            data.update(data.pop('entity'))
-
-        return data_list
-    
-  
-def get_all_traitentities(ok_api_client: okc.OkApiClient, trait_id: str, layers: List[str]) -> List[Dict[str,Any]]:
-    """
-    Returns all traitentites
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait to query the data
-
-    layers : [str]
-        list containing layer_ids to search
-
-    Returns
-    -------
-    List[Dict[str,Any]]
-        result containing all traitentites
-    """
-    
-    trait_entities = _get_all_traitentities(ok_api_client, trait_id, layers)
-    return trait_entities
-
-def get_all_traitentity_relations(ok_api_client: okc.OkApiClient, trait_id: str, traitrelation_id: str, layers: List[str]) -> List[Dict[str,Any]]:
-    """
-    Returns the trait relations for all trait entities of a particular trait
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait to query the data
-
-    layers : [str]
-        list containing layer_ids to search
-
-    Returns
-    -------
-    List[Dict[str,Any]]
-        result all data for a specific trait in a list format
-    """
-
-    client = ok_api_client._get_graphql_client()
-    with client as session:
-        ds = DSLSchema(client.schema)
-
-        escaped_trait_id = _get_escaped_trait_id(trait_id)
-        prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
-
-        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_id)
-        dsl_type = getattr(ds, f"TE_{escaped_trait_id}")
-        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_id}")
-        dsl_wrapper_type = getattr(ds, f"TEWrapper_{escaped_trait_id}")
-
-        entity_fields = list(map(lambda t: getattr(dsl_type, t[0]).select(ds.RelatedCIType.relatedCIID), filter(lambda t: t[0] == traitrelation_id and _is_non_trait_hinted_relation_field(t[1].type), dsl_type._type.fields.items())))
-
-        var = DSLVariableDefinitions()
-        raw_query = DSLQuery(
-                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
-                        tetType.select(
-                            dsl_root_type.all.select(
-                                dsl_wrapper_type.ciid,
-                                dsl_wrapper_type.entity.select(*entity_fields)
-                            )
-                        )
-                    )
-                )
-        raw_query.variable_definitions = var
-        query = dsl_gql(raw_query)
-
-        result = session.execute(query, variable_values={"layers": layers})
-
-        result_list = []
-        for entity in result['traitEntities'][prefixed_escaped_trait_id]['all']:
-            related_ciids = [related_entity['relatedCIID'] for related_entity in entity['entity'][traitrelation_id]]
-            result_dict = {
-                "base_ciid": entity['ciid'],
-                "related_ciids": related_ciids,
-            }
-            result_list.append(result_dict)
-
-        return result_list
-    
-def set_traitentity_relations(ok_api_client: okc.OkApiClient, trait_id: str, traitrelation_id: str, base_ciid: uuid.UUID | str, related_ciids: List[uuid.UUID | str], write_layer: str, read_layers: List[str] = None) -> bool:
-    """
-    Sets a particular trait relation of a particular trait for a single CI
-    Adds new traitrelations and deletes all traitrelations not in the provided list
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait
-
-    traitrelation_id: str
-        the id of the trait's traitrelation
-        
-    base_ciid: uuid.UUID | str
-        the base ciid
-        
-    related_ciids: List[uuid.UUID | str]
-        the list of related ciids
-
-    write_layer : str
-        the id of the layer in which the data should be added
-
-    read_layers : [str]
-        A list with ids of the layers in which the omnikeeper will look if trait entities already exist
-
-    Returns
-    -------
-    List[Dict[str,Any]]
-        result all data for a specific trait in a list format
-    """
-        
-    prefixed_escaped_trait_id = _get_prefixed_trait_id(_get_escaped_trait_id(trait_id))
-    escaped_traitrelation_id = _get_escaped_trait_id(traitrelation_id)
-    query = gql(f"""
-        mutation($readLayers: [String]!, $writeLayer: String!, $baseCIID: Guid!, $relatedCIIDs: [Guid!]!) {{
-        setRelationsByCIID_{prefixed_escaped_trait_id}_{escaped_traitrelation_id}(
-            layers: $readLayers
-            writeLayer: $writeLayer
-            baseCIID: $baseCIID
-            relatedCIIDs: $relatedCIIDs
-        ) {{
-            ciid
-        }}
-        }}
-        """)
-        
-    if read_layers is None:
-        read_layers = [write_layer]
-
-    ok_api_client.execute_graphql(query, variables=dict(
-        writeLayer=write_layer, 
-        readLayers=read_layers, 
-        baseCIID=base_ciid,
-        relatedCIIDs=related_ciids
-        ))
-
-    return True
-
-def bulk_replace_traitentity_relations(ok_api_client: okc.OkApiClient, trait_id: str, traitrelation_id: str, input: List[Dict[str, Any]], relevant_ciids: List[str], write_layer: str, read_layers: List[str] = None) -> bool:
-    """
-    Bulk replaces a particular trait relation of a particular trait for ALL trait entities of that trait
-    Adds new traitrelations and deletes all relevant traitrelations not in the provided list
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait
-
-    traitrelation_id: str
-        the id of the trait's traitrelation
-        
-    input: List[Dict[str, Any]]
-        a list of dicts, the dicts in the following form: { "baseCIID" = <ciid>, "relatedCIIDs" = [<ciid>, <ciid>, ...] }
-
-    relevant_ciids: List[str]
-        a list of CIIDs, that specifies which CIs are actually relevant for this operation. This is necessary to let omnikeeper know which CIs it should consider for this operation
-        CIs not in the list of relevant_ciids are not changed
-        depending on your usecase..
-        ...you may want to set relevant_ciids equal to the list of baseCIIDs in input
-        ...or you may want to keep track of the relevant_ciids yourself, because you got an initial list from get_all_traitentity_relations()
-
-    write_layer : str
-        the id of the layer in which the data should be added
-
-    read_layers : [str]
-        A list with ids of the layers in which the omnikeeper will look if trait entities already exist
-
-    Returns
-    -------
-    bool 
-        True if the update is successful, False otherwise
-    """
-
-    prefixed_escaped_trait_id = _get_prefixed_trait_id(_get_escaped_trait_id(trait_id))
-    escaped_traitrelation_id = _get_escaped_trait_id(traitrelation_id)
-    query = gql(f"""
-        mutation($readLayers: [String]!, $writeLayer: String!, $input: [TE_Upsert_Relations_Only_Input]!, $relevantCIIDs: [Guid]!) {{
-        bulkReplaceRelations_{prefixed_escaped_trait_id}_{escaped_traitrelation_id}(
-            layers: $readLayers
-            writeLayer: $writeLayer
-            input: $input
-            relevantCIIDs: $relevantCIIDs
-        ) {{
-            success
-        }}
-        }}
-        """)
-        
-    if read_layers is None:
-        read_layers = [write_layer]
-
-    result = ok_api_client.execute_graphql(query, variables=dict(
-        writeLayer=write_layer, 
-        readLayers=read_layers, 
-        input=input,
-        relevantCIIDs=relevant_ciids
-        ))
-
-    return result[f"bulkReplaceRelations_{prefixed_escaped_trait_id}_{escaped_traitrelation_id}"]["success"]
-  
-def _bulk_replace_trait_entities_by_filter(ok_api_client: okc.OkApiClient, trait_id: str, input: List[Dict[str,Any]], id_attributes: List[str], id_relations: List[str], write_layer: str, read_layers: List[str] = None, filter: object = {}) -> bool:
-    """
-    Internal method used to replace all traitentites in a layer, it can use a filter when updating the trait entities,
-    this will also delete all old trait entities, if there are any
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait to query the data
-
-    input : List[Dict[str,Any]]
-        Trait entities as list of dictionaries
-
-    id_attributes : [str]
-        attributes to be considered as trait IDs
-    
-    id_relations : [str]
-        ids to be considered as trait relations IDs
-
-    write_layer : str
-        the id of the layer in which the data should be added
-
-    read_layers : [str]
-        A list with ids of the layers in which the omnikeeper will look if trait entities already exist
-
-    filter : object
-        a filter object can be used, default {}, example for filter object: {type: {exact: "Validator"}, context: {exact: "test"}, group: {exact: "test"} }
-
-    Returns
-    -------
-    bool 
-        True if the update is successful, False otherwise
-    """
-    
-    escaped_trait_id = _get_escaped_trait_id(trait_id)
-    prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
-    query = gql(f"""
-        mutation($readLayers: [String]!, $writeLayer: String!, $idAttributes: [String!]!, $idRelations: [String!]!, $filter: TE_filter_Input_{escaped_trait_id}!, $input: [TE_Upsert_Input_{escaped_trait_id}]!) {{
-        bulkReplaceByFilter_{prefixed_escaped_trait_id}(
-            layers: $readLayers
-            writeLayer: $writeLayer
-            filter: $filter
-            input: $input
-            idAttributes: $idAttributes
-            idRelations: $idRelations
-        ) {{
-            success
-        }}
-        }}
-        """)
-        
-    if read_layers is None:
-        read_layers = [write_layer]
-
-    result = ok_api_client.execute_graphql(query, variables=dict(
-        writeLayer=write_layer, 
-        readLayers=read_layers, 
-        idAttributes=id_attributes,
-        idRelations=id_relations,
-        filter=filter,
-        input=input
-        ))
-
-    return result[f"bulkReplaceByFilter_{prefixed_escaped_trait_id}"]["success"]
-
-def _bulk_replace_trait_entities(ok_api_client: okc.OkApiClient, trait_id: str, input: List[Dict[str,Any]], write_layer: str, read_layers: List[str] = None) -> bool:
-    """
-    Internal method that sets all trait entities, this will also delete all old trait entities, if there are any
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait to query the data
-
-    input : List[Dict[str,Any]]
-        The cis items which will be inserted, needs to be of the form:
-        [{"ciid": "836DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "foo", "attribute2": 2},
-         {"ciid": "936DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "bar", "attribute2": 3}]
-
-    write_layer : str
-        the id of the layer in which the data should be added
-
-    read_layers : [str]
-        A list with ids of the layers in which the omnikeeper will look if the cis already exists
-
-    Returns
-    -------
-    bool 
-        True if the update is successful, False otherwise
-    """
-    escaped_trait_id = _get_escaped_trait_id(trait_id)
-    prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
-
-    query = gql(f"""
-        mutation($readLayers: [String]!, $writeLayer: String!, $input: [TE_CIID_And_Upsert_Attributes_Only_Input_{escaped_trait_id}]!) {{
-        bulkReplace_{prefixed_escaped_trait_id}(
-            layers: $readLayers
-            writeLayer: $writeLayer
-            input: $input
-        ) {{
-            success
-        }}
-        }}
-        """)
-        
-    final_input = [{"ciid": d["ciid"], "attributes": {k: v for k, v in d.items() if k != "ciid"}} for d in input]
-        
-    if read_layers is None:
-        read_layers = [write_layer]
-    result = ok_api_client.execute_graphql(query, variables=dict(
-        writeLayer=write_layer, 
-        readLayers=read_layers, 
-        input=final_input
-        ))
-
-    return result[f"bulkReplace_{prefixed_escaped_trait_id}"]["success"]
-
-# TODO: support use of uuid.UUID for ciids
-def bulk_replace_trait_entities_by_filter(ok_api_client: okc.OkApiClient, trait_id: str, input: List[Dict[str,Any]], id_attributes: List[str], id_relations: List[str], write_layer: str, read_layers: List[str] = None, filter: object = {}) -> bool:
-    """
-    Replaces all traitentites in a layer, it can use a filter when updating the trait entities,
-    this will also delete all old trait entities, if there are any
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait to query the data
-
-    input : List[Dict[str,Any]]
-        The cis items which will be inserted, needs to be of the form:
-        [{"ciid": "836DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "foo", "attribute2": 2},
-         {"ciid": "936DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "bar", "attribute2": 3}]
-
-    id_attributes : [str]
-        attributes to be considered as trait IDs
-    
-    id_relations : [str]
-        ids to be considered as trait relations IDs
-
-    write_layer : str
-        the id of the layer in which the data should be added
-
-    read_layers : [str]
-        A list with ids of the layers in which the omnikeeper will look if trait entities already exist
-
-    filter : object
-        a filter object can be used, default {}, example for filter object: {type: {exact: "Validator"}, context: {exact: "test"}, group: {exact: "test"} }
-
-    Returns
-    -------
-    bool 
-        True if the update is successful, False otherwise
-    """
-    result = _bulk_replace_trait_entities_by_filter(ok_api_client, trait_id, input, id_attributes, id_relations, write_layer, read_layers, filter)
-    return result
-
-# TODO: support use of uuid.UUID for ciids
-def bulk_replace_trait_entities(ok_api_client: okc.OkApiClient, trait_id: str, input: List[Dict[str,Any]], write_layer: str, read_layers: List[str] = None) -> bool:
-    """
-    Sets all trait entities, this will also delete all old trait entities, if there are any
-
-    Parameters
-    ----------
-    ok_api_client : OkApiClient
-        The OkApiClient instance representing omnikeeper connection
-
-    trait_id : str
-        the id of the trait to query the data
-
-    input : List[Dict[str,Any]]
-        The cis items which will be inserted, needs to be of the form:
-        [{"ciid": "836DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "foo", "attribute2": 2},
-         {"ciid": "936DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "bar", "attribute2": 3}]
-
-    write_layer : str
-        the id of the layer in which the data should be added
-
-    read_layers : [str]
-        A list with ids of the layers in which the omnikeeper will look if the cis already exists
-
-    Returns
-    -------
-    bool 
-        True if the update is successful, False otherwise
-    """
-    result = _bulk_replace_trait_entities(ok_api_client, trait_id, input, write_layer, read_layers)
-    return result
-
-class OKEntityList:
-    def __init__(self, ok_list: List[Dict[str, Any]]):
-        self.ok_list = ok_list
-        self.ciid_lookup_table = {str(v['ciid']): index for index, v in enumerate(ok_list)}
-
-    def update_or_add_via_ciid(self, item: Dict[str, Any], ciid: str) -> int:
-        item['__keep'] = True
-        index = self.ciid_lookup_table.get(ciid, None)
-        if index is not None:
-            # ci exists in the data already -> update
-            self.ok_list[index].update(item)
-            return index
-        else:
-            # ci does not exist yet -> add
-            item['ciid'] = ciid
-            self.ok_list.append(item)
-            self.ciid_lookup_table[ciid] = len(self.ok_list) - 1
-            return index
-    
-    def get_final_list(self) -> List[Dict[str, Any]]:
-        return [{k: v for k, v in d.items() if k != '__keep'} for d in self.ok_list if '__keep' in d]
-
-class OKRelationList:
-    def __init__(self, ok_list: List[Dict[str, Any]]):
-        self.ok_list = ok_list
-        self.lookup_table = {str(v['base_ciid']): index for index, v in enumerate(ok_list)}
-
-    def add_or_update(self, base_ciid: str, related_ciids: List[str], merge_strategy_related_ciids: str = 'replace'):
-        related_ciids_non_duplicates = list(set(related_ciids)) # NOTE: list(set(...)) ensures uniqueness
-        item = { 'base_ciid': base_ciid, 'related_ciids': related_ciids_non_duplicates, '__keep': True}
-        index = self.lookup_table.get(base_ciid, None)
-        if index is not None:
-            # give caller the choice on how to merge related_ciids
-            if merge_strategy_related_ciids == 'replace':
-                # simply replace existing related_ciids dictionary with new dictionary
-                self.ok_list[index].update(item)
-            elif merge_strategy_related_ciids == 'merge':
-                exsting_related_ciids = self.ok_list[index]['related_ciids']
-                new_related_ciids = item['related_ciids']
-                final_related_ciids = list(set(exsting_related_ciids + new_related_ciids)) # NOTE: list(set(...)) ensures uniqueness
-                item['related_ciids'] = final_related_ciids
-                self.ok_list[index].update(item)
-                pass
-            else:
-                raise Exception(f"Unknown value for merge_strategy_related_ciids: {merge_strategy_related_ciids}")
-        else:
-            self.ok_list.append(item)
-            self.lookup_table[base_ciid] = len(self.ok_list) - 1
-
-    def build_inverse_list(self) -> Self:
-        tmp = dict()
-        for d in self.ok_list:
-            for r in d['related_ciids']:
-                existing = tmp.get(r, None)
-                if existing is None:
-                    tmp[r] = [d['base_ciid']]
-                else:
-                    existing.append(d['base_ciid'])
-        
-        final_list = [{'base_ciid': k, 'related_ciids': v} for k, v in tmp.items()]
-        return OKRelationList(final_list)
-
-    def get_related_ciids(self, base_ciid: str, default = []) -> List[str]:
-        index = self.lookup_table.get(base_ciid, None)
-        if index is None:
-            return default
-        return self.ok_list[index]["related_ciids"]
-    
-    def get_relevant_ciids(self) -> List[str]:
-        return [d['base_ciid'] for d in self.ok_list]
-    
-    def get_final_list(self) -> List[Dict[str, Any]]:
-        tmp = [{k: v for k, v in d.items() if k != '__keep'} for d in self.ok_list if '__keep' in d]
-
-        # HACK, TODO: rework client library to not have to rewrite keys
-        for d in tmp:
-            d['baseCIID'] = d.pop('base_ciid')
-            d['relatedCIIDs'] = d.pop('related_ciids')
-
-        return tmp
+from gql import gql
+import graphql
+from graphql import GraphQLType
+from gql.dsl import DSLQuery, DSLVariableDefinitions, DSLSchema, dsl_gql
+from dateutil import parser
+import datetime
+import omnikeeper_client as okc
+from typing import List, Dict, Any, Self
+import uuid
+from typing import (
+    List,
+)
+
+
+def _is_relation_field(type: GraphQLType) -> bool:
+    """
+    Checks if field is a relation. A typical relation field looks like this:
+    GraphQLList <GraphQLObjectType 'TEWrapper_tsa_cmdb__interface'>> or
+    GraphQLList <GraphQLObjectType 'RelatedCIType'>
+    Parameters
+    ----------
+    type : GraphQLType
+        The type of the field
+    Returns
+    -------
+    bool
+        True if field is a relation, False otherwise
+    """
+    if not graphql.type.is_list_type(type):
+        return False
+    list_type = graphql.type.assert_list_type(type)
+    if not graphql.type.is_object_type(list_type.of_type): # TODO: is this enough?
+        return False
+    return True
+
+def _is_non_trait_hinted_relation_field(type: GraphQLType) -> bool:
+    """
+    Checks if field of a non-trait hinted is a realtion
+    Parameters
+    ----------
+    type : GraphQLType
+        The GraphQLType to check
+    Returns
+    -------
+    bool
+        True if the type is a non-trait hinted relation field, False otherwise
+    """
+    if not graphql.type.is_list_type(type):
+        return False
+    list_type = graphql.type.assert_list_type(type)
+    if not graphql.type.is_object_type(list_type.of_type):
+        return False
+    if list_type.of_type.name != 'RelatedCIType':
+        return False
+    return True
+
+def _get_escaped_trait_id(name: str) -> str:
+    """
+    Creates the escaped trait name
+    Parameters
+    ----------
+    name : str
+        the trait name
+    Returns
+    -------
+    str
+        the escaped trait name
+    """
+    return str.replace(name, '.', '__')
+
+def _get_prefixed_trait_id(name: str) -> str:
+    """
+    Creates the prefixed trait name with m prefix
+    Parameters
+    ----------
+    name : str
+        the trait name
+    Returns
+    -------
+    str
+        the prefixed trait name with m prefix
+    """
+    if name.startswith("_"):
+        return f"m{name}"
+    return name
+
+def get_latest_trait_change(ok_api_client: okc.OkApiClient, trait_id: str, layers: List[str]) -> datetime.datetime:
+    """
+    Returns the timestamp of the latest change for the provided trait
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait to query the data
+
+    layers : [str]
+        list containing layer_ids to search
+
+    Returns
+    -------
+    timestamp : datetime
+        timestamp of the latest trait data change
+    """
+
+    client = ok_api_client._get_graphql_client()
+    with client as session:
+        ds = DSLSchema(client.schema)
+
+        escaped_trait_id = _get_escaped_trait_id(trait_id)
+        prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
+        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_id)
+        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_id}")
+        var = DSLVariableDefinitions()
+        raw_query = DSLQuery(
+                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
+                        tetType.select(
+                            dsl_root_type.latestChangeAll.select(
+                                ds.ChangesetType.timestamp
+                            )
+                        )
+                    )
+                )
+        raw_query.variable_definitions = var
+        query = dsl_gql(raw_query)
+
+        result = session.execute(query, variable_values={"layers": layers})
+
+        timestamp_str = result['traitEntities'][prefixed_escaped_trait_id]['latestChangeAll']['timestamp']
+        timestamp = parser.parse(timestamp_str)
+        return timestamp
+ 
+def _get_all_traitentities(ok_api_client: okc.OkApiClient, trait_id: str, layers: List[str]) -> List[Dict[str,Any]]:
+    """
+    Internal method used to fetch all traitentites
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait to query the data
+
+    layers : [str]
+        list containing layer_ids to search
+
+    Returns
+    -------
+    List[Dict[str,Any]]
+        result containing all traitentites
+    """
+    
+    client = ok_api_client._get_graphql_client()
+    with client as session:
+        ds = DSLSchema(client.schema)
+
+        escaped_trait_id = _get_escaped_trait_id(trait_id)
+        prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
+
+        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_id)
+        dsl_type = getattr(ds, f"TE_{escaped_trait_id}")
+        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_id}")
+        dsl_wrapper_type = getattr(ds, f"TEWrapper_{escaped_trait_id}")
+        entity_fields = list(map(lambda t: getattr(dsl_type, t[0]), filter(lambda t: not _is_relation_field(t[1].type), dsl_type._type.fields.items())))
+
+        var = DSLVariableDefinitions()
+        raw_query = DSLQuery(
+                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
+                        tetType.select(
+                            dsl_root_type.all.select(
+                                dsl_wrapper_type.ciid,
+                                dsl_wrapper_type.entity.select(*entity_fields)
+                            )
+                        )
+                    )
+                )
+        raw_query.variable_definitions = var
+        query = dsl_gql(raw_query)
+
+        result = session.execute(query, variable_values={"layers": layers})
+
+        data_list = result['traitEntities'][prefixed_escaped_trait_id]['all']
+        for data in data_list:
+            data.update(data.pop('entity'))
+
+        return data_list
+    
+  
+def get_all_traitentities(ok_api_client: okc.OkApiClient, trait_id: str, layers: List[str]) -> List[Dict[str,Any]]:
+    """
+    Returns all traitentites
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait to query the data
+
+    layers : [str]
+        list containing layer_ids to search
+
+    Returns
+    -------
+    List[Dict[str,Any]]
+        result containing all traitentites
+    """
+    
+    trait_entities = _get_all_traitentities(ok_api_client, trait_id, layers)
+    return trait_entities
+
+def get_all_traitentity_relations(ok_api_client: okc.OkApiClient, trait_id: str, traitrelation_id: str, layers: List[str]) -> List[Dict[str,Any]]:
+    """
+    Returns the trait relations for all trait entities of a particular trait
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait to query the data
+
+    layers : [str]
+        list containing layer_ids to search
+
+    Returns
+    -------
+    List[Dict[str,Any]]
+        result all data for a specific trait in a list format
+    """
+
+    client = ok_api_client._get_graphql_client()
+    with client as session:
+        ds = DSLSchema(client.schema)
+
+        escaped_trait_id = _get_escaped_trait_id(trait_id)
+        prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
+
+        tetType = getattr(ds.TraitEntitiesType, prefixed_escaped_trait_id)
+        dsl_type = getattr(ds, f"TE_{escaped_trait_id}")
+        dsl_root_type = getattr(ds, f"TERoot_{escaped_trait_id}")
+        dsl_wrapper_type = getattr(ds, f"TEWrapper_{escaped_trait_id}")
+
+        entity_fields = list(map(lambda t: getattr(dsl_type, t[0]).select(ds.RelatedCIType.relatedCIID), filter(lambda t: t[0] == traitrelation_id and _is_non_trait_hinted_relation_field(t[1].type), dsl_type._type.fields.items())))
+
+        var = DSLVariableDefinitions()
+        raw_query = DSLQuery(
+                    ds.GraphQLQueryRoot.traitEntities.args(layers=var.layers).select(
+                        tetType.select(
+                            dsl_root_type.all.select(
+                                dsl_wrapper_type.ciid,
+                                dsl_wrapper_type.entity.select(*entity_fields)
+                            )
+                        )
+                    )
+                )
+        raw_query.variable_definitions = var
+        query = dsl_gql(raw_query)
+
+        result = session.execute(query, variable_values={"layers": layers})
+
+        result_list = []
+        for entity in result['traitEntities'][prefixed_escaped_trait_id]['all']:
+            related_ciids = [related_entity['relatedCIID'] for related_entity in entity['entity'][traitrelation_id]]
+            result_dict = {
+                "base_ciid": entity['ciid'],
+                "related_ciids": related_ciids,
+            }
+            result_list.append(result_dict)
+
+        return result_list
+    
+def set_traitentity_relations(ok_api_client: okc.OkApiClient, trait_id: str, traitrelation_id: str, base_ciid: uuid.UUID | str, related_ciids: List[uuid.UUID | str], write_layer: str, read_layers: List[str] = None) -> bool:
+    """
+    Sets a particular trait relation of a particular trait for a single CI
+    Adds new traitrelations and deletes all traitrelations not in the provided list
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait
+
+    traitrelation_id: str
+        the id of the trait's traitrelation
+        
+    base_ciid: uuid.UUID | str
+        the base ciid
+        
+    related_ciids: List[uuid.UUID | str]
+        the list of related ciids
+
+    write_layer : str
+        the id of the layer in which the data should be added
+
+    read_layers : [str]
+        A list with ids of the layers in which the omnikeeper will look if trait entities already exist
+
+    Returns
+    -------
+    List[Dict[str,Any]]
+        result all data for a specific trait in a list format
+    """
+        
+    prefixed_escaped_trait_id = _get_prefixed_trait_id(_get_escaped_trait_id(trait_id))
+    escaped_traitrelation_id = _get_escaped_trait_id(traitrelation_id)
+    query = gql(f"""
+        mutation($readLayers: [String]!, $writeLayer: String!, $baseCIID: Guid!, $relatedCIIDs: [Guid!]!) {{
+        setRelationsByCIID_{prefixed_escaped_trait_id}_{escaped_traitrelation_id}(
+            layers: $readLayers
+            writeLayer: $writeLayer
+            baseCIID: $baseCIID
+            relatedCIIDs: $relatedCIIDs
+        ) {{
+            ciid
+        }}
+        }}
+        """)
+        
+    if read_layers is None:
+        read_layers = [write_layer]
+
+    ok_api_client.execute_graphql(query, variables=dict(
+        writeLayer=write_layer, 
+        readLayers=read_layers, 
+        baseCIID=base_ciid,
+        relatedCIIDs=related_ciids
+        ))
+
+    return True
+
+def bulk_replace_traitentity_relations(ok_api_client: okc.OkApiClient, trait_id: str, traitrelation_id: str, input: List[Dict[str, Any]], relevant_ciids: List[str], write_layer: str, read_layers: List[str] = None) -> bool:
+    """
+    Bulk replaces a particular trait relation of a particular trait for ALL trait entities of that trait
+    Adds new traitrelations and deletes all relevant traitrelations not in the provided list
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait
+
+    traitrelation_id: str
+        the id of the trait's traitrelation
+        
+    input: List[Dict[str, Any]]
+        a list of dicts, the dicts in the following form: { "baseCIID" = <ciid>, "relatedCIIDs" = [<ciid>, <ciid>, ...] }
+
+    relevant_ciids: List[str]
+        a list of CIIDs, that specifies which CIs are actually relevant for this operation. This is necessary to let omnikeeper know which CIs it should consider for this operation
+        CIs not in the list of relevant_ciids are not changed
+        depending on your usecase..
+        ...you may want to set relevant_ciids equal to the list of baseCIIDs in input
+        ...or you may want to keep track of the relevant_ciids yourself, because you got an initial list from get_all_traitentity_relations()
+
+    write_layer : str
+        the id of the layer in which the data should be added
+
+    read_layers : [str]
+        A list with ids of the layers in which the omnikeeper will look if trait entities already exist
+
+    Returns
+    -------
+    bool 
+        True if the update is successful, False otherwise
+    """
+
+    prefixed_escaped_trait_id = _get_prefixed_trait_id(_get_escaped_trait_id(trait_id))
+    escaped_traitrelation_id = _get_escaped_trait_id(traitrelation_id)
+    query = gql(f"""
+        mutation($readLayers: [String]!, $writeLayer: String!, $input: [TE_Upsert_Relations_Only_Input]!, $relevantCIIDs: [Guid]!) {{
+        bulkReplaceRelations_{prefixed_escaped_trait_id}_{escaped_traitrelation_id}(
+            layers: $readLayers
+            writeLayer: $writeLayer
+            input: $input
+            relevantCIIDs: $relevantCIIDs
+        ) {{
+            success
+        }}
+        }}
+        """)
+        
+    if read_layers is None:
+        read_layers = [write_layer]
+
+    result = ok_api_client.execute_graphql(query, variables=dict(
+        writeLayer=write_layer, 
+        readLayers=read_layers, 
+        input=input,
+        relevantCIIDs=relevant_ciids
+        ))
+
+    return result[f"bulkReplaceRelations_{prefixed_escaped_trait_id}_{escaped_traitrelation_id}"]["success"]
+  
+def _bulk_replace_trait_entities_by_filter(ok_api_client: okc.OkApiClient, trait_id: str, input: List[Dict[str,Any]], id_attributes: List[str], id_relations: List[str], write_layer: str, read_layers: List[str] = None, filter: object = {}) -> bool:
+    """
+    Internal method used to replace all traitentites in a layer, it can use a filter when updating the trait entities,
+    this will also delete all old trait entities, if there are any
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait to query the data
+
+    input : List[Dict[str,Any]]
+        Trait entities as list of dictionaries
+
+    id_attributes : [str]
+        attributes to be considered as trait IDs
+    
+    id_relations : [str]
+        ids to be considered as trait relations IDs
+
+    write_layer : str
+        the id of the layer in which the data should be added
+
+    read_layers : [str]
+        A list with ids of the layers in which the omnikeeper will look if trait entities already exist
+
+    filter : object
+        a filter object can be used, default {}, example for filter object: {type: {exact: "Validator"}, context: {exact: "test"}, group: {exact: "test"} }
+
+    Returns
+    -------
+    bool 
+        True if the update is successful, False otherwise
+    """
+    
+    escaped_trait_id = _get_escaped_trait_id(trait_id)
+    prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
+    query = gql(f"""
+        mutation($readLayers: [String]!, $writeLayer: String!, $idAttributes: [String!]!, $idRelations: [String!]!, $filter: TE_filter_Input_{escaped_trait_id}!, $input: [TE_Upsert_Input_{escaped_trait_id}]!) {{
+        bulkReplaceByFilter_{prefixed_escaped_trait_id}(
+            layers: $readLayers
+            writeLayer: $writeLayer
+            filter: $filter
+            input: $input
+            idAttributes: $idAttributes
+            idRelations: $idRelations
+        ) {{
+            success
+        }}
+        }}
+        """)
+        
+    if read_layers is None:
+        read_layers = [write_layer]
+
+    result = ok_api_client.execute_graphql(query, variables=dict(
+        writeLayer=write_layer, 
+        readLayers=read_layers, 
+        idAttributes=id_attributes,
+        idRelations=id_relations,
+        filter=filter,
+        input=input
+        ))
+
+    return result[f"bulkReplaceByFilter_{prefixed_escaped_trait_id}"]["success"]
+
+def _bulk_replace_trait_entities(ok_api_client: okc.OkApiClient, trait_id: str, input: List[Dict[str,Any]], write_layer: str, read_layers: List[str] = None) -> bool:
+    """
+    Internal method that sets all trait entities, this will also delete all old trait entities, if there are any
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait to query the data
+
+    input : List[Dict[str,Any]]
+        The cis items which will be inserted, needs to be of the form:
+        [{"ciid": "836DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "foo", "attribute2": 2},
+         {"ciid": "936DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "bar", "attribute2": 3}]
+
+    write_layer : str
+        the id of the layer in which the data should be added
+
+    read_layers : [str]
+        A list with ids of the layers in which the omnikeeper will look if the cis already exists
+
+    Returns
+    -------
+    bool 
+        True if the update is successful, False otherwise
+    """
+    escaped_trait_id = _get_escaped_trait_id(trait_id)
+    prefixed_escaped_trait_id = _get_prefixed_trait_id(escaped_trait_id)
+
+    query = gql(f"""
+        mutation($readLayers: [String]!, $writeLayer: String!, $input: [TE_CIID_And_Upsert_Attributes_Only_Input_{escaped_trait_id}]!) {{
+        bulkReplace_{prefixed_escaped_trait_id}(
+            layers: $readLayers
+            writeLayer: $writeLayer
+            input: $input
+        ) {{
+            success
+        }}
+        }}
+        """)
+        
+    final_input = [{"ciid": d["ciid"], "attributes": {k: v for k, v in d.items() if k != "ciid"}} for d in input]
+        
+    if read_layers is None:
+        read_layers = [write_layer]
+    result = ok_api_client.execute_graphql(query, variables=dict(
+        writeLayer=write_layer, 
+        readLayers=read_layers, 
+        input=final_input
+        ))
+
+    return result[f"bulkReplace_{prefixed_escaped_trait_id}"]["success"]
+
+# TODO: support use of uuid.UUID for ciids
+def bulk_replace_trait_entities_by_filter(ok_api_client: okc.OkApiClient, trait_id: str, input: List[Dict[str,Any]], id_attributes: List[str], id_relations: List[str], write_layer: str, read_layers: List[str] = None, filter: object = {}) -> bool:
+    """
+    Replaces all traitentites in a layer, it can use a filter when updating the trait entities,
+    this will also delete all old trait entities, if there are any
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait to query the data
+
+    input : List[Dict[str,Any]]
+        The cis items which will be inserted, needs to be of the form:
+        [{"ciid": "836DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "foo", "attribute2": 2},
+         {"ciid": "936DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "bar", "attribute2": 3}]
+
+    id_attributes : [str]
+        attributes to be considered as trait IDs
+    
+    id_relations : [str]
+        ids to be considered as trait relations IDs
+
+    write_layer : str
+        the id of the layer in which the data should be added
+
+    read_layers : [str]
+        A list with ids of the layers in which the omnikeeper will look if trait entities already exist
+
+    filter : object
+        a filter object can be used, default {}, example for filter object: {type: {exact: "Validator"}, context: {exact: "test"}, group: {exact: "test"} }
+
+    Returns
+    -------
+    bool 
+        True if the update is successful, False otherwise
+    """
+    result = _bulk_replace_trait_entities_by_filter(ok_api_client, trait_id, input, id_attributes, id_relations, write_layer, read_layers, filter)
+    return result
+
+# TODO: support use of uuid.UUID for ciids
+def bulk_replace_trait_entities(ok_api_client: okc.OkApiClient, trait_id: str, input: List[Dict[str,Any]], write_layer: str, read_layers: List[str] = None) -> bool:
+    """
+    Sets all trait entities, this will also delete all old trait entities, if there are any
+
+    Parameters
+    ----------
+    ok_api_client : OkApiClient
+        The OkApiClient instance representing omnikeeper connection
+
+    trait_id : str
+        the id of the trait to query the data
+
+    input : List[Dict[str,Any]]
+        The cis items which will be inserted, needs to be of the form:
+        [{"ciid": "836DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "foo", "attribute2": 2},
+         {"ciid": "936DA01F-9ABD-4D9D-80C7-02AF85C822A8", "attribute1": "bar", "attribute2": 3}]
+
+    write_layer : str
+        the id of the layer in which the data should be added
+
+    read_layers : [str]
+        A list with ids of the layers in which the omnikeeper will look if the cis already exists
+
+    Returns
+    -------
+    bool 
+        True if the update is successful, False otherwise
+    """
+    result = _bulk_replace_trait_entities(ok_api_client, trait_id, input, write_layer, read_layers)
+    return result
+
+OKEntityItem = Dict[str, Any]
+
+class OKEntityList:
+    def __init__(self, ok_list: List[OKEntityItem]):
+        self.ok_list = ok_list
+        self.ciid_lookup_table = {str(v['ciid']): index for index, v in enumerate(ok_list)}
+
+    def update_or_add_via_ciid(self, new_item: OKEntityItem, ciid: str, duplicate_strategy: str = 'update') -> int:
+        index = self.ciid_lookup_table.get(ciid, None)
+        if index is not None:
+            # ci exists in the data already -> update
+            existing = self.ok_list[index]
+
+            old_update_count = existing.get('__update_count', 0)
+
+            if old_update_count >= 1 and duplicate_strategy is not None:
+                if duplicate_strategy == "skip":
+                    return -1
+                else: # default: update
+                    existing.update(new_item)
+            else:
+                existing.update(new_item)
+                
+            existing['__update_count'] = old_update_count + 1
+
+            return index
+        else:
+            # ci does not exist yet -> add
+            new_item['ciid'] = ciid
+            new_item['__update_count'] = 1
+            self.ok_list.append(new_item)
+            self.ciid_lookup_table[ciid] = len(self.ok_list) - 1
+            return index
+    
+    def get_final_list(self) -> List[OKEntityItem]:
+        return [{k: v for k, v in d.items() if k != '__update_count'} for d in self.ok_list if '__update_count' in d]
+
+
+class OKRelationList:
+    def __init__(self, ok_list: List[Dict[str, Any]]):
+        self.ok_list = ok_list
+        self.lookup_table = {str(v['base_ciid']): index for index, v in enumerate(ok_list)}
+        self.keeps = set() # set of tuples [(base_ciid, related_ciid)], which tracks what relations we must "keep"
+
+    def add_or_update(self, base_ciid: str, related_ciids: List[str], merge_strategy_related_ciids: str = 'replace'):
+        related_ciids_non_duplicates = list(set(related_ciids)) # NOTE: list(set(...)) ensures uniqueness
+        index = self.lookup_table.get(base_ciid, None)
+        if index is not None:
+            # give caller the choice on how to merge related_ciids
+            if merge_strategy_related_ciids == 'replace':
+                # simply replace existing related_ciids dictionary with new dictionary
+                self.ok_list[index].update({'related_ciids': related_ciids_non_duplicates})
+                self.keeps.update([(base_ciid, related_ciid) for related_ciid in related_ciids_non_duplicates])
+            elif merge_strategy_related_ciids == 'merge':
+                exsting_related_ciids = self.ok_list[index]['related_ciids']
+                final_related_ciids = list(set(exsting_related_ciids + related_ciids_non_duplicates)) # NOTE: list(set(...)) ensures uniqueness
+                self.ok_list[index].update({'related_ciids': final_related_ciids})
+                self.keeps.update([(base_ciid, related_ciid) for related_ciid in related_ciids_non_duplicates])
+            else:
+                raise Exception(f"Unknown value for merge_strategy_related_ciids: {merge_strategy_related_ciids}")
+        else:
+            self.ok_list.append({'base_ciid': base_ciid, 'related_ciids': related_ciids_non_duplicates})
+            self.keeps.update([(base_ciid, related_ciid) for related_ciid in related_ciids_non_duplicates])
+            self.lookup_table[base_ciid] = len(self.ok_list) - 1
+
+    def build_inverse_list(self) -> Self:
+        tmp = dict()
+        for d in self.ok_list:
+            for r in d['related_ciids']:
+                existing = tmp.get(r, None)
+                if existing is None:
+                    tmp[r] = [d['base_ciid']]
+                else:
+                    existing.append(d['base_ciid'])
+        
+        final_list = [{'base_ciid': k, 'related_ciids': v} for k, v in tmp.items()]
+        return OKRelationList(final_list)
+
+    def get_related_ciids(self, base_ciid: str, keep_only: bool, default = []) -> List[str]:
+        index = self.lookup_table.get(base_ciid, None)
+        if index is None:
+            return default
+        
+        related_ciids = self.ok_list[index]["related_ciids"]
+        if keep_only:
+            return [related_ciid for related_ciid in related_ciids if (base_ciid, related_ciid) in self.keeps]
+        else:
+            return related_ciids
+    
+    def get_relevant_ciids(self) -> List[str]:
+        return [d['base_ciid'] for d in self.ok_list]
+    
+    def get_final_list(self) -> List[Dict[str, Any]]:
+        final = []
+        for item in self.ok_list:
+            final_related_ciids = [related_ciid for related_ciid in item['related_ciids'] if (item['base_ciid'], related_ciid) in self.keeps]
+            if len(final_related_ciids) > 0:
+                # HACK, TODO: rework client library to not have to rewrite keys
+                # final.append({'base_ciid': item['base_ciid'], 'related_ciids': final_related_ciids})
+                final.append({'baseCIID': item['base_ciid'], 'relatedCIIDs': final_related_ciids})
+
+        return final
```

## omnikeeper_client/typing.py

 * *Ordering differences only*

```diff
@@ -1,177 +1,177 @@
-from typing import (
-    List,
-    Dict,
-    Any,
-    Optional,
-)
-
-import json
-import uuid
-
-ATTRIBUTETYPE_TEXT = "TEXT"
-ATTRIBUTETYPE_MULTILINE_TEXT = "MULTILINE_TEXT"
-ATTRIBUTETYPE_INTEGER = "INTEGER"
-ATTRIBUTETYPE_DOUBLE = "DOUBLE"
-ATTRIBUTETYPE_BOOLEAN = "BOOLEAN"
-ATTRIBUTETYPE_JSON = "JSON"
-
-_TYPECONVERSIONMAP_FROM_MERGEDATTRIBUTE = {
-    ATTRIBUTETYPE_TEXT: str,
-    ATTRIBUTETYPE_MULTILINE_TEXT: str,
-    ATTRIBUTETYPE_INTEGER: int,
-    ATTRIBUTETYPE_DOUBLE: float,
-    ATTRIBUTETYPE_BOOLEAN: bool,
-    ATTRIBUTETYPE_JSON: json.loads,
-}
-
-# TODO add more convert functions other TEXT and integer, remove lambda and write str directly if wanted
-_TYPECONVERSIONMAP_TO_MERGEDATTRIBUTE = {
-    ATTRIBUTETYPE_TEXT: lambda x: str(x),
-    ATTRIBUTETYPE_MULTILINE_TEXT: lambda x: str(x),
-    ATTRIBUTETYPE_INTEGER: lambda x: str(x),
-    ATTRIBUTETYPE_DOUBLE: lambda x: str(x),
-    ATTRIBUTETYPE_BOOLEAN: bool,
-    ATTRIBUTETYPE_JSON: json.dumps,
-}
-
-def attributevalue_to_pythonvalue(attribute_value: Dict[str, Any]) -> Any:
-    """converts a single merged attribute value to a native python value of equivalent type
-    
-    Parameters
-    ----------
-    
-    attribute_value : Dict[str, Any]
-        attribute to convert, expects dict containing {"type": ... , "isArray": ... , "values": ... }
-
-    Returns
-    -------
-    Any
-        attributevalue converted to native python type
-    """
-    type = attribute_value['type']
-    values = attribute_value['values']
-
-    if type in _TYPECONVERSIONMAP_FROM_MERGEDATTRIBUTE:
-        if attribute_value['isArray']:
-            return [_TYPECONVERSIONMAP_FROM_MERGEDATTRIBUTE[type](v) for v in values]
-        else:
-            return _TYPECONVERSIONMAP_FROM_MERGEDATTRIBUTE[type](values[0])
-
-    else:
-        raise NotImplementedError(f"type conversion for merged attribute type {type} not implemented")
-
-def attributes_to_dict(attributes: List[Dict[str, Any]]) -> Dict[str, Any]:
-    """converts a mergedAttributes list to native python attribute dictionary
-
-    Parameters
-    ----------
-    attributes: List[Dict[str, Any]] 
-        list of attributes
-
-    Returns
-    -------
-    Dict[str, Any]
-        attribute key, value dict
-    """
-    return {attribute['attribute']['name']: attributevalue_to_pythonvalue(attribute['attribute']['value']) for attribute in attributes}
-
-def _detect_single_attributetype(value : Any) -> str:
-    """tries to transform any given legacy value to attribute type if unsure TEXT type is returned
-    
-    Parameters
-    ----------
-    value : Any
-        the value to be inspected
-
-    Returns
-    -------
-    str
-        the corresponding ATTRIBUTETYPE
-    """
-
-    # print (type(value))
-
-    # a simple plan
-    simple_types = {
-        int : ATTRIBUTETYPE_INTEGER,
-        float : ATTRIBUTETYPE_DOUBLE,
-        bool : ATTRIBUTETYPE_BOOLEAN,
-        dict : ATTRIBUTETYPE_JSON,
-        list : ATTRIBUTETYPE_JSON, # this is need for List of List
-    }
-    if type(value) in simple_types:
-        return simple_types[type(value)]
-    
-    # string is a bit more complex as we look out for multiline signs
-    if type(value) == str:
-        if "\n" in value:
-            return ATTRIBUTETYPE_MULTILINE_TEXT
-        if "\r" in value:
-            return ATTRIBUTETYPE_MULTILINE_TEXT
-        
-        return ATTRIBUTETYPE_TEXT
-    
-    return ATTRIBUTETYPE_TEXT
-
-def dict_to_attributes(ciid : uuid.UUID, native_attribute_dict : Dict[str, Any], type_hints : Dict[str, str] = {}, type_hints_isarray : Dict[str, bool] = {}) -> List[Dict[str, Any]]:
-    """converts a native python attribute dictionary to a omnikeeper mergedAttributes list
-    
-    Parameters
-    ----------
-    ciid : uuid.UUID
-        ciid to write attributes for 
-
-    native_attribute_dict : Dict[str, Any] 
-        attribute key, value dict  
-
-    type_hints : Dict[str, str]
-        an optional hint map to override types and not use autodetect
-
-    type_hints_isarray : Dict[str, bool]
-        an optional hint map to override isArray and not use autodetect        
-
-    Returns
-    -------
-    List[Dict[str, Any]]
-        list of attributes
-    """
-
-    attributes = []
-
-    for k, v in native_attribute_dict.items():
-        # detect list/array
-        if k in type_hints_isarray:
-            is_array = type_hints_isarray[k]
-        else:
-            is_array = (type(v) == list)
-
-        # detect type
-        if k in type_hints:
-            attr_type = type_hints[k]
-        else:
-            if is_array:
-                if len(v) > 0:
-                    attr_type = _detect_single_attributetype(v[0])
-                else:
-                    # we don not know it without a hint or at least one item
-                    attr_type = ATTRIBUTETYPE_TEXT
-
-            else:
-                attr_type = _detect_single_attributetype(v)
-
-        if is_array:
-            attr_values = [_TYPECONVERSIONMAP_TO_MERGEDATTRIBUTE[attr_type](item) for item in v]
-        else:
-            attr_values = [_TYPECONVERSIONMAP_TO_MERGEDATTRIBUTE[attr_type](v)]
-
-        attributes.append({
-            "ci": str(ciid),
-            "name": k,
-            "value": {
-                "type": attr_type,
-                "isArray": is_array,
-                "values": attr_values,
-            }
-        })
-
-    return attributes
+from typing import (
+    List,
+    Dict,
+    Any,
+    Optional,
+)
+
+import json
+import uuid
+
+ATTRIBUTETYPE_TEXT = "TEXT"
+ATTRIBUTETYPE_MULTILINE_TEXT = "MULTILINE_TEXT"
+ATTRIBUTETYPE_INTEGER = "INTEGER"
+ATTRIBUTETYPE_DOUBLE = "DOUBLE"
+ATTRIBUTETYPE_BOOLEAN = "BOOLEAN"
+ATTRIBUTETYPE_JSON = "JSON"
+
+_TYPECONVERSIONMAP_FROM_MERGEDATTRIBUTE = {
+    ATTRIBUTETYPE_TEXT: str,
+    ATTRIBUTETYPE_MULTILINE_TEXT: str,
+    ATTRIBUTETYPE_INTEGER: int,
+    ATTRIBUTETYPE_DOUBLE: float,
+    ATTRIBUTETYPE_BOOLEAN: bool,
+    ATTRIBUTETYPE_JSON: json.loads,
+}
+
+# TODO add more convert functions other TEXT and integer, remove lambda and write str directly if wanted
+_TYPECONVERSIONMAP_TO_MERGEDATTRIBUTE = {
+    ATTRIBUTETYPE_TEXT: lambda x: str(x),
+    ATTRIBUTETYPE_MULTILINE_TEXT: lambda x: str(x),
+    ATTRIBUTETYPE_INTEGER: lambda x: str(x),
+    ATTRIBUTETYPE_DOUBLE: lambda x: str(x),
+    ATTRIBUTETYPE_BOOLEAN: bool,
+    ATTRIBUTETYPE_JSON: json.dumps,
+}
+
+def attributevalue_to_pythonvalue(attribute_value: Dict[str, Any]) -> Any:
+    """converts a single merged attribute value to a native python value of equivalent type
+    
+    Parameters
+    ----------
+    
+    attribute_value : Dict[str, Any]
+        attribute to convert, expects dict containing {"type": ... , "isArray": ... , "values": ... }
+
+    Returns
+    -------
+    Any
+        attributevalue converted to native python type
+    """
+    type = attribute_value['type']
+    values = attribute_value['values']
+
+    if type in _TYPECONVERSIONMAP_FROM_MERGEDATTRIBUTE:
+        if attribute_value['isArray']:
+            return [_TYPECONVERSIONMAP_FROM_MERGEDATTRIBUTE[type](v) for v in values]
+        else:
+            return _TYPECONVERSIONMAP_FROM_MERGEDATTRIBUTE[type](values[0])
+
+    else:
+        raise NotImplementedError(f"type conversion for merged attribute type {type} not implemented")
+
+def attributes_to_dict(attributes: List[Dict[str, Any]]) -> Dict[str, Any]:
+    """converts a mergedAttributes list to native python attribute dictionary
+
+    Parameters
+    ----------
+    attributes: List[Dict[str, Any]] 
+        list of attributes
+
+    Returns
+    -------
+    Dict[str, Any]
+        attribute key, value dict
+    """
+    return {attribute['attribute']['name']: attributevalue_to_pythonvalue(attribute['attribute']['value']) for attribute in attributes}
+
+def _detect_single_attributetype(value : Any) -> str:
+    """tries to transform any given legacy value to attribute type if unsure TEXT type is returned
+    
+    Parameters
+    ----------
+    value : Any
+        the value to be inspected
+
+    Returns
+    -------
+    str
+        the corresponding ATTRIBUTETYPE
+    """
+
+    # print (type(value))
+
+    # a simple plan
+    simple_types = {
+        int : ATTRIBUTETYPE_INTEGER,
+        float : ATTRIBUTETYPE_DOUBLE,
+        bool : ATTRIBUTETYPE_BOOLEAN,
+        dict : ATTRIBUTETYPE_JSON,
+        list : ATTRIBUTETYPE_JSON, # this is need for List of List
+    }
+    if type(value) in simple_types:
+        return simple_types[type(value)]
+    
+    # string is a bit more complex as we look out for multiline signs
+    if type(value) == str:
+        if "\n" in value:
+            return ATTRIBUTETYPE_MULTILINE_TEXT
+        if "\r" in value:
+            return ATTRIBUTETYPE_MULTILINE_TEXT
+        
+        return ATTRIBUTETYPE_TEXT
+    
+    return ATTRIBUTETYPE_TEXT
+
+def dict_to_attributes(ciid : uuid.UUID, native_attribute_dict : Dict[str, Any], type_hints : Dict[str, str] = {}, type_hints_isarray : Dict[str, bool] = {}) -> List[Dict[str, Any]]:
+    """converts a native python attribute dictionary to a omnikeeper mergedAttributes list
+    
+    Parameters
+    ----------
+    ciid : uuid.UUID
+        ciid to write attributes for 
+
+    native_attribute_dict : Dict[str, Any] 
+        attribute key, value dict  
+
+    type_hints : Dict[str, str]
+        an optional hint map to override types and not use autodetect
+
+    type_hints_isarray : Dict[str, bool]
+        an optional hint map to override isArray and not use autodetect        
+
+    Returns
+    -------
+    List[Dict[str, Any]]
+        list of attributes
+    """
+
+    attributes = []
+
+    for k, v in native_attribute_dict.items():
+        # detect list/array
+        if k in type_hints_isarray:
+            is_array = type_hints_isarray[k]
+        else:
+            is_array = (type(v) == list)
+
+        # detect type
+        if k in type_hints:
+            attr_type = type_hints[k]
+        else:
+            if is_array:
+                if len(v) > 0:
+                    attr_type = _detect_single_attributetype(v[0])
+                else:
+                    # we don not know it without a hint or at least one item
+                    attr_type = ATTRIBUTETYPE_TEXT
+
+            else:
+                attr_type = _detect_single_attributetype(v)
+
+        if is_array:
+            attr_values = [_TYPECONVERSIONMAP_TO_MERGEDATTRIBUTE[attr_type](item) for item in v]
+        else:
+            attr_values = [_TYPECONVERSIONMAP_TO_MERGEDATTRIBUTE[attr_type](v)]
+
+        attributes.append({
+            "ci": str(ciid),
+            "name": k,
+            "value": {
+                "type": attr_type,
+                "isArray": is_array,
+                "values": attr_values,
+            }
+        })
+
+    return attributes
```

## omnikeeper_client/util.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-import webcolors
-import json
-
-from typing import (
-    Any
-)
-
-def hex_string_to_rgb_color(hex: str) -> int:
-    (r,g,b) = webcolors.hex_to_rgb(hex)
-    return (r << 16) | (g << 8) | (b)
-
-def json_pretty(data : Any) -> None:
-    return json.dumps(data, indent=2)
-
-# utility function that converts an arbitrary class object into a dict, recursively
-# taken from https://gist.github.com/sungitly/3f75cb297572dace2937
-def to_dict(item):
-    match item:
-        case dict():
-            data = {}
-            for k, v in item.items():
-                data[k] = to_dict(v)
-            return data
-        case list() | tuple():
-            return [to_dict(x) for x in item]
-        case object(__dict__=_):
-            data = {}
-            for k, v in item.__dict__.items():
-                if not k.startswith("_"):
-                    data[k] = to_dict(v)
-            return data
-        case _:
-            return item
+import webcolors
+import json
+
+from typing import (
+    Any
+)
+
+def hex_string_to_rgb_color(hex: str) -> int:
+    (r,g,b) = webcolors.hex_to_rgb(hex)
+    return (r << 16) | (g << 8) | (b)
+
+def json_pretty(data : Any) -> None:
+    return json.dumps(data, indent=2)
+
+# utility function that converts an arbitrary class object into a dict, recursively
+# taken from https://gist.github.com/sungitly/3f75cb297572dace2937
+def to_dict(item):
+    match item:
+        case dict():
+            data = {}
+            for k, v in item.items():
+                data[k] = to_dict(v)
+            return data
+        case list() | tuple():
+            return [to_dict(x) for x in item]
+        case object(__dict__=_):
+            data = {}
+            for k, v in item.__dict__.items():
+                if not k.startswith("_"):
+                    data[k] = to_dict(v)
+            return data
+        case _:
+            return item
```

## Comparing `omnikeeper_client-5.4.0.dist-info/LICENSE` & `omnikeeper_client-6.0.0.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,201 +1,201 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
```

## Comparing `omnikeeper_client-5.4.0.dist-info/METADATA` & `omnikeeper_client-6.0.0.dist-info/METADATA`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,17 @@
-Metadata-Version: 2.1
-Name: omnikeeper-client
-Version: 5.4.0
-Summary: Python library containing helper functions for implementing omnikeeper clients
-Home-page: UNKNOWN
-Author: Maximilian Csuk
-License: Apache 2.0
-Platform: UNKNOWN
-License-File: LICENSE
-Requires-Dist: appengine-python-standard ~=1.1
-Requires-Dist: gql ~=3.4
-Requires-Dist: oauthlib ~=3.2
-Requires-Dist: pandas >=2.0
-Requires-Dist: pydantic ~=2.6
-Requires-Dist: python-json-logger ~=2.0
-Requires-Dist: requests-oauthlib ~=1.3
-Requires-Dist: requests-toolbelt ~=0.10
-Requires-Dist: webcolors ~=1.3
-
-UNKNOWN
-
+Metadata-Version: 2.1
+Name: omnikeeper-client
+Version: 6.0.0
+Summary: Python library containing helper functions for implementing omnikeeper clients
+Author: Maximilian Csuk
+License: Apache 2.0
+License-File: LICENSE
+Requires-Dist: appengine-python-standard ~=1.1
+Requires-Dist: gql ~=3.4
+Requires-Dist: oauthlib ~=3.2
+Requires-Dist: pandas >=2.0
+Requires-Dist: python-json-logger ~=2.0
+Requires-Dist: requests-oauthlib ~=1.3
+Requires-Dist: requests-toolbelt ~=0.10
+Requires-Dist: webcolors ~=1.3
+Requires-Dist: pydantic ~=2.6
+
```

## Comparing `omnikeeper_client-5.4.0.dist-info/RECORD` & `omnikeeper_client-6.0.0.dist-info/RECORD`

 * *Files 25% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-omnikeeper_client/__init__.py,sha256=OG6WLJCy_eYyqi8a3cJPmOCR8-sW_0FBUFq-gtp-ZVw,1344
-omnikeeper_client/apiclient.py,sha256=X2NMaqM23pGLmDFDV2ueJnJzGdUEjz1WLrVvlWkYaGA,1984
-omnikeeper_client/ci.py,sha256=hXYsfDbMNvIy32CbStar1ade3ifH6VTL4VjxF9ICy1I,5040
-omnikeeper_client/dataframes.py,sha256=1G-k_IhPejA1UpR0_JYzLSgEBkVymD24gWNpWC5aHC0,3796
-omnikeeper_client/issues.py,sha256=APnn2Li0spekUj3ygZe2bnYmo2x9fr_eybhl6jNYueI,1080
-omnikeeper_client/layer.py,sha256=To0INBUjgOiIuwwcMRo3wdT1mIbwcm-cVjJ4Lqh0SwI,3232
-omnikeeper_client/pyd.py,sha256=8AQVtMzxz2tkDP8z-0MCLA0meLOxmtEMBHQxI_f6Uwk,2765
-omnikeeper_client/simple_traits.py,sha256=yduQQKL93hUOBe6NQBBHchrtC8qr-kl8BU29b5cnbls,10639
-omnikeeper_client/trait.py,sha256=mPn46R2Aj5x1F6us_Z5VQ2iXf2pYQW9osSgItcQ8L5Q,4574
-omnikeeper_client/traitentities.py,sha256=ecjnzHKSzLf8GFNOFC3n4XN6riv7tX5FNIJ0L0ZBTbE,24876
-omnikeeper_client/typing.py,sha256=dLzATV6Ez3VhPMEGdnsLKkZNS1aFgfURYbRKHiAGEFE,5262
-omnikeeper_client/util.py,sha256=Htf_rrlvd6usJ-ONWOU1l0Bz_CnisjQrlRzNODppiZg,917
-omnikeeper_client-5.4.0.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-omnikeeper_client-5.4.0.dist-info/METADATA,sha256=Dw7GpDifMFjB2Nnet7fmZwfhqlXEW-5Rqda66urpruo,572
-omnikeeper_client-5.4.0.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
-omnikeeper_client-5.4.0.dist-info/top_level.txt,sha256=3VgpRS-e1mbaX1mKkPt9Mszwazf6tc1Tk3GORBV6ijk,18
-omnikeeper_client-5.4.0.dist-info/RECORD,,
+omnikeeper_client/__init__.py,sha256=hL_-TBYAWluHiFXio0LF7wbjNOfs1De7J-Y0Taeqhuw,1415
+omnikeeper_client/apiclient.py,sha256=Wq1i0mulgoHGUvj0_g1tZCEffnhTxvfe1XEWbrm2zrs,2045
+omnikeeper_client/ci.py,sha256=c_P-_uLvInTALzJvC06n8HJ6iCgS14RZ2pKee91AMKI,5211
+omnikeeper_client/dataframes.py,sha256=0snXt4Io2HBxlsGc28OI6OnTm-Qyj06nyk0AA-P-sh4,3907
+omnikeeper_client/issues.py,sha256=gFjc5PhniIMUQIthBoMG1s3enG8ExWeoRhBcZcZrQJo,1206
+omnikeeper_client/layer.py,sha256=9r928gw20H_0TYFfPv972cLAiX4B-HdCny3j_F9L-vc,3354
+omnikeeper_client/pyd.py,sha256=h2Va7Gd4-I0p6X6Yizv2ebExgsukDKIjYCxjCOddCi4,2854
+omnikeeper_client/simple_traits.py,sha256=HkPV4Rkf70oDXUwhSSA9dVEHCxtI5K3uGd4XmRQaUaA,10855
+omnikeeper_client/trait.py,sha256=RU312IWCCKpwso2xn1X4LumZzwnKga53UTxnHBtufxU,4717
+omnikeeper_client/traitentities.py,sha256=41wmOWW-TWKpHzq0_juigYxzRxSRwftoVath8B_eFtg,26923
+omnikeeper_client/typing.py,sha256=ULabK159CSXDtdjnIAapygV5uewbORVpIU7DCCuCIUM,5439
+omnikeeper_client/util.py,sha256=Cl9HnU5nc4XXmg8I5wUeirt50lLkGKiLnUHhKZeYtCE,950
+omnikeeper_client-6.0.0.dist-info/LICENSE,sha256=HrhfyXIkWY2tGFK11kg7vPCqhgh5DcxleloqdhrpyMY,11558
+omnikeeper_client-6.0.0.dist-info/METADATA,sha256=DPz8RBqbt19BK_sDVxCG-E2geb84DCP0cmCu4hp8lvc,543
+omnikeeper_client-6.0.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+omnikeeper_client-6.0.0.dist-info/top_level.txt,sha256=3VgpRS-e1mbaX1mKkPt9Mszwazf6tc1Tk3GORBV6ijk,18
+omnikeeper_client-6.0.0.dist-info/RECORD,,
```

