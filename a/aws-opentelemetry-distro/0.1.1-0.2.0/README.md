# Comparing `tmp/aws_opentelemetry_distro-0.1.1-py3-none-any.whl.zip` & `tmp/aws_opentelemetry_distro-0.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,22 @@
-Zip file size: 49681 bytes, number of entries: 35
--rw-r--r--  2.0 unx      887 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/_aws_attribute_keys.py
--rw-r--r--  2.0 unx    16342 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/_aws_metric_attribute_generator.py
--rw-r--r--  2.0 unx     7337 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/_aws_span_processing_util.py
+Zip file size: 50903 bytes, number of entries: 35
+-rw-r--r--  2.0 unx      972 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/_aws_attribute_keys.py
+-rw-r--r--  2.0 unx    21249 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/_aws_metric_attribute_generator.py
+-rw-r--r--  2.0 unx     7648 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/_aws_span_processing_util.py
 -rw-r--r--  2.0 unx     2539 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/always_record_sampler.py
 -rw-r--r--  2.0 unx     4671 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/attribute_propagating_span_processor.py
 -rw-r--r--  2.0 unx     2408 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/attribute_propagating_span_processor_builder.py
 -rw-r--r--  2.0 unx     5992 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/aws_metric_attributes_span_exporter.py
 -rw-r--r--  2.0 unx     1466 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/aws_metric_attributes_span_exporter_builder.py
 -rw-r--r--  2.0 unx    14094 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/aws_opentelemetry_configurator.py
--rw-r--r--  2.0 unx     2592 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/aws_opentelemetry_distro.py
+-rw-r--r--  2.0 unx     3544 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/aws_opentelemetry_distro.py
 -rw-r--r--  2.0 unx     5235 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/aws_span_metrics_processor.py
 -rw-r--r--  2.0 unx     2872 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/aws_span_metrics_processor_builder.py
 -rw-r--r--  2.0 unx     1425 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/metric_attribute_generator.py
--rw-r--r--  2.0 unx     4072 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sqs_url_parser.py
+-rw-r--r--  2.0 unx     1628 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sqs_url_parser.py
 -rw-r--r--  2.0 unx      130 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/version.py
 -rw-r--r--  2.0 unx    16500 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/configuration/sql_dialect_keywords.json
 -rw-r--r--  2.0 unx     4172 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/patches/_botocore_patches.py
 -rw-r--r--  2.0 unx     1841 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/patches/_instrumentation_patch.py
 -rw-r--r--  2.0 unx     1623 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/patches/_resource_detector_patches.py
 -rw-r--r--  2.0 unx     4146 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sampler/_aws_xray_sampling_client.py
 -rw-r--r--  2.0 unx      642 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sampler/_clock.py
@@ -26,12 +26,12 @@
 -rw-r--r--  2.0 unx     1615 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sampler/_rate_limiting_sampler.py
 -rw-r--r--  2.0 unx     6041 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sampler/_rule_cache.py
 -rw-r--r--  2.0 unx     2729 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sampler/_sampling_rule.py
 -rw-r--r--  2.0 unx     9461 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sampler/_sampling_rule_applier.py
 -rw-r--r--  2.0 unx     1017 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sampler/_sampling_statistics_document.py
 -rw-r--r--  2.0 unx     2263 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sampler/_sampling_target.py
 -rw-r--r--  2.0 unx     6747 b- defN 20-Feb-02 00:00 amazon/opentelemetry/distro/sampler/aws_xray_remote_sampler.py
-?rw-r--r--  2.0 unx     4682 b- defN 20-Feb-02 00:00 aws_opentelemetry_distro-0.1.1.dist-info/METADATA
-?rw-r--r--  2.0 unx       87 b- defN 20-Feb-02 00:00 aws_opentelemetry_distro-0.1.1.dist-info/WHEEL
-?rw-r--r--  2.0 unx      249 b- defN 20-Feb-02 00:00 aws_opentelemetry_distro-0.1.1.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx     3940 b- defN 20-Feb-02 00:00 aws_opentelemetry_distro-0.1.1.dist-info/RECORD
-35 files, 145844 bytes uncompressed, 42995 bytes compressed:  70.5%
+?rw-r--r--  2.0 unx     4749 b- defN 20-Feb-02 00:00 aws_opentelemetry_distro-0.2.0.dist-info/METADATA
+?rw-r--r--  2.0 unx       87 b- defN 20-Feb-02 00:00 aws_opentelemetry_distro-0.2.0.dist-info/WHEEL
+?rw-r--r--  2.0 unx      249 b- defN 20-Feb-02 00:00 aws_opentelemetry_distro-0.2.0.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx     3940 b- defN 20-Feb-02 00:00 aws_opentelemetry_distro-0.2.0.dist-info/RECORD
+35 files, 149722 bytes uncompressed, 44217 bytes compressed:  70.5%
```

## zipnote {}

```diff
@@ -87,20 +87,20 @@
 
 Filename: amazon/opentelemetry/distro/sampler/_sampling_target.py
 Comment: 
 
 Filename: amazon/opentelemetry/distro/sampler/aws_xray_remote_sampler.py
 Comment: 
 
-Filename: aws_opentelemetry_distro-0.1.1.dist-info/METADATA
+Filename: aws_opentelemetry_distro-0.2.0.dist-info/METADATA
 Comment: 
 
-Filename: aws_opentelemetry_distro-0.1.1.dist-info/WHEEL
+Filename: aws_opentelemetry_distro-0.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: aws_opentelemetry_distro-0.1.1.dist-info/entry_points.txt
+Filename: aws_opentelemetry_distro-0.2.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: aws_opentelemetry_distro-0.1.1.dist-info/RECORD
+Filename: aws_opentelemetry_distro-0.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## amazon/opentelemetry/distro/_aws_attribute_keys.py

```diff
@@ -2,15 +2,16 @@
 # SPDX-License-Identifier: Apache-2.0
 """Utility module holding attribute keys with special meaning to AWS components"""
 AWS_SPAN_KIND: str = "aws.span.kind"
 AWS_LOCAL_SERVICE: str = "aws.local.service"
 AWS_LOCAL_OPERATION: str = "aws.local.operation"
 AWS_REMOTE_SERVICE: str = "aws.remote.service"
 AWS_REMOTE_OPERATION: str = "aws.remote.operation"
-AWS_REMOTE_TARGET: str = "aws.remote.target"
+AWS_REMOTE_RESOURCE_TYPE: str = "aws.remote.resource.type"
+AWS_REMOTE_RESOURCE_IDENTIFIER: str = "aws.remote.resource.identifier"
 AWS_SDK_DESCENDANT: str = "aws.sdk.descendant"
 AWS_CONSUMER_PARENT_SPAN_KIND: str = "aws.consumer.parent.span.kind"
 
 # AWS_#_NAME attributes are not supported in python as they are not part of the Semantic Conventions.
 # TODOï¼šMove to Semantic Conventions when these attributes are added.
 AWS_QUEUE_URL: str = "aws.sqs.queue_url"
 AWS_QUEUE_NAME: str = "aws.sqs.queue_name"
```

## amazon/opentelemetry/distro/_aws_metric_attribute_generator.py

```diff
@@ -7,16 +7,17 @@
 
 from amazon.opentelemetry.distro._aws_attribute_keys import (
     AWS_LOCAL_OPERATION,
     AWS_LOCAL_SERVICE,
     AWS_QUEUE_NAME,
     AWS_QUEUE_URL,
     AWS_REMOTE_OPERATION,
+    AWS_REMOTE_RESOURCE_IDENTIFIER,
+    AWS_REMOTE_RESOURCE_TYPE,
     AWS_REMOTE_SERVICE,
-    AWS_REMOTE_TARGET,
     AWS_SPAN_KIND,
     AWS_STREAM_NAME,
 )
 from amazon.opentelemetry.distro._aws_span_processing_util import (
     LOCAL_ROOT,
     MAX_KEYWORD_LENGTH,
     SQL_KEYWORD_PATTERN,
@@ -24,14 +25,15 @@
     UNKNOWN_REMOTE_OPERATION,
     UNKNOWN_REMOTE_SERVICE,
     UNKNOWN_SERVICE,
     extract_api_path_value,
     get_egress_operation,
     get_ingress_operation,
     is_aws_sdk_span,
+    is_db_span,
     is_key_present,
     is_local_root,
     should_generate_dependency_metric_attributes,
     should_generate_service_metric_attributes,
 )
 from amazon.opentelemetry.distro.metric_attribute_generator import (
     DEPENDENCY_METRIC,
@@ -41,14 +43,16 @@
 from amazon.opentelemetry.distro.sqs_url_parser import SqsUrlParser
 from opentelemetry.sdk.resources import Resource, ResourceAttributes
 from opentelemetry.sdk.trace import BoundedAttributes, ReadableSpan
 from opentelemetry.semconv.trace import SpanAttributes
 
 # Pertinent OTEL attribute keys
 _SERVICE_NAME: str = ResourceAttributes.SERVICE_NAME
+_DB_CONNECTION_STRING: str = SpanAttributes.DB_CONNECTION_STRING
+_DB_NAME: str = SpanAttributes.DB_NAME
 _DB_OPERATION: str = SpanAttributes.DB_OPERATION
 _DB_STATEMENT: str = SpanAttributes.DB_STATEMENT
 _DB_SYSTEM: str = SpanAttributes.DB_SYSTEM
 _FAAS_INVOKED_NAME: str = SpanAttributes.FAAS_INVOKED_NAME
 _FAAS_TRIGGER: str = SpanAttributes.FAAS_TRIGGER
 _GRAPHQL_OPERATION_TYPE: str = SpanAttributes.GRAPHQL_OPERATION_TYPE
 _HTTP_METHOD: str = SpanAttributes.HTTP_METHOD
@@ -58,17 +62,28 @@
 _NET_PEER_NAME: str = SpanAttributes.NET_PEER_NAME
 _NET_PEER_PORT: str = SpanAttributes.NET_PEER_PORT
 _NET_SOCK_PEER_ADDR: str = SpanAttributes.NET_SOCK_PEER_ADDR
 _NET_SOCK_PEER_PORT: str = SpanAttributes.NET_SOCK_PEER_PORT
 _PEER_SERVICE: str = SpanAttributes.PEER_SERVICE
 _RPC_METHOD: str = SpanAttributes.RPC_METHOD
 _RPC_SERVICE: str = SpanAttributes.RPC_SERVICE
+_SERVER_ADDRESS: str = SpanAttributes.SERVER_ADDRESS
+_SERVER_PORT: str = SpanAttributes.SERVER_PORT
+_SERVER_SOCKET_ADDRESS: str = SpanAttributes.SERVER_SOCKET_ADDRESS
+_SERVER_SOCKET_PORT: str = SpanAttributes.SERVER_SOCKET_PORT
 _AWS_TABLE_NAMES: str = SpanAttributes.AWS_DYNAMODB_TABLE_NAMES
 _AWS_BUCKET_NAME: str = SpanAttributes.AWS_S3_BUCKET
 
+# Normalized remote service names for supported AWS services
+_NORMALIZED_DYNAMO_DB_SERVICE_NAME: str = "AWS::DynamoDB"
+_NORMALIZED_KINESIS_SERVICE_NAME: str = "AWS::Kinesis"
+_NORMALIZED_S3_SERVICE_NAME: str = "AWS::S3"
+_NORMALIZED_SQS_SERVICE_NAME: str = "AWS::SQS"
+_DB_CONNECTION_STRING_TYPE: str = "DB::Connection"
+
 # Special DEPENDENCY attribute value if GRAPHQL_OPERATION_TYPE attribute key is present.
 _GRAPHQL: str = "graphql"
 
 # As per https://opentelemetry.io/docs/specs/semconv/resource/#service, if service name is not specified, SDK defaults
 # the service name to unknown_service:<process name> or just unknown_service.
 _OTEL_UNKNOWN_SERVICE_PREFIX: str = "unknown_service"
 
@@ -106,15 +121,15 @@
 
 
 def _generate_dependency_metric_attributes(span: ReadableSpan, resource: Resource) -> BoundedAttributes:
     attributes: BoundedAttributes = BoundedAttributes(immutable=False)
     _set_service(resource, span, attributes)
     _set_egress_operation(span, attributes)
     _set_remote_service_and_operation(span, attributes)
-    _set_remote_target(span, attributes)
+    _set_remote_type_and_identifier(span, attributes)
     _set_span_kind_for_dependency(span, attributes)
     return attributes
 
 
 def _set_service(resource: Resource, span: ReadableSpan, attributes: BoundedAttributes) -> None:
     """Service is always derived from SERVICE_NAME"""
     service: str = resource.attributes.get(_SERVICE_NAME)
@@ -194,17 +209,17 @@
     """
     remote_service: str = UNKNOWN_REMOTE_SERVICE
     remote_operation: str = UNKNOWN_REMOTE_OPERATION
     if is_key_present(span, AWS_REMOTE_SERVICE) or is_key_present(span, AWS_REMOTE_OPERATION):
         remote_service = _get_remote_service(span, AWS_REMOTE_SERVICE)
         remote_operation = _get_remote_operation(span, AWS_REMOTE_OPERATION)
     elif is_key_present(span, _RPC_SERVICE) or is_key_present(span, _RPC_METHOD):
-        remote_service = _normalize_service_name(span, _get_remote_service(span, _RPC_SERVICE))
+        remote_service = _normalize_remote_service_name(span, _get_remote_service(span, _RPC_SERVICE))
         remote_operation = _get_remote_operation(span, _RPC_METHOD)
-    elif is_key_present(span, _DB_SYSTEM) or is_key_present(span, _DB_OPERATION) or is_key_present(span, _DB_STATEMENT):
+    elif is_db_span(span):
         remote_service = _get_remote_service(span, _DB_SYSTEM)
         if is_key_present(span, _DB_OPERATION):
             remote_operation = _get_remote_operation(span, _DB_OPERATION)
         else:
             remote_operation = _get_db_statement_remote_operation(span, _DB_STATEMENT)
     elif is_key_present(span, _FAAS_INVOKED_NAME) or is_key_present(span, _FAAS_TRIGGER):
         remote_service = _get_remote_service(span, _FAAS_INVOKED_NAME)
@@ -264,18 +279,22 @@
     remote_operation = remote_operation.lstrip()[:MAX_KEYWORD_LENGTH]
     match: Optional[Match[str]] = re.match(SQL_KEYWORD_PATTERN, remote_operation.upper())
     remote_operation = match.group(0) if match else UNKNOWN_REMOTE_OPERATION
 
     return remote_operation
 
 
-def _normalize_service_name(span: ReadableSpan, service_name: str) -> str:
+def _normalize_remote_service_name(span: ReadableSpan, service_name: str) -> str:
+    """
+    If the span is an AWS SDK span, normalize the name to align with <a
+    href="https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/supported-resources.html">AWS Cloud Control
+    resource format</a> as much as possible. Long term, we would like to normalize service name in the upstream.
+    """
     if is_aws_sdk_span(span):
-        return "AWS.SDK." + service_name
-
+        return "AWS::" + service_name
     return service_name
 
 
 def _generate_remote_service(span: ReadableSpan) -> str:
     remote_service: str = UNKNOWN_REMOTE_SERVICE
     if is_key_present(span, _NET_PEER_NAME):
         remote_service = _get_remote_service(span, _NET_PEER_NAME)
@@ -316,49 +335,128 @@
 
     if remote_operation == UNKNOWN_REMOTE_OPERATION:
         _log_unknown_attribute(AWS_REMOTE_OPERATION, span)
 
     return remote_operation
 
 
-def _set_remote_target(span: ReadableSpan, attributes: BoundedAttributes) -> None:
-    remote_target: Optional[str] = _get_remote_target(span)
-    if remote_target is not None:
-        attributes[AWS_REMOTE_TARGET] = remote_target
-
-
-def _get_remote_target(span: ReadableSpan) -> Optional[str]:
+def _set_remote_type_and_identifier(span: ReadableSpan, attributes: BoundedAttributes) -> None:
     """
-    RemoteTarget attribute AWS_REMOTE_TARGET is used to store the resource
-    name of the remote invokes, such as S3 bucket name, mysql table name, etc.
-    TODO: currently only support AWS resource name, will be extended to support
-    the general remote targets, such as ActiveMQ name, etc.
+    Remote resource attributes {@link AwsAttributeKeys#AWS_REMOTE_RESOURCE_TYPE} and {@link
+    AwsAttributeKeys#AWS_REMOTE_RESOURCE_IDENTIFIER} are used to store information about the resource associated with
+    the remote invocation, such as S3 bucket name, etc. We should only ever set both type and identifier or neither.
+    If any identifier value contains | or ^ , they will be replaced with ^| or ^^.
+
+    AWS resources type and identifier adhere to <a
+    href="https://docs.aws.amazon.com/cloudcontrolapi/latest/userguide/supported-resources.html">AWS Cloud Control
+    resource format</a>.
     """
-    if is_key_present(span, _AWS_BUCKET_NAME):
-        return "::s3:::" + span.attributes.get(_AWS_BUCKET_NAME)
+    remote_resource_type: Optional[str] = None
+    remote_resource_identifier: Optional[str] = None
 
-    if is_key_present(span, AWS_QUEUE_URL):
-        arn = SqsUrlParser.get_sqs_remote_target(span.attributes.get(AWS_QUEUE_URL))
-        if arn:
-            return arn
-
-    if is_key_present(span, AWS_QUEUE_NAME):
-        return "::sqs:::" + span.attributes.get(AWS_QUEUE_NAME)
-
-    if is_key_present(span, AWS_STREAM_NAME):
-        return "::kinesis:::stream/" + span.attributes.get(AWS_STREAM_NAME)
-
-    # Only extract the table name when _AWS_TABLE_NAMES has size equals to one
-    if is_key_present(span, _AWS_TABLE_NAMES) and len(span.attributes.get(_AWS_TABLE_NAMES)) == 1:
-        return "::dynamodb:::table/" + span.attributes.get(_AWS_TABLE_NAMES)[0]
-
-    return None
+    if is_aws_sdk_span(span):
+        # Only extract the table name when _AWS_TABLE_NAMES has size equals to one
+        if is_key_present(span, _AWS_TABLE_NAMES) and len(span.attributes.get(_AWS_TABLE_NAMES)) == 1:
+            remote_resource_type = _NORMALIZED_DYNAMO_DB_SERVICE_NAME + "::Table"
+            remote_resource_identifier = _escape_delimiters(span.attributes.get(_AWS_TABLE_NAMES)[0])
+        elif is_key_present(span, AWS_STREAM_NAME):
+            remote_resource_type = _NORMALIZED_KINESIS_SERVICE_NAME + "::Stream"
+            remote_resource_identifier = _escape_delimiters(span.attributes.get(AWS_STREAM_NAME))
+        elif is_key_present(span, _AWS_BUCKET_NAME):
+            remote_resource_type = _NORMALIZED_S3_SERVICE_NAME + "::Bucket"
+            remote_resource_identifier = _escape_delimiters(span.attributes.get(_AWS_BUCKET_NAME))
+        elif is_key_present(span, AWS_QUEUE_NAME):
+            remote_resource_type = _NORMALIZED_SQS_SERVICE_NAME + "::Queue"
+            remote_resource_identifier = _escape_delimiters(span.attributes.get(AWS_QUEUE_NAME))
+        elif is_key_present(span, AWS_QUEUE_URL):
+            remote_resource_type = _NORMALIZED_SQS_SERVICE_NAME + "::Queue"
+            remote_resource_identifier = _escape_delimiters(
+                SqsUrlParser.get_queue_name(span.attributes.get(AWS_QUEUE_URL))
+            )
+    elif is_db_span(span):
+        remote_resource_type = _DB_CONNECTION_STRING_TYPE
+        remote_resource_identifier = _get_db_connection(span)
+
+    if remote_resource_type is not None and remote_resource_identifier is not None:
+        attributes[AWS_REMOTE_RESOURCE_TYPE] = remote_resource_type
+        attributes[AWS_REMOTE_RESOURCE_IDENTIFIER] = remote_resource_identifier
+
+
+def _get_db_connection(span: ReadableSpan) -> None:
+    """
+    RemoteResourceIdentifier is populated with rule:
+        ^[{db.name}|]?{address}[|{port}]?
+
+    {address} attribute is retrieved in priority order:
+    - {SpanAttributes.SERVER_ADDRESS},
+    - {SpanAttributes.NET_PEER_NAME},
+    - {SpanAttributes.SERVER_SOCKET_ADDRESS},
+    - {SpanAttributes.DB_CONNECTION_STRING}-Hostname
+
+    {port} attribute is retrieved in priority order:
+    - {SpanAttributes.SERVER_PORT},
+    - {SpanAttributes.NET_PEER_PORT},
+    - {SpanAttributes.SERVER_SOCKET_PORT},
+    - {SpanAttributes.DB_CONNECTION_STRING}-Port
+
+    If address is not present, neither RemoteResourceType nor RemoteResourceIdentifier will be provided.
+    """
+    db_name: Optional[str] = span.attributes.get(_DB_NAME)
+    db_connection: Optional[str] = None
+
+    if is_key_present(span, _SERVER_ADDRESS):
+        server_address: Optional[str] = span.attributes.get(_SERVER_ADDRESS)
+        server_port: Optional[int] = span.attributes.get(_SERVER_PORT)
+        db_connection = _build_db_connection(server_address, server_port)
+    elif is_key_present(span, _NET_PEER_NAME):
+        network_peer_address: Optional[str] = span.attributes.get(_NET_PEER_NAME)
+        network_peer_port: Optional[int] = span.attributes.get(_NET_PEER_PORT)
+        db_connection = _build_db_connection(network_peer_address, network_peer_port)
+    elif is_key_present(span, _SERVER_SOCKET_ADDRESS):
+        server_socket_address: Optional[str] = span.attributes.get(_SERVER_SOCKET_ADDRESS)
+        server_socket_port: Optional[int] = span.attributes.get(_SERVER_SOCKET_PORT)
+        db_connection = _build_db_connection(server_socket_address, server_socket_port)
+    elif is_key_present(span, _DB_CONNECTION_STRING):
+        connection_string: Optional[str] = span.attributes.get(_DB_CONNECTION_STRING)
+        db_connection = _build_db_connection_string(connection_string)
+
+    if db_connection and db_name:
+        db_connection = _escape_delimiters(db_name) + "|" + db_connection
+
+    return db_connection
+
+
+def _build_db_connection(address: str, port: int) -> Optional[str]:
+    return _escape_delimiters(address) + ("|" + str(port) if port else "")
+
+
+def _build_db_connection_string(connection_string: str) -> Optional[str]:
+
+    uri = urlparse(connection_string)
+    address = uri.hostname
+    try:
+        port = uri.port
+    except ValueError:
+        port = None
+
+    if address is None:
+        return None
+
+    port_str = "|" + str(port) if port is not None and port != -1 else ""
+    return _escape_delimiters(address) + port_str
+
+
+def _escape_delimiters(input_str: str) -> Optional[str]:
+    if input_str is None:
+        return None
+    return input_str.replace("^", "^^").replace("|", "^|")
 
 
 def _set_span_kind_for_dependency(span: ReadableSpan, attributes: BoundedAttributes) -> None:
     span_kind: str = span.kind.name
     attributes[AWS_SPAN_KIND] = span_kind
 
 
 def _log_unknown_attribute(attribute_key: str, span: ReadableSpan) -> None:
     message: str = "No valid %s value found for %s span %s"
-    _logger.log(DEBUG, message, attribute_key, span.kind.name, str(span.context.span_id))
+    if _logger.isEnabledFor(DEBUG):
+        _logger.log(DEBUG, message, attribute_key, span.kind.name, str(span.context.span_id))
```

## amazon/opentelemetry/distro/_aws_span_processing_util.py

```diff
@@ -81,14 +81,23 @@
 
 
 def is_aws_sdk_span(span: ReadableSpan) -> bool:
     # https://opentelemetry.io/docs/specs/otel/trace/semantic_conventions/instrumentation/aws-sdk/#common-attributes
     return "aws-api" == span.attributes.get(SpanAttributes.RPC_SYSTEM)
 
 
+# Check if the current Span adheres to database semantic conventions
+def is_db_span(span: ReadableSpan) -> bool:
+    return (
+        is_key_present(span, SpanAttributes.DB_SYSTEM)
+        or is_key_present(span, SpanAttributes.DB_OPERATION)
+        or is_key_present(span, SpanAttributes.DB_STATEMENT)
+    )
+
+
 def should_generate_service_metric_attributes(span: ReadableSpan) -> bool:
     return (is_local_root(span) and not _is_boto3sqs_span(span)) or SpanKind.SERVER == span.kind
 
 
 def should_generate_dependency_metric_attributes(span: ReadableSpan) -> bool:
     return (
         SpanKind.CLIENT == span.kind
```

## amazon/opentelemetry/distro/aws_opentelemetry_distro.py

```diff
@@ -1,19 +1,23 @@
 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 # SPDX-License-Identifier: Apache-2.0
 import os
+import sys
+from logging import Logger, getLogger
 
 from amazon.opentelemetry.distro.patches._instrumentation_patch import apply_instrumentation_patches
 from opentelemetry.distro import OpenTelemetryDistro
 from opentelemetry.environment_variables import OTEL_PROPAGATORS, OTEL_PYTHON_ID_GENERATOR
 from opentelemetry.sdk.environment_variables import (
     OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION,
     OTEL_EXPORTER_OTLP_PROTOCOL,
 )
 
+_logger: Logger = getLogger(__name__)
+
 
 class AwsOpenTelemetryDistro(OpenTelemetryDistro):
     def _configure(self, **kwargs):
         """Sets up default environment variables and apply patches
 
         Set default OTEL_EXPORTER_OTLP_PROTOCOL to be HTTP. This must be run before super(), which attempts to set the
         default to gRPC. If we run afterwards, we don't know if the default was set by base OpenTelemetryDistro or if it
@@ -32,14 +36,29 @@
             apply_patches: bool - apply patches to upstream instrumentation. Default is True.
 
         TODO:
          1. OTLPMetricExporterMixin is using hard coded histogram_aggregation_type, which reads
             OTEL_EXPORTER_OTLP_METRICS_DEFAULT_HISTOGRAM_AGGREGATION environment variable. Need to work with upstream to
             make it to be configurable.
         """
+
+        # Issue: https://github.com/open-telemetry/opentelemetry-python-contrib/issues/2495
+        # mimicking what is done here: https://tinyurl.com/54mvzmte
+        # For handling applications like django running in containers, we are setting the current working directory
+        # to the sys.path for the django application to find its executables.
+        #
+        # Note that we are updating the sys.path and not the PYTHONPATH env var, because once sys.path is
+        # loaded upon process start, it doesn't refresh from the PYTHONPATH value.
+        #
+        # To be removed once the issue has been fixed in https://github.com/open-telemetry/opentelemetry-python-contrib
+        cwd_path = os.getcwd()
+        _logger.debug("Current working directory path: %s", cwd_path)
+        if cwd_path not in sys.path:
+            sys.path.insert(0, cwd_path)
+
         os.environ.setdefault(OTEL_EXPORTER_OTLP_PROTOCOL, "http/protobuf")
 
         super(AwsOpenTelemetryDistro, self)._configure()
 
         os.environ.setdefault(OTEL_PROPAGATORS, "xray,tracecontext,b3,b3multi")
         os.environ.setdefault(OTEL_PYTHON_ID_GENERATOR, "xray")
         os.environ.setdefault(
```

## amazon/opentelemetry/distro/sqs_url_parser.py

```diff
@@ -1,154 +1,47 @@
 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 # SPDX-License-Identifier: Apache-2.0
 from typing import List, Optional
 
-_ARN_DELIMETER: str = ":"
 _HTTP_SCHEMA: str = "http://"
 _HTTPS_SCHEMA: str = "https://"
 
 
 class SqsUrlParser:
     @staticmethod
-    def get_sqs_remote_target(sqs_url: str) -> Optional[str]:
-        sqs_url: str = _strip_schema_from_url(sqs_url)
-
-        if not _is_sqs_url(sqs_url) and not _is_legacy_sqs_url(sqs_url) and not _is_custom_url(sqs_url):
+    def get_queue_name(url: str) -> Optional[str]:
+        """
+        Best-effort logic to extract queue name from an HTTP url. This method should only be used with a string that is,
+        with reasonably high confidence, an SQS queue URL. Handles new/legacy/some custom URLs. Essentially, we require
+        that the URL should have exactly three parts, delimited by /'s (excluding schema), the second part should be a
+        12-digit account id, and the third part should be a valid queue name, per SQS naming conventions.
+        """
+        if url is None:
             return None
-
-        region: str = _get_region(sqs_url)
-        account_id: str = _get_account_id(sqs_url)
-        partition: str = _get_partition(sqs_url)
-        queue_name: str = _get_queue_name(sqs_url)
-
-        remote_target: List[Optional[str]] = []
-
-        if all((region, account_id, partition, queue_name)):
-            remote_target.append("arn")
-
-        remote_target.extend(
-            [
-                _ARN_DELIMETER,
-                _null_to_empty(partition),
-                _ARN_DELIMETER,
-                "sqs",
-                _ARN_DELIMETER,
-                _null_to_empty(region),
-                _ARN_DELIMETER,
-                _null_to_empty(account_id),
-                _ARN_DELIMETER,
-                queue_name,
-            ]
-        )
-
-        return "".join(remote_target)
-
-
-def _strip_schema_from_url(url: str) -> str:
-    return url.replace(_HTTP_SCHEMA, "").replace(_HTTPS_SCHEMA, "")
-
-
-def _get_region(sqs_url: str) -> Optional[str]:
-    if sqs_url is None:
+        url = url.replace(_HTTP_SCHEMA, "").replace(_HTTPS_SCHEMA, "")
+        split_url: List[Optional[str]] = url.split("/")
+        if len(split_url) == 3 and _is_account_id(split_url[1]) and _is_valid_queue_name(split_url[2]):
+            return split_url[2]
         return None
 
-    if sqs_url.startswith("queue.amazonaws.com/"):
-        return "us-east-1"
-
-    if _is_sqs_url(sqs_url):
-        return _get_region_from_sqs_url(sqs_url)
-
-    if _is_legacy_sqs_url(sqs_url):
-        return _get_region_from_legacy_sqs_url(sqs_url)
-
-    return None
-
-
-def _is_sqs_url(sqs_url: str) -> bool:
-    split: List[Optional[str]] = sqs_url.split("/")
-    return (
-        len(split) == 3
-        and split[0].startswith("sqs.")
-        and split[0].endswith(".amazonaws.com")
-        and _is_account_id(split[1])
-        and _is_valid_queue_name(split[2])
-    )
-
-
-def _is_legacy_sqs_url(sqs_url: str) -> bool:
-    split: List[Optional[str]] = sqs_url.split("/")
-    return (
-        len(split) == 3
-        and split[0].endswith(".queue.amazonaws.com")
-        and _is_account_id(split[1])
-        and _is_valid_queue_name(split[2])
-    )
-
-
-def _is_custom_url(sqs_url: str) -> bool:
-    split: List[Optional[str]] = sqs_url.split("/")
-    return len(split) == 3 and _is_account_id(split[1]) and _is_valid_queue_name(split[2])
-
-
-def _is_valid_queue_name(input_str: str) -> bool:
-    if len(input_str) == 0 or len(input_str) > 80:
-        return False
-
-    for char in input_str:
-        if char != "_" and char != "-" and not char.isalpha() and not char.isdigit():
-            return False
-
-    return True
-
 
 def _is_account_id(input_str: str) -> bool:
-    if len(input_str) != 12:
+    if input_str is None or len(input_str) != 12:
         return False
 
     try:
         int(input_str)
     except ValueError:
         return False
 
     return True
 
 
-def _get_region_from_sqs_url(sqs_url: str) -> Optional[str]:
-    split: List[Optional[str]] = sqs_url.split(".")
-    return split[1] if len(split) >= 2 else None
-
-
-def _get_region_from_legacy_sqs_url(sqs_url: str) -> Optional[str]:
-    split: List[Optional[str]] = sqs_url.split(".")
-    return split[0]
-
-
-def _get_account_id(sqs_url: str) -> Optional[str]:
-    if sqs_url is None:
-        return None
-
-    split: List[Optional[str]] = sqs_url.split("/")
-    return split[1] if len(split) >= 2 else None
-
-
-def _get_partition(sqs_url: str) -> Optional[str]:
-    region: Optional[str] = _get_region(sqs_url)
-
-    if region is None:
-        return None
-
-    if region.startswith("us-gov-"):
-        return "aws-us-gov"
-
-    if region.startswith("cn-"):
-        return "aws-cn"
-
-    return "aws"
-
-
-def _get_queue_name(sqs_url: str) -> Optional[str]:
-    split: List[Optional[str]] = sqs_url.split("/")
-    return split[2] if len(split) >= 3 else None
+def _is_valid_queue_name(input_str: str) -> bool:
+    if input_str is None or len(input_str) == 0 or len(input_str) > 80:
+        return False
 
+    for char in input_str:
+        if char != "_" and char != "-" and not char.isalpha() and not char.isdigit():
+            return False
 
-def _null_to_empty(input_str: str) -> str:
-    return input_str if input_str is not None else ""
+    return True
```

## amazon/opentelemetry/distro/version.py

```diff
@@ -1,4 +1,4 @@
 # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 # SPDX-License-Identifier: Apache-2.0
 
-__version__ = "0.1.1"
+__version__ = "0.2.0"
```

## Comparing `aws_opentelemetry_distro-0.1.1.dist-info/METADATA` & `aws_opentelemetry_distro-0.2.0.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.3
 Name: aws-opentelemetry-distro
-Version: 0.1.1
+Version: 0.2.0
 Summary: AWS OpenTelemetry Python Distro
 Project-URL: Homepage, https://github.com/aws-observability/aws-otel-python-instrumentation/tree/main/aws-opentelemetry-distro
 Author: Amazon Web Services
 License-Expression: Apache-2.0
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: Apache Software License
@@ -72,25 +72,25 @@
 Requires-Dist: opentelemetry-sdk-extension-aws==2.0.1
 Requires-Dist: opentelemetry-sdk==1.22.0
 Provides-Extra: patch
 Requires-Dist: botocore~=1.0; extra == 'patch'
 Provides-Extra: test
 Description-Content-Type: text/x-rst
 
-AWS OpenTelemetry Distro
-========================================
+AWS Distro For OpenTelemetry Python Distro
+============================================
 
 Installation
 ------------
 
 ::
 
     pip install aws-opentelemetry-distro
 
 
-This package provides AWS OpenTelemetry Python Distro, which allows for auto-instrumentation of Python applications.
+This package provides Amazon Web Services distribution of the OpenTelemetry Python Instrumentation, which allows for auto-instrumentation of Python applications.
 
 References
 ----------
 
 * `OpenTelemetry Project <https://opentelemetry.io/>`_
 * `Example using opentelemetry-distro <https://opentelemetry.io/docs/instrumentation/python/distro/>`_
```

## Comparing `aws_opentelemetry_distro-0.1.1.dist-info/RECORD` & `aws_opentelemetry_distro-0.2.0.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-amazon/opentelemetry/distro/_aws_attribute_keys.py,sha256=o8mtmcIUVCJHPd2BKLd8fEcwzmpNW-rhxCPdCyhDieo,887
-amazon/opentelemetry/distro/_aws_metric_attribute_generator.py,sha256=MMKZ5oh51TxFgXp26TTBdoE4edl6F5-pVny0GTUkpjE,16342
-amazon/opentelemetry/distro/_aws_span_processing_util.py,sha256=BrqxhYYzpDtVJODWINy3OxfW24dCFX3PRNR2Y-dVRQs,7337
+amazon/opentelemetry/distro/_aws_attribute_keys.py,sha256=taRtWJjdTFjnShAKBAltaxvBCGvrhsTO0XL6qcmQxbI,972
+amazon/opentelemetry/distro/_aws_metric_attribute_generator.py,sha256=4fhy3elhJt0fhaVlGMNwqm6SGgeqi8xXV0NjmeYtQXY,21249
+amazon/opentelemetry/distro/_aws_span_processing_util.py,sha256=6yFP9WaHTz5a3nMFV5jWbNpo49kGexvDNluTtXLwByQ,7648
 amazon/opentelemetry/distro/always_record_sampler.py,sha256=zq3EyY56kjTgSZ1-QsKu5uFa952BcFRoHC_ZUisSg2M,2539
 amazon/opentelemetry/distro/attribute_propagating_span_processor.py,sha256=l2sVIrYTi3CROK0aZDs6AA5Wwde-STDYGKrFsmQM4KQ,4671
 amazon/opentelemetry/distro/attribute_propagating_span_processor_builder.py,sha256=4JbXewZ2bMcFc9nGnnsrW9cfGYEpZI4phWO4ztTqjNY,2408
 amazon/opentelemetry/distro/aws_metric_attributes_span_exporter.py,sha256=UtYV9Xfnu2it-WqDjqVlCyUWWGJJz0nNkbuMdXzPnjU,5992
 amazon/opentelemetry/distro/aws_metric_attributes_span_exporter_builder.py,sha256=cP-v9NOFOhhnuL_keFgLO1sBfMctUL5MzDQu71WqenY,1466
 amazon/opentelemetry/distro/aws_opentelemetry_configurator.py,sha256=bXStGvaQCZn92hK2ltxZg8vO2Wy_paP8SdbCIV6ke0Y,14094
-amazon/opentelemetry/distro/aws_opentelemetry_distro.py,sha256=7z2rNrm-CT4_VvZTr3ndkMSf1muN6VhiKglg6jTJIag,2592
+amazon/opentelemetry/distro/aws_opentelemetry_distro.py,sha256=wh7i4kV2fC-xX9NlN6RutPIm2W1TOQxnK4mAiUd7IE8,3544
 amazon/opentelemetry/distro/aws_span_metrics_processor.py,sha256=IjxvnxdBwlEzHmFov7N-OSHZXRW5wqLhlRxJHQrlURM,5235
 amazon/opentelemetry/distro/aws_span_metrics_processor_builder.py,sha256=3QUXNpHTJyYK3PSeHAHfL3i7FcHNDAZadovz4MDwEsQ,2872
 amazon/opentelemetry/distro/metric_attribute_generator.py,sha256=2YZymKnnwUJS-7xPPI3zAHRnkTJtHRVQj__tRLTzZ9M,1425
-amazon/opentelemetry/distro/sqs_url_parser.py,sha256=jidMkHwo_jP0Ox1a8zmjfJKTW60qGABtQMKriOPVJBg,4072
-amazon/opentelemetry/distro/version.py,sha256=N0sf00pSHzHOHx_-mDgQlPspNY_KFAyh1ETG6HzmKjo,130
+amazon/opentelemetry/distro/sqs_url_parser.py,sha256=rRKflWWiQJUeFTYXafUO_YDLJNIfxyX1M2lzZrN4V_U,1628
+amazon/opentelemetry/distro/version.py,sha256=g_GiAMUe9ti_PXte5Tqn9GED4It9sSzI0WnoRN6y16g,130
 amazon/opentelemetry/distro/configuration/sql_dialect_keywords.json,sha256=Gl92Xdx7EpPN5HlkZr1RU_BUvCTuklMaVE73kduH0yk,16500
 amazon/opentelemetry/distro/patches/_botocore_patches.py,sha256=t6xsgs31ks0oAyAqPiLI-3Gn7P0Kx8cMImgAKsE3HcU,4172
 amazon/opentelemetry/distro/patches/_instrumentation_patch.py,sha256=e2hEX__FmNZS9W-HzITO5znNkKaztXi6kVeJdHs6kI8,1841
 amazon/opentelemetry/distro/patches/_resource_detector_patches.py,sha256=1f4FQQiC4oJOXdh7TU47AkZ48HrdgK9NrLkdIm2akyo,1623
 amazon/opentelemetry/distro/sampler/_aws_xray_sampling_client.py,sha256=vOztNhoo2KDHqE5vagzsHkHQvaUOLI0Rb9XP9Tr7wvE,4146
 amazon/opentelemetry/distro/sampler/_clock.py,sha256=6M8hhv2FEgmggl3rVnFTB62VkUUzTiwL2G7MQOwPmUc,642
 amazon/opentelemetry/distro/sampler/_fallback_sampler.py,sha256=By1a0jyfy7W7DZn4GJm2OkdDrO9kYuKUepAsRaso3CE,1833
@@ -25,11 +25,11 @@
 amazon/opentelemetry/distro/sampler/_rate_limiting_sampler.py,sha256=wJR7AlbXh57FDaoNV2NYWKW4ZjDBz_3OuV4M4UNKKxQ,1615
 amazon/opentelemetry/distro/sampler/_rule_cache.py,sha256=1SxwCUwNNpJFOLYtXXcEOiDkclxo5WLugt7gsJ56yiw,6041
 amazon/opentelemetry/distro/sampler/_sampling_rule.py,sha256=fp-06Ur4bDtBTCXLHU2rN-wHWmOUluL_IAhINj4jRUc,2729
 amazon/opentelemetry/distro/sampler/_sampling_rule_applier.py,sha256=TNpgbhoBVg9TkJp2oZ_0zGLV14tDxJzw8FxadJWW2ic,9461
 amazon/opentelemetry/distro/sampler/_sampling_statistics_document.py,sha256=C9evmg9vfEMJzq5FfRkImBoT191ICJ1Fhth6nTWg6ZI,1017
 amazon/opentelemetry/distro/sampler/_sampling_target.py,sha256=wccite2KK9CsWA6QudlnGUwCgbdCpeo6vGhMq2TPCYM,2263
 amazon/opentelemetry/distro/sampler/aws_xray_remote_sampler.py,sha256=e7hAPPnBtNPukKnThZIyF4SjouIbbH8S-M-of8d5Ees,6747
-aws_opentelemetry_distro-0.1.1.dist-info/METADATA,sha256=3XXMb_JpA5xpKGLMD4y8jaiHyJsTDH7HU8j1UHlCM4g,4682
-aws_opentelemetry_distro-0.1.1.dist-info/WHEEL,sha256=zEMcRr9Kr03x1ozGwg5v9NQBKn3kndp6LSoSlVg-jhU,87
-aws_opentelemetry_distro-0.1.1.dist-info/entry_points.txt,sha256=GgVt2TsDQc86JNySAMv8hwEg9umy3cniBKUFWLzhgSU,249
-aws_opentelemetry_distro-0.1.1.dist-info/RECORD,,
+aws_opentelemetry_distro-0.2.0.dist-info/METADATA,sha256=9beZlmh5D-sAuhhG6EpdsMvVlet37GwlDJs0HgA7bzk,4749
+aws_opentelemetry_distro-0.2.0.dist-info/WHEEL,sha256=zEMcRr9Kr03x1ozGwg5v9NQBKn3kndp6LSoSlVg-jhU,87
+aws_opentelemetry_distro-0.2.0.dist-info/entry_points.txt,sha256=GgVt2TsDQc86JNySAMv8hwEg9umy3cniBKUFWLzhgSU,249
+aws_opentelemetry_distro-0.2.0.dist-info/RECORD,,
```

